// @compiled on Sat Aug 13 01:07:13 MDT 2016
// Note: this is a generated file all changes will be lost. 


/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ManagedBeans.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ManagedBeans.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.api.bean            = adf.mf.api.bean            || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

adf.mf.internal.mb.ManagedBeanDefinition = adf.mf.internal.mb.ManagedBeanDefinition || {
  "APPLICATION": "applicationScope",
  "PAGE_FLOW":   "pageFlowScope",
  "VIEW":        "viewScope"
};

/**
 * Set a collection of managed bean definitions.  The collection of bean
 * definitions supplied here _REPLACES_ any existing definitions, it does
 * not add to the existing set.
 *
 * @param {Array.<adf.mf.internal.mb.ManagedBeanDefinition>} beanDefs an array of
 *        ManagedBeanDefinition objects.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.internal.mb.setBeanDefinitions = function(beanDefs, success, failed)
{
  // ensure defs is an array
  var defs = (adf.mf.internal.util.is_array(beanDefs))? beanDefs : [beanDefs];
  var scb  = (adf.mf.internal.util.is_array(success))?  success  : [success];

  if (!adf.mf.internal.isJavaAvailable())
  {
    if (defs.length == 0)
    {
      /* if there are no beans being defined, this command is a NOOP */
      for (var i = 0; i < scb.length; ++i)
      {
        try
        {
          scb[i](null, null);
        }
        catch(e) { /* ignore */ }
      }
      return;  /* do not actually make the java call since it will error out */
    }
    else
    {
      /* since there were beans defined, log a message and then let it error out in the invoke */
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.mb.setBeanDefinitions", "ERROR_MNGD_BEANS_NOT_SUPPORTED");
    }
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setBeanDefinitions",
    defs, success, failed);
};

/**
 * Add a managed bean definition
 *
 * @param {adf.mf.api.bean.ManagedBeanDefinition} beanDefinition the managed bean definition to add
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.api.bean.addBeanDefinition = function(beanDefinition, success, failed)
{
  if (!adf.mf.internal.isJavaAvailable())
  {
   var scb = (adf.mf.internal.util.is_array(success)) ? success : [success];
   for (var i = 0, size = scb.length; i < size; ++i)
   {
      try
      {
        scb[i](null, null);
      }
      catch(e) { /* ignore */ }
    }
    return;
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "addBeanDefinition",
    beanDefinition, success, failed);
};

/**
 * Remove a bean definition from the current context
 *
 * @param {adf.mf.api.bean.ManagedBeanDefinition} beanDefinition the definition of the bean to remove.
 *        The managed properties array does not need to be populated, all other properties are required.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.api.bean.removeBeanDefinition = function(beanDefinition, success, failed)
{
  if (!adf.mf.internal.isJavaAvailable())
  {
    var scb = (adf.mf.internal.util.is_array(success)) ? success : [success];
    for (var i = 0, size = scb.length; i < size; ++i)
    {
      try
      {
        scb[i](null, null);
      }
      catch(e) { /* ignore */ }
    }
    return;
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "removeBeanDefinition",
    beanDefinition, success, failed);
};

/**
 * Managed Bean definition
 *
 * @param {string} name managed bean's name
 * @param {string} type managed bean's type
 * @param {string} scope managed bean's scope
 * @param {Array.<adf.mf.internal.mb.ManagedPropertyDefinition>} props managed bean's managed
 *        properties
 */
adf.mf.api.bean.ManagedBeanDefinition = function(name, type, scope, props)
{
  this.beanName     = name;  /* managed bean's name  */
  this.fqnClassname = type;  /* managed bean's type  */
  this.scope        = scope; /* managed bean's scope */
  this.props        = props; /* managed bean's props */
};

/**
 * @deprecated Use adf.mf.api.bean.ManagedBeanDefinition instead
 */
adf.mf.internal.mb.ManagedBeanDefinition = adf.mf.api.bean.ManagedBeanDefinition;

/**
 * @return {string} the managed bean's name
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getBeanName = function()
{
  return this.beanName;
};

/**
 * @return {string} the managed bean's fully qualified Java class name
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getBeanClass = function()
{
  return this.fqnClassname;
};

/**
 * @return {string} the managed bean's associated scope
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getScope = function()
{
  return this.scope;
};

/**
 * @return {Array.<adf.mf.internal.mb.ManagedPropertyDefinition>} the associated managed bean's
 *         properties
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getManagedProperties = function()
{
  return this.props;
};

/**
 * Managed property definition used in the managed bean definition
 * that should be set by the controller layer on creation
 *
 * @param {string} name managed bean property
 * @param {string} type managed bean property's fully qualified Java classname
 * @param {Object} value managed bean property's value
 */
adf.mf.api.bean.ManagedPropertyDefinition = function(name, type, value)
{
  this.name  = name;  /* managed property's name  */
  this.type  = type;  /* managed property's type  */
  this.value = value; /* managed property's value */
};

/**
 * @deprecated Use adf.mf.api.bean.ManagedPropertyDefinition instead
 */
adf.mf.internal.mb.ManagedPropertyDefinition = adf.mf.api.bean.ManagedPropertyDefinition;

/**
 * @return {string} the managed property's name
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getName = function()
{
  return this.name;
};

/**
 * @return {string} the managed property's fully qualified class name
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getType = function()
{
  return this.type;
};

/**
 * @return {Object} the managed property's value
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getValue = function()
{
  return this.value;
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ManagedBeans.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ContainerIntegration.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ContainerIntegration.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

(function()
{
  var ADFMF_CONTAINER_UTILITIES = "oracle.adfmf.framework.api.AdfmfContainerUtilities"
  var ADFMF_CONTAINER_UTILITIES_INTERNAL =
    "oracle.adfmf.framework.internal.AdfmfContainerUtilitiesInternal";
  var ASYNC_SUCCESS_CALLBACK = "asyncContainerJavaScriptFunctionResponseSuccess";
  var ASYNC_FAILED_CALLBACK = "asyncContainerJavaScriptFunctionResponseFailed";

  /**
   * Checks and obtains new configuration if available.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is checkForNewConfiguration, which is defined
   * as:
   * public static void checkForNewConfiguration() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.checkForNewConfiguration = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.checkForNewConfiguration(
       function(req, res) &#123; alert("checkForNewConfiguration complete"); },
       function(req, res) &#123; alert("checkForNewConfiguration failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.checkForNewConfiguration = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "checkForNewConfiguration", success, failed);
  };

  /**
   * Gets an array of <code>FeatureInformation</code> objects that provide
   * information about the features that are available in this session of the
   * ADF Mobile application and should be displayed on a custom springboard.
   * These features have already been filtered by the evaluation of constraints.
   * These are the features that would normally be displayed on the default
   * springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatures, which is defined
   * as:
   * public static FeatureInformation[] getFeatures() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatures = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>
   *
   *      An array of <code>FeatureInformation</code> objects each
   *      representing a feature that is available. This will include the
   *      feature id, the feature name, a path to the feature icon and a path
   *      to the feature image. Normally a springboard will display the name
   *      of the feature and the image for that feature.
   *
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatures(
       function(req, res) &#123; alert("getFeatures complete"); },
       function(req, res) &#123; alert("getFeatures failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatures = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatures", success, failed);
  };

  /**
   * Gets <code>ApplicatiaonInformation</code> object containing the information
   * about the application. This can be used to get the application name for a
   * custom springboard. Additional information such as vendor, version and
   * application id are provided as well.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getApplicationInformation, which is defined
   * as:
   * public static ApplicatiaonInformation getApplicationInformation() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getApplicationInformation = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>
   *
   *      A <code>ApplicatiaonInformation</code> object containing
   *      application level metadata. This includes application name, vendor,
   *      version and application id.
   *
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getApplicationInformation(
       function(req, res) &#123; alert("getApplicationInformation complete"); },
       function(req, res) &#123; alert("getApplicationInformation failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getApplicationInformation = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getApplicationInformation", success, failed);
  };

  /**
   * Activates the feature with the given ID.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoFeature, which is defined
   * as:
   * public static void gotoFeature(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoFeature = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature to activate
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
   * adf.mf.api.gotoFeature("feature0",
   *  function(req, res) &#123; alert("gotoFeature complete"); },
   *  function(req, res) &#123; alert("gotoFeature failed with " + adf.mf.util.stringify(res); }
   * );
   * </pre>
   */
  adf.mf.api.gotoFeature = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoFeature", featureId, success, failed);
  };

  /**
   * Activates the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoSpringboard, which is defined
   * as:
   * public static void gotoSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.gotoSpringboard(
       function(req, res) &#123; alert("gotoSpringboard complete"); },
       function(req, res) &#123; alert("gotoSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.gotoSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoSpringboard", success, failed);
  };

  /**
   * Hides the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is hideSpringboard, which is defined
   * as:
   * public static void hideSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.hideSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.hideSpringboard(
       function(req, res) &#123; alert("hideSpringboard complete"); },
       function(req, res) &#123; alert("hideSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.hideSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "hideSpringboard", success, failed);
  };

  /**
   * Shows the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showSpringboard, which is defined
   * as:
   * public static void showSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showSpringboard(
       function(req, res) &#123; alert("showSpringboard complete"); },
       function(req, res) &#123; alert("showSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showSpringboard", success, failed);
  };

  /**
   * Activates the default feature.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoDefaultFeature, which is defined
   * as:
   * public static void gotoDefaultFeature() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoDefaultFeature = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.gotoDefaultFeature(
       function(req, res) &#123; alert("gotoDefaultFeature complete"); },
       function(req, res) &#123; alert("gotoDefaultFeature failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.gotoDefaultFeature = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoDefaultFeature", success, failed);
  };

  /**
   * Resets the feature with the given ID.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is resetFeature, which is defined
   * as:
   * public static void resetFeature(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.resetFeature = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature to reset
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.resetFeature("feature0",
       function(req, res) &#123; alert("resetFeature complete"); },
       function(req, res) &#123; alert("resetFeature failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.resetFeature = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "resetFeature", featureId, success, failed);
  };

  /**
   * Hides navigation bar.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is hideNavigationBar, which is defined
   * as:
   * public static void hideNavigationBar() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.hideNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.hideNavigationBar(
       function(req, res) &#123; alert("hideNavigationBar complete"); },
       function(req, res) &#123; alert("hideNavigationBar failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.hideNavigationBar = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "hideNavigationBar", success, failed);
  };

  /**
   * Shows navigation bar.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showNavigationBar, which is defined
   * as:
   * public static void showNavigationBar() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showNavigationBar(
       function(req, res) &#123; alert("showNavigationBar complete"); },
       function(req, res) &#123; alert("showNavigationBar failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showNavigationBar = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showNavigationBar", success, failed);
  };

  /**
   * Shows the preferences screen.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showPreferences, which is defined
   * as:
   * public static void showPreferences() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showPreferences = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showPreferences(
       function(req, res) &#123; alert("showPreferences complete"); },
       function(req, res) &#123; alert("showPreferences failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showPreferences = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showPreferences", success, failed);
  };

  /**
   * Invokes a Javascript method with the given arguments on the specified
   * feature. Returns the result of the method execution.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is invokeContainerJavaScriptFunction, which is defined
   * as:
   * public static Object invokeContainerJavaScriptFunction(String featureId, String methodName, Object[] args) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature on which to invoke the method
   * @param methodName
   *       method name
   * @param args
   *       array of arguments to be passed to method
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Object
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   *  <ul>
   *  <li>included a simple appFunction.js file to feature1 (by adding it to feature1 content's include in JDeveloper).</li>
   *  <li>added calls to adf.mf.api.invokeContainerJavaScriptFunction to your code</li>
   *  </ul>
   * <br/>
   * <b>appFunctions.js</b>
   * <pre>
   (function()
   &#123;
     if (!window.application) window.application = &#123;};

     application.testFunction = function()
     &#123;
       var args = arguments;

       alert("APP ALERT " + args.length + " ");
       return "application.testFunction - passed";
     };
   })();
   * </pre>
   * <br/>
   * <pre>
  adf.mf.api.invokeContainerJavaScriptFunction("feature1",
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  or
  adf.mf.api.invokeContainerJavaScriptFunction("feature1", [ "P1" ],
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  );
  or
  adf.mf.api.invokeContainerJavaScriptFunction("feature1", [ "P1", "P2" ],
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   * <br/>
   * Now when the user presses the button they will see three alerts (from the appFunctions.js):
   * <pre>
      APP ALERT 0
      APP ALERT 1
      APP ALERT 2
   * </pre>
   */
  adf.mf.api.invokeContainerJavaScriptFunction = function(/* String */ featureId, /* String */ methodName, /* Object[] */ args, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "invokeContainerJavaScriptFunction", featureId, methodName, args, success, failed);
  };

  /**
   * Invokes a native method on the specified class with the given arguments.
   * Returns the result of method execution.
   *
   * @param className
   *       class name
   * @param methodName
   *       method name
   * @param args
   *       array of arguments to be passed to method
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Object
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.invokeContainerMethod = function(/* String */ classname, /* String */ methodName, /* Object[] */ args, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "invokeContainerMethod", classname, methodName, args, success, failed);
  };

  /**
   * Returns the feature information for the passed in feature id.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatureById, which is defined
   * as:
   * public static FeatureInformation getFeatureById(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatureById = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of the feature to retrieve
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Feature
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatureById("feature.id",
       function(req, res) &#123; alert("getFeatureById complete"); },
       function(req, res) &#123; alert("getFeatureById failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatureById = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatureById", featureId, success, failed);
  };

  /**
   * Returns the feature information for the passed in feature name.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatureByName, which is defined
   * as:
   * public static FeatureInformation getFeatureByName(String featureName) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatureByName = function(featureName, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureName
   *       Name of the feature to retrieve
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatureByName("feature.name",
       function(req, res) &#123; alert("getFeatureByName complete"); },
       function(req, res) &#123; alert("getFeatureByName failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatureByName = function(/* String */ featureName, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatureByName", featureName, success, failed);
  };

  /**
   * internal api for invoke Java
   * e.g. adf.mf.internal.api.invokeMethod(commId, classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
   */

  adf.mf.internal.api.invokeMethod = function()
  {
    argc  = arguments.length;
    params = new Array();

    for (var i=3; i < argc-2; i++)
    {
      params[i-3] = arguments[i];
    }

    var request = { "classname"  : arguments[1], /* clazz  */
      "method"    : arguments[2], /* method */
      "params"    : params };

    adf.mf.internal.context.invokeJavaMethod(/* CommId */ arguments[0], request, arguments[argc-2], arguments[argc-1]);
  };

  /**
   * The framework enables you to display the device's e-mail interface, and optionally pre-populate certain fields:
   *
   *  @param options
   *    is a JSON object with the following optional properties:
   *    <ul>
   *    <li>to: recipients (comma-separated)</li>
   *    <li>cc: CC recipients (comma-separated)</li>
   *    <li>subject: message subject</li>
   *    <li>body: message body</li>
   *    <li>bcc: BCC recipients (comma-separated)</li>
   *    <li>attachments: list of filenames to attach to the e-mail (comma-separated)</li>
   *    <li>mimeTypes:
   *    <ul><li><b>iOS</b>: List of MIME types to use for the attachments (comma-separated).
   *    Specify null to let the framework automatically determine the MIME types.
   *    It is also possible to only specify the MIME types for selected attachments; see examples below.</li>
   *    <li><b>Android</b>: MIME type in Android isn't true MIME type but just a way for Android to filter
   *    applications to be shown in the application chooser dialog. But empty MIME type doesn't work
   *    and throws exception. So if no MIME type is passed in, we use "plain/text" by default. Also, if
   *    there are multiple attachment types, user doesn't need to provide multiple MIME types, but can
   *    provide just most suitable MIME type (as per Android documentation). That being said, if the user
   *    has an application which is being deployed to both iOS and Android, they can pass in the comma-separated
   *    list of mime types and Android will still work fine.</li></ul>
   *    </li>
   *    </ul>
   *  <br/>
   *  After this interface is displayed, the user can choose to either send the e-mail or discard it. Note that it
   *  is not possible to automatically send the e-mail due to device/carrier restrictions; only the end user can actually
   *  send the e-mail. The device must also have at least one e-mail account configured to send e-mail; otherwise, an
   *  error will be displayed indicating that no e-mail accounts could be found.
   *  <br/>
   *  Examples:
   *
   * Populate an e-mail to 'john.doe@foo.com', copy 'jane.doe@bar.com', with the subject 'Test message',
   * and the body 'This is a test message'
   * <br/>
   * <pre>
  adf.mf.api.sendEmail(&#123;to: "john.doe@foo.com",
                 cc: "jane.doe@bar.com",
                 subject: "Test message",
                 body: "This is a test message"},
                success, failed);
   * </pre>
   * <br/>
   * Taking the same example, but now adding a BCC to 'mary.may@another.com' and 'lary.day@another.com'
   * and attaching two files.<br/>
   * <b>NOTE:</b> By not specifying a value for the mimeTypes parameter, you are telling the framework to automatically
   * determine the MIME type for each of the attachments
   * <br/>
   * <pre>
  adf.mf.api.sendEmail(&#123;to: "john.doe@foo.com",
                 cc: "jane.doe@bar.com",
                 bcc: "mary.may@another.com,lary.day@another.com"
                 subject: "Test message",
                 attachments: "path/to/file1.txt,path/to/file2.png"},
                success, failed);
   * </pre>
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.sendEmail = function(/* JSON */ options, success, failed)
  {
    if (options)
    {
      var attachments = options["attachments"];
      var mimeTypes = options["mimeTypes"];
      if (attachments || mimeTypes)
      {
        var attachmentsArray = attachments ? attachments.split(",") : [];
        var mimeTypesArray = mimeTypes ? mimeTypes.split(",") : [];
        var numMimeTypes = mimeTypesArray.length;
        var numAttachments = attachmentsArray.length;
        if (numMimeTypes > 0 && numAttachments != numMimeTypes)
        {
          // When attachments and MIME types are both specified, the number of each
          // must match.
          if (failed != null)
          {
            var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
              "ERROR_MIMETYPES_NOTEQUAL_ATTACHMENTS", [numMimeTypes, numAttachments]);
            failed(rmsg);
            return;
          }
        }
      }
    }
    cordova.exec( success, failed, "AdfmfEmail", "sendEmail", [options]);
  };

  // This variant of the sendEmail API is ONLY used when invoking sendEmail from Embedded Java code
  adf.mf.internal.api.sendEmail = function (commId, requestId, emailOptions)
  {
    try
    {
      adf.mf.api.sendEmail(emailOptions, /* Options to pre-populate e-mail dialog */

        function(result) /* Success callback */
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendEmail", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail",
              se);
          }
        },

        function(result) /* Error callback */
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendEmail", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail",
              se);
          }
        });
     }
     catch(se)
     {
       adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
         "adf.mf.api.sendEmail", "ERROR_EXCEPTION");

       // Only log the exception at a fine level for security reasons
       adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail", se);

       adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
         ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  /**
   * The framework enables you to display the device's text messaging (SMS) interface, and
   * optionally pre-populate certain fields:
   *
   *  @param options
   *     is a JSON object with the following optional properties:
   *     <ul>
   *     <li>to: recipients (comma-separated)</li>
   *     <li>body: message body</li>
   *     </ul>
   *  <br/>
   *  After this interface is displayed, the user can choose to either send the
   *  SMS or discard it. Note that it is not possible to automatically send the
   *  SMS due to device/carrier restrictions; only the end user can actually send the SMS.
   *  <br/>
   *  Examples:
   *
   * Populate an SMS message to '1234567890' with the body 'This is a test message'
   * <br/>
   * <pre>
   adf.mf.api.sendSMS(&#123;to: "1234567890",
                       body: "This is a test message"},
                      success, failed);
   * </pre>
   *
   * <b>success callback</b> must be in the form of
   *    function(request, response) where the request
   *    contains the original request and the response
   *    contains the associated AdfmfContainerUtilities
   *    method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *    function(request, response) where the request
   *    contains the original request and the response
   *    contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.sendSMS = function(/* JSON */ options, success, failed)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.api.sendSMS",
        "CORDOVA_DEBUG",
        "Inside the ContainterIntegration.js invoking AdfmfSMS.sendSMS Cordova plugin");
    }
    cordova.exec(success, failed, "AdfmfSMS", "sendSMS", [options]);
  };

  // This variant of the sendSMS API is ONLY used when invoking sendSMS from Embedded Java code
  adf.mf.internal.api.sendSMS = function (commId, requestId, smsOptions)
  {
    try
    {
      adf.mf.api.sendSMS(smsOptions,
        // Options to pre-populate SMS dialog
        // Success callback
        function(result)
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendSMS", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);
          }
        },
        // Error callback
        function(result)
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendSMS", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.sendSMS", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.api.getDeviceProperties = function(success, failed)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api.getDeviceProperties",
        "CORDOVA_DEBUG",
        "Inside the ContainterIntegration.js invoking " +
          "ADFMobileDeviceProperties.getDeviceProperties Cordova plugin");
    }
    cordova.exec(success, failed, "ADFMobileDeviceProperties", "getDeviceProperties", []);
  };

  adf.mf.internal.api.getCurrentPosition = function (commId, requestId)
  {
    try
    {
      navigator.geolocation.getCurrentPosition(

        function (data)
        {
          // 'data' is a complex object with prototypical inheritance and is not guaranteed
          // to return expected results when serialized using JSON.stringify.
          // Therefore, convert it into a POJO - 'position'- and pass-on 'position' instead.
          var position =
          {
            timestamp: null,
            coords:
            {
              speed: null,
              longitude: null,
              latitude: null,
              heading: null,
              altitudeAccuracy: null,
              altitude: null,
              accuracy: null
            }
          };
          if (data != null)
          {
            // This pattern is used so that if the value that is being assigned is undefined,
            // the default value of the LHS variable is preserved.
            position.timestamp = (data.timestamp === undefined ? position.timestamp : data.timestamp);
            if (data.coords != null)
            {
              position.coords.accuracy = (data.coords.accuracy === undefined ? position.coords.accuracy : data.coords.accuracy);
              position.coords.altitude = (data.coords.altitude === undefined ? position.coords.altitude : data.coords.altitude);
              position.coords.altitudeAccuracy = (data.coords.altitudeAccuracy === undefined ? position.coords.altitudeAccuracy : data.coords.altitudeAccuracy);
              position.coords.heading = (data.coords.heading === undefined ? position.coords.heading : data.coords.heading);
              position.coords.latitude = (data.coords.latitude === undefined ? position.coords.latitude : data.coords.latitude);
              position.coords.longitude = (data.coords.longitude === undefined ? position.coords.longitude : data.coords.longitude);
              position.coords.speed = (data.coords.speed === undefined ? position.coords.speed : data.coords.speed);
            }
            else
            {
              position.coords = data.coords;
            }
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, position, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getCurrentPosition", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getCurrentPosition", se);
          }
        },

        function (data)
        {
          var message = ((data != null) && (data.message != null)) ? data.message : "unknown error";
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getCurrentPosition", "ERROR_IN_REQUEST", ASYNC_FAILED_CALLBACK,
              se);
          }
      });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "navigator.geolocation.getCurrentPosition", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getCurrentPosition", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.watchPosition = function (commId, requestId, userWatchId, geolocationOptions)
  {
    var firstTime = true;
    try
    {
      var watchId = navigator.geolocation.watchPosition(

        function (data)
        {
          // 'data' is a complex object with prototypical inheritance and is not guaranteed to
          // return expected results when serialized using JSON.stringify.
          // Therefore, convert it into a POJO - 'position'- and pass-on 'position' instead.
          var position =
          {
            timestamp: null,
            coords:
            {
              speed: null,
              longitude: null,
              latitude: null,
              heading: null,
              altitudeAccuracy: null,
              altitude: null,
              accuracy: null
            }
          };

          if (data != null)
          {
            // This pattern is used so that if the value that is being assigned is undefined,
            // the default value of the LHS variable is preserved.
            position.timestamp = data.timestamp || position.timestamp;
            if (data.coords != null)
            {
              position.coords.accuracy = data.coords.accuracy || position.coords.accuracy;
              position.coords.altitude = data.coords.altitude || position.coords.altitude;
              position.coords.altitudeAccuracy = data.coords.altitudeAccuracy || position.coords.altitudeAccuracy;
              position.coords.heading = data.coords.heading || position.coords.heading;
              position.coords.latitude = data.coords.latitude || position.coords.latitude;
              position.coords.longitude = data.coords.longitude || position.coords.longitude;
              position.coords.speed = data.coords.speed || position.coords.speed;
            }
          }

          if (firstTime)
          {
            // unblock the calling thread only on the first callback.
            try
            {
              adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
                ASYNC_SUCCESS_CALLBACK,
                requestId, String(watchId), function () {}, function () {});
            }
            catch (se)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.watchPosition", "ERROR_IN_REQUEST");

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.internal.api", "watchPosition", se);
            }
            firstTime = false;
          }
          try
          {
            adf.mf.api.invokeMethod("oracle.adf.model.datacontrols.device.GeolocationProxy",
               "invokeEmbeddedCallback", userWatchId, position, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.watchPosition.invokeEmbeddedCallback", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.watchPosition", "invokeEmbeddedCallback", se);
          }
        },

        function (data)
        {
          // if error, need to clear watchId so there is no dangling callbacks
          navigator.geolocation.clearWatch(String(watchId));

          var message = ((data != null) && (data.message != null)) ? data.message : "unknown error";

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.watchPosition", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.watchPosition", ASYNC_FAILED_CALLBACK, se);
          }
        },
        geolocationOptions);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.watchPosition", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "watchPosition", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.clearWatch = function (watchID)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.clearWatch",
        "CORDOVA_DEBUG", watchID);
    }
    navigator.geolocation.clearWatch(watchID); // no callbacks
  };

  adf.mf.internal.api.createContact = function (commId, requestId, properties)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.createContact",
            "CORDOVA_DEBUG", adf.mf.util.stringify(properties));
    }

    try
    {
      // Fix for Bug 16433413: If displayName is passed as null, then Cordova returns "null" for displayName.
      // If empty string is passed in, either valid displayName is returned or null is returned when there is
      // no displayName.
      if (properties !== undefined && properties !== null)
      {
        // Remove all dot properties from javascript object (JSON) to be sent to Cordova layer
        adf.mf.internal.removeDotProperties(properties);

        if (properties.displayName == null)
        {
          properties.displayName = "";
        }
      }

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.createContact",
          "CORDOVA_DEBUG_JUST_BEFORE_CREATE_CONTACT_CALL_TO_CORDOVA", adf.mf.util.stringify(properties));
      }

      var contact = navigator.contacts.create(properties);
      if (contact.note == null)
      {
        contact.note = '';
      }
      if (contact.nickname == null)
      {
        contact.nickname = '';
      }

      contact.save(

        function (data)
        {
          var contact = data || {};

          // In cordova-2.2.0.js, createIn method adds "Invalid Object" value for null Birthday
          // so we need to put back null there to serialize in to Java layer properly.
          var bDay = contact.birthday;
          if (isNaN(bDay) || ("undefined" == typeof bDay.getDate))
          {
            contact.birthday = null;
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK,
              requestId, contact, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.createContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "createContact", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.createContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "createContact", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.createContact", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "createContact", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.findContacts = function (commId, requestId, fields, options)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
        "CORDOVA_DEBUG - fields", fields);
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
        "CORDOVA_DEBUG - options", adf.mf.util.stringify(options));
    }

	  try
	  {
		  navigator.contacts.find(fields,
        function (data)
        {
          var contacts = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.find success",
              "CORDOVA_FIND_CONTACTS_BEFORE_CONVERTING", adf.mf.util.stringify(contacts));
          }

          try
          {
            // cordova-2.2.0.js doesn't invoke createIn() method and thus does not convert birthday from
            // long to String for findContact call and thus the contact(s) returned have birthday as
            // long in stringified way. eg. "505003627119". Whereas saveContact call correctly invokes
            // createIn() method and thus returns valid string. eg. "1986-01-01T22:47:07.119Z".
            // As ADFMF supports this string type or just the long (without stringified long) we need to
            // invoke createIn() method for each contact to convert date to supported format before
            // invoking the success callback method.
            for (var i = 0; i < contacts.length; i++)
            {
              var contact = contacts[i];

              // Copied this method body from cordova-2.2.0.js and:
              // 1) Added if condition to safeguard it
              // 2) Removed console.log and added our framework logging.
              var bDay = contact.birthday;
              try
              {
                if (null != bDay && !isNaN(bDay))
                {
                  contact.birthday = new Date(parseFloat(bDay));
                }
              }
              catch (exception)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.find success",
                    "CORDOVA_FIND_CONTACTS_DURING_CONVERT_BDAY",
                    "Exception converting date from long to String");
                }

                adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                  "adf.mf.internal.api.findContacts", "ERROR_EXCEPTION");

                // Only log the exception at a fine level for security reasons
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api", "findContacts", exception);
              }
            }

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
                "CORDOVA_FIND_CONTACTS_AFTER_CONVERTING", adf.mf.util.stringify(contacts));
            }

            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, contacts, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.findContacts", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "findContacts", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.findContacts", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "findContacts", se);
          }
        },
        options);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.findContacts", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "findContacts", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.removeContact = function (commId, requestId, properties)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api.removeContact",
        "CORDOVA_DEBUG",
        adf.mf.util.stringify(properties));
    }

    try
    {
      var contact = navigator.contacts.create(properties);

      contact.remove(
        function (data)
        {
          var contact = data || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, contact, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.removeContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "removeContact", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.removeContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "removeContact", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.removeContact", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "removeContact", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.getPicture = function (commId, requestId, cameraOptions)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.getPicture",
        "CORDOVA_DEBUG", adf.mf.util.stringify(cameraOptions));
    }

    try
    {
      navigator.camera.getPicture(

        function (data)
        {
          var imageData = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getPicture success",
              "CORDOVA_DEBUG", "");
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, imageData, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getPicture", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getPicture", se);
          }
        },

        function (data)
        {
          var message = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.getPicture",
              "CORDOVA_DEBUG", message);
          }

          // Return empty string as image data and call success callback instead of calling failure
          // callback
          var imageData = "";
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
               ASYNC_SUCCESS_CALLBACK, requestId, imageData, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getPicture", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getPicture", se);
          }
        }, cameraOptions);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.getPicture", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getPicture", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };


  adf.mf.internal.api.getDeviceProperties = function(commId, requestId)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal.api.getDeviceProperties",
        "CORDOVA_DEBUG", "");
    }

    try
    {
      adf.mf.api.getDeviceProperties(

        function (data)
        {
          var deviceProperties = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getDeviceProperties success", "CORDOVA_DEBUG",
              adf.mf.util.stringify(deviceProperties));
          }

          // Replace the phonegap version with the value from device.cordova
          // deviceProperties.device.phonegap = window.device.cordova;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, deviceProperties, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getDeviceProperties", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getDeviceProperties", se);
          }
        },

        function (data)
        {
          var message = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getDeviceProperties failed", "CORDOVA_DEBUG", "");
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getDeviceProperties", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getDeviceProperties", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.getDeviceProperties", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getDeviceProperties", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  /**
   * INTERNAL FUNCTION used to to remove dot properties from JSON
   */
  adf.mf.internal.removeDotProperties = function(dat)
  {
	  if (dat !== undefined && dat !== null)
	  {
		  if (Array.isArray(dat))
		  {
			  for (var i = 0; i < dat.length; i++)
			  {
				  var retValue = this.removeDotProperties(dat[i]);
				  if (retValue === null)
				  {
					  dat.splice (i, 1);
					  i--;
				  }
			  }
		  }
		  else if (typeof dat === 'object')
		  {
			  for (var property in dat)
			  {
				  if (property !== undefined && property !== null)
				  {
					  if (property == '.null')
					  {
						  if (dat[property] == true)
						  {
							  return null;
						  }
					  }
					  else if (property.indexOf (".") == 0)
					  {
						  // If the property is a dot property, delete it, as those shouldn't be sent to Cordova layer.
						  delete dat[property];
					  }
					  else if ((typeof dat[property]) != 'function')
					  {
						  var retValue = this.removeDotProperties(dat[property]);
						  if (retValue === null)
						  {
							  delete dat[property];
						  }
					  }
				  }
			  }
		  }
	  }

	  return dat;
  };

  /**
   * INTERNAL API used for Push Notification
   *
   * namespace : adf.mf.internal.api.pushnotifications
   *
   * methods :
   * 	public :
   * 		register(params)
   * 			Register with APNs/GCM. Calls container.internal.device.integration.PushNotifications(params, tokenHandler, errorHandler)
   * 			@params : JSON formatted registration parameters. Ex : {"badge":"true", "sound":"true"}
   * 	private :
   * 		tokenHandler(request, token)
   * 			Success callback for registration on iOS. Here we use adf.mf.api.invokeMethod to pass on the token to embedded's eventing mechanism.
   * 			@token : Device token received from APNs
   * 		successHandler(request, response)
   * 			Success callback for registration on Android.
   *            This is merely a success callback for a successful attempt to register - no token is received from GCM at this point.
   * 		errorHandler(request, error)
   * 			Failure callback for registration. Right now not utilized but will be hooked to error handling callbacks in Embedded when they are available.
   * 			@error Error
   * 		onNotificationAPN(notification)
   * 			Called by PushPlugin upon a notification from APNs. Here we use adf.mf.api.invokeMethod to pass on the notification to Embedded's eventing mechanism
   * 			@notification  JSON object representing notification payload
   * 		onNotificationGCM(notification)
   * 			General event callback used by PushPlugin on Android to report :
   * 				- token upon successful registration with GCM
   * 				- incoming notification event from GCM
   * 				- errors if any
   * 			Calls into tokenHandler/onNotificationAPN in order to pass on data to embedded's eventing mechanism depending on the event type.
   * 			@notification JSON notification event with following keys
   * 				event   : If "registered", its a successful registration callback, if "message" its a notification event
   * 				payload : Value is JSON of notification payload if event is "message"
   * 				regid   : Value is a string representing registration ID issued by GCM in response to a registration request
   */
  window.PushNotifications = function()
  {
    /* PUBLIC - Register for Push Notifications */
    this.register = function(params)
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "PushNotifications", "register",
          "invoking push notification command.");
      }
      try
      {
        var isAndroid = (navigator.userAgent.toLowerCase().indexOf("android") != -1);
        if (isAndroid)
        {
          params['ecb'] = "adf.mf.internal.api.pushnotifications.onNotificationGCM";
          container.internal.device.integration.PushNotifications.register(params,
            successHandler, errorHandler);
        }
        else
        {
          params['ecb'] = "adf.mf.internal.api.pushnotifications.onNotificationAPN";
          container.internal.device.integration.PushNotifications.register(params,
            tokenHandler, errorHandler);
        }
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.api.pushnotifications", "ERROR_REGISTER_PUSH_NOTIFICATION");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api", "pushnotifications", e);
      }
    };

    /* PRIVATE - Gets called by PushPlugin on iOS after successful registration */
    var tokenHandler = function(request, token)
    {
      adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedToken",
        token,
        //success
        function(req,res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "tokenHandler",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        },
        //failure
        function(req,res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.tokenHandler",
            "ERROR_PUSH_NOTIFICATION_CALLBACK_EXCEPTION");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "tokenHandler",
              "Inside the failure callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    /* PRIVATE - Gets called by PushPlugin if there was an error trying to register*/
    var errorHandler = function(request, error)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.pushnotifications", "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

      // For security purposes, only log the request and response details at FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api.pushnotifications", "errorHandler",
          "There was an error in processing this request : " + adf.mf.util.stringify(request) +
          ". Error : " + adf.mf.util.stringify(error));
      }

      adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedError",
        adf.mf.util.stringify(error),
        // success
        function(req, res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications",
              "errorHandler",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        },
        // failure
        function(req, res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.errorHandler",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "errorHandler",
            "Inside the failure callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    /* PRIVATE - Gets called by PushPlugin if the call to register on Android succeeded */
    var successHandler = function(request, response)
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.pushnotifications",
          "successHandler",
          "Request: " + adf.mf.util.stringify(request) + " Response: " +
            adf.mf.util.stringify(response));
      }
    };

    /* PRIVATE Gets called by PushPlugin on iOS when notification arrives */
    this.onNotificationAPN = function(notification)
    {
      // appState
      var appState = 0;
      if (notification.triggersStartup === "true")
      {
        appState = 1;
      }
      else if (notification.foreground === "0")
      {
        appState = 2;
      }
      else if (notification.foreground === "1")
      {
        appState = 3;
      }

      // token
      var token = "";
      if (notification.hasOwnProperty('deviceToken'))
      {
        token = notification.deviceToken;
      }

	    adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedRemoteNotification",
        JSON.stringify(notification),
        appState,
        token,
		    // success
        function(req,res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications",
              "onNotificationAPN",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        },
        // failure
        function(req,res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.onNotificationAPN",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "onNotificationAPN",
              "Inside the failure callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    // PRIVATE Gets called by PushPlugin on Android when a notification event (registration success,
    // registration failure, incoming notification) occurs
    this.onNotificationGCM = function(notification)
    {
      switch (notification.event)
      {
        case 'registered':
          if (notification.regid.length > 0)
          {
            tokenHandler(null,notification.regid);
          }
          break;

        case 'message':
          // appState
          var appState = 0;
          if (notification.coldstart)
          {
            appState = 1;
          }
          else if (notification.foreground)
          {
            appState = 3;
          }
          else
          {
            appState = 2;
          }

          // token
          var token = "";
          if (notification.payload.hasOwnProperty('deviceToken'))
          {
            token = notification.payload.deviceToken;
          }

          adf.mf.api.invokeMethod(
            "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
            "receivedRemoteNotification",
            JSON.stringify(notification.payload),
            appState,
            token,
            // success
            function(req, res)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.pushnotifications",
                  "onNotificationGCM",
                  "Inside the success callback for request " + adf.mf.util.stringify(req) +
                    " with response "+adf.mf.util.stringify(res));
              }
            },
            // failure
            function(req, res)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle",
                adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.pushnotifications.onNotificationGCM",
                "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

              // For security purposes, only log the request and response details at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.pushnotifications", "onNotificationGCM",
                  "Inside the failure callback for request " + adf.mf.util.stringify(req) +
                    " with response " + adf.mf.util.stringify(res));
              }
            }
          );
          break;

        case 'error':
          adf.mf.log.logInfoResource("ADFErrorBundle",
            adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.onNotificationGCM",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "onNotificationGCM",
              "Error Received : " + JSON.stringify(notification));
          }
          errorHandler(null, notification.error);
        break;

        default:
          // Unknown, an event was received and we do not know what it is
          break;
      }
    };
  };
  adf.mf.internal.api.pushnotifications = new PushNotifications();

  /**
   * Local Notifications
   *
   * @namespace
   */
  adf.mf.api.localnotification =
  {
    /**
     * Schedule a local notification
     *
     * @param {Object} options - notification options
     * @param {string} options.title - notification title
     * @param {string} options.alert - notification alert
     * @param {Date} options.date - date at which notification needs to be triggered
     * @param {Number} options.badge - application icon will be badged by this number when notification is triggered
     * @param {string} options.sound - set it to 'SYSTEM_DEFAULT' to play the default system sound upon a notification
     * @param {string} options.vibration - set it to 'SYSTEM_DEFAULT' for default system vibration upon a notification
     * @param {Object} options.payload - custom payload to be sent via notification
     * @param {successCallback} scb - success callback
     * @param {errorCallback} ecb  - error callback
     */
    add: function(options, scb, ecb)
    {
  	  var successHandler = function(request, response)
  	  {
  	    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  		{
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.localnotification.add",
          "successHandler",
          "Request: "
  				  + adf.mf.util.stringify(request)
  				  + " Response: "
  				  + adf.mf.util.stringify(response));
  	    }
  	    if (typeof(scb) == typeof(Function))
  	      scb(request,response);
  	  };

      var errorHandler = function(request,error)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.add.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"There was an error in processing this request : " + adf.mf.util.stringify(request) +
              ". Error : "+adf.mf.util.stringify(error));
        }

        if (typeof(ecb) == typeof(Function))
          ecb(request, error);
      };

  	  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  	  {
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "LocalNotification", "add", "invoking local notification command.");
  	  }

  	  try
  	  {
        container.internal.device.integration.LocalNotification.add(options, successHandler,
          errorHandler);
  	  }
  	  catch(e)
  	  {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.add.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"LocalNotification.add was not invoked (error=" + adf.mf.util.stringify(e) + ")");
        }
      }
  	},

    /**
     * Cancel a scheduled local notification
     *
     * @param {string} notificationId - id of the scheduled notification that needs to be cancelled
     * @param {successCallback} scb - success callback
     * @param {errorCallback} ecb - error callback
     */
    cancel: function(notificationId, scb, ecb)
    {
      var successHandler = function(request, response)
  	  {
  	    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
  				  "adf.mf.api.localnotification.cancel",
  				  "successHandler",
            "Request: " +
              adf.mf.util.stringify(request) +
              " Response: " +
              adf.mf.util.stringify(response));
  	    }

  	    if (typeof(scb) == typeof(Function))
  	      scb(request,response);
  	  };

      var errorHandler = function(request, error)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.cancel.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"There was an error in processing this request : " + adf.mf.util.stringify(request) +
            ". Error : " + adf.mf.util.stringify(error));
        }

        if (typeof(ecb) == typeof(Function))
          ecb(request, error);
      };

  	  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  	  {
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "LocalNotification",
          "cancel",
          "invoking local notification command.");
  	  }

  	  try
  	  {
        container.internal.device.integration.LocalNotification.cancel(notificationId,
          successHandler, errorHandler);
  	  }
  	  catch(e)
  	  {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.cancel",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification", "cancel",
        		"LocalNotification.cancel was not invoked (error=" + adf.mf.util.stringify(e) + ")");
        }
  	  }
    }

    /**
     * Success Callback
     *
     * @callback successCallback
     * @param {Object} request - request
     * @param {Object} response - response
     * @param {string} response.id - id of the notification
     */

    /**
     * Error Callback
     *
     * @callback errorCallback
     * @param {Object} request - request
     * @param {Object} response - response
     */
  };

  /**
   * Internal API used for local notifications
   *
   * These methods are to be used only by the embedded java code
   */
  adf.mf.internal.api.localnotification = adf.mf.internal.api.localnotification || function()
  {
  };

  adf.mf.internal.api.localnotification.add =
    adf.mf.internal.api.localnotification.add || function(commId, requestId, params)
  {
	  container.internal.device.integration.LocalNotification.add(params,
      // Success callback
      function(request,result)
      {
        var responseData = result.id || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.add", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "add", se);
        }
      },
      // Error callback
      function(request,result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.add", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "add", se);
        }
      });
  };

  adf.mf.internal.api.localnotification.cancel =
    adf.mf.internal.api.localnotification.cancel || function(commId, requestId, params)
  {
	  container.internal.device.integration.LocalNotification.cancel(params,
      // Success callback
      function(request,result)
      {
        var responseData = result.id || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.cancel", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "cancel", se);
        }
      },
      // Error callback
      function(request,result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.cancel",
            "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "cancel", se);
        }
      });
  };

  /**
   * Internal API used for sliding window plugins
   *
   * These methods are to be used only by the embedded java code
   */
  adf.mf.internal.api.slidingwindow = adf.mf.internal.api.slidingwindow || function() {};

  adf.mf.internal.api.slidingwindow.create =
    adf.mf.internal.api.slidingwindow.create || function(commId, requestId, featureId)
  {
    container.internal.device.integration.SlidingWindow.create(featureId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId,
            ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK,
            requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.create", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "create", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.create", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "create", se);
        }
      });
  };

  adf.mf.internal.api.slidingwindow.show =
    adf.mf.internal.api.slidingwindow.show || function(commId, requestId, windowId, options)
  {
    container.internal.device.integration.SlidingWindow.show(windowId, options,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.show", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "show", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.show", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "show", se);
        }
    });
  };

  adf.mf.internal.api.slidingwindow.hide =
    adf.mf.internal.api.slidingwindow.hide || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.hide(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.hide", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "hide", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.hide", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "hide", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.destroy =
    adf.mf.internal.api.slidingwindow.destroy || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.destroy(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.destroy", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "destroy", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.destroy", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "destroy", se);
        }
    });
  };

  adf.mf.internal.api.slidingwindow.getWindowInfo =
    adf.mf.internal.api.slidingwindow.getWindowInfo || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.getWindowInfo(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowInfo", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowInfo", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowInfo", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowInfo", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getTopWindowId =
    adf.mf.internal.api.slidingwindow.getTopWindowId || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getTopWindowId(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getTopWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getTopWindowId", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getTopWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getTopWindowId", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getWindowIds =
    adf.mf.internal.api.slidingwindow.getWindowIds || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getWindowIds(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowIds", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowIds", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowIds", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowIds", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getCurrentWindowId =
    adf.mf.internal.api.slidingwindow.getCurrentWindowId || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getCurrentWindowId(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getCurrentWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getCurrentWindowId", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getCurrentWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getCurrentWindowId", se);
        }
      });
  };

  /**
   * PUBLIC FUNCTION used to set the status bar style on iOS
   *
   * e.g. adf.mf.api.setStatusBarStyle(style, callback)
   *
   * The style may be one of the following values
   *    "dark"   : A dark status bar, intended for use on light backgrounds.
   *    "light"  : A light status bar, intended for use on dark backgrounds.
   *
   * @param {string} style     the style to set.  either "dark" or "light"
   * @param {function(string)} callback - function is called back with the current style as the
   *   argument can be null
   *
   * Example:
   *   adf.mf.api.setStatusBarStyle("dark",
   *     function(style) { console.log("new style: " + style); });
   */
  adf.mf.api.setStatusBarStyle = function(style, callback)
  {
    cordova.exec(
      function(result)
      {
        if (callback)
        {
          callback(result);
        }
      },
      function() {},
      "ADFMobileShell",
      "setStatusBarStyle",
      [ style ]);
  }

  /**
   * PUBLIC FUNCTION used to get the status bar style on iOS
   *
   * e.g. adf.mf.api.getStatusBarStyle(callback)
   *
   * The callback function will be invoked with a single string argument which will be one of
   *    "dark"   : A dark status bar, intended for use on light backgrounds.
   *    "light"  : A light status bar, intended for use on dark backgrounds.
   *
   * @param {function(string)} callback - function is called back with the current style as the
   *   argument can be null
   *
   * Example:
   *      adf.mf.api.getStatusBarStyle(function(style) { console.log("current style: " + style); });
   */
  adf.mf.api.getStatusBarStyle = function(callback)
  {
    cordova.exec(
      function(result)
      {
        if (callback)
        {
          callback(result);
        }
      },
      function() {},
      "ADFMobileShell",
      "getStatusBarStyle",
      []);
  }
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ContainerIntegration.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfLocale.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfLocale.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "AdfLocale"
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfLocale.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELErrors.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ELErrors.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};


/*
 * Represents any of the ADF flavored exceptions
 */
adf.mf.AdfException = function(message) { 
	/* since this is the only exception that is know and sent to both sides of the channel it needs to match the Java type */ 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.AdfException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'AdfException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.AdfException.prototype = new Error();


/*
 * Represents any of the exception conditions that can arise during expression evaluation.
 */
adf.mf.ELException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.ELException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'ELException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.ELException.prototype = new Error();


/**
 * Thrown to indicate that a method has been passed an illegal or 
 * inappropriate argument.
 */
adf.mf.IllegalArgumentException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IllegalArgumentException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IllegalArgumentException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IllegalArgumentException.prototype = new Error();

/**
 * Thrown to indicate that an array is being accessed beyond
 * it array boundaries.
 */
adf.mf.IndexOutOfBoundsException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IndexOutOfBoundsException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IndexOutOfBoundsException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IndexOutOfBoundsException.prototype = new Error();

/**
 * Thrown to indicate that the channel is not available.
 */
adf.mf.NoChannelAvailableException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.NoChannelAvailableException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'NoChannelAvailableException';
	this.message                                                = (message || "Operation not supported in the current environment");
	this.stack													= (new Error()).stack;
};     
adf.mf.NoChannelAvailableException.prototype = new Error();


/**
 * Thrown to indicate that a null pointer has been encountered.
 */
adf.mf.NullPointerException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.NullPointerException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'NullPointerException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.NullPointerException.prototype = new Error();


/**
 * Thrown to indicate that a illegal state has been encountered.
 */
adf.mf.IllegalStateException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IllegalStateException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IllegalStateException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IllegalStateException.prototype = new Error();


/**
 * Thrown when a property could not be found while evaluating a {@link adf.mf.el.ValueExpression} or
 * {@link MethodExpression}. For example, this could be triggered by an index out of bounds while
 * setting an array value, or by an unreadable property while getting the value of a JavaBeans
 * property.
 */
adf.mf.PropertyNotFoundException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.PropertyNotFoundException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'PropertyNotFoundException';
	this.message                                                = (message || "");
	// Uncomment this if you want to track where the exception is coming from:
	//this.stack													= (new Error()).stack;
};
adf.mf.PropertyNotFoundException.prototype = new Error();


/**
 * Thrown when a property could not be written to while setting the value on a
 * {@link adf.mf.el.ValueExpression}. For example, this could be triggered by trying to set a map value on an
 * unmodifiable map.
 */
adf.mf.PropertyNotWritableException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.PropertyNotWritableException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'PropertyNotWritableException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.PropertyNotWritableException.prototype = new Error();


/**
 * Thrown to indicate that the requested operation is not supported.
 */
adf.mf.UnsupportedOperationException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.UnsupportedOperationException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'UnsupportedOperationException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.UnsupportedOperationException.prototype = new Error();


adf.mf.DataRangeNotPresentException = function(message) {
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.DataRangeNotPresentException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'DataRangeNotPresentException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.DataRangeNotPresentException.prototype = new Error();



/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELErrors.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfResource.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfResource.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "AdfResource"
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfResource.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/JavaScriptContext.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- JavaScriptContext.js ---------------------- */
//@requires ELErrors
//@requires AdfPerfTiming


var adf                   = window.adf || {};
adf.mf                    = adf.mf || {};
adf.mf.api                = adf.mf.api || {};
adf.mf.el                 = adf.mf.el || {};
adf.mf.locale             = adf.mf.locale || {};
adf.mf.log                = adf.mf.log || {};
adf.mf.resource           = adf.mf.resource || {};
adf.mf.util               = adf.mf.util || {};

adf.mf.internal           = adf.mf.internal || {};
adf.mf.internal.api       = adf.mf.internal.api || {};
adf.mf.internal.el        = adf.mf.internal.el || {};
adf.mf.internal.el.parser = adf.mf.internal.el.parser || {};
adf.mf.internal.locale    = adf.mf.internal.locale || {};
adf.mf.internal.log       = adf.mf.internal.log || {};
adf.mf.internal.mb        = adf.mf.internal.mb || {};
adf.mf.internal.perf      = adf.mf.internal.perf || {};
adf.mf.internal.resource  = adf.mf.internal.resource || {};
adf.mf.internal.util      = adf.mf.internal.util || {};

/**
 * JavaScriptContext is defined here.  It is an internal object but depends on
 * a couple helper objects (JavaScriptFunctions and JavaScriptVariables) that
 * are defined here as well.  Since only the JavaScriptContext must be exposed
 * to other internal objects, it will have an adf.mf.internal.el namespace.  The
 * others are never exposed and are only local to this initialization function.
 */
(function()
{
  // private to the JavaScriptContext object
  function JavaScriptFunctions() // implements FunctionMapper
  {
    // map from function name to function implementation
    this.map = null;

    /**
     * @param {string} prefix
     * @param {string} localName
     * @return {function}
     */
    this.resolveFunction = function(prefix, localName)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      return this.map[prefix + ":" + localName];
    };

    /**
     * @param {string} prefix
     * @param {string} localName
     * @param {function} func
     */
    this.setFunction = function(prefix, localName, func)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      this.map[prefix + ":" + localName] = func;
    };
  };

  // private to the JavaScriptContext object
  function JavaScriptVariables()
  // implements VariableMapper
  {
    // map from variable name to variable's value
    this.map             = null;
    this.nextModLZWCode  = 0;

    /**
     * @param {string} variable
     * @return {adf.mf.el.ValueExpression}
     */
    this.resolveVariable = function(variable)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      return this.map[variable];
    };

    /**
     *
     * @param {string} variable
     * @param {Object} value
     * @return {adf.mf.el.ValueExpression}
     */
    this.setVariable = function(variable, value)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      this.map[variable] = value;

      return this.map[variable];
    };

    /**
     * @param {string} variable
     */
    this.removeVariable = function(variable)
    {
      if (this.map !== null)
      {
        if (this.map[variable] !== undefined)
        {
          delete this.map[variable];
        }
      }
    };

    this.clearWeakReferences = function()
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          if (this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY] !== undefined)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
             adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
              "JavaScriptVariables","clearWeakReferences",
              "removing weak ref - " + v);
            }
            delete this.map[v];
          }
        }
        this.nextModLZWCode = 0;
      }
    };

    /**
     * @param {string} variable
     * @return {string}
     */
    this.resolveWeakReference = function(variable)
    {
      var v = this.resolveVariable(variable);

      if (v != undefined)
      {
        return v[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];
      }

      return undefined;
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.getWeakReference = function(name)
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          var fqn = this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];

          if ((fqn !== undefined) && (name.indexOf(fqn) == 0))
          {
            var wrn = v + name.substring(fqn.length);

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
               "JavaScriptVariables", "getWeakReference",
               "just found weak ref - " + wrn);
            }

            return wrn;
          }
        }
      }
      return undefined;
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.findMatchingWeakReference = function(name)
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          var fqn = this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];

          if ((fqn !== undefined) && (name == fqn))
          {
            return v;
          }
        }
      }

      return undefined;
    };

    /**
     * @param {string} reference
     * @return {string}
     */
    this.addCompressedReference = function(reference)
    {
      var lzwk = this.findMatchingWeakReference(reference);

      if (lzwk == undefined)
      {
        var key = adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY;
        var wr  = {};

        wr[key] = reference;
        lzwk = "_" + (this.nextModLZWCode++);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "JavaScriptVariables", "addCompressedReference",
            "just added a weak ref - " + wr);
        }

        this.setVariable(lzwk, wr);
      }

      return lzwk;
    };
  };

  /**
   * Still internal but exposed to the other internal objects
   *
   * @param {ELResolver} elResolver
   */
  adf.mf.internal.el.JavaScriptContext = function(elResolver)
    // implements ELContext
  {
    this.context   = this;
    this.functions = null;
    this.resolver  = (elResolver || null);
    this.variables = null;
    this.queue     = null;
    this.vmchannel = null;
    this.security  = null;
    this.modid     = (new Date()).getTime();

    /**
     * Get the modification id for the context.
     * @return {int}
     */
    this.getModId = function()
    {
      return this.modid;
    };

    /**
     * Update the modification id for the context.
     */
    this.updateModId = function()
    {
      this.modid = (new Date()).getTime();
    };

    /**
     * Returns the context object associated with the given key. The ELContext maintains a
     * collection of context objects relevant to the evaluation of an expression. These context
     * objects are used by ELResolvers. This method is used to retrieve the context with the given
     * key from the collection. By convention, the object returned will be of the type specified by
     * the key. However, this is not required and the key is used strictly as a unique identifier.
     *
     * @param {Class} key
     *        The unique identifier that was used to associate the context object with this
     *        ELContext.
     * @return {ELContext} The context object associated with the given key, or null if no such context was
     *      found.
     * @throws NullPointerException
     *         if key is null.
     */
    this.getContext = function(key)
    {
      // First check to make sure we have a context to give back */
      if ((this.context === undefined) || (this.context === null))
      {
        return null;
      }

      // Next check that they passed a key and if not return the root context
      if (key === undefined)
      {
        return this.context;
      }

      // Looks like we have everything so return the key'ed context
      return this.context[key];
    };

    /**
     * Retrieves the ELResolver associated with this context. The ELContext maintains a reference to
     * the ELResolver that will be consulted to resolve variables and properties during an
     * expression evaluation. This method retrieves the reference to the resolver. Once an ELContext
     * is constructed, the reference to the ELResolver associated with the context cannot be
     * changed.
     *
     * @return {ELResolver} The resolver to be consulted for variable and property resolution during expression
     *      evaluation.
     */
    this.getELResolver = function()
    {
      if (this.resolver === null)
      {
        this.resolver = new VariableResolver();

        // Add some scopes to the context */
        this.getVariableMapper().setVariable("viewScope", {});
        this.getVariableMapper().setVariable("pageFlowScope", {});
        this.getVariableMapper().setVariable("applicationScope", {});

        // Represents #{feature} implicit object that allows developers to access runtime state of the feature.
        // The name intentionally does not end with "Scope" as it is more of a context.
        // This constant is defined in Java in oracle.adfmf.Constants, and both names need to be kept in sync.
        this.getVariableMapper().setVariable("feature", {});
        this.getVariableMapper().setVariable("preferenceScope", {});
        this.getVariableMapper().setVariable("validationScope", {});
        this.getVariableMapper().setVariable("deviceScope", {"device": {}, "hardware": {"screen": {}}});
      }

      return this.resolver;
    };

    /**
     * Retrieves the FunctionMapper associated with this ELContext.
     *
     * @return {FunctionMapper} The function mapper to be consulted for the resolution of EL functions.
     */
    this.getFunctionMapper = function()
    {
      if (this.functions === null)
      {
        this.functions = new JavaScriptFunctions();
      }

      return this.functions;
    };

    /**
     * Retrieves the VariableMapper associated with this ELContext.
     *
     * @return {VariableMapper} The variable mapper to be consulted for the resolution of EL variables.
     */
    this.getVariableMapper = function()
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables;
    };


    /**
     * Returns whether an {@link ELResolver} has successfully resolved a given (base, property)
     * pair. The {@link CompositeELResolver} checks this property to determine whether it should
     * consider or skip other component resolvers.
     *
     * @return {boolean} The variable mapper to be consulted for the resolution of EL variables.
     * @see CompositeELResolver
     */
    this.isPropertyResolved = function()
    {
      return this.resolved;
    };

    /**
     * Associates a context object with this ELContext. The ELContext maintains a collection of
     * context objects relevant to the evaluation of an expression. These context objects are used
     * by ELResolvers. This method is used to add a context object to that collection. By
     * convention, the contextObject will be of the type specified by the key. However, this is not
     * required and the key is used strictly as a unique identifier.
     *
     * @param {Class} key
     *        The key used by an {@link ELResolver} to identify this context object.
     * @param {Object} contextObject
     *        The context object to add to the collection.
     * @throws NullPointerException
     *         if key is null or contextObject is null.
     */
    this.putContext = function(key, contextObject)
    {
      if ((this.context === undefined) || (this.context === null))
      {
        this.context = {};
      }

      if ((key === undefined) || (key === null))
      {
        throw Error("invalid key");
      }

      if ((contextObject === undefined) || (contextObject === null))
      {
        throw Error("invalid context object");
      }

      this.context[key] = contextObject;
    };

    /**
     * @param {ELResolver} resolver
     */
    this.setELResolver = function(resolver)
    {
      this.resolver = resolver;
    };

    /**
     * @param {string} prefix
     * @param {string} localName
     * @param {function} func
     */
    this.setFunction = function(prefix, localName, func)
    {
      if (this.functions === null)
      {
        this.functions = new JavaScriptFunctions();
      }

      this.functions.setFunction(prefix, localName, func);
    };

    /**
     * Called to indicate that a ELResolver has successfully resolved a given (base, property) pair.
     * The {@link CompositeELResolver} checks this property to determine whether it should consider
     * or skip other component resolvers.
     *
     * @param {boolean} resolved
     *        true if the property has been resolved, or false if not.
     * @see CompositeELResolver
     */
    this.setPropertyResolved = function(resolved)
    {
      this.resolved = resolved;
    };

    this.clearWeakReferences = function()
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.clearWeakReferences();
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.getWeakReference = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.getWeakReference(name);
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.addCompressedReference = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.addCompressedReference(name);
    };

    /**
     * @param {ELExpression} elExpression
     */
    this.uncompressReference = function(elExpression)
    {
      try
      {
        if (this.variables == null)
        {
          return elExpression;
        }

        var token = elExpression.tokens [0];
        var result = this.variables.resolveWeakReference(token.index);

        if (!result)
        {
          return elExpression;
        }

        if (result == token.index)
        {
          return elExpression;
        }

        var replacement = {};

        replacement[token.index] = result;

        return elExpression.stripLocalValues(false, replacement, false);
      }
      catch(err)
      {
        return elExpression;
      }
    };

    /**
     * @param {string} name
     * @return {Object}
     */
    this.getVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.resolveVariable(name);
    };


    /**
     * @param {string} name
     * @param {adf.mf.el.ValueExpression} expression
     */
    this.setVariable = function(name, expression)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.setVariable(name, expression);
    };


    /**
     * @param {string} name
     */
    this.removeVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.removeVariable(name);
    };


    /**
     * @param {string} name
     * @param {adf.mf.el.ValueExpression} expression
     */
    this.pushVariable = function(name, expression)
    {
      var prevValue = undefined;

      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      prevValue = this.variables.resolveVariable(name);

      if (this.queue === null)
      {
        this.queue = [];
      }

      if (prevValue != null)
      {
        this.queue[name] = this.queue[name] || [];

        this.queue[name].push(prevValue);
      }

      return this.variables.setVariable(name, expression);
    };

    /**
     * @param {string} name
     */
    this.popVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      if (this.queue === null)
      {
        this.queue = [];
      }

      if ((q = this.queue[name]) != null)
      {
        var v;

        if ((v = q.pop()) != null)
        {
          this.setVariable(name, v);
        }
        else
        {
          if (q.length == 0)
          {
            delete this.queue[name];
            this.variables.removeVariable(name);
          }
        }
      }
    };

    /**
     * @param {Object} commId The communication channel ID (type unsure)
     */
    this.invokeJavaMethod = function(commId, request, success, failed)
    {
      if (this.vmchannel === null)
      {
        this.vmchannel  = new adf.mf.internal.VMChannel(this);
      }

      if (commId != undefined)
      {
        request.featureId = commId;
      }

      this.vmchannel.nonBlockingCall(request, success, failed);
    };

    this.invokeSecurityMethod = function(command, username, password, tenantname, success, failed)
    {
      if (this.security === null)
      {
        //this.security  = new Security(this);
        this.security  = new adf.mf.security(this);
      }

      var fm = this.getFunctionMapper();
      var f  = fm.resolveFunction("Security", command);

      return f.call(undefined, username, password, tenantname, success, failed);
    };

    /**
     * @return {string}
     */
    this.toString = function()
    {
      return "[ ELContext: " + this.context + " ]";
    };
  };

  function VariableResolver()
  {
  }

  adf.mf.internal.el.VariableResolver = VariableResolver;

  /**
   * Attempts to resolve the given property object on the given base object.
   *
   * If the base object is null or undefined, delegates to
   * context.getVariableMapper().resolveVariable(property).
   *
   * If the base object is a Java language array, returns the value at the given index. The index
   * is specified by the property argument, and coerced into an integer. If the coercion could not
   * be performed, an IllegalArgumentException is thrown. If the index is out of bounds, null is
   * returned.
   *
   * If the base object is a map, returns the value associated with the given key, as specified by
   * the property argument. If the key was not found, null is returned. Just as in
   * java.util.Map.get(Object), just because null is returned doesn't mean there
   * is no mapping for the key; it's also possible that the Map explicitly maps
   * the key to null.
   *
   *
   * @param {ELContext} context
   *        The context of this evaluation.
   * @param {Object} base
   *        The base object to return the most general property type for, or null to enumerate
   *        the set of top-level variables that this resolver can evaluate.
   * @param {Object} property
   *        The property or variable to return the acceptable type for.
   * @return {Object} If the propertyResolved property of ELContext was set to true, then the result of the
   *      variable or property resolution; otherwise undefined.
   * @throws NullPointerException
   *         if context is null
   * @throws PropertyNotFoundException
   *         if base is not null and the specified property does not exist or is not readable.
   * @throws ELException
   *         if an exception was thrown while performing the property or variable resolution.
   *         The thrown exception must be included as the cause property of this exception, if
   *         available.
   */
  VariableResolver.prototype.getValue = function(context, base, property)
  {
    var result = undefined;

    if ((base === undefined) || (base === null))
    {
      // Root Property EL Resolver
      var variables = context.getVariableMapper();

      try
      {
        result = variables.resolveVariable(property);

        if ((result instanceof Object) &&
          (result[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY] !== undefined))
        {
          var ref = result[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];
          var p = adf.mf.internal.el.parser.parse("#{" + ref + "}");

          try
          {
            result = p.evaluate(context);
          }
          catch (e)
          {
            result = {};
            p.setValue(context, result);
          }
        }
      }
      catch (e)
      {
      }
    }
    else if (Array.isArray(base))
    {
      // Array EL Resolver
      result = base[property];
    }
    else if ((typeof base) === 'object')
    {
      var baseType = base['.type'];

      if (baseType === 'Attribute')
      {
        // Attribute EL Resolver
        if (property == "bindings")
        {
          result = new adf.mf.internal.el.AttributeBinding(base);
        }
        else if (property == 'inputValue')
        {
          // getInputValue
          result = base.getPropertyInputValue(property);
        }
        else
        {
          result = base.getProperty(property);
        }
      }
      else if (baseType === 'AttributeBinding')
      {
        // Attribute Binding EL Resolver
        result = new adf.mf.internal.el.Attribute(base, property);
      }
      else if (baseType === 'TreeBindings')
      {
        // Tree Binding EL Resolver
        // special cases:
        //   inputValue: need to read to the provider's object and not here
        if (property == 'iterator')
        {
          try
          {
            result = new adf.mf.el.TreeNodeIterator(base, 0);

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.el", "TreeBindingsELResolver",
                "resolved iterator with " + result.getCachedRowCount(0) + " rows cached.");
            }
          }
          catch (ie)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
               "adf.mf.internal.el", "TreeBindingsELResolver",
               "resolving the iterator resulted in an exception: " + ie);
            }
          }
        }
        else if (base[property] !== undefined)
        {
          result = base[property];
        }
        else
        {
          var ab = base.columnAttributes() || {};

          result = ab[property];
        }
      }
      else if (baseType === 'oracle.adfmf.bindings.dbf.TreeNode')
      {
        // TreeNode EL Resolver
        if (property == "bindings")
        {
          result = new adf.mf.internal.el.AttributeBinding(base);
        }
        else if (property.toLowerCase() == "rowkey")
        {
          result = base.rowKey();
        }
        else if (property == "dataProvider")
        {
          result = base.getProvider();
        }
        else
        {
          var dp = base.getProvider() || {};

          result = dp[property];

          // if it is a row, attempt to resolve row.bindings.property.inputValue
          if (result == undefined && dp[".type"] === 'row')
          {
            result = VariableResolver.getValueFromRow(dp, property);
          }
        }
      }
      else if (baseType === 'OptionalFragmentArgument')
      {
        // Optional Fragment Argument EL Resolver
        result = base;
      }
      else
      {
        // Map EL Resolver
        // First attempt to get the property
        result = base[property];

        // If it is a row, attempt to resolve row.bindings.property.inputValue
        if (result == undefined && baseType === 'row')
        {
          result = VariableResolver.getValueFromRow(base,property);
        }
      }
    } // (typeof base) == 'object'

    if (result === undefined)
    {
      throw new adf.mf.PropertyNotFoundException();
    }
    return result;
  };

  /**
   * Resolves the EL #{row.property} to #{row.bindings.property.inputValue}
   */
  VariableResolver.getValueFromRow = function(row, property)
  {
    var bindings = row["bindings"];

    if (bindings && typeof bindings == 'object')
    {
      var attr = bindings[property];

      if (attr && typeof attr == 'object')
      {
        return attr["inputValue"];
      }
    }

    return undefined;
  }

  /**
   * Set on the EL #{row.property} will be set to #{row.bindings.property.inputValue}
   *
   * @param {Object} row the provider from the collection model on which to set the value
   * @param {string} property the property name for which to set the value
   * @param {Object} value the value to set
   */
  VariableResolver.setValueInRow = function(row, property, value)
  {
    var bindings = row["bindings"];
    if (bindings && typeof bindings == 'object')
    {
      var attr = bindings[property];
      if (attr && typeof attr == 'object')
      {
        attr["inputValue"] = value;
      }
      else if (attr == null)
      {
        // If the attr is null, this means that an attribute that is not defined in the
        // page bindings is trying to be set. If we do not set it, we can get into an
        // infinite loop of re-requesting the bad value on the page (bug 23324654).
        // So instead, set the value to the null object here (do not use the value being passed
        // in) to stop the loop.
        attr = { "inputValue": { ".null": true } };
        bindings[property] = attr;

        // Now log an error so that the page author can detect that something is wrong
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.el.VariableResolver.setValueInRow",
          "ERROR_INVALID_COLLECTION_MODEL_ATTRIBUTE");

        // For security purposes, only log the details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          var valueStr;
          try
          {
            valueStr = adf.mf.util.stringify(value);
          }
          catch (e)
          {
            valueStr = "" + value;
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.el.VariableResolver", "setValueInRow",
            "Trying to set property: " + property + " with value: " + valueStr);
        }
      }
    }
  }

  /**
  * Attempts to set the value of the given property object on the given base object.
  *
  * If the base object is null or undefined, delegates to
  * context.getVariableMapper().setVariable(property, value).
  *
  * If the base object is a Java language array, attempts to set the value at the given index
  * with the given value. The index is specified by the property argument, and coerced into an
  * integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If
  * the index is out of bounds, a PropertyNotFoundException is thrown.
  *
  * If the base object is a map, attempts to set the value associated with the given key, as
  * specified by the property argument.
  *
  * @param {ELContext} context
  *        The context of this evaluation.
  * @param {Object} base
  *        The base object to return the most general property type for, or null to enumerate
  *        the set of top-level variables that this resolver can evaluate.
  * @param {Object} property
  *        The property or variable to return the acceptable type for.
  * @param {Object} value
  *        The value to set the property or variable to.
  * @throws NullPointerException
  *         if context is null
  * @throws PropertyNotFoundException
  *         if base is not null and the specified property does not exist or is not readable.
  * @throws PropertyNotWritableException
  *         if the given (base, property) pair is handled by this ELResolver but the
  *         specified variable or property is not writable.
  * @throws ELException
  *         if an exception was thrown while attempting to set the property or variable. The
  *         thrown exception must be included as the cause property of this exception, if
  *         available.
  */
  VariableResolver.prototype.setValue = function(
    context,
    base,
    property,
    value)
  {
    if ((base === undefined) || (base === null))
    {
      // Root Property EL Resolver
      context.getVariableMapper().setVariable(property, value);
    }
    else if (Array.isArray(base))
    {
      // Array EL Resolver
      base[property] = value;
    }
    else if ((typeof base) == 'object')
    {
      var baseType = base['.type'];

      if (baseType == 'Attribute')
      {
        // Attribute EL Resolver
        if (property == 'inputValue')
        {
          base.setPropertyInputValue(value);
        }
        else
        {
          base.setProperty(property, value);
        }
      }
      else if (baseType == 'AttributeBinding')
      {
        // Attribute Binding EL Resolver
        base[property] = value;
      }
      else if (baseType == 'TreeBindings')
      {
        // Tree Binding EL Resolver
        // special cases:
        //  inputValue: need to written to the provider's object and not here
        if (property == 'iterator')
        {
          throw new adf.mf.PropertyNotWritableException("resolver is read-only");
        }
        else if (base[property] !== undefined)
        {
          base[property] = value;
        }
        else
        {
          if ((typeof value) !== 'AttributeBindings')
          {
            throw new adf.mf.IllegalArgumentException("value is not a AttributeBindings object");
          }

          var ab = base.columnAttributes() || {};

          ab[property] = value;
        }
      }
      else if (baseType == 'oracle.adfmf.bindings.dbf.TreeNode')
      {
        // TreeNode EL Resolver
        if (property == "bindings")
        {
          base.bindings = value;
        }
        else if (property == "dataProvider")
        {
          base.dataProvider = value;
        }
        else if (property == "rowKey")
        {
          throw new adf.mf.PropertyNotWritableException("rowKey is read-only");
        }
        else
        {
          var dp = base.getProvider() || {};

          if (dp[".type"] == "row")
          {
            VariableResolver.setValueInRow(dp, property, value);
          }
          else
          {
            dp[property] = value;
          }
        }
      }
      else if (baseType == 'OptionalFragmentArgument')
      {
        // Optional Fragment Argument EL Resolver
      }
      else if (baseType == "row")
      {
        VariableResolver.setValueInRow(base, property, value);
      }
      else
      {
        // Map EL Resolver
        base[property] = value;
      }
    }
  };

  adf.mf.internal.el.Attribute = function(/* AttributeBinding */ ab, /* string */ name)
  {
    this['ab'] = ab;
    this['.type'] = 'Attribute';
    this['.name'] = name;

    this.toString = function()
    {
      return "Attribute[" + adf.mf.util.stringify(this.getPropertyInputValue()) + "]";
    };

    this.getProperty = function(/* string */ name)
    {
      var bindings = undefined;
      var property = undefined;

      try
      {
        bindings = this.ab.getBindings();
        property = bindings[this['.name']];
      }
      catch (e)
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['.name']);
      }

      return property[name];
    };

    this.getPropertyInputValue = function()
    {
      if ((ab !== undefined) && (ab.tn !== undefined))
      {
        return '' + adf.mf.util.stringify(this.ab.tn.getProvider()[this['.name']]);
      }
      else
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['.name']);
      }
    };

    this.setProperty = function(/* string */ name, /* object */ value)
    {
      var bindings = this.ab.getBindings();
      var property = bindings[this['.name']];

      property[name] = value;
    };

    this.setPropertyInputValue = function(/* object */ value)
    {
      if ((ab !== undefined) && (ab.tn !== undefined))
      {
        var p = this.ab.tn.getProvider();

        p[this['.name']] = value;
      }
      else
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['_name']);
      }
    };
  };

  adf.mf.internal.el.AttributeBinding = function(/* TreeNode */ tn)
  {
    this['.type'] = 'AttributeBinding';
    this.tn = tn;

    this.getBindings = function()
    {
      return tn.getBindings();
    };

    this.getProvider = function()
    {
      return tn.getProvider();
    };

    this.toString = function()
    {
      return "Attribute Bindings";
    };
  };

  adf.mf.internal.el.OptionalFragmentArgument = function()
  {
    this['.type']  = 'OptionalFragmentArgument';

    this.toString   = function()
    {
      return "OptionalFragmentArgument";
    };

    this.getProperty = function(/* string */ name)
    {
      return this;
    };

    this.setProperty = function(/* string */ name, /* object */ value)
    {
      /* ignore */
    };
  };

  adf.mf.api.OptionalFragmentArgument = adf.mf.api.OptionalFragmentArgument ||
    new adf.mf.internal.el.OptionalFragmentArgument;

  adf.mf.internal.VMChannel = function(/* Context */ context)
  {
    /**
     * blockingCall(java-class-name, java-class-method-name, success-callback, failed-callback, arguments);
     */
    this.blockingCall = function(request, success, failed)
    {
      throw adf.mf.UnsupportedOperationException("blocking calls are not supported in this version");
    };

    this.nonBlockingCall= function(request, success, failed)
    {
      var scb  = [];
      var fcb  = [];
      var op   = request.classname + ":" + request.method;

      if (adf.mf.internal.batchRequest !== undefined)
      {
        var deferedObject = {};

        /* configure up the success and failed callback vectors */
        scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);
        fcb = fcb.concat(adf.mf.internal.util.is_array(failed)?  failed  : [failed ]);

        adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.VMChannel", "nonBlockingCall",
        "appending request on the batch request - actual request is being defered.");
        adf.mf.internal.batchRequest.push(request);

        deferedObject[adf.mf.internal.api.constants.DEFERRED_PROPERTY];

        for (var i = 0; i < scb.length; ++i)
        {
          try
          {
            var callback = scb[i];
            if (callback)
              callback(request, deferedObject);
          }
          catch(se)
          {
            // nothing we can do
          }
        }
      }
      else
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Non blocking call",
          adf.mf.log.level.FINER,
          "adf.mf.internal.VMChannel.nonBlockingCall", op);

        /* configure up the success and failed callback vectors */
        scb = scb.concat([function() { perf.stop(); }]);
        scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);

        fcb = fcb.concat([function() { perf.stop(); }]);
        fcb = fcb.concat(adf.mf.internal.errorHandlers);
        fcb = fcb.concat(adf.mf.internal.util.is_array(failed)?  failed  : [failed ]);

        try
        {
          container.internal.device.integration.vmchannel.invoke(10000, request, scb, fcb);
        }
        catch(e)
        {
          if ((! adf.mf.internal.isJavaAvailable()) || (e.name == "TypeError") ||
            (e.name == "ReferenceError"))
          {
            // this is when navigator, container.internal.device.integration, or
            // container.internal.device.integration.vmchannel is missing.
            e = new adf.mf.NoChannelAvailableException();
          }

          for (var i = 0; i < fcb.length; ++i)
          {
            try
            {
              var callback = fcb[i];
              if (callback)
                callback(request, e);
            }
            catch(fe)
            {
              // nothing we can do
            }
          }
        }
      }
    };

    context.setFunction("VMChannel", "blockingCall", this.blockingCall);
    context.setFunction("VMChannel", "nonBlockingCall", this.nonBlockingCall);
  };

  adf.mf.security = function(/* Context */ context)
  {
    this.login = function(username, password, tenantname)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureLogin(username, password, tenantname);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "login",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.logout = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureLogout();
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "logout",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.isAuthenticated = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureIsAuthenticated();
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "isAuthenticated",
          "adfmf - invoking the Security command");
      }
    };

    this.cancelLogin = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.cancelLogin();
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "cancelLogin",
          "adfmf - invoking the Security command");
      }
    };

    this.isConnectionMultiTenantAware = function(username, password, tenantname, callback)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureIsConnectionMultiTenantAware(
          callback);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security",
            "isConnectionMultiTenantAware",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.getMultiTenantUsername = function(username, password, tenantname, callback)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureGetMultiTenantUsername(callback);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getMultiTenantUsername",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.getLoginViewInitData = function(username, password, tenantname, success, failed)
    {
      try
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getLoginViewInitData",
            "invoking security command.");
        }

        container.internal.device.integration.Security.getLoginViewInitData(success, failed);
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getLoginViewInitData",
            "Security.getLoginViewInitData was not invoked (error=" + e + ")");
        }
      }
    };

    context.setFunction("Security", "cancelLogin", this.cancelLogin);
    context.setFunction("Security", "login", this.login);
    context.setFunction("Security", "logout", this.logout);
    context.setFunction("Security", "isAuthenticated", this.isAuthenticated);
    context.setFunction("Security", "isConnectionMultiTenantAware",
      this.isConnectionMultiTenantAware);
    context.setFunction("Security", "getMultiTenantUsername", this.getMultiTenantUsername);
    context.setFunction("Security", "getLoginViewInitData", this.getLoginViewInitData);
  };
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/JavaScriptContext.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adflog.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Adflog.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "Adflog" (don't think this particular one is required anywhere... maybe just bootstrap)
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adflog.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfPerfTiming.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfPerfTiming.js ---------------------- */
// @requires Adflog
// @requires ELErrors

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

/**
 * adf.mf.internal.perf consists of a set of javascript functions
 * to instrument the adf.mf javascript sub-systems
 *
 * HOW-TO USE THIS:
 * Declare the performance loggers
 *
 *    # used to control what monitors are captured in the list of monitors
 *    oracle.maf.performance.monitor.captured.useParentHandlers=false
 *    oracle.maf.performance.monitor.captured.handlers=oracle.adfmf.util.logging.ConsoleHandler
 *    oracle.maf.performance.monitor.captured.level = FINEST
 *    
 *    # used to control what monitor observations (start/stop times) are logged.
 *    oracle.maf.performance.monitor.observations.reported=false
 *    oracle.maf.performance.monitor.observations.reported.handlers=oracle.adfmf.util.logging.ConsoleHandler
 *    oracle.maf.performance.monitor.observations.reported.level = FINEST
 */
 
(function()
{
  //
  // JS representation of "oracle.maf.performance.monitor.observations.reported" logger
  //
  var perfMonReportedLogger = adf.mf.log.PerfMonReported = adf.mf.log.PerfMonReported ||
    new adf.mf.log.logger("oracle.maf.performance.monitor.observations.reported");
  //
  // JS representation of "oracle.maf.performance.monitor.captured" logger
  //
  var perfMonCapturedLogger = adf.mf.log.PerfMonCaptured = adf.mf.log.PerfMonCaptured ||
    new adf.mf.log.logger("oracle.maf.performance.monitor.captured");

  // ============================================================================================
  // Private methods and variables
  // Uncomment the following lines, in order to obtain performance numbers for start up.
  //perfMonReportedLogger.init(adf.mf.log.level.FINE,
  //  "[%LEVEL% - %LOGGER% - %CLASS% - %METHOD%] %MESSAGE%");
  //perfMonCapturedLogger.init(adf.mf.log.level.FINE,
  //  "[%LEVEL% - %LOGGER% - %CLASS% - %METHOD%] %MESSAGE%");
  //

  var FINEST = adf.mf.log.level.FINEST;
  var FINER = adf.mf.log.level.FINER;
  var FINE = adf.mf.log.level.FINE;
  var INFO = adf.mf.log.level.INFO;

  var noop = function() {};
  var noopTask = { "stop" : noop, "setInstanceName" : noop}; 
  var Assert = adf.mf.api.AdfAssert;

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Task object (base class)
  function Task(name)
  {
    this.Init(name);
  }

  adf.mf.api.AdfObject.createSubclass(Task, adf.mf.api.AdfObject, "Task");

  Task.InitClass = function()
  {
    // Used to keep a unique ID per task to identify it
    this._nextId = 1;
    // Tasks that are currently running
    this._activeTasks = [];
    this.VisitResult = { "ACCEPT": 0, "REJECT": 1, "COMPLETE": 2 };
  };

  /**
   * Get the most recent task that was started
   */
  Task.getActiveTask = function()
  {
    return (Task._activeTasks.length == 0) ?
      null : Task._activeTasks[Task._activeTasks.length - 1];
  };

  Task.prototype.Init = function(name)
  {
    this._id = Task._nextId++;
    this._name = name;
    this._parent = null;
    this._tasks = [];
    this._start = null;
    this._stop = null;
    this._tasksCompletedAt = null;
    this._activeTaskCount = 0;
    this._level = FINEST;
    this._description = null;
    this._instanceName = null;
  };

  Task.prototype.getIdentifier = function()
  {
    // Lazily create it for performance as we won't always need it
    if (this._identifier == null)
    {
      this._identifier = this.constructor.name + "[" + this._id + "/" + this._name + "]";
    }

    return this._identifier;
  };

  /**
   * Get the count of the tasks that are still running
   * @return {Number} the active count
   */
  Task.prototype.getActiveTaskCount = function()
  {
    return this._activeTaskCount;
  };

  /**
   * @return {Number} the unique ID of the task
   */
  Task.prototype.getId = function()
  {
    return this._id;
  };

  /**
   * @return {string} the friendly name of the task
   */
  Task.prototype.getName = function()
  {
    return this._name;
  };

  /**
   * @return {Task} the parent or null if a top level task
   */
  Task.prototype.getParent = function()
  {
    return this._parent;
  };
  
  Task.prototype.getLevel = function()
  {
    return this._level;
  };
  
  Task.prototype.setLevel = function(level)
  {
    this._level = level;
  };
  
  Task.prototype.getDescription = function()
  {
    return this._description;
  };
  
  Task.prototype.setDescription = function(description)
  {
    this._description = description;
  };
  
  Task.prototype.getInstanceName = function()
  {
    return this._instanceName;
  };
  
  Task.prototype.setInstanceName = function(instanceName)
  {
    this._instanceName = instanceName;
  };

  /**
   * @return {Operation} the closest parent operation or null if none
   */
  Task.prototype.getParentOperation = function()
  {
    for (var p = this._parent; p != null; p = p.getParent())
    {
      if (p instanceof Operation)
      {
        return p;
      }
    }

    return null;
  };

  /**
   * Add a child
   * @param {Task} task the child
   */
  Task.prototype.addChildTask = function(task)
  {
    if (this._stop != null)
    {
      Assert.assert(false,
        "addChildTask called on a stopped task: " + this.getIdentifier() +
        ", attempting to add " + task.getIdentifier());
    }
    this._tasks.push(task);
    ++this._activeTaskCount;
  };

  /**
   * Start the task running
   */
  Task.prototype.start = function()
  {
    if (this._start != null)
    {
      Assert.assert(
        false,
        "start called on a task that was already started: " + this.getIdentifier());
    }

    this._start = (new Date()).getTime();
    this._parent = Task.getActiveTask();

    if (this._parent != null)
    {
      this._parent.addChildTask(this);
    }

    Task._activeTasks.push(this);

    return this;
  };

  /**
   * Stop the task (may not be yet completed if there are children tasks still running)
   * @param {boolean} check if the task was already stopped, and if so, don't stop it again
   */
  Task.prototype.stop = function(checkStopped)
  {
    try
    {
      if (this._stop != null)
      {
        if (checkStopped)
        {
          return;
        }
        Assert.assert(
          false,
          "stop called on a task that was already stopped: " + this.getIdentifier());
      }
      
      
      this._stop = (new Date()).getTime();

      // Notify the sub-class
      this.Stopped();

      // See if this task is now complete
      this._checkComplete();
    }
    catch (e)
    {
      // Eat any exceptions in the performance code to prevent issues loading the page
      if (perfMonReportedLogger.isLoggable(FINEST))
      {
        perfMonReportedLogger.logp(FINEST,
          "adf.mf.internal.perf.Task", "stop",
          "Exception thrown " + e.message);
      }
      return { "stop": noop };
    }
  };
  

  /**
   * @return {Number} the start time (ms) of the task or null if not started
   */
  Task.prototype.getStart = function()
  {
    return this._start;
  };

  /**
   * @return {Number} the stop time (ms) of the task or null if not yet stopped.
   */
  Task.prototype.getStop = function()
  {
    return this._stop;
  };

  /**
   * @return {Number} the time (ms) between the start and stop times (may be null if not yet stopped)
   */
  Task.prototype.getElapsed = function()
  {
    return (this._start == null || this._stop == null) ?
      null : (this._stop - this._start);
  };

  /**
   * @return {Number} the time (ms) between the start and when the task was completed (all children
   * completed)
   */
  Task.prototype.getTotalElapsed = function()
  {
    return (this._start == null || this._tasksCompletedAt == null) ?
      null : (this._tasksCompletedAt - this._start);
  };

  /**
   * @return {Number} the time (ms) of the task completion or null if not yet stopped or children
   * tasks are still running
   */
  Task.prototype.getTasksCompletedAt = function()
  {
    return this._tasksCompletedAt;
  };

  /**
   * Visit interface. The callback accepts the task and returns a Task.VisitResult object.
   * @return {bool} true if visiting should continue
   */
  Task.prototype.visit = function(callback)
  {
    var result = callback(this);
    switch (result)
    {
      case Task.VisitResult["ACCEPT"]:
        for (var t = 0, numTasks = this._tasks.length; t < numTasks; ++t)
        {
          var task = this._tasks[t];
          if (!task.visit(callback))
          {
            return false;
          }
        }
        return true;
      case Task.VisitResult["REJECT"]:
        return true;
      case Task.VisitResult["COMPLETE"]:
      default:
        return false;
    }
  };

  /**
   * Check if the task was forced to complete (took too long)
   */
  Task.prototype.wasForcedToComplete = function()
  {
    return this._forceCompleted === true;
  };

  /**
   * Force a long running task to complete
   */
  Task.prototype.forceComplete = function()
  {
    if (this._tasksCompletedAt == null)
    {
      this._forceCompleted = true;
      for (var t = 0, numTasks = this._tasks.length; t < numTasks; ++t)
      {
        var task = this._tasks[t];

        if (task._tasksCompletedAt == null)
        {
          // Forcing the child to complete should result in the _childTaskComplete call
          // from the child and therefore the _activeTaskCount should be decremented
          // by the end of this function and the _checkComplete will run
          task.forceComplete();
        }

        if (this._tasksCompletedAt != null)
        {
          break;
        }
      }

      if (this._stop == null)
      {
        this.stop();
      }
    }

    Assert.assert(this._tasksCompletedAt != null,
      "Task was forced to complete, but is still active");
  };

  /**
   * Gets the monitor ID. This ID includes the path to indicate the correct nesting level.
   *
   * @return {string} the monitor ID of this task
   */
  Task.prototype.getMonitorId = function()
  {
    var monitorId = this.getName();
    return monitorId;
  };

  /**
   * Function for sub-classes
   */
  Task.prototype.Completed = function() {}

  /**
   * Function for sub-classes
   */
  Task.prototype.Stopped = function() {}

  Task.prototype._checkComplete = function()
  {
    if (this._stop != null && this._tasksCompletedAt == null)
    {
      if (this._activeTaskCount == 0)
      {
        this._tasksCompletedAt = (new Date()).getTime();

        var activeTask = Task.getActiveTask();
        if (activeTask != this)
        {
          Assert.assert(false,
            "Task that was not the active one was completed. Completed task: " +
            this.getIdentifier() + ". Active task: " + activeTask.getIdentifier());
        }

        Task._activeTasks.pop();

        // Notify the sub-class
        this.Completed();

        if (this._parent != null)
        {
          // Notify the parent
          this._parent._childTaskComplete(this);
        }
      }
    }
  };

  Task.prototype._childTaskComplete = function(task)
  {
    --this._activeTaskCount;
    this._checkComplete();
  };

  // Since Task has static methods, ensure that it is initialized before the first instance has
  // been created
  adf.mf.api.AdfObject.ensureClassInitialization(Task);

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Operation object

  /**
   * Function representing an operation to track performance. All method calls during the operation
   * are tracked as part of the operation.
   */
  function Operation(name, description, level)
  {
    this.Init(name, description, level);
  }

  adf.mf.api.AdfObject.createSubclass(Operation, Task, "Operation");

  Operation.InitClass = function()
  {
    this._activeOperation = null;
    this._completedOperations = [];
  };

  Operation.prototype.Init = function(name, description, level)
  {
    Operation.superclass.Init.call(this, name);
    this.setDescription(description);
    this.setLevel(level);
  };

  // Static members

  /**
   * Checks if there is a top level operation currently running
   * @return {boolean} true if there is an active operation
   */
  Operation.isOperationActive = function()
  {
    return Operation._activeOperation != null;
  };

  /**
   * Start the operation. Tracks the start time and either sets the operation as the top active
   * operation or adds it as a child to the last operation started.
   */
  Operation.prototype.start = function()
  {
    Operation.superclass.start.call(this);

    if (this.getParent() == null)
    {
      Operation._activeOperation = this;
    }
  };

  /**
   * Called when an operation is done. For the top level operation this will start the process
   * of sending the data to the embedded side for logging as a monitor observation.
   */
  Operation.prototype.Stopped = function()
  {
    if (Operation._activeOperation == this && this.getActiveTaskCount() > 0)
    {
      // This is the top level operation, but tasks are still active.
      // Wait up to 10 seconds for any active calls to complete
      if (this._waitingOnCompletionTimeout == null)
      {
        this._waitingOnTaskCompletion = window.setTimeout(
          this._activeTaskTimeout.bind(this), 10000);
      }
    }
  };

  Operation.prototype.Completed = function()
  {
    if (Operation._activeOperation == this)
    {
      Operation._activeOperation = null;
    }

    if (this.getParent() == null)
    {
      this._sendToEmbedded();
    }
  };

  /**
   * Called from the timeout set in the stop method if not all the children calls and operations
   * were complete at the time. If this method is called, the code will stop waiting for those to
   * complete, assuming them to be broken in some way.
   */
  Operation.prototype._activeTaskTimeout = function()
  {
    delete this._waitingOnTaskCompletion;

    if (this.getTasksCompletedAt() == null)
    {
      this.forceComplete();
    }
  };

  /**
   * Appends the monitor observations for this operation to the passed in array.
   * @param {Array.<Object>} monitorObservations the array to append to
   */
  Operation.prototype._appendMonitorObservations = function(monitorObservations)
  {
    this.visit(
      function (task)
      {
        var id = task.getMonitorId();
        var taskData =
        {
          "id": id,
          //
          // Stop time does not need to be sent, it can be calculated based on duration
          //
          "duration": task.getTotalElapsed(),
          "start": task.getStart(),
          "level" : task.getLevel().toString()
        };
        
        //
        // Description is optional. For common tasks, it is defined in MonitorFactory on the Embedded side
        //
        var description = task.getDescription();
        if (description)
        {
          taskData["description"] = description;
        }
        var instanceName = task.getInstanceName();
        if (instanceName)
        {
          taskData["instanceName"] = instanceName;
        }

        monitorObservations.push(taskData);
        return Task.VisitResult["ACCEPT"];
      });
  };

  /**
   * Sends the information to the embedded side to be logged as a monitor observation
   */
  Operation.prototype._sendToEmbedded = function()
  {
    this._active = null;

    // See if there is an active operation. If so, delay the sending of the data until no
    // operations are currently running. This allows the code to try to find a time that the UI is
    // not busy to send the data, reducing the hit on performance
    if (Operation._activeOperation != null)
    {
      Operation._completedOperations.push(this);

      if (perfMonReportedLogger.isLoggable(FINEST))
      {
        perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf.Operation", "_sendToEmbedded",
          "Another operation is currently running, waiting to send the data to the embedded side " +
          "until that operation completes");
      }

      return;
    }

    var numCompletedOperations = Operation._completedOperations.length;
    var monitorObservations = [];

    // If there are any operations that were delayed send their observations as well
    if (numCompletedOperations > 0)
    {
      for (var i = 0; i < numCompletedOperations; ++i)
      {
        var op = Operation._completedOperations[i];
        op._appendMonitorObservations(monitorObservations);
      }
      Operation._completedOperations = [];
    }

    this._appendMonitorObservations(monitorObservations);
    
    // If this send is a result of story ending, let Embedded side know
    if (this._storyEnding != null)
    {
      monitorObservations.push({"story" : this._storyEnding});
    }
    adf.mf.api.invokeMethod(
      "oracle.adfmf.framework.api.Model",
      "addMonitorObservations",
      monitorObservations, noop, noop);
  };

  // Since Operation has static methods, ensure that it is initialized before the first instance has
  // been created
  adf.mf.api.AdfObject.ensureClassInitialization(Operation);

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Call object

  /**
   * Call object. Used for tracking start and stop calls on code functions.
   * @param {String} name the name of the call being made. Typically the fully qualified path
   *        to the function being executed
   */
  function Call(name, description, level)
  {
    this.Init(name);
    this.setDescription(description);
    this.setLevel(level);
  }

  adf.mf.api.AdfObject.createSubclass(Call, Task, "Call");

  Call.prototype.toString = function()
  {
    return this.getIdentifier();
  };

  // ============================================================================================
  // API methods

  /**
   * Notifies the framework of the start of an operation. An operation is a long running process to
   * be tracked for performance. Calls during the operation may be tracked to determine the
   * breakdown of the time spent in an operation. Operations may be nested but should only be used
   * to track major events (load page, navigation, handle data change event, etc.).
   *
   * @param {string} name the name of the operation
   * @param {Object} logging level for this operation
   * @param {string} description a description of the operation
   * @param {string} an optional instance name for this operation. For example, page name.
   * @return {{stop: function()}} an object with a stop function that must be called when the
   *         operation has completed
   */
  adf.mf.internal.perf.startMonitorOperation = function(name, level, description, instanceName)
  {
    //
    // Only start Operation if the captured logging level allows it
    //
    if (perfMonCapturedLogger.isLoggable(level))
    {
      try
      {
        var op = new Operation(name, description, level);
        if (instanceName != undefined)
        {
          op.setInstanceName(instanceName);
        }
        op.start();
        return op;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code to prevent issues loading the page
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "startMonitorOperation", "Exception thrown " +
            e.message);
        }
      }
    }
    return noopTask;
  }

  /**
   * Notifies the framework of a method call to be tracked as part of the time breakdown of an
   * operation. This should be used for methods that contribute to the overhead of an operation
   * and should therefore be tracked to determine performance changes.
   *
   * @param {string} name the name of the method
   * @param {Object} an optional logging level for this operation
   * @param {string} an optional description a description of the call
   * @param {string} an optional instance name forf this call. For example, component id.
   * @return {{stop: function()}} an object with a stop function that must be called when the
   *         call has completed. The stop function may be called asynchronously.
   */
  adf.mf.internal.perf.startMonitorCall = function(name, level, description, instanceName)
  {
    //
    // Only start Calls if the captured logging level allows it and Operation is active
    //
    if (Operation.isOperationActive() && perfMonCapturedLogger.isLoggable(level))
    {
      try
      {
        var call = new Call(name, description, level);
        if (instanceName != undefined)
        {
          call.setInstanceName(instanceName);
        }
        call.start();
        return call;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code to prevent issues loading the page
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "startMonitorCall", "Exception thrown " + e.message);
        }
        return noopTask;
      }
    }
    else
    {
      return noopTask;
    }
    return noopTask;
  };
  
  adf.mf.internal.perf.startOperation = function(name, description)
  {
    if (perfMonReportedLogger.isLoggable(FINE))
    {
      perfMonReportedLogger.logp(FINE, "adf.mf.internal.perf", "startOperation",
        "Use adf.mf.internal.perf.startMonitorOperation instead.");
    }
    return noopTask;
  }
  
  adf.mf.internal.perf.start = function(name)
  {
    if (perfMonReportedLogger.isLoggable(FINE))
    {
      perfMonReportedLogger.logp(FINE, "adf.mf.internal.perf", "start",
        "Use adf.mf.internal.perf.startMonitorCall instead.");
    }
    return noopTask;
  };
  
  
  /**
   * Forces all active Operations to stop.
   * @param {string} name the story that is ending
   * @return {bool} true if Operations were forced to stop
   */
  adf.mf.internal.perf.forceComplete = function(story)
  {
    if (Operation.isOperationActive())
    {
      try
      {
        Operation._activeOperation._storyEnding = story;
        Operation._activeOperation.forceComplete();
        return true;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "forceComplete", "Exception thrown " + e.message);
        }
      }
    }
    return false;
  }

  /**
   * ADFc is still using this function, disable it instead of removing it so that the calling code
   * will not fail.
   * @deprecated Use adf.mf.internal.perf.start for method calls and
   *             adf.mf.internal.perf.startOperation for major operations (page loading, page
   *             navigation, etc.)
   */
  adf.mf.internal.perf.perfTimings = noop;
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfPerfTiming.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELParser.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ELParser.js ---------------------- */
// @requires ELErrors
// @requires JavaScriptContext


var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.el.parser.cache  = adf.mf.internal.el.parser.cache  || {};
adf.mf.internal.el.parser.ops    = adf.mf.internal.el.parser.ops    || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

/**
 * Literals:
 *    Boolean: true and false
 *    Integer: as in Java
 *    Floating point: as in Java
 *    String: with single and double quotes; " is escaped as \", ' is escaped as \', and \ is escaped as \\.
 *    Null: null
 *
 * Operators:
 *    In addition to the . and [] operators discussed in Variables, there is the additional operators:
 *       Arithmetic: +, - (binary), *, / and div, % and mod, - (unary)
 *       Logical: and, &&, or, ||, not, !
 *       Relational: ==, eq, !=, ne, <, lt, >, gt, <=, ge, >=, le.
 *                  Comparisons can be made against other values, or against boolean,
 *                  string, integer, or floating point literals.
 *       Empty: The empty operator is a prefix operation that can be used to determine whether a value is null or empty.
 *       Conditional: A ? B : C. Evaluate B or C, depending on the result of the evaluation of A.
 *
 *   The precedence of operators highest to lowest, left to right is as follows:
 *      1. [] .
 *      2. () - Used to change the precedence of operators.
 *      3. - (unary) not ! empty
 *      4. * / div % mod
 *      5. + - (binary)
 *      6. < > <= >= lt gt le ge
 *      7. == != eq ne
 *      8. && and
 *      9. || or
 *     10. ? :
 *
 *  Reserved Words:
 *  The following words are reserved for the JSP expression language and should not be used as identifiers.
 *      and   eq   gt   true   instanceof
 *      or    ne   le   false  empty
 *      not   lt   ge   null   div   mod
 *  Note that many of these words are not in the language now, but they may be in the future,
 *  so you should avoid using them.
 *
 *  Examples:
 *  Here are some example EL expressions and the result of evaluating them.
 *
 *  EL Expression            Result
 *  ----------------------------------  --------------------------------------------------------------------
 *  ${1 > (4/2)}            false
 *  ${4.0 >= 3}              true
 *  ${100.0 == 100}            true
 *  ${(10*10) ne 100}          false
 *  ${'a' < 'b'}            true
 *  ${'hip' gt 'hit'}          false
 *  ${4 > 3}              true
 *  ${1.2E4 + 1.4}            12001.4
 *  ${3 div 4}              0.75
 *  ${10 mod 4}              2
 *  ${empty param.Add}          True if the request parameter named Add is null or an empty string
 *  ${pageContext.request.contextPath}  The context path
 *  ${sessionScope.cart.numberOfItems}  The value of the numberOfItems property of the session-scoped attribute
 *                    named cart
 *  ${param['mycom.productId']}      The value of the request parameter named mycom.productId
 *  ${header["host"]}          The host
 *  ${departments[deptName]}      The value of the entry named deptName in the departments map
 *
 *
 *  How to use the ELParser and ELExpression objects:
 *  - If you want to parse and evaluate an expression for a one time evaluation (i.e. will not be cached)
 *    do the following:
 *      adf.mf.internal.el.parser.evaluate(expression, context);
 *    i.e.
 *      adf.mf.internal.el.parser.evaluate("Hello", context);
 *      adf.mf.internal.el.parser.evaluate("${1.23E3}", context);
 *      adf.mf.internal.el.parser.evaluate("${applicationScope.loginRequired}", context);
 *      adf.mf.internal.el.parser.evaluate("${applicationScope.variableA < applicationScope.variableB}", context);
 *
 *  - If you want to parse an expression and use it over and over or simply let the "system" cached the expression
 *    for you, do the following:
 *      var expr      = adf.mf.internal.el.parser.parse(expression);
 *      ...
 *      var value     = expr.evaluate(context);  // can be called multiple times
 *
 *    i.e.
 *      var expr = adf.mf.internal.el.parser.evaluate("Hello");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate("${1.23E3}");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate(context, "${applicationScope.loginRequired}");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate(context, "${applicationScope.variableA < applicationScope.variableB}");
 *      expr.evaluate(context);  // can be called multiple times
 */
(function()
{
  adf.mf.internal.el.parser.ops =  {};

  var isStr = function(s) { return typeof(s) === 'string' || s instanceof String; };
  adf.mf.internal.el.parser.ops.isStr = isStr;

  adf.mf.internal.el.parser.ops.concat = function(a, b) { return "" + a + b; };

  // standard EL binary operations implementations
  //function add(a, b) { return (isStr(a) || isStr(b))? ("" + a + b) : (a + b); }
  adf.mf.internal.el.parser.ops.add = function(a, b)
  {
    // EL should not allow adding strings together, but this code re-writes EL like "#{null}#{null}"
    // to #{null + null}. In order to prevent a radical change at this point, support string
    // concatination despite being against the EL specification.
    if (a === null && b === null)
    {
      // JavaEL will use a blank string for nulls being concatinated
      return "";
    }
    else if (a === null && isStr(b))
    {
      return b;
    }
    else if (isStr(a) && b === null)
    {
      return a;
    }

    return a + b;
  };

  adf.mf.internal.el.parser.ops.subtract = function(a, b)           { return a - b;                        };
  adf.mf.internal.el.parser.ops.multiply = function(a, b)           { return a * b;                        };
  adf.mf.internal.el.parser.ops.divide = function(a, b)             { return a / b;                        };
  adf.mf.internal.el.parser.ops.modulo = function(a, b)             { return a % b;                        };
  adf.mf.internal.el.parser.ops.index = function(a, b)              { return a[b];                         };

  // standard EL unary operation implementations
  adf.mf.internal.el.parser.ops.negate = function(a)                { return -a;                           };
  adf.mf.internal.el.parser.ops.empty = function(a)
  {
    return ((a === null) || (a === '') || (a == []) ||
      (a === adf.mf.api.OptionalFragmentArgument));
  };

  adf.mf.internal.el.parser.ops.not = function(a)                   { return !adf.mf.internal.el.parser.ops.coerce(a);                   };

  // standard EL logical operations implementations
  adf.mf.internal.el.parser.ops.greaterThanOrEqual = function(a, b) { return a >= b;                       };
  adf.mf.internal.el.parser.ops.greaterThan = function(a, b)        { return a > b;                        };
  adf.mf.internal.el.parser.ops.lessThanOrEqual = function(a, b)    { return a <= b;                       };
  adf.mf.internal.el.parser.ops.lessThan = function(a, b)           { return a < b;                        };
  adf.mf.internal.el.parser.ops.equals = function(a, b)             { return adf.mf.internal.el.parser.ops.coerce(a) == adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.notEqual = function(a, b)           { return adf.mf.internal.el.parser.ops.coerce(a) != adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.or = function(a, b)                 { return adf.mf.internal.el.parser.ops.coerce(a) || adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.and = function(a, b)                { return adf.mf.internal.el.parser.ops.coerce(a) && adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.ternary = function(a,b,c)           { return (adf.mf.internal.el.parser.ops.coerce(a))? b : c;           };

  // coerce the value to a boolean if so be it
  adf.mf.internal.el.parser.ops.coerce = function(a)                { return (a == "true") ? true : (a == "false") ? false : a; };

  // standard EL function implementations
  adf.mf.internal.el.parser.ops.unknown = function()                {                                      };
  adf.mf.internal.el.parser.ops.block = function()     {};

  adf.mf.internal.el.parser.ops.append = function(a, b)
  {
        if (Object.prototype.toString.call(a) != "[object Array]")
        {
          return [a, b];
        }
        a = a.slice();
        a.push(b);
        return a;
      };

      /*
       *  The precedence of operators highest to lowest, left to right is as follows:
       *      1. [] .
       *      2. () - Used to change the precedence of operators.
       *      3. - (unary) not ! empty
       *      4. * / div % mod
       *      5. + - (binary)
       *      6. < > <= >= lt gt le ge
       *      7. == != eq ne
       *      8. && and
       *      9. || or
       *     10. ? :
       */
  adf.mf.internal.el.parser.ops.unaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        "-"     : ["-",     adf.mf.internal.el.parser.ops.negate,          +1, +2, 3, false],
        "!"     : ["!",     adf.mf.internal.el.parser.ops.not,             +1, +2, 3, false],
        "not"   : ["not",   adf.mf.internal.el.parser.ops.not,             +3, +2, 3, true ],
        "empty" : ["empty", adf.mf.internal.el.parser.ops.empty,           +5, +2, 3, true ]
      };

  adf.mf.internal.el.parser.ops.binaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        // ",": [",",   adf.mf.internal.el.parser.ops.append,              +1, -1, -1, false], ---> not really a binary operator
        "#"   : ["#",   adf.mf.internal.el.parser.ops.concat,              +1, +2,  5, false],
        "+"   : ["+",   adf.mf.internal.el.parser.ops.add,                 +1, +2,  5, false],
        "-"   : ["-",   adf.mf.internal.el.parser.ops.subtract,            +1, +2,  5, false],
        "*"   : ["*",   adf.mf.internal.el.parser.ops.multiply,            +1, +1,  4, false],
        "/"   : ["/",   adf.mf.internal.el.parser.ops.divide,              +1, +1,  4, false],
        "div" : ["div", adf.mf.internal.el.parser.ops.divide,              +3, +2,  4, true ],
        "%"   : ["%",   adf.mf.internal.el.parser.ops.modulo,              +1, +2,  4, false],
        "mod" : ["mod", adf.mf.internal.el.parser.ops.modulo,              +3, +2,  4, true ],
        "and" : ["and", adf.mf.internal.el.parser.ops.and,                 +3, +2,  8, true ],
        "&&"  : ["&&",  adf.mf.internal.el.parser.ops.and,                 +2, +2,  8, false],
        "or"  : ["or",  adf.mf.internal.el.parser.ops.or,                  +2, +2,  9, true ],
        "||"  : ["||",  adf.mf.internal.el.parser.ops.or,                  +2, +2,  9, false],
        "<="  : ["<=",  adf.mf.internal.el.parser.ops.lessThanOrEqual,     +2, +2,  6, false],
        "le"  : ["le",  adf.mf.internal.el.parser.ops.lessThanOrEqual,     +2, +2,  6, true ],
        "<"   : ["<",   adf.mf.internal.el.parser.ops.lessThan,            +1, +1,  6, false],
        "lt"  : ["lt",  adf.mf.internal.el.parser.ops.lessThan,            +2, +1,  6, true ],
        ">="  : [">=",  adf.mf.internal.el.parser.ops.greaterThanOrEqual,  +2, +2,  6, false],
        "ge"  : ["ge",  adf.mf.internal.el.parser.ops.greaterThanOrEqual,  +2, +2,  6, true ],
        ">"   : [">",   adf.mf.internal.el.parser.ops.greaterThan,         +1, +2,  6, false],
        "gt"  : ["gt",  adf.mf.internal.el.parser.ops.greaterThan,         +2, +2,  6, true ],
        "=="  : ["==",  adf.mf.internal.el.parser.ops.equals,              +2, +2,  7, false],
        "eq"  : ["eq",  adf.mf.internal.el.parser.ops.equals,              +2, +2,  7, true ],
        "!="  : ["!=",  adf.mf.internal.el.parser.ops.notEqual,            +2, +2,  7, false],
        "ne"  : ["ne",  adf.mf.internal.el.parser.ops.notEqual,            +2, +2,  7, true ]
      };

  adf.mf.internal.el.parser.ops.ternaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        "?"   : ["?",   adf.mf.internal.el.parser.ops.ternary,             +1, +2,  11, false]
      };

  adf.mf.internal.el.parser.ops.constants =
  {
        "true"  : true,
        "false" : false,
        "null"  : null
      };

  adf.mf.internal.el.parser.ops.functions =
  {
        "abs"             : Math.abs,
        "sign"            : adf.mf.internal.el.parser.ops.unknown,
        "pow"             : Math.pow,
        "exp"             : Math.exp,
        "ln"              : adf.mf.internal.el.parser.ops.unknown,
        "round"           : Math.round,
        "truncate"        : Math.floor,
        "len"             : adf.mf.internal.el.parser.ops.unknown,
        "strstr"          : adf.mf.internal.el.parser.ops.unknown,
        "leftstr"         : adf.mf.internal.el.parser.ops.unknown,
        "rightstr"        : adf.mf.internal.el.parser.ops.unknown,
        "substr"          : String.substr,
        "lower"           : String.toLowerCase,
        "upper"           : String.toUpperCase,
        "date"            : adf.mf.internal.el.parser.ops.unknown,
        "now"             : adf.mf.internal.el.parser.ops.unknown,
        "lookup"          : adf.mf.internal.el.parser.ops.unknown
      };

  var PRIMARY  = 1 <<  0;
  var OPERATOR = 1 <<  1;
  var FUNCTION = 1 <<  2;
  var LPAREN   = 1 <<  3;
  var RPAREN   = 1 <<  4;
  var COMMA    = 1 <<  5;
  var SIGN     = 1 <<  6;
  var CALL     = 1 <<  7;
  var OPENEXP  = 1 <<  8;
  var CLOSEEXP = 1 <<  9;
  var UNIOP    = 1 << 10;
  var HOOK     = 1 << 11;
  var COLON    = 1 << 12;
  var LBRACE   = 1 << 13;
  var NO_ARGS  = 1 << 14;

  /* types of tokens that will be encountered */
  var TOKEN_CONSTANT         =  0;
  var TOKEN_UNARY_OPERATOR   =  1;
  var TOKEN_BINARY_OPERATOR  =  2;
  var TOKEN_TERNARY_OPERATOR =  3;
  var TOKEN_VARIABLE         =  4;
  var TOKEN_FUNCTION         =  5;
  var TOKEN_INDEX            =  6;
  var TOKEN_DOT_OFFSET       =  7;
  var TOKEN_PROPERTY         =  8;
  var TOKEN_COLON            =  9;
  var TOKEN_COMMA            = 10;
  var TOKEN_NO_ARGS          = 11;


  function Token(type, index, prior, value)
  {
    this.type  = type;
    this.index = index || 0;
    this.prior = prior || 3;
    this.value = (value !== undefined) ? value : null;

    this.toString = function ()
    {
      switch (this.type)
      {
        case TOKEN_CONSTANT:         return escape(this.value);
        case TOKEN_UNARY_OPERATOR:   /* or */
        case TOKEN_BINARY_OPERATOR:  /* or */
        case TOKEN_TERNARY_OPERATOR: /* or */
        case TOKEN_NO_ARGS:          /* or */
        case TOKEN_INDEX:            /* or */
        case TOKEN_COLON:            /* or */
        case TOKEN_COMMA:            /* or */
        case TOKEN_DOT_OFFSET:       /* or */
        case TOKEN_VARIABLE:         return this.index;
        case TOKEN_FUNCTION:         return "INVOKE";
        default:                     return "Invalid Token";
      }
    };
  }

  // table used by table driven parser
  var parserRules = {};
  // default rule (function)
  var otherRule;

  /**
   * Adds several new rules to 'parserRules' table.
   *
   * @param {Object.<string, Object>} rules This is table of new rules like {"+": [...], "true": true}.
   *   This format is compatible with "adf.mf.internal.el.parser.ops.xxx" definition
   *   tables.
   * @param {function} f Function that will be called when some of registerred rules
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' is 'value'
   *   object from rules map.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function addParserRules(rules, f, caseInsensitive)
  {
    for (var k in rules)
    {
      addParserRule(k, f, rules [k], caseInsensitive);
    }
  }

  /**
   * Adds one rule to 'parserRules' table.
   *
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function addParserRule(text, f, param, caseInsensitive)
  {
    _addParserRulesForCharacter(0, text, parserRules, f, param, caseInsensitive);
  }

  /**
   * This method adds rules for one character from the given text. This method
   * is private.
   *
   * @private
   * @param {number} index Index to the text string. It points to the
   *   current character.
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {Object.<string, Object>} m Points to the current node in
   *   parserRules table.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function _addParserRulesForCharacter(index, text, m, f, param, caseInsensitive)
  {
    var ch = text.charAt(index);
    var last = index + 1 == text.length;
    if (caseInsensitive)
    {
      ch = ch.toLowerCase();
      _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last);
      var ch2 = ch.toUpperCase();
      if (ch !== ch2)
        _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch2, last);
    } else
      _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last);
  }

  /**
   * This method adds one rule for one character from the given text. This method
   * is private.
   *
   * @private
   * @param {number} index Index to the text string. It points to the
   *   current character.
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {Object.<string, Object>} m Points to the current node in
   *   parserRules table.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   * @param {string} ch Character that should be added.
   * @param {boolean} last This parameter should be true for last character from
   *   text string.
   */
  function _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last)
  {
    var nm = m [ch];
    if (!nm)
    {
      nm = [{}];
      m [ch] = nm;
    }
    if (last)
    {
      nm [nm.length] = f;
      nm [nm.length] = param;
    } else
      _addParserRulesForCharacter(index + 1, text, nm [0], f, param, caseInsensitive);
  }

  /**
   * This function parses one token from ELParser.expression according to rules
   * stored in 'parserRules', and calls one of registerred callback method.
   *
   * @param {Object} elParser Instance of ELParser.
   * @returns {boolean} True, if some token was recognized.
   */
  function parseToken(elParser)
  {
    if (_parseTokenCharacter(elParser, elParser.pos, parserRules)) return true;
    if (otherRule) return otherRule.call(elParser, elParser.pos);
    return false;
  }

  /**
   * This function parses one character from the current token according to rules
   * stored in 'parserRules', and calls one of registerred callback method.
   *
   * @param {Object} elParser Instance of ELParser.
   * @param {number} index Index to elParser.expression.
   * @param {Object.<string, Object>} map Points to the current node in
   *   parserRules table.
   * @returns {boolean} True, if some token was recognized.
   */
  function _parseTokenCharacter(elParser, index, map)
  {
    var ch = elParser.expression.charAt(index);
    var r = map [ch];
    if (r)
    {
      if (_parseTokenCharacter(elParser, index + 1, r [0])) return true;
      for (var j = 1; j < r.length; j+=2)
      {
        if (r [j + 1] === 0 ? r [j].call(elParser, index + 1) : r [j].call(elParser, index + 1, r [j + 1]))
          return true;
      }
    }
    return false;
  }

  /*
   * Adds rule for parsing binary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.binaryOperations, function(index, param)
  {
    if (param[5] && !this.isOperatorBoundary(index))
      return false;

    this.finishTerm (this.pos);
    this.token = param[0];
    this.prior = param[4];
    this.pos   += param[2];
    if (this.isSign() && (this.expected & SIGN))
    {
      if (this.isNegativeSign())
      {
        this.token = adf.mf.internal.el.parser.ops.unaryOperations["-"][0];
        this.prior = adf.mf.internal.el.parser.ops.unaryOperations["-"][4];
        this.nooperands++;
        this.addfunc(TOKEN_UNARY_OPERATOR);
      }
      this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | CLOSEEXP);
    }
    else if (this.isComment())
    {
      /* do nothing */
    }
    else
    {
      if ((this.expected & OPERATOR) === 0)
      {
        var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_OPERATOR_FOUND");

        this.parsingError(this.pos, rmsg);
      }
      this.nooperands += 2;
      this.addfunc(TOKEN_BINARY_OPERATOR);
      this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
    }
    return true;
  });

  /*
   * Adds rule for parsing unary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.unaryOperations, function(index, param)
  {
    if (param[5] && !this.isOperatorBoundary(index))
      return false;
    this.token = param[0];
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & UNIOP) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_UNIARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_UNARY_OPERATOR);
    this.nooperands++;
    this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | CLOSEEXP);
    this.finishTerm (this.pos);
    this.pos  += param[0].length;
    return true;
  });

  /*
   * Adds rule for parsing '}'.
   */
  addParserRule("}", function()
  {
    while (this.operatorStack.length > 0)
    {
      this.tokenStack.push(this.operatorStack.pop());
    }
    this.finishTerm (this.pos);
    this.pos++;
    if ((this.expected & CLOSEEXP) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["}"]);

      this.parsingError(this.pos, rmsg);
    }
    if (this.expCount > 1)
    {
      this.token   = "+";   // should go to # if we should concat
      this.prior   = 30;    // 30 = 3 (for add) * 10 (to ensure it is always the last precedence)
      this.nooperands  += 2;
      this.addfunc(TOKEN_BINARY_OPERATOR);
    }
    this.text        = this.pos;
    this.expected    = (OPENEXP);
    return true;
  });

  /*
   * Adds rule for parsing ','.
   */
  addParserRule(",", function(index)
  {
    this.pos++;
    this.prior = -1;
    this.token = ",";
    if ((this.expected & COMMA) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [","]);

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_COMMA);
    this.nooperands    += 2;
    this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
    this.finishTerm (this.pos - 1);
    return true;
  });

  /*
   * Adds rule for parsing constant literals.
   */
  addParserRules(adf.mf.internal.el.parser.ops.constants, function(index, param)
  {
    // Verify that this is not part of a longer varible name that
    // just starts with a constant
    if (index < this.expression.length)
    {
      var nextChar = this.expression.charCodeAt(index);
      // Match a word character, [0-9A-Za-z_]
      if ((nextChar >= 48 /* 0 */ && nextChar <= 57 /* 9 */) ||
        (nextChar >= 65 /* A */ && nextChar <= 90 /* Z */) ||
        (nextChar >= 97 /* a */ && nextChar <= 122 /* z */) ||
        nextChar == 95 /* _ */)
        {
        // The string only begins with a constant, it is not a constant
        return false;
      }
    }
    this.value = param;
    this.pos  = index;

    if ((this.expected & PRIMARY) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_CONSTANT_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    var constant = new Token(TOKEN_CONSTANT, 0, 0, this.value);
    this.tokenStack.push(constant);
    this.expected = (OPERATOR | HOOK | LPAREN | RPAREN | COLON | COMMA | CLOSEEXP);
    return true;
  }, true);

  /*
   * Adds rule for parsing '#'.
   */
  addParserRule("#", function(index)
  {
    this.directive = this.pos;
    this.pos = index;
    return true;
  });

  /*
   * Adds rule for parsing '$'.
   */
  addParserRule("$", function(index)
  {
    this.directive = this.pos;
    this.finishTerm (this.pos);
    this.pos = index;
    return true;
  });

  /*
   * Adds rule for parsing '['.
   */
  addParserRule("[", function(index)
  {
    this.pos++;

    if ((this.expected & LBRACE) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["["]);

      this.parsingError(this.pos, rmsg);
    }
    else
    {
      this.nooperands  +=  2;
      this.prior   =  1;
      this.token   = '[';

      this.addfunc(TOKEN_INDEX);
      this.pmatch += 100;
    }

    this.expected = (PRIMARY | LPAREN | FUNCTION | UNIOP | SIGN);
    return true;
  });

  /*
   * Adds rule for parsing '('.
   */
  addParserRule("(", function(index)
  {
    this.pos++;
    this.pmatch += 100;

    if ((this.expected & LPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["("]);

      this.parsingError(this.pos, rmsg);
    }

    if (this.expected & CALL)
    {
      this.nooperands +=  2;
      this.prior  =  11;
      this.token  = '(';
      this.addfunc(TOKEN_FUNCTION);
      this.expected = (PRIMARY | LPAREN | RPAREN | FUNCTION | UNIOP | NO_ARGS | SIGN);
    }
    else
    {
      this.expected = (PRIMARY | LPAREN | RPAREN | UNIOP | SIGN);
    }
    return true;
  });

  /*
   * Adds rule for parsing numeric literals.
   */
  addParserRules({"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"+":0,"-":0,".":0},
  function(index)
  {
    var result   = false;
    var i        = this.pos;

    var exponent = false;
    var dot = false;
    var digit = false;

    while (i < this.expression.length)
    {
      var c = this.expression.charAt(i);
      if (c == '.')
      {
        if (dot || exponent)
        {
          result = false;
          break;
        }

        dot = true;
      }
      else if (c == '+' || c == '-')
      {
        if (i == this.pos) break;
        var previousChar = this.expression.charAt (i - 1);
        if (previousChar != 'e' && previousChar != 'E') break;
      }
      else if (c == 'e' || c == 'E')
      {
        if (!digit)
        {
          // A number must have a digit before the e or E (.e1 is not valid)
          result = false;
          break;
        }
        exponent = true;
      }
      else if (c >= '0' && c <= '9')
      {
        digit = true;
        result = true;
      }
      else
      {
        if ((c.toLowerCase() !== c.toUpperCase()) || (c === '_'))
          result = false;
        break;
      }
      i++;
    }

    if (result)
    {
      var str = this.expression.substr(this.pos, i - this.pos);
      this.value = parseFloat(str);
      if ((this.expected & PRIMARY) === 0)
      {
        var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_NUMBER_CONSTANT_FOUND");

        this.parsingError(this.pos, rmsg);
      }
      token = new Token(TOKEN_CONSTANT, 0, 0, this.value);
      this.tokenStack.push(token);

      this.expected = (OPERATOR | HOOK | RPAREN | COLON | COMMA | CLOSEEXP);
      this.pos = i;
    }

    return result;
  });

  /*
   * Adds rule for parsing binary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.binaryOperations, function(index, param)
  {
    // This code doesn't seem to be used, instead the block at line 450 is used.
    // Can this be removed?
    if (param[5] && !this.isOperatorBoundary(index))
      return false;
    this.token = this.expression.substr(this.pos, index - this.pos);
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & FUNCTION) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_BINARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_BINARY_OPERATOR);
    this.nooperands += 2;
    this.expected    = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos);
    this.pos   = index;
    return true;
  });

  /*
   * Adds rule for parsing ternary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.ternaryOperations, function(index, param)
  {
    this.token = this.expression.substr(this.pos, index - this.pos);
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & HOOK) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_TERNARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_TERNARY_OPERATOR);
    this.nooperands  += 2;
    this.expected     = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos);
    this.pos   = index;
    return true;
  });

  /*
   * Adds rule for parsing ')'.
   */
  addParserRule(")", function()
  {
    this.finishTerm (this.pos);
    this.pos++;
    this.pmatch -= 100;
    if ((this.expected & RPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [")"]);

      this.parsingError(this.pos, rmsg);
    }

    if ((this.expected & NO_ARGS) === NO_ARGS)
    {
      var vartoken = new Token(TOKEN_NO_ARGS, this.token, 0, 0);
      this.tokenStack.push(vartoken);
    }

    this.expected = (OPERATOR | HOOK | RPAREN | COMMA | LBRACE | LPAREN | COLON | CALL | CLOSEEXP);
    return true;
  });

  /*
   * Adds rule for parsing ']'.
   */
  addParserRule("]", function()
  {
    this.finishTerm (this.pos);
    this.pos++;
    this.pmatch -= 100;
    if ((this.expected & RPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["]"]);

      this.parsingError(this.pos, rmsg);
    }

    // Move the operation from the operation stack to the token stack
    if (this.operatorStack.length > 0 &&
      this.operatorStack[this.operatorStack.length - 1].type == TOKEN_INDEX)
    {
      this.tokenStack.push(this.operatorStack.pop());
    }

    this.expected = (OPERATOR | HOOK | LBRACE | RPAREN | CLOSEEXP | COLON);
    return true;
  });

  /*
   * Adds rule for parsing ':'.
   */
  addParserRule(":", function()
  {
    this.pos++;
    this.prior = 10;
    this.token = ":";
    if ((this.expected & COLON) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [":"]);

      this.parsingError(this.pos, rmsg);
    }

    this.addfunc(TOKEN_COLON);
    this.nooperands  += 2;
    this.expected     = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos - 1);
    return true;
  });

  /*
   * Adds rule for parsing '.'.
   */
  addParserRule(".", function()
  {
    this.nooperands  +=  2;
    this.prior   = 1;
    this.token = '.';
    this.addfunc(TOKEN_DOT_OFFSET);
    this.pos++;
    this.expected = (PRIMARY);
    return true;
  });

  /**
   * This call adds rules for parsing identifiers to parserRules, and
   * registers callback function that is able to parse identifiers.
   *
   * @param {type} f Function that implements parsing identifiers.
   */
  function addIdentifierParserRule(f)
  {
    for (var ch in parserRules)
    {
      if ((ch.toLowerCase() !== ch.toUpperCase()) || (ch === '_'))
      {
        var nm = parserRules [ch];
        nm [nm.length] = f;
        nm [nm.length] = null;
        addIdentifierParserRuleForNode(nm [0], f);
      }
    }
    otherRule = f;
  }

  /**
   * This call adds rules for parsing identifiers to the concrete node of
   * parserRules table, and registers callback function that is able
   * to parse identifiers.
   *
   * @param {type} f Function that implements parsing identifiers.
   */
  function addIdentifierParserRuleForNode(m, f)
  {
    for (var ch in m)
    {
      if ((ch.toLowerCase() !== ch.toUpperCase()) || (ch === '_') ||
          ((ch >= '0') && (ch <= '9'))
      )
      {
        var nm = m [ch];
        nm [nm.length] = f;
        nm [nm.length] = null;
        addIdentifierParserRuleForNode(nm [0], f);
      }
    }
  }

  /*
   * Adds rule for parsing indentifiers.
   */
  addIdentifierParserRule(function(index)
  {
    var st = null;
    for (var i = index; i < this.expression.length; i++)
    {
      var ch = this.expression.charAt(i);
      if ((ch.toLowerCase() != ch.toUpperCase()) || (ch === '_'))
        continue;
      if ((this.pos < i) &&
          ((ch >= '0') && (ch <= '9'))
      )
        continue;
      break;
    } // for i
    if (this.pos === i) return false;
    if ((this.expected & PRIMARY) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_VARIABLE_FOUND");
      this.parsingError(this.pos, rmsg);
    }

    this.token = this.expression.substr(this.pos, i - this.pos);
    var vartoken = null;
    if (!this.currentTermStart [this.pmatch])
    {
      vartoken = new Token(TOKEN_VARIABLE, this.token, 0, 0);
      this.currentTermStart [this.pmatch] = this.pos;
      this.currentELTermStart [this.pmatch] = this.tokenStack.length;
    } else
      vartoken = new Token(TOKEN_PROPERTY, this.token, 0, 0);

    this.prior = 3;
    this.pos = i;
    this.tokenStack.push(vartoken);
    this.expected = (OPERATOR | HOOK | COLON | RPAREN | COMMA | LPAREN | LBRACE | CALL | CLOSEEXP);
    return true;
  });

  /*
   * Adds rule for parsing string literals.
   */
  addParserRules({"'":0,'"':0}, function(index)
  {
    var delim = this.expression.charAt(this.pos);
    var esc = false;
    for (var i = index; i < this.expression.length; i++)
    {
      var ch = this.expression.charAt(i);
      if (ch === '\\')
        esc = true;
      else
      {
        esc = false;
        if ((!esc) && ch === delim)
        {
          var str = this.expression.substr(this.pos + 1, i - this.pos - 1);
          this.value = this.unescape(str, this.pos);
          this.pos = i + 1;
          if ((this.expected & PRIMARY) === 0)
          {
            var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_STRING_FOUND");

            this.parsingError(this.pos, rmsg);
          }
          var token = new Token(TOKEN_CONSTANT, 0, 0, this.value);
          this.tokenStack.push(token);

          this.expected = (OPERATOR | HOOK | COLON | RPAREN | COMMA | CLOSEEXP);
          return true;
        }
      }
    } // for i
    this.pos = i;
    return false;
  });

  /*
   * Adds rule for parsing whitespaces.
   */
  addParserRules({" ":0,'\n':0,'\r':0,'\t':0}, function(index)
  {
    this.pos++;
    return true;
  });

  adf.mf.internal.el.parser.cache.clear = function()
  {
    adf.mf.internal.el.parser.cache.map  = {};
    adf.mf.internal.el.parser.cache.hit  = 0;
    adf.mf.internal.el.parser.cache.miss = 0;
  };

  adf.mf.internal.el.parser.cache.count = function()
  {
    var count = 0;

    if (adf.mf.internal.el.parser.cache.map != null)
    {
      for (var key in adf.mf.internal.el.parser.cache.map)
      {
        ++count;
      }
    }
    return count;
  };

  adf.mf.internal.el.parser.cache.purge = function(expr)
  {
    if (adf.mf.internal.el.parser.cache.map == null)
    {
      return;
    }
    delete adf.mf.internal.el.parser.cache.map[expr];
  };

  adf.mf.internal.el.parser.cache.lookup = function(expr)
  {
    var pexp  = null;

    if (adf.mf.internal.el.parser.cache.map == null)
    {
      adf.mf.internal.el.parser.cache.map  = {};
      adf.mf.internal.el.parser.cache.hit  = 0;
      adf.mf.internal.el.parser.cache.miss = 0;
    }

    pexp = adf.mf.internal.el.parser.cache.map[expr];

    if ((pexp == undefined) || (pexp == null))
    {
      pexp = new ELParser().parse(expr);
      adf.mf.internal.el.parser.cache.map[expr] = pexp;
      ++adf.mf.internal.el.parser.cache.miss;
    }
    else
    {
      pexp.unflatten();
      ++adf.mf.internal.el.parser.cache.hit;
    }

    return pexp;
  };

  var ELParser = function ()
  {

    /**
     * This method calls parser given expression, and returns ELExpression.
     *
     * @param {string} expr
     * @returns {ELExpression}
     */
    adf.mf.internal.el.parser.parse = function (expr)
    {
      return adf.mf.internal.el.parser.cache.lookup(expr);
    };

    adf.mf.internal.el.parser.evaluate = function (context, expr)
    {
      var pexp  = adf.mf.internal.el.parser.cache.lookup(expr);
      return pexp.evaluate(context);
    };

    function ELExpression(tokens, expr, terms, elTerms)
    {
      this.tokens             = tokens;
      this.stringVersion      = null;
      this.readonly           = null;
      this._expr              = expr;
      this.elTerms            = elTerms;
    }

    adf.mf.internal.el.parser.ELParser = ELParser;
    adf.mf.internal.el.parser.ELExpression = ELExpression;

    /**
     * Expressions are also designed to be immutable so that only one instance needs to be created for
     * any given expression String / {@link FunctionMapper}. This allows a container to pre-create
     * expressions and not have to reparse them each time they are evaluated.
     */
    ELExpression.prototype =
    {
      ensureItIsNotTheNullObject: function(t)
      {
        return (t == null || t[".null"] === true) ? null : t;
      },

      evaluate: function (context)
      {
        var n1, n2, n3, fn, item;
        var nstack       = [];
        var tokenLength  = this.tokens.length;
        var val          = null;
        var ind          = null;
        var ignoreNull   = false;

        for (var i = 0; i < tokenLength; i++)
        {
          item = this.tokens[i];

          var type = item.type;
          switch (type)
          {
            case TOKEN_CONSTANT:
              nstack.push(item.value);
              break;

            case TOKEN_TERNARY_OPERATOR:
              n3 = this.ensureItIsNotTheNullObject(nstack.pop());
              n2 = this.ensureItIsNotTheNullObject(nstack.pop());
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.ternaryOperations[item.index])[1]; /* function to execute the operation */
              nstack.push(fn(n1, n2, n3));
              break;

            case TOKEN_BINARY_OPERATOR:
              n2 = this.ensureItIsNotTheNullObject(nstack.pop());
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.binaryOperations[item.index])[1]; /* function to execute the operation */
              nstack.push(fn(n1, n2));
              break;

            case TOKEN_DOT_OFFSET:
            case TOKEN_INDEX:
              var elResolver = context.getELResolver();

              n2 = nstack.pop();
              n1 = nstack.pop();

              try
              {
                var val = elResolver.getValue(context, n1, n2);

                nstack.push(val);

                if (type == TOKEN_INDEX)
                {
                  // Not sure why this is needed, but without this functionality,
                  // the control tests will hang on Android, going into an apparent
                  // infinite loop.
                  ignoreNull = true;
                }
              }
              catch (ex)
              {
                if (((typeof n1) !== 'object') && (n2 === "inputValue"))
                {
                  nstack.push(n1);
                }
                else
                {
                  if (type == TOKEN_INDEX || (ignoreNull && type == TOKEN_DOT_OFFSET))
                  {
                    // This is the old approach and preserving backwards compatibility. In Java,
                    // only a MapElResolver will not throw property not found exceptions. The issue
                    // is that in JavaScript, there is no knowledge of a java.util.Map. So, for now
                    // the indexed expression will work like a map evaluation, and the dot notation
                    // as a property lookup.
                    val = n1[n2];
                    nstack.push(val);

                    // Flag this expression as not having been resolved so that it can be added
                    // to the batch at the end (used by adf.mf.el.getLocalValue)
                    adf.mf.internal.el.indexedExpressionUnresolved = true;
                  }
                  else
                  {
                    throw new adf.mf.PropertyNotFoundException(this.getExpression());
                  }
                }
              }
              break;

            case TOKEN_COMMA:
            case TOKEN_COLON:
            case TOKEN_NO_ARGS:
              /* ignore */
              break;

            case TOKEN_PROPERTY:
              nstack.push(item.index);
              break;

            case TOKEN_VARIABLE:
              var elResolver = context.getELResolver();
              try
              {
                var value = elResolver.getValue(context, null, item.index);
                nstack.push(value);
                ignoreNull = false;
              }
              catch (ex)
              {
                throw new adf.mf.PropertyNotFoundException(this.getExpression());
              }
              break;

            case TOKEN_UNARY_OPERATOR:
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.unaryOperations[item.index])[1];
              nstack.push(fn(n1));
              break;

            case TOKEN_FUNCTION:
              n1 = nstack.pop();
              fn = nstack.pop();
              if (fn.apply && fn.call)
              {
                if (Object.prototype.toString.call(n1) == "[object Array]")
                {
                    n1.push(context);
                }
                else
                {
                  var x = this.ensureItIsNotTheNullObject(n1);

                  n1 = [x];
                  n1.push(context);
                }
                nstack.push(fn.apply(undefined, n1));
              }
              else
              {
                throw new adf.mf.ELException(fn + " is not a function");
              }
              break;
            default:
              throw new adf.mf.ELException("invalid ELExpression - " + type);
          }
        }
        if (nstack.length > 1)
        {
          throw new adf.mf.ELException("invalid ELExpression (mis-match tokens and operations)");
        }

        return nstack[0];
      },

      setValue: function (context, value)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "ValueExpression", "setValue",
            ("adfmf- setValue " + this.toString() + " = " + adf.mf.util.stringify(value)));
        }

        var tokens = this.tokens;
        var stack = [];
        var d = tokens.length;

        for (var i = 0; i < d; i++)
        {
          var token = tokens [i];
          switch (token.type)
          {
            case TOKEN_VARIABLE:
              // If the variable is the only token, use the EL resolver to set the value
              if (i == d - 1)
              {
                context.getELResolver().setValue(context, null, token.index, value);
                return;
              }

              var v = null;

              try
              {
                v = context.getELResolver().getValue(context, null, token.index);
              }
              catch (e)
              {
                // Use the .loaded to signify that the variable has not been loaded from the embedded side
                adf.mf.el.addVariable(token.index, v = { ".loaded": false });
              }

              stack.push(v);
              break;

            case TOKEN_PROPERTY:
              stack.push(token.index);
              break;

            case TOKEN_DOT_OFFSET:
            case TOKEN_INDEX:
              var n = stack.pop();
              var baseObject = stack.pop();
              var v = null;

              // If this is the last property of the object, use the EL resolver to
              // set the value
              if (i == d - 1)
              {
                context.getELResolver().setValue(context, baseObject, n, value);

                // Remove the .null if set
                if (baseObject != null)
                {
                  delete baseObject[".null"];
                }

                return;
              }

              try
              {
                v = context.getELResolver().getValue(context, baseObject, n);
              }
              catch (e)
              {
                // Set the base object to a new object, but mark it as not loaded so that we may be sure to generate
                // a cache miss if this object is requested and not a sub-property of the object from the
                // getLocalValue
                v = baseObject[n] = { ".loaded": false };

                // Remove the .null if set
                delete baseObject[".null"];
              }

              stack.push(v);
              break;

            case TOKEN_CONSTANT:
              stack.push(token.value);
              break;

            case TOKEN_TERNARY_OPERATOR:
              var n3 = this.ensureItIsNotTheNullObject(stack.pop());
              var n2 = this.ensureItIsNotTheNullObject(stack.pop());
              var n1 = this.ensureItIsNotTheNullObject(stack.pop());

              // function to execute the operation
              var fn = (adf.mf.internal.el.parser.ops.ternaryOperations[token.index])[1];

              stack.push(fn(n1, n2, n3));
              break;

            case TOKEN_BINARY_OPERATOR:
              var n2 = this.ensureItIsNotTheNullObject(stack.pop());
              var n1 = this.ensureItIsNotTheNullObject(stack.pop());

              // function to execute the operation
              var fn = (adf.mf.internal.el.parser.ops.binaryOperations[token.index])[1];

              stack.push(fn(n1, n2));
              break;

            default:
              break;
          } // switch
        } // for

        throw new adf.mf.PropertyNotWritableException(this.toString());
      },

      /**
       * Returns the original String used to create this ELExpression, unmodified. This is used for
       * debugging purposes but also for the purposes of comparison (e.g. to ensure the expression in
       * a configuration file has not changed). This method does not provide sufficient information to
       * re-create an expression. Two different expressions can have exactly the same expression
       * string but different function mappings. Serialization should be used to save and restore the
       * state of an ELExpression.
       *
       * @return The original expression String.
       */
      /* String */
      getExpressionString: function()
      {
        if (!this._expr)
          this.refresh();
        return this._expr;
      },

      /**
       * Get the expression using the EL indexed expression notation. This may be used to create
       * a common syntax to be able to compare two different EL expressions to see if they reference
       * the same object and property.
       * @return {string} the indexed representation as a string
       */
      getIndexedRepresentation: function()
      {
        if (this._indexedExpr == null)
        {
          var stack = [];

          for (var i = 0; i < this.tokens.length; i++)
          {
            var token = this.tokens[i];

            switch (token.type)
            {
              case TOKEN_CONSTANT:
                stack.push(escape(token.value));
                break;

              case TOKEN_TERNARY_OPERATOR:
                var n3 = stack.pop();

                // There may only be one here. This will occur during a dependencies call
                // for example where the EL expression is split into tokens.
                if (stack.length == 0)
                {
                  stack.push(n3);
                }
                else
                {
                  var n2 = stack.pop();
                  var n1 = stack.pop();
                  stack.push("((" + n1 + ")? " + n2 + " : " + n3 + ")");
                }

                break;

              case TOKEN_COMMA:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push("" + n1 + ", " + n2 + "");
                break;

              case TOKEN_COLON:
                break; // ignore

              case TOKEN_NO_ARGS:
                stack.push("");
                break;

              case TOKEN_BINARY_OPERATOR:
                var n2 = stack.pop();

                // There may only be one here. This will occur during a dependencies call
                // for example where the EL expression is split into tokens.
                if (stack.length == 0)
                {
                  stack.push(n2);
                }
                else
                {
                  var n1 = stack.pop();

                  stack.push("(" + n1 + " " + token.index + " " + n2 + ")");
                }

                break;

              case TOKEN_INDEX:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push(n1 + "[" + n2 + "]");
                break;

              case TOKEN_DOT_OFFSET:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push(n1 + '["' + n2 + '"]');
                break;

              case TOKEN_PROPERTY:
                stack.push(token.index);
                break;

              case TOKEN_VARIABLE:
                stack.push(token.index);
                break;

              case TOKEN_UNARY_OPERATOR:
                var n1 = stack.pop();

                switch (token.index)
                {
                  case "!":
                    stack.push("(!" + n1 + ")");
                    break;

                  case "-":
                    stack.push("(-" + n1 + ")");
                    break;

                  default:
                    stack.push(f + "(" + n1 + ")");
                    break;
                }

                break;

              case TOKEN_FUNCTION:
                var n1 = stack.pop();
                var fn = stack.pop();

                stack.push(fn + "(" + n1 + ")");
                break;

              default:
                throw new adf.mf.ELException("Invalid ELExpression");
            }
          }

          if (stack.length > 1)
          {
            console.log(stack);
            throw new adf.mf.ELException("Invalid ELExpression (incorrect number of operands)");
          }

          this._indexedExpr = stack[0];
        }

        return this._indexedExpr;
      },

      getExpression: function()
      {
        return "#{" + this.getExpressionString() + "}";
      },

      /**
       * Evaluates the expression as an lvalue and determines if {@link #setValue(ELContext, Object)}
       * will always fail.
       *
       * @param context used to resolve properties (<code>base.property</code> and <code>base[property]</code>)
       * and to determine the result from the last base/property pair
       * @return <code>true</code> if {@link #setValue(ELContext, Object)} always fails.
       * @throws ELException if evaluation fails (e.g. property not found, type conversion failed, ...)
       * @return {boolean}
       */
      isReadOnly: function()
      {
        if (this.readonly === null)
        {
          this.readonly = !((this.tokens.length > 0) && (this.tokens[0].type == TOKEN_VARIABLE));
        }
        return this.readonly;
      },

      /**
       * obtain all the variables this expression is dependent on.
       *
       * @returns {Array}
       */
      dependentObjects: function ()
      {
        var tokenLength = this.tokens.length;
        var vars        = [];

        for (var i = 0; i < tokenLength; i++)
        {
          var item = this.tokens[i];
          if ((item.type === TOKEN_VARIABLE) && (vars.indexOf(item.index) == -1))
          {
            vars.push(item.index);
          }
        }

        return vars;
      },

      /**
       * Convert the ELExpression to a context free expression.
       */
      dependencies: function ()
      {
        if (!this.terms)
        {
          this.terms = [];
          var elTerms = this.toContextFreeExpression ().getELTerms();
          for (var i = 0; i < elTerms.length; i++)
          {
            var t = elTerms [i].getExpressionString ();
            this.terms.push (t);
          }
        }
        return this.terms;
      },

      /**
       * Get an array of context free expressions for each dependency in
       * the indexed EL syntax
       * @returns {Array.<string>} array of dependencies in indexed syntax
       */
      getIndexedDependencies: function()
      {
        if (this._indexedDependencies == null)
        {
          // Get all the dependencies in context free form
          var elTerms = this.toContextFreeExpression().getELTerms();
          var deps = [];

          // Cache the value so it only has to be computed once
          this._indexedDependencies = deps;

          for (var i = 0; i < elTerms.length; ++i)
          {
            deps.push(elTerms[i].getIndexedRepresentation());
          }
        }

        return this._indexedDependencies;
      },

      /**
       * Obtain all the terms this expression is dependent on.
       *
       * @returns {Array} This method returns array of ELExpressions.
       */
      getELTerms: function ()
      {
        if (!this.elTerms)
          this.refresh ();
        return this.elTerms;
      },

      /**
       * Concatenates two ELExpressions.
       *
       * @param {Object} ELExpression to be concatenated to this ELExpression.
       */
      concat: function (elExpression)
      {
        var tokens = this.tokens.slice();
        var firstToken = elExpression.tokens [0];
        var newToken = new Token (TOKEN_PROPERTY, firstToken.index, firstToken.prior, firstToken.value);
        tokens.push(newToken);
        tokens.push(new Token (TOKEN_DOT_OFFSET, ".", -2, 0));
        adf.mf.internal.util.appendAll(tokens, elExpression.tokens, 1);
        var expression = this.getExpressionString() + '.' + elExpression.getExpressionString();
        return new ELExpression (tokens, expression, [expression], null);
      },

      /**
       * Appends array index access this ELExpression.
       *
       * @param {number} array index
       * @returns {Object} ELExpression.
       */
      appendIndex: function (index)
      {
        var tokens = this.tokens.slice();
        tokens.push (new Token (TOKEN_CONSTANT, 0, 3, index));
        tokens.push (new Token (TOKEN_INDEX, "[", -99, 0));
        var expression = this.getExpressionString() +
          (typeof index === "string" ? "['" + index + "']" :  "[" + index + "]");
        return new ELExpression (tokens, expression, [expression], null);
      },

      /**
       * @param {Array} arr
       * @param {Array} exclude
       */
      cleanup: function(arr, exclude)
      {
        var dfarr  = adf.mf.util.removeDuplicates(arr);
        var elen   = exclude.length;
        var dlen   = dfarr.length;

        for (var e = 0; e < elen; ++e)
        {
          for (var d = 0; d < dlen; ++d)
          {

            if (dfarr[d] == exclude[e])
            {
              dfarr.splice(d, 1);
            }
          }
        }

        return dfarr;
      },

      /**
       * This method computes this._expr, this.terms and this.elTerms variables
       * based on this.tokens value.
       */
      refresh: function ()
      {
        var stack = [];
        var termStart = [];
        var termsMap = {};
        var terms = [];
        var elTerms = [];

        function finishTerm (el, from, to, term)
        {
          if (!termsMap[term])
          {
            termsMap[term] = true;
            terms.push(term);

            var tokens = el.tokens.slice(from, to);

            elTerms.push(new ELExpression(tokens));
          }
        }

        function finishTerms (el, to)
        {
          for (var i = 2; i < arguments.length; i++)
          {
            var from = termStart.pop();

            if (from >= 0)
              finishTerm (el, from - 1, to - 1, arguments [i]);
            else
              from = -from;

            to = from;
          }

          termStart.push(-to);
        }

        for (var i = 0; i < this.tokens.length; i++)
        {
          var token = this.tokens[i];
          var type = token.type;

          if (type === TOKEN_CONSTANT)
          {
            stack.push(escape(token.value));
            termStart.push(-i-1);
          }
          else if (type === TOKEN_TERNARY_OPERATOR)
          {
            var n3 = stack.pop();
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("((" + n1 + ")? " + n2 + " : " + n3 + ")");
            finishTerms(this, i + 1, n3, n2, n1);
          }
          else if (type === TOKEN_COMMA)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("" + n1 + ", " + n2 + "");
            finishTerms(this, i + 1, n2, n1);
          }
          else if (type === TOKEN_COLON)
          {
            /* ignore */
          }
          else if (type === TOKEN_NO_ARGS)
          {
            stack.push("");
            termStart.push(-i-1);
          }
          else if (type === TOKEN_BINARY_OPERATOR)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("(" + n1 + " " + token.index + " " + n2 + ")");
            finishTerms(this, i + 1, n2, n1);
          }
          else if (type === TOKEN_INDEX)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();
            var term = n1 + "[" + n2 + "]";

            stack.push(term);

            var from1 = termStart.pop();

            if (from1 >= 0)
              finishTerm(this, from1 - 1, i, n2);
          }
          else if (type === TOKEN_DOT_OFFSET)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();
            var n3 = n1 + "." + n2;

            stack.push(n3);
          }
          else if (type === TOKEN_PROPERTY)
          {
            stack.push(token.index);
          }
          else if (type === TOKEN_VARIABLE)
          {
            stack.push(token.index);
            termStart.push(i + 1);
          }
          else if (type === TOKEN_UNARY_OPERATOR)
          {
            var n1 = stack.pop();
            var f = token.index;

            if (f === "!")
            {
              stack.push("(!" + n1 + ")");
            }
            else if (f === "-")
            {
              stack.push("(-" + n1 + ")");
            }
            else
            {
              stack.push(f + "(" + n1 + ")");
            }

            finishTerms(this, i + 1, n1);
          }
          else if (type === TOKEN_FUNCTION)
          {
            var n1 = stack.pop();
            var fn = stack.pop();
            var n2 = fn + "(" + n1 + ")";

            stack.push(n2);

            var from1 = termStart.pop();

            if (from1 >= 0)
              finishTerm(this, from1 - 1, i, n1);
          }
          else
          {
            throw new adf.mf.ELException("Invalid ELExpression");
          }
        }
        if (stack.length > 1)
        {
          throw new adf.mf.ELException("Invalid ELExpression (incorrect number of operands)");
        }
        if (termStart.length > 0)
        {
          var from = termStart.pop();

          if (from >= 0)
            finishTerm(this, from - 1, i, stack[0]);
        }

        this._expr = stack[0];
        this.elTerms = elTerms;
      },

      /**
       * This method clears cached values of local variables.
       */
      unflatten: function()
      {
        for (var i = 0; i < this.tokens.length; i++)
        {
          var token = this.tokens [i];

          if (token.flattened)
          {
            token.type = TOKEN_VARIABLE;
            token.value = 0;
            token.flattened = false;
          }
        }
      },

      /**
       * @returns {ELExpression}
       */
      toContextFreeExpression: function()
      {
        // for a context free version but not swapping out local variables.
        return this.stripLocalValues (true, undefined, false);
      },

      /**
       * Strips local values.
       *
       * @param {boolean} contextFree
       * @param {array} tokenReplacement
       * @param {boolean} replaceLocalVariables
       * @returns {ELExpression}
       */
      stripLocalValues: function(contextFree, tokenReplacement, replaceLocalVariables)
      {
        var result = null;

        for (var i = 0; i < this.tokens.length; i++)
        {
          var item = this.tokens[i];

          if (item.type === TOKEN_VARIABLE)
          {
            if (tokenReplacement != null)
            {
              var replacement = tokenReplacement[item.index];

              if (replacement)
              {
                if (!replacement.tokens)
                {
                  if (replacement.match(/[#$][{]/g) != null)
                  {
                    replacement = adf.mf.internal.el.parser.parse(replacement);
                  }
                  else
                  {
                    replacement = adf.mf.internal.el.parser.parse("#{" + replacement + "}");
                  }
                }

                result = replaceEL(result, this, i, replacement);
                continue;
              }
            }

            if (contextFree)
            {
              var elResolver = adf.mf.internal.context.getELResolver();

              try
              {
                var value = elResolver.getValue(adf.mf.internal.context, null, item.index);

                if ((value != null) && (value.getAlias !== undefined))
                {
                  // change the variable to be it's context free (alias) form
                  var expandedEL = value.getAlias();

                  result = replaceEL(result, this, i, expandedEL);
                  continue;
                }
                else if (replaceLocalVariables && (value != undefined) && ((typeof value) !== 'object'))
                {
                  result = replaceValue(result, this, i, value);
                  continue;
                }
              }
              catch (ex)
              {
              }
            }
          }

          if (result)
            result.tokens.push(item);
        } // for i

        if (result)
          return result.getEL();

        this._expr = null;

        return this;
      },

      toString: function()
      {
        // for a non-context free version and not swapping out local variables.
        return this.getExpressionString();
      }
    };

    function replaceValue (result, el, index, value)
    {
      if (!result)
        result = new Result(el, index);

      result.tokens.push(new Token(TOKEN_CONSTANT, 0, 0, value));

      return result;
    }

    function replaceEL(result, el, index, insertedEL)
    {
      if (!result)
        result = new Result(el, index);

      adf.mf.internal.util.appendAll(result.tokens, insertedEL.tokens);

      return result;
    }

    function Result(el, index)
    {
      this.tokens = el.tokens.slice (0, index);
    }

    Result.prototype.getEL = function()
    {
      return new ELExpression(this.tokens, null, null, null);
    };

    function ELParser()
    {
      this.success    = false;
      this.errormsg   = "";
      this.expression = "";
      this.pos        = 0;
      this.value      = 0;
      this.prior      = 3;
      this.token      = 0;
      this.pmatch     = 0;
    }

    /*
     * Expression Language BNF - taken from the JavaServer Pages 2.0 Specification (Section JSP.2.9 Collected Syntax)
     *
     * Expression           ::= Expression1 ExpressionRest?
     * ExpressionRest       ::= '?' Expression ':' Expression
     * Expression1          ::= Expression BinaryOp Expression | UnaryExpression
     * BinaryOp             ::= 'and' | '&&' | 'or' | '||' | '+' | '-' | '*' | '/' | 'div' | '%' | 'mod' |
     *                          '<' | 'gt' |'>' | 'lt' | '<=' | 'ge' |'>=' | 'le' | '==' | 'eq' | '=!' | 'ne'
     * UnaryExpression      ::= UnaryOp UnaryExpression |   Value
     * UnaryOp              ::= '-' | '!' | 'not' | 'empty'
     * Value                ::= ValuePrefix | Value ValueSuffix
     * ValuePrefix          ::= Literal | '(' Expression ')' | Identifier except for ImplicitObject |
     *                          ImplicitObject | FunctionInvocation
     * ValueSuffix          ::= '.' Identifier | '[' Expression ']'
     * Identifier           ::= Java language identifierCollected Syntax 1-83
     * ImplicitObject       ::= 'pageContext' | 'pageScope' | 'requestScope' | 'sessionScope' | 'applicationScope' |
     *                          'param' | 'paramValues' | 'header' | 'headerValues' | 'initParam' | 'cookie'
     * FunctionInvocation   ::= (Identifier ':')? Identifier '(' ( Expression ( ',' Expression )* )? ')'
     * Literal              ::= BooleanLiteral | IntegerLiteral | FloatingPointLiteral | StringLiteral | NullLiteral
     * BooleanLiteral       ::= 'true' | 'false'
     * StringLiteral        ::= '([^'\]|\'|\\)*' | "*(\\|"\|[\"^])"
     *                          i.e., a string of any characters enclosed by single or double quotes,
     *                                where \ is used to escape ', ", and \. It is possible to use single
     *                                quotes within double quotes, and vice versa, without escaping.
     * IntegerLiteral       ::= ['0'-'9']+
     * FloatingPointLiteral ::= (['0'-'9'])+ '.' (['0'-'9'])* Exponent? | '.' (['0'-'9'])+ Exponent? | (['0'-'9'])+ Exponent?
     * Exponent             ::= ['e','E'] (['+','-'])? (['0'-'9'])+
     * NullLiteral          ::= 'null'
     *
     * Notes
     * - An identifier is constrained to be a Java identifier - e.g., no -, no /, etc.
     * - A String only recognizes a limited set of escape sequences, and \ may not appear unescaped.
     * - The relational operator for equality is == (double equals).
     * - The value of an IntegerLiteral ranges from Long.MIN_VALUE to Long.MAX_VALUE
     * - The value of a FloatingPointLiteral ranges from Double.MIN_VALUE to Double.MAX_VALUE
     */
    ELParser.prototype =
    {
      parse: function (expr)
      {
        var insideExpression = false;
        var token            = null;

        this.operatorStack      = [];
        this.tokenStack         = [];
        this.expected           = (OPENEXP);
        this.nooperands         = 0;
        this.pmatch             = 0;
        this.errormsg           = "";
        this.success            = true;
        this.expression         = expr;
        this.pos                = 0;
        this.text               = 0;
        this.expCount           = 0;
        this.currentELTermStart = {};
        this.currentTermStart   = {};
        this.elTerms            = [];
        this.terms              = [];
        this.termsMap           = {};

        /* look for nested EL expressions */
        if (expr.match(new RegExp(".*[$#]{[^}]*[$#]{")))
        {
          this.parsingError(this.pos, "ERROR_EL_PARSER_NESTED_EL_NOT_SUPPORTED");
        }

        while (this.pos < this.expression.length)
        {
          if ((this.expected & OPENEXP) == OPENEXP)
          {
            if (this.isExpressionDirective())
            {
              /* we have a potential expression */
            }
            else
            {
              var txt = null;

              if (this.pos + 1 == this.expression.length)
              {
                txt = this.expression.substring(this.text, this.expression.length);

                if (this.text !== 0)
                {
                  this.expCount++;
                }
              }
              else if (this.isOpenExpression())
              {
                this.expCount++;
                txt           = this.expression.substring(this.text, this.pos - 1);
                this.expected = (PRIMARY | LPAREN | RPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
              }

              // in this case have something like: xxx#{...}
              // we want the xxx to be concatenated on the result of #{...}
              if ((txt !== null) && (txt.length > 0))
              {
                var t = new Token(TOKEN_CONSTANT, 0, 0, txt);

                if (this.expCount++ > 1)
                {
                  this.token = "+";   // should go to # if we should concat
                  this.prior = 30;    // 30 = 3 (for add) * 10 (to ensure it is always the last precedence)
                  this.nooperands  += 2;
                  this.addfunc(TOKEN_BINARY_OPERATOR);
                  this.text = this.pos;
                }

                this.tokenStack.push(t);
              }
            }

            this.pos++;
          }
          else if (parseToken(this))
          {
          }
          else
          {
            if (this.errormsg === "")
            {
              var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
                "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [this.expression.charAt(this.pos)]);

              this.parsingError(this.pos, rmsg);
            }
            else
            {
              this.parsingError(this.pos, this.errormsg);
            }
          }
        }

        if (insideExpression)
        {
          var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_MISSING_ENDING");

          this.parsingError(this.pos, rmsg);
        }

        if (this.pmatch != 0)
        {
          var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_MISMATCH");

          this.parsingError(this.pos, rmsg);
        }

        while (this.operatorStack.length > 0)
        {
          var tmp = this.operatorStack.pop();

          this.tokenStack.push(tmp);
        }

        if (this.tokenStack.length == 0)
        {
          token = new Token(TOKEN_CONSTANT, 0, 0, "");
          this.tokenStack.push(token);
        }

        if (this.nooperands + 1 !== this.tokenStack.length)
        {
          var msg = "{";

          for (var i=0; i < this.tokenStack.length; ++i)
          {
            msg += " token["+i+"] = '" + this.tokenStack[i].toString() + "' ";
          }

          msg += "}";

          var rmsg = adf.mf.internal.resource.getResourceStringImpl(
            "ADFErrorBundle", "ERROR_EL_PARSER_INCORRECT_OPERANDS",
            [("[" + (this.nooperands + 1) + ", " + this.tokenStack.length + "]"), msg]);

          this.parsingError(this.pos, rmsg);
        }

        return new ELExpression(this.tokenStack, null, null, this.elTerms);
      },

      finishTerm: function(endPosition)
      {
        this.finishTermTokens();

        var termStart = this.currentTermStart[this.pmatch];

        if (!termStart)
        {
          return;
        }

        var term = this.expression.substr(termStart, endPosition - termStart).trim();
        var elTermStart = this.currentELTermStart[this.pmatch];
        var newELTerm = null;

        if (!this.termsMap[term])
        {
          if (elTermStart === 0 &&
            endPosition === this.expression.length)
          {
            newELTerm = this;
          }
          else
          {
            var termExpression = this.tokenStack.slice(elTermStart);

            newELTerm = new ELExpression(termExpression, term, [term], null);
          }

          this.elTerms.push(newELTerm);
          this.termsMap[term] = true;
        }

        this.currentTermStart[this.pmatch] = null;
        this.currentELTermStart[this.pmatch] = null;
      },

      evaluate: function (expr, variables)
      {
        var /* ELExpression */ elExpr = this.parse(expr);
        var /* var array    */ vars   = [];
        var /* return value */ v;

        try
        {
          v = elExpr.evaluate(variables);
        }
        catch(e)
        {
          try
          {
            vars = elExpr.dependencies();
          }
          catch(e2)
          {
            vars = [];
          }

          vars.push(expr);

          throw e;
        }

        return v;
      },

      parsingError: function (column, msg)
      {
        this.success = false;
        this.errormsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
          "ERROR_IN_EL_PARSING");

        // This is a huge issue, log a message in case the caller is not catching exceptions
        adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal.el.parser", "EL Parser",
          this.errormsg);

        // For security purposes, only log the details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "ELParser", "parse",
            "EL Parsing Error: " + msg + " -- [column " + column + "] " + this.expression);
        }

        throw new adf.mf.ELException(this.errormsg);
      },

      finishTermTokens: function ()
      {
        while (this.operatorStack.length > 0)
        {
          if (this.operatorStack[this.operatorStack.length - 1].type == TOKEN_DOT_OFFSET)
          {
            this.tokenStack.push(this.operatorStack.pop());
          }
          else
          {
            break;
          }
        }
      },

      addfunc: function (type)
      {
        var operator = new Token(type, this.token, this.prior - this.pmatch, 0);
        while (this.operatorStack.length > 0)
        {
          if (operator.prior >= this.operatorStack[this.operatorStack.length - 1].prior)
          {
            this.tokenStack.push(this.operatorStack.pop());
          }
          else
          {
            break;
          }
        }
        this.operatorStack.push(operator);
      },

      /**
       * unescape an input string into a normal string
       *
       * @param input string to unescape
       * @param pos   in the overall expression we are unescaping
       *
       * @returns the unescaped string
       */
      unescape: function(input, pos)
      {
        var buf    = [];
        var escape = false;

        for (var i = 0; i < input.length; i++)
        {
          var c = input.charAt(i);

          if (! escape)
          {
            if (c == '\\') { /* turn on escaping */
              escape = true;
            } else {  /* non-escaped character, just add it to the buffer */
              buf.push(c);
            }
          } else { /* character following the escape character \\ */
            switch (c)
            {
            case '\\': buf.push('\\'); break;
            case '/':  buf.push('/');  break;
            case 'b':  buf.push('\b'); break;
            case 'f':  buf.push('\f'); break;
            case 'n':  buf.push('\n'); break;
            case 'r':  buf.push('\r'); break;
            case 't':  buf.push('\t'); break;
            case 'u':  /* following 4 chars make up the hex code for the character */
              var unicodeCode = parseInt(input.substring(i+1, i+5), 16);
              buf.push(String.fromCharCode(unicodeCode)); // add the string representation of the unicode char
              i += 4;
              break;
            default:
              throw this.parsingError(pos + i, "Illegal escape sequence: '\\" + c + "'");
            }
            escape = false;
          }
        }

        return buf.join('');  /* convert the array to a single string */
      },

      /**
       * Determine if the next token is a sign token (- or +)
       *
       * @returns {Boolean}
       */
      isSign: function ()
      {
        var code = this.expression.charCodeAt(this.pos - 1);
        return (code === 45 || code === 43); // - or +
      },

      /**
       * Determine if the next token is a negative sign token
       *
       * @returns {Boolean}
       */
      isNegativeSign: function ()
      {
        return (this.expression.charCodeAt(this.pos - 1) === 45); // -
      },

      /**
       * Determine if the next token is a dot token
       *
       * @returns {Boolean}
       */
      isDot: function ()
      {
        var code = this.expression.charCodeAt(this.pos);
        if (code === 46) { // .
          this.pos++;
          this.prior = 0;
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is the open expression token
       *
       * @returns {Boolean}
       */
      isOpenExpression: function ()
      {
        var code = this.expression.charCodeAt(this.pos);
        if ((code === 123) && (this.directive + 1 == this.pos)) // {
        {
          // this.pos++;
          return true;
        }
        return false;
      },

      /**
       * Determine if this is a expression directive.
       *
       * @returns {Boolean}
       */
      isExpressionDirective: function ()
      {
        var status = false;
        var code   = this.expression.charCodeAt(this.pos);

        if ((code === 35 /* # */) || (code === 36 /* $ */))
        {
          this.directive = this.pos;
          status         = true;
        }
        return status;
      },

      /**
       * Determine if the next token is ends the operator
       *
       * @returns {Boolean}
       */
      isOperatorBoundary: function (pos)
      {
        var code = this.expression.charCodeAt(pos);

        if (code === 40 /* (     */ ||
          code === 32 /* space */ ||
          code ===  9 /* tab   */ ||
          code === 10 /* LF    */ ||
          code === 13 /* CR    */)
          {
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is a variable token
       *
       * @returns {Boolean}
       */
      isVariable: function ()
      {
        var str       = "";
        var length    = 0;

        for (var i = this.pos; i < this.expression.length; i++)
        {
          var c           = this.expression.charAt(i);
          var includeChar = true;

          /* see if this character is not a valid character for a name */
          if (str === "")
          {
            /* first character must be alpha except for compressed keys
             * which will start with _ (and be in the form of _999)
             */
            if ((c.toLowerCase() == c.toUpperCase()) && (c !== '_'))
            {
              break;
            }
          }

          if (c.toLowerCase() == c.toUpperCase())
          {
            if (((c >= '0') && (c <= '9')) ||    /* numbers are validate             */
               ((c == '.') || (c == '_'))) {    /* dot and underscore are also okay */
              }else break;
          }

          length++;
          if (includeChar)
          {
            str += c;
          }
        }
        if (str.length > 0)
        {
          this.token  = str;
          this.prior  = 3;
          this.pos   += length; // str.length;
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is a comment token.
       *
       * @returns {Boolean}
       */
      isComment: function ()
      {
        /*
         * remember we need to look back one character for the slash since it might
         * have been picked up as a unary or binary operation token.
         */
        var code = this.expression.charCodeAt(this.pos - 1);

        if ((code === 47 /* slash */) && (this.expression.charCodeAt(this.pos) === 42 /* start */))
        {
          this.pos = this.expression.indexOf("*/", this.pos) + 2; /* eat all those characters */

          if (this.pos === 1)
          {
            this.pos = this.expression.length;
          }
          return true;
        }
        return false;
      }
    };

    function escape(v)
    {
      var quote     = "\""; // "'";
      var escapable = /[\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var meta      = { '\b': '\\b','\t': '\\t','\n': '\\n','\f': '\\f','\r': '\\r','\\': '\\\\' };
      if ((typeof v) === "string")
      {
        escapable.lastIndex = 0;
            return escapable.test(v) ?
                quote + v.replace(escapable, function (a)
                  {
                      var c = meta[a];
                      return ((typeof c === 'string')? c :
                          '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
                  }) + quote :
                  quote + v + quote;
      }
      return v;
    }

    return ELParser;
  }();
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/TreeNode.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- TreeNode.js ---------------------- */
// @requires ELErrors
// @requires AdfPerfTiming

// @requires JavaScriptContext


var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

(function() {

  var collectionModelExtensionELExpression = adf.mf.internal.el.parser.parse(
    "#{collectionModel.treeNodeBindings.providers}");

  function TreeNode(/* TreeBinding */ tb, /* index */ index, /* ELExpression */ treeBindingEL)
  {
    this.id       = tb.id;
    this.index    = index;
    this.modid    = adf.mf.internal.context.getModId();
    this.treeBindingEL = treeBindingEL;
    this.alias    = null;

    this.getAlias = function (/* boolean */ compressed)
    {
      if (compressed)
      {
        var ref = this.id + ".collectionModel.treeNodeBindings.providers['" + this.getKey() + "']";
        var alias = adf.mf.internal.api.addCompressedReference(ref);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNode", "getAlias",
            "alias=" + alias + " expanded=" + ref);
        }

        return alias;
      }
      if (!this.alias)
      {
        this.alias = this.treeBindingEL.concat(collectionModelExtensionELExpression)
          .appendIndex(this.getKey());
      }
      return this.alias;
    };

    /**
     * INTERNAL function to get the current collection
     * model stored for the given tree binding's id.
     */
    this.getTreeNodeBindings = function()
    {
      // check to see if we already have the latest tree node bindings
      if (this.modid == adf.mf.internal.context.getModId())
      {
        return tb.treeNodeBindings;
      }
      else
      {
        // looks like the cache has been updated, be safe re-fetch
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        if (cm != null && cm.treeNodeBindings != null)
        {
          return cm.treeNodeBindings;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
           adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "TreeNode.getTreeNodeBindings",
            "WARN_COLLECTION_MODEL_NOT_FOUND");

          // For security purposes, only log the details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "TreeNode", "getTreeNodeBindings",
              "Collection model is null or its tree node bindings: " + this.id);
          }
        }

        return {};
      }
    };
    this.tnb = this.getTreeNodeBindings();

    /**
     * getProvider will update the current provider
     * reference and return it's value to the caller.
     */
    this.getProvider = function()
    {
      var key = this.getKey();

      this.provider = (key != undefined)? this.tnb.providers[key] : undefined;

      return this.provider;
    };

    /**
     * getBindings will return the associated
     * column bindings to the caller.
     */
    this.getBindings = function()
    {
      return this.tnb.columnBindings;
    };

    /*
     * get the current key value
     */
    this.getKey = function()
    {
      this.key = ((index < 0) || (index >= this.tnb.keys.length)) ?
        undefined : this.tnb.keys[index];

      return this.key;
    };

    this.rowKey = function()
    {
      return this.getKey();
    };

    this.provider = this.getProvider();
    this.key      = this.getKey();
    this.note     = '' + (typeof this) + ' with EL variable id: ' + this.id + ' on index ' +
      this.index;
    this['.type'] = 'oracle.adfmf.bindings.dbf.TreeNode';

    // If an attribute is null or an empty array, the value is not being sent by the embedded side.
    // As a result, a request for that attribute will result in a cache miss (undefined value) and
    // cause a round trip to the embedded side. By checking the column attributes during
    // the creation of this object, we can avoid the undefined values by setting the properties to
    // null when not present
    if (this.provider != null)
    {
      for (var attributeName in tb.columnAttributes)
      {
        if (this.provider[attributeName] === undefined &&
          (this.provider.bindings == null || this.provider.bindings[attributeName] === undefined))
        {
          // We are not given the meta-data if this attribute is a true attribute or an accessor.
          // The accessors are stored directly on the provider, but the attributes are stored on
          // the bindings object of the provider. Since we do not know, store the value on the
          // provider directly.
          this.provider[attributeName] = null;
        }
      }
    }
  };

  /**
   *
   * Here are some things to note about using the iterator.
   *
   * Step  1. Resolve #{bindings.products.collectionModel}
   *          adf.mf.api.getValue("#{bindings.products.collectionModel}",
   *                          function(a,b) {value = b[0].value; success();}, failed);
   *
   * Step  2. Resolve #{bindings.products.collectionModel.iterator}
   *          adf.mf.api.getValue("#{bindings.products.collectionModel.iterator}",
   *                          function(a,b) {bpci = b[0].value; success();}, failed);
   *
   * Step 3.  Jumping around the rows with the iterator
   *          Resolve iterator.first():
   *          bpci.first(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   *          Resolve iterator.last():
   *          bpci.first(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }
   *                                function(a, b){ failed();});
   *
   *          Resolve iterator.previous():
   *          bpci.previous(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   *          Resolve iterator.next():
   *          bpci.next(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   * Step  4. Accessing iterator bindings:
   *          Resolve #{row.bindings}:
   *          adf.mf.api.getValue("#{row.bindings}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Resolve #{row.bindings.name}:
   *          adf.mf.api.getValue("#{row.bindings.name}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve");});
   *
   *          Resolve #{row.bindings.name.inputValue}:"
   *                     adf.mf.api.getValue("#{row.bindings.name.inputValue}",
   *                                     function(a,b) {value = b[0].value; success();},
   *                                     function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Update #{row.bindings.name.inputValue}:"+ stringify(value) + "");
   *                     adf.mf.api.setValue({'name':"#{row.bindings.name.inputValue}", 'value':value},
   *                                      function() {showSuccess("Updated"); success();},
   *                                      function() {showFailure("Unable to updated");});
   *
   *          Resolve #{row.dataProvider}:
   *          adf.mf.api.getValue("#{row.dataProvider}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Resolve #{row.dataProvider}:
   *          adf.mf.api.getValue("#{row.dataProvider.name}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Update #{row.dataProvider.name}:
   *          adf.mf.api.setLocalValue({'name':"#{row.dataProvider.name}", 'value':value},
   *                               function() {showSuccess("Updated"); success();},
   *                               function() {showFailure("Unable to updated"); failure();});
   *
   * Step 5: Register some data change listeners on #{bindings.products.collectionModel}:
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 1 of " + stringify(v));});
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 2 of " + stringify(v));});
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 3 of " + stringify(v));});
   *
   * Step 6. Access the number of cached rows:
   *         var cr = bpci.getCachedRowCount(0);
   *
   * Step 7. Access the number of rows in a Range Size:
   *         var rs = bpci.getRangeSize();
   *
   * Step 8. Validating the data change event was processed correctly: ");
   *
   {
   *            bpci.first(loopBody, function(e){ console.log("Error: first failed: " + stringify(e));});
   *            ...
   *         }
   *         ...
   *
   *         // Easy way to loop thru the number of rows we have cached starting at 0
   *         function loopBody()
   *
   {
   *            if (++count < bpci.getCachedRowCount(0))
   *
   {
   *               var v1 = adf.mf.api.getLocalValue("id:#{row.bindings.id.inputValue}");
   *               var v2 = adf.mf.api.getLocalValue("name:#{row.bindings.name.inputValue}");
   *
   *               content += "checking provider[" + bpci.index + "] = [" + v1 + "]:" + v2 + "<br>";
   *
   *               bpci.next(function(a, b){ adf.mf.api.addVariable('row', b[0].value); loopBody(); },
   *                         function(a, b){ showSuccess("no more records to check"); showContent();});
   *             }
   *         }
   **/
  function TreeNodeIterator(/* TreeBinding */ tb, /* index */ idx)
  {
    this.id                         = tb.id;
    this.treeNodeBindings           = tb.treeNodeBindings  || {providers:{}, keys:[]};
    this.index                      = idx;
    this.currentKey                 = null;
    this[".type"]                   = "TreeNodeIterator";  /* needed for minimized version to obtain the type */
    this.modid                      = adf.mf.internal.context.getModId();
    this.treeBindingEL              = adf.mf.internal.el.parser.parse("#{" + tb.id + "}");


    /**
     * INTERNAL function to get the current collection
     * model stored for the given tree binding's id.
     */
    this.getTreeNodeBindings = function()
    {
      // check to see if we already have the latest tree node bindings
      if (this.modid == adf.mf.internal.context.getModId())
      {
        return tb.treeNodeBindings;
      }
      else
      {
        // looks like the cache has been updated, be safe re-fetch
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        if (cm != null && cm.treeNodeBindings != null)
        {
          return cm.treeNodeBindings;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "TreeNodeIterator.getTreeNodeBindings",
            "WARN_COLLECTION_MODEL_NOT_FOUND");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "TreeNodeIterator", "getTreeNodeBindings",
              "Unable to find the collection model or tree node bindings for " + this.id);
          }
        }

        return { providers:{}, keys:[] };
      }
    };

    /**
     * create a new provider
     */
    this.createRow = function(provider, /* boolean */ insertFlag, success, failed)
    {
      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "create",
        this.id, this.currentKey, provider, insertFlag, success, failed);
    };

    /**
     * fetch the first row in the collection
     */
    this.first = function(success, failed)
    {
      this.fetch(0, success, failed);
    };

    /**
     * @returns the current row index
     */
    this.getCurrentIndex = function()
    {
      return this.index;
    };

    /**
     * @returns the current row key
     */
    this.getCurrentKey = function()
    {
      return this.currentKey;
    };

    /**
     * @returns the current provider (row)
     */
    this.getCurrentRow = function()
    {
      var tnb = this.getTreeNodeBindings();

      return (this.currentKey !== undefined)?
          tnb.providers[this.currentKey]: undefined;
    };

    /**
     * @returns true if their are more records buffered that can be read
     */
    this.hasNext = function()
    {
      var tnb = this.getTreeNodeBindings();

      return (this.index < (tnb.keys.length - 1));
    };

    /**
     * @returns true if their are more records buffered that can be read
     */
    this.hasPrevious = function()
    {
      return (this.index > 0);
    };

    /**
     * fetch the last row in the collection
     */
    this.last = function(success, failed)
    {
      var tnb = this.getTreeNodeBindings();

      this.fetch((tnb.keys.length - 1), success, failed);
    };

    /**
     * obtain the next record in the collection
     */
    this.next = function(success, failed)
    {
      // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "next",
          //           "Range Size: " + this.getRangeSize() + " where we have loaded " + this.getCachedRowCount(this.index) + " rows.");
      this.fetch((this.index + 1), success, failed);
    };

    /**
     * fetch the first row in the collection
     */
    /* provider */
    this.localFirst = function()
    {
      return this.localFetch(0);
    };

    /**
     * fetch the last row in the collection
     */
    /* provider */
    this.localLast = function()
    {
      var tnb = this.getTreeNodeBindings();

      return this.localFetch((tnb.keys.length - 1));
    };

    /**
     * get the next provider if you have it already cached, if not will return undefined
     */
    /* provider */
    this.localNext = function()
    {
      return this.localFetch((this.index + 1));
    };

    /**
     * get the previous provider if you have it already cached, if not will return undefined
     */
    /* provider */
    this.localPrevious = function()
    {
      return this.localFetch((this.index - 1));
    };

    /**
     * request the next set of records to be fetched
     */
    this.nextSet = function(success, failed)
    {
      this.fetchSet('next', this.index, success, failed);
    };

    /**
     * obtain the next record in the collection
     */
    this.previous = function(success, failed)
    {
      this.fetch((this.index - 1), success, failed);
    };

    /**
     * request the previous set of records to be fetched
     */
    this.previousSet = function(success, failed)
    {
      this.fetchSet('previous', this.index, success, failed);
    };

    /**
     * request the current record set to be re-fetched
     */
    this.refresh = function(success, failed)
    {
      this.fetchSet('next', this.index, success, failed);
    };

    /**
     * set the current index for the iterator
     *
     * @throws IllegalArgumentException if the index is out of range
     */
    this.setCurrentIndex = function(/* int */ index)
    {
      var tnb = this.getTreeNodeBindings();

      if ((index < 0) || (index > (tnb.keys.length - 1)))
      {
        this.index      = -1;
        this.currentKey = undefined;
      }

      this.index      = index;
      this.currentKey = tnb.keys[index];
    };


    /**
     * @return the number of contiguously loaded row starting at a given point.
     *
     * @param startingAtIndex
     */
    /* int */
    this.getCachedRowCount = function(/* int */ startingAtIndex)
    {
      var count = 0;
      var tnb   = this.getTreeNodeBindings();

      if ((startingAtIndex < 0) ||
         (startingAtIndex > (tnb.keys.length - 1)))
      {
        return 0;
      }

      // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "getCachedRowCount", "Passed the first test.");
      for (var i = startingAtIndex; i < tnb.keys.length; ++i)
      {
        var k = tnb.keys[i];

        // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "getCachedRowCount", "index: " + i + "  key: " + k);

        if (tnb.providers[k] != undefined) ++count;
                else break;
      }

      return count;
    };


    /**
     * @return the number of rows in a given range
     */
    /* int */
    this.getRangeSize = function()
    {
      var sz = adf.mf.api.getLocalValue("#{" + this.id + ".IterBinding.RangeSize}");
      return (sz == undefined)? 0 : sz;
    };


    /***** internal methods *****/

    /**
     * fetch the first row in the collection
     */
    this.fetch = function(index, success, failed)
    {
      var tnb = this.getTreeNodeBindings();

      this.setCurrentIndex(index);

      if (this.currentKey !== undefined)
      {
        if (tnb.providers[this.currentKey] === undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("no provider present for the key " + this.currentKey +
                                    " need to fetch the value."));
          }
          this.fetchProviderByKey(this.currentKey, this.index, success, failed);
        }
        else
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("we have a provider for key " + this.currentKey +
                                   " = " + adf.mf.util.stringify(tnb.providers[this.currentKey])));
          }
          this.returnProvider(this.currentKey, new TreeNode(tb, this.index, this.treeBindingEL), success);
        }
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                 "no element found");
        }
        this.returnProvider(undefined, undefined, failed);
      }
    };

    /**
     * fetch a row in the collection
     */
    /* provider */
    this.localFetch = function(index)
    {
      var tnb      = this.getTreeNodeBindings();
      var  oldIndex = this.index;

      this.setCurrentIndex(index);

      if (this.currentKey !== undefined)
      {
        if (tnb.providers[this.currentKey] !== undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("we have a provider for key " + this.currentKey +
                                   " = " + adf.mf.util.stringify(tnb.providers[this.currentKey])));
          }
          var treeNode = new TreeNode(tb, this.index, this.treeBindingEL);
          var provider = treeNode.getProvider();
          if (provider['rowKey'] === undefined)
          {
            provider['rowKey'] = treeNode.rowKey();
          }
          return treeNode;
        }
      }

      this.setCurrentIndex(oldIndex);  /* move the cursor back to where it was first */
      return undefined;
    };


    this.getKeys = function(success, failed)
    {
      var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");;
      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "getKeys",
                                          this.id,
                                          [function(a,b) { cm.treeNodeBindings.keys = b; },
                                          success], failed);
    };

    /**
     * remove the current row (provider)
     */
    this.removeCurrentRow = function(success, failed)
    {
      var tnb       = this.getTreeNodeBindings();
      var removeKey = this.currentKey;
      var range     = 0;
      var newIndex  = this.index;

      /* first lets remove the key in the JavaScript cached collection model */
      for (var i = 0; i < tnb.keys.length; ++i)
      {
        if (tnb.keys[i] === this.currentKey)
        {
          tnb.keys.splice(i, 1);
          break;
        }
      }

      range = tnb.keys.length - 1;
      if (newIndex == range)
      {   /* we removed the last one, so move the index to the new last */
        newIndex = (range - 1);
      }
      if (range < 0)
      {  /* there are no elements in the collection any more */
        this.index      = -1;
        this.currentKey = undefined;
      }
      else
      {
        this.setCurrentIndex(newIndex);
      }

      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "removeRowWithKey",
                                 this.id, removeKey, success, failed);
    };

    this.setCurrentRowKey = function(key)
    {
      var i = this.getTreeNodeBindings().keys.indexOf(key);
      if (i != -1)
      {
        this.index = i;
        this.currentKey = key;
        return true;
      }
      return false;
    };

    this.setCurrentRowWithKey = function(key, success, failed)
    {
      var tnb      = this.getTreeNodeBindings();
      var newIndex = -1;

      for (var i = 0; i < tnb.keys.length; ++i)
      {
        if (tnb.keys[i] === key)
        {
          newIndex = i;
          break;
        }
      }
      if (newIndex != -1)
      {
        this.setCurrentIndex(newIndex);

        adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "setCurrentRowWithKey",
                                      this.id, key, success, failed);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "setCurrentRowWithKey",
                                 ("unable to find the key to set the current row to."));
        }
      }
    };


    /* ---------- internal callback functions ------------- */

    this.fetchSet = function(pcns, index, success, failed)
    {
      var cm    = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
      var scb   = [];
      var fcb   = [];
      var op    = "oracle.adfmf.bindings.iterator.IteratorHandler:fetchSetRelativeTo";
      var upf   = this.updateProviders;
      var start = adf.mf.internal.perf.startMonitorCall("Tree node iterator fetch set", adf.mf.log.level.FINER, op);


      scb = scb.concat(
        [
          function(a,b)
          {
            start.stop();
            start = adf.mf.internal.perf.startMonitorCall("Tree node iterator update providers", adf.mf.log.level.FINER,
              "adf.mf.api.TreeNodeIterator.updateProviders");
            try
            {
              upf(cm, b);
            }
            finally
            {
              start.stop();
            }
          }
        ]);
      scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);

      fcb = fcb.concat(
        [
          function(a,b)
          {
            start.stop();
            adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
              "TreeNodeIterator.fetchSet", "WARN_UNABLE_TO_FETCH_SET");

            // For security purposes, only log the request and response details at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "TreeNodeIterator", "fetchSet",
                "Faled to fetch set: " + adf.mf.util.stringify(arguments));
            }
          }
        ]);

      fcb = fcb.concat(adf.mf.internal.util.is_array(failed) ? failed : [ failed ]);

      /* pcns: previous, current, or next set */
      return adf.mf.api.invokeMethod(
        "oracle.adfmf.bindings.iterator.IteratorHandler", "fetchSetRelativeTo",
        this.id, pcns, cm.treeNodeBindings.keys[index], scb, fcb);
    };

    /* ---------- internal callback functions ------------- */
    this.fetchProviderByKey = function(key, index, success, failed)
    {
      var rpf = this.returnProvider;

      this.fetchSet("next", index,
        function(a,b) { rpf(key, new TreeNode(tb, index, this.treeBindingEL), success); },
        failed);
    };

    this.updateKeys = function(keys)
    {
      try
      {
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        cm.treeNodeBindings.keys = keys;
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "TreeNodeIterator.updateKeys", "ERROR_TREENODEITERATOR_UPDATE_KEYS");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "TreeNodeIterator", "updateKeys",
            "Error updating the keys of " + this.id + " error: " + e);
        }
      }
    };

    this.updateProviders = function(cm, values)
    {
      var providers = values || {};
      var keys      = [];

      if (cm === undefined)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "TreeNodeIterator.updateProviders", "ERROR_TREENODEITERATOR_UPDATE_PROVIDERS");
      }
      else
      {
        for (var p in providers)
        {
          if (p !== undefined)
          {
            cm.treeNodeBindings.providers[p] = providers[p];
          }
        }
      }
    };

    this.returnProvider = function(name, provider, callback)
    {
      var request  = [{ 'name':name}];
      var response = [{ 'name':name, 'value': provider }];

      if (adf.mf.internal.util.is_array(callback))
      {
        var count = callback.length;

        for (var i = 0; i < count; ++i)
        {
          callback[i](request, response);
        }
      }
      else
      {
        callback(request, response);
      }
    };
  };

  adf.mf.internal.el.TreeNode   = TreeNode;
  adf.mf.el.TreeNodeIterator    = TreeNodeIterator;
})();




/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/TreeNode.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Utilities.js///////////////////////////////////////

/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Utilities.js ---------------------- */
// @requires AdfPerfTiming


var adf                                       = window.adf                                    || {};
adf.mf                                        = adf.mf                                        || {};
adf.mf.api                                    = adf.mf.api                                    || {};
adf.mf.el                                     = adf.mf.el                                     || {};
adf.mf.locale                                 = adf.mf.locale                                 || {};
adf.mf.log                                    = adf.mf.log                                    || {};
adf.mf.resource                               = adf.mf.resource                               || {};
adf.mf.util                                   = adf.mf.util                                   || {};

adf.mf.internal                               = adf.mf.internal                               || {};
adf.mf.internal.api                           = adf.mf.internal.api                           || {};
adf.mf.internal.converters                    = adf.mf.internal.converters                    || {};
adf.mf.internal.converters.dateParser         = adf.mf.internal.converters.dateParser         || {};
adf.mf.internal.converters.dateParser.iso8601 = adf.mf.internal.converters.dateParser.iso8601 || {};
adf.mf.internal.el                            = adf.mf.internal.el                            || {};
adf.mf.internal.el.parser                     = adf.mf.internal.el.parser                     || {};
adf.mf.internal.locale                        = adf.mf.internal.locale                        || {};
adf.mf.internal.log                           = adf.mf.internal.log                           || {};
adf.mf.internal.mb                            = adf.mf.internal.mb                            || {};
adf.mf.internal.perf                          = adf.mf.internal.perf                          || {};
adf.mf.internal.resource                      = adf.mf.internal.resource                      || {};
adf.mf.internal.util                          = adf.mf.internal.util                          || {};


/**
 * startBatchRequest marks the start of the batch request.  Once this function is called
 * all subsequent requests to the java layer will be deferred until the flushBatchRequest.
 * Between the start and flush batch request markers, all requests success callbacks will
 * be called with deferred object ({.deferred:true}) response object.
 *
 * @see adf.mf.util.flushBatchRequest
 */
/* void */
adf.mf.util.startBatchRequest = function()
{
  if(adf.mf.internal.batchRequest != undefined)
  {
    throw new adf.mf.ELException("Batch Request already started.");
  }
  adf.mf.internal.batchRequest = [];
};


/* boolean */
adf.mf.util.isException = function(/* exception object */ obj)
{
  var o       = ((obj != undefined) && ('object' == typeof obj))? obj : {};
  var e       = (o[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true);

  if(e)  return e;
  else { /* lets see if it ends with Exception */
    return adf.mf.util.isType(o, "Exception");
  }
};


/* boolean */
adf.mf.util.isType = function(/* object */ obj, /* type name */ tname)
{
  var o       = ((obj != undefined) && ('object' == typeof obj))? obj : {};
  var type    = o[adf.mf.internal.api.constants.TYPE_PROPERTY] || "unknown";

  return (type.length == tname.length)?
    (type == tname) :
    (type.indexOf(tname, type.length - tname.length) != -1);
};


/**
 * Where startBatchRequest marks the start of the batch request, flushBatchRequest marks
 * the end of the batch and flushes (processes) the requests.  The caller can determine
 * if the flush should abort of the first error or continue to completion by passing either
 * true or false in the abortOnError parameter.  Regardless, the success callbacks will
 * be called in order if the batch is deemed successful otherwise the failed callbacks
 * will be invoked.  The callbacks parameters will be a vector of requests/responses one
 * for each request that was batched.
 *
 * @see adf.mf.util.startBatchRequest
 */
/* void */
adf.mf.util.flushBatchRequest = function(/* boolean abortOnError, callback success, callback failed, [boolean ignoreErrorMessages]*/)
{
  var argv  = arguments;
  var argc  = arguments.length;
  var scb   = [];
  var fcb   = [];

  if (argc!=4 && argc!=3 && argc!=2)
  {
    throw new adf.mf.ELException("Wrong number of arguments");
  }

  var abortOnError   = argv[0] || false;
  var errorHandler   = ((argc == 4) && (argv[3] == true))?
    adf.mf.internal.api.nvpEatErrors :
    adf.mf.internal.api.arraySimulatedErrors;
  var perf = adf.mf.internal.perf.startMonitorCall("Sending batch request to embedded", adf.mf.log.level.FINEST, "adf.mf.util.flushBatchRequest");
  scb = scb.concat([errorHandler]);
  scb = scb.concat((adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]]);
  scb = scb.concat([function() { perf.stop(true); }]);

  fcb = fcb.concat((adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]]);
  fcb = fcb.concat([function() { perf.stop(true); }]);

  try
  {
    if((adf.mf.internal.batchRequest === undefined) || (adf.mf.internal.batchRequest === null))
    {  /* so we do not have a defined batch request */
      throw new adf.mf.IllegalStateException("batch request is not defined");
    }

    if(adf.mf.internal.batchRequest.length > 0)
    {  /* so we have pending requests */
      if(adf.mf.internal.isJavaAvailable())
      {
        var   requests = adf.mf.internal.batchRequest.slice(0);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "adf.mf.util", "flushBatchRequest",
            ("batch request contains " + requests.length + " requests."));
        }

        adf.mf.internal.batchRequest = undefined;
        adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model",
            "processBatchRequests", abortOnError, requests, scb, fcb);
      }
      else
      {
        throw new adf.mf.IllegalStateException("invalid environment defined for batch request");
      }
    }
    else
    {  /* this is okay, let the called know we are done */
      adf.mf.internal.batchRequest = undefined;
      for(var i = 0; i < scb.length; ++i) { try { scb[i](); }catch(e){}; }
    }
  }
  catch(e)
  {  /* this is not good, let the caller know */
    for(var i = 0; i < fcb.length; ++i) { try { fcb[i](); }catch(e){}; }
  }
  finally
  {
    perf.stop(true);
  }
};


/**
 * Get the context free version of the passed in EL expression.
 **/
/* String */
adf.mf.util.getContextFreeExpression = function(/* EL Expression */ el)
{
  return adf.mf.internal.el.parser.parse(el).toContextFreeExpression().getExpression();
};


/**
 * remove array entry
 */
/* array */
adf.mf.util.removeArrayEntry = function(/* Array */ arr, /* Object */ obj)
{
	var temp = [];

	if(adf.mf.internal.util.is_array(arr))
	{
		for(var i = 1; i < arr.length; ++i)
		{
			if(arr[i] !== obj)
			{
				temp.push(arr[i]);
			}
		}
	}
	else
	{
		throw new adf.mf.IllegalStateException("array was not passed");
	}
	return temp;
};

/**
 * remove duplicate entries from the array 'arr'.  If 'arr' is
 * not an array the 'arr' object is simply returned.
 */
/* array */
adf.mf.util.removeDuplicates = function(/* Array */ arr)
{
  if(adf.mf.internal.util.is_array(arr))
  {
    arr.sort();
    for(var i = 1; i < arr.length; )
    {
      if(arr[i-1] == arr[i])
      {
        arr.splice(i, 1);
      }
      else
      {
        i++;
      }
    }
  }
  return arr;
};

function elExpressionReplacer (key, value) {
	if (value && value._expr && value.tokens)
		return value._expr;
	return value;
}

/**
 * Convert the passed in object into a string representation for printing.
 *
 * @param   dat - data object to be converted
 * @returns string representation of the dat object
 */
/* String */
adf.mf.util.stringify = function(/* object */ dat)
{
  // Stringify is potentially costly, so profile it. The function call forwarding is made so
  // recursion does not spit out bunch of log timestamps
  var perf = adf.mf.internal.perf.startMonitorCall("Converting object to a string", adf.mf.log.level.FINEST, "adf.mf.util.stringify");
  try
  {
    // Forward the call so calee can recurse
    return JSON.stringify(dat, elExpressionReplacer);
  }
  finally
  {
    perf.stop();
  }

  return return_value;
};


/**
 * Return the number of milliseconds since 01 January, 1970 UTC that the provided
 * date string represents. Attempt to use the native Date.parse, and fall back to
 * adf.mf.internal.converters.dateParser.iso8601.parse if the native one returns
 * NaN. Returns NaN if a valid date cannot be parsed.
 *
 * @param   dateString - string containing a date in a format supported natively,
              or ISO-8601
 * @returns the number of ms since 01 January, 1970 UTC, or NaN if not parsable
 */
/* Number */
adf.mf.internal.converters.dateParser.parse = function(dateStr)
{
  var dateParse = Date.parse(dateStr);

  if (isNaN(dateParse))
  {
    dateParse = adf.mf.internal.converters.dateParser.iso8601.parse(dateStr);
  }

  return dateParse;
};


/**
 * Return the number of milliseconds since 01 January, 1970 UTC that the provided
 * ISO 8601 date string represents.
 *
 * @param   iso8601String - ISO 8601 formatted date string
 * @returns the number of ms since 01 January, 1970 UTC, or NaN if not parsable
 *
 * Most of the information for this standard to support was taken from:
 * http://en.wikipedia.org/wiki/ISO_8601
 *
 * The following ISO 8601 formats are supported by this parser. For now, the date string
 * must be of the format <date> or <date>T<time>, not just a <time>.
 *
 * Dates:
 * YYYY
 * YYYY-MM-DD
 * YYYY-MM
 * YYYYMMDD
 *
 * Times:
 * hh:mm:ss
 * hh:mm
 * hhmmss
 * hhmm
 * hh
 *
 * Decimal fractions may also be added to any of the three time elements. A decimal mark,
 * either a comma or a dot (without any preference as stated in resolution 10 of the 22nd
 * General Conference CGPM in 2003, but with a preference for a comma according to ISO
 * 8601:2004) is used as a separator between the time element and its fraction. A fraction
 * may only be added to the lowest order time element in the representation. To denote "14
 * hours, 30 and one half minutes", do not include a seconds figure. Represent it as
 * "14:30,5", "1430,5", "14:30.5", or "1430.5". There is no limit on the number of decimal
 * places for the decimal fraction.
 *
 * Time zone designators:
 * <time>Z
 * <time>��hh:mm
 * <time>��hhmm
 * <time>��hh
 *
 * When the ISO 8601 string is applied against the regular expression, matches[] should contain
 * the following values. For MM/DD/mm/ss, only one of the corresponding array indicies for each
 * will contain data, the other remaining undefined. Which ones are populated depend on the use
 * of separator characters ('-', ':') in the ISO 8601 string.
 *
 * matches[1]   YYYY <- YYYY-MM-DDThh:mm:ss.fffZ        (the year)
 * matches[2]   MM   <- YYYYMMDDThh:mm:ss.fffZ          (the month when no hyphen separates year & month)
 * matches[3]   DD   <- YYYYMMDDThh:mm:ss.fffZ          (the day when no hyphen separates month & day)
 * matches[4]   MM   <- YYYY-MM-DDThh:mm:ss.fffZ        (the month when a hyphen separates year & month)
 * matches[5]   DD   <- YYYY-MM-DDThh:mm:ss.fffZ        (the day when a hyphen separates month & day)
 * matches[6]   hh   <- YYYY-MM-DDThh:mm:ss.fffZ        (the hours)
 * matches[7]   mm   <- YYYY-MM-DDThh:mm:ss.fffZ        (the minutes when no colon separates hours & minutes)
 * matches[8]   ss   <- YYYY-MM-DDThh:mm:ss.fffZ        (the seconds when no colon separates minutes & seconds)
 * matches[9]   mm   <- YYYY-MM-DDThhmmss.fffZ          (the minutes when a colon separates hours & minutes)
 * matches[10]  ss   <- YYYY-MM-DDThhmmss.fffZ          (the seconds when a colon separates minutes & seconds)
 * matches[11]  fff  <- YYYY-MM-DDThh.fffZ              (the fractional hours)
 *          or  fff  <- YYYY-MM-DDThhmm.fffZ            (the fractional minutes, with or without colon separator)
 *          or  fff  <- YYYY-MM-DDThhmmss.fffZ          (the fractional seconds, with or without colon separator)
 * matches[12]  Z    <- YYYY-MM-DDThh:mm:ss.fffZ        (Zulu time, aka +00:00)
 * matches[13]  ��    <- YYYY-MM-DDThh:mm:ss.fff��zh:zm   ('+' or '-'; the direction of the timezone offset)
 * matches[14]  zh   <- YYYY-MM-DDThh:mm:ss.fff-zh:zm   (the hours of the time zone offset)
 * matches[15]  zm   <- YYYY-MM-DDThh:mm:ss.fff-zh:zm   (the minutes of the time zone offset)
 */
/* Number */
adf.mf.internal.converters.dateParser.iso8601.parse = function(iso8601Str)
{
  var re = /^(\d{4})(?:(\d{2})(\d{2})|-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2})(?::(\d{2})(?::(\d{2}))?|(\d{2})(?:(\d{2}))?)?(?:[,\.](\d+))?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  var matches = re.exec(iso8601Str);

  if (!matches)
  {
    return NaN;
  }

  var pc = this.constants;

  // assign parsed values to correct units, initializing with default if unspecified
  var year     = matches[pc.YEAR];
  var month    = matches[pc.MONTH]    || matches[pc.MONTH_HYPHEN]  || "1";
  var day      = matches[pc.DAY]      || matches[pc.DAY_HYPHEN]    || "1";
  var hours    = matches[pc.HOURS]    || "0";
  var minutes  = matches[pc.MINUTES]  || matches[pc.MINUTES_COLON] || "0";
  var seconds  = matches[pc.SECONDS]  || matches[pc.SECONDS_COLON] || "0";
  var fraction = matches[pc.FRACTION] || "0";
  var zulu     = matches[pc.ZULU];

  year = parseInt(year, 10);
  month = parseInt(month, 10);
  day = parseInt(day, 10);

  hours = parseInt(hours, 10);
  minutes = parseInt(minutes, 10);
  seconds = parseInt(seconds, 10);

  var fractionMillis = 0;

  // if fraction specified, determine which time part it belongs to and compute additional ms
  if (matches[pc.FRACTION])
  {
    fraction = parseFloat("." + fraction);

    if (matches[pc.SECONDS] || matches[pc.SECONDS_COLON])
    {
      fractionMillis = Math.round(fraction * 1000);       // 1000 = ms / second
    }
    else if (matches[pc.MINUTES] || matches[pc.MINUTES_COLON])
    {
      fractionMillis = Math.round(fraction * 60000);      // 60 * 1000 = ms / minute
    }
    else
    {
      fractionMillis = Math.round(fraction * 3600000);    // 60 * 60 * 1000 = ms / hour
    }
  }

  // create date from time parts (month is zero-based)
  var dateMillis = Date.UTC(year, month - 1, day, hours, minutes, seconds);

  dateMillis += fractionMillis;

  // adjust for timezone
  if (!zulu)
  {
    var tzPlus    = matches[pc.TZ_PLUS];
    var tzHours   = matches[pc.TZ_HOURS]   || "0";
    var tzMinutes = matches[pc.TZ_MINUTES] || "0";

    var offsetMillis = parseInt(tzHours, 10) * 3600000;   // 60 * 60 * 1000
    offsetMillis += parseInt(tzMinutes, 10) * 60000;      // 60 * 1000;

    if (tzPlus == "+")
    {
      dateMillis += offsetMillis;
    }
    else
    {
      dateMillis -= offsetMillis;
    }
  }

  return dateMillis;
};


adf.mf.internal.converters.dateParser.iso8601.constants =
{
  YEAR:          1,
  MONTH:         2,
  DAY:           3,
  MONTH_HYPHEN:  4,
  DAY_HYPHEN:    5,
  HOURS:         6,
  MINUTES:       7,
  SECONDS:       8,
  MINUTES_COLON: 9,
  SECONDS_COLON: 10,
  FRACTION:      11,
  ZULU:          12,
  TZ_PLUS:       13,
  TZ_HOURS:      14,
  TZ_MINUTES:    15
};

/**
 * INTERNAL FUNCTION used to do token subsitution on the passed in expression
 * with the replacementStack of name/value objects.
 */
adf.mf.internal.util.tokenSubsitution = function(/* string */ expression, /* array */ replacementStack)
{
	var result = expression;

	for(var i = 0; i < replacementStack.length; ++i)
	{
		var  replaceMap = replacementStack[i];
		var  ele        = adf.mf.internal.el.parser.parse(result);

		result = ele.stripLocalValues(true, replaceMap, false).getExpression();
	}
	return result;
};

/**
 * INTERNAL FUNCTION used to do strip the local values and token subsitution in one step.
 */
adf.mf.internal.util.stripLocalValues = function(/* string */ expression, /* context free */ bContextFree, /* array */ replacementStack)
{
		if (!expression.tokens)
			expression = adf.mf.internal.el.parser.parse(expression);

	if(replacementStack != null)
	{
		for(var i = 0; i < replacementStack.length; ++i)
		{
			var replaceMap = replacementStack[i];
			expression = expression.stripLocalValues(bContextFree, replaceMap, true);
		}
	}
	else
	{
		expression  = expression.stripLocalValues(bContextFree, null, true);
	}
	return expression;
};


/**
 * Internal method to determine if the expression is valid as a
 * left hand expression for assignments.
 */
adf.mf.internal.util.isAssignable = function(/* string */ expression)
{
	var c1  = false;
	var c2  = false;
	var exp = expression;

	// since the term is allowed to have wrapping parenthesis we need to remove them if they exist
	exp = exp.replace(/^\(/g, " ").replace(/\)$/g, " ").trim();

	// since an array element is a valid LHS token, remove all characters in and including the brackets [.*]
	exp = exp.replace(/\[[^\]]*\]/g, "replace");

	// remove all the numbers from the expression to remove numeric constants
	exp = exp.replace(/[0-9]/g, "");

	// now look for any operators or parenthesis, denoting more than a single token remains
	c1  = (exp.search(/[!%&|\+\-\*\/\(]/i) == -1);

	// make sure we still have characters, i.e. letters for the variable
	c2  = (exp.length > 0);

	return (c1 && c2);
};


/**
 * INTERNAL FUNCTION used to determine if the input is an array or not
 */
adf.mf.internal.util.is_array = Array.isArray;

/**
 * INTERNAL FUNCTION appends array2, to array2. It does not create new array.
 */
adf.mf.internal.util.appendAll = function(array1, array2, array2From)
{
	if (!array2From) array2From = 0;
	for (var i = array2From; i < array2.length; i++)
		array1.push(array2[i]);
};

adf.mf.util.obfuscate = function(s) {
	return s.replace(/[a-zA-Z]/g, function(c) {
		return String.fromCharCode((c <= "Z"? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26);
	});
};

/**
 * Check if a string starts with another string
 *
 * @param {?string} findIn the string to check against
 * @param {?string} strToFind the string to look for
 * @return {boolean} true if findIn is a string and strToFind is a string and findIn starts with
 *         strToFind
 */
adf.mf.util.stringStartsWith = function(
	findIn,
	strToFind)
{
	return findIn != null &&
		strToFind != null &&
		strToFind.length > 0 &&
		findIn.length >= strToFind.length &&
		findIn.substring(0, strToFind.length) == strToFind;
};

/**
 * Check if a string ends with another string
 *
 * @param {?string} findIn the string to check against
 * @param {?string} strToFind the string to look for
 * @return {boolean} true if findIn is a string and strToFind is a string and findIn ends with
 *         strToFind
 */
adf.mf.util.stringEndsWith = function(
	findIn,
	strToFind)
{
	return findIn != null &&
		strToFind != null &&
		strToFind.length > 0 &&
		findIn.length >= strToFind.length &&
		findIn.substring(findIn.length - strToFind.length) == strToFind;
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Utilities.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adfel.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Adfel.js ---------------------- */
// @requires ELErrors
//
// @requires JavaScriptContext

// @requires ELParser
// @requires TreeNode
// @requires Utilities
// @requires AdfPerfTiming
// @requires AdfResource
// @requires AdfLocale

var PERFMON    = true;

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.el.parser.cache  = adf.mf.internal.el.parser.cache  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};



adf.mf.internal.api.constants = adf.mf.internal.api.constants || {
  'KEY_PROPERTY'            : '.key',
  'NULL_FLAG_PROPERTY'      : '.null',
  'TYPE_PROPERTY'           : '.type',
  'TRANSIENT_FLAG_PROPERTY' : '.transient',
  'EXCEPTION_FLAG_PROPERTY' : '.exception',
  'VALUE_REF_PROPERTY'      : '.valueref',
  'WEAK_REFERENCE_PROPERTY' : '.weakref',
  'DEFERRED_PROPERTY'       : '.deferred'
};

(function() {
  /**
   * The JavaScriptContext is basic the javascript model layer.  It is an EL
   * context for javascript.  So things like root level variables, functions,
   * .. as well as wrapping the VMChannel and other base platform items.
   */
  adf.mf.internal.context = new adf.mf.internal.el.JavaScriptContext();

  /**
   * Define a 'default' binding instance
   */
  var bindingInstances    = {};

  /**
   * Topic: Understanding_DataChangeListeners:
   *
   * There is one dataChangeListener for EACH individual variable we are monitoring for
   * changes.  So for the EL Expression #{a + b} there would be two dataChangeListeners
   * (one for 'a' and one for 'b').  Each of these dataChangeListers records are handled
   * independently, since we might actually be monitoring 'a' or 'b' already or as part
   * of another expression.  The dataChangeListeners record contains two arrays; one for
   * the all the unique IDs (EL Expressions) that we should be listening on, and one for
   * the callbacks to notify.
   *
   * Given that, when a data change listener (via addDataChangeListener) is registered,
   * the EL Expression is decomposed into all of it's individual variables where each
   * variable get their own dataChangeListner record.  So given the above EL Expression
   * (#{a + b}), there is an 'a' DCL and a 'b' DCL that would look something like this:
   *
   *   dataChangeListeners["a"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *   dataChangeListeners["b"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *
   * now if we then register the EL Expression #{a + c}, we would get something like this:
   *
   *   dataChangeListeners["a"] = { "id":["#{a + b}", "#{a + c}"]
   *                                "callback":[function() {...}, function() {...}] }
   *   dataChangeListeners["b"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *   dataChangeListeners["c"] = { "id":["#{a + c}"] "callback":[function() {...}] }
   *
   * Notice how the dataChangeListeners["a"]'s id and callback array grew and the
   * inclusion of the "c" dataChangeListener record.
   *
   * Now, when some data is changed in the CVM layer a data change event (DCE) is raised
   * and passed back on a VMChannel response message.  The native container framework then
   * pulls this DCE off the response and passes it to (javascript) processDataChangeEvent.
   * In this javascript function the DCE is disected and for each and every variable/provider
   * change in the DCE the following is done:
   *   1. data is updated in the JavaScriptContext
   *   2. determine if any registered data change listeners exists for that variable or provider.
   *      This is done by simply looking up the variable name in the dataChangeListeners map
   *      (i.e. name->dataChangeListeners records (described above)).
   *
   * Since the data change listener record contains all the registered ELs (id) and handlers
   * (callback), we simply send a notification to all the handlers with each of the registered
   * EL Expression (id in the code).
   *
   * So if we code that looked like this:
   *  adf.mf.api.addDataChangeListeners("#{a}",   fa);   // 1
   *  adf.mf.api.addDataChangeListeners("#{!a}",  fna);  // 2
   *  adf.mf.api.addDataChangeListeners("#{b}",   fb);   // 3
   *  adf.mf.api.addDataChangeListeners("#{a+b}", fab);  // 4
   *
   * Then we receive a data change event for a, then following notifications would
   * be emitted:
   *   fa(#{a})    // registered by line 1
   *   fna(#{!a})  // registered by line 2
   *   fab(#{a+b}) // registered by line 4
   * If we then recieve a data change event fo b, these notifications would be emitted:
   *   fb(#{b})    // registered by line 3
   *   fab(#{a+b}) // registered by line 4
   *
   * To unregister a data change listener simply call adf.mf.api.removeDataChangeListeners
   * i.e.
   *   adf.mf.api.removeDataChangeListeners("#{a+b}") // remove the line 4 listener
   *
   *
   * In addition to the data change listeners for individual EL expressions, one can register for
   * a bulk notification mechanism.  In this case, the framework will not attempt to map individual
   * ELs to specific callback, instead the registered callback(s) will be invoked with the list of
   * ELs that where changed.  This 'bulk' mechanism has some PROs and CONs.  It provides a single
   * notification with all the changed ELs allowing the handler to process all the changes in a single
   * call (allowing a single update event for multiple changes in components like a table).  However,
   * it does place the work of filtering/routing EL changes to the proper sub-component.
   *
   * NOTE: The providers detail will only contain itemized changes provided the 'itemized'
   *       property exists and is true.  Otherwise the entire collection model should be
   *       updated since no detailed information is known.  This detailed information is
   *       delivered as a map with the collection model id being the key.  The value of the
   *       property will be a provider change record in the following format:
   *
   *       {
   *         bindings.notes.collectionModel: {
   *           itemized: true;
   *           created: [0: {key: UID-3464; }];
   *           updated: [];
   *           deleted: [];
   *           dirtied: [];
   *         };
   *       }
   *
   *       where:
   *         itemized: true | false,  // true if created,updated, and deleted information is provided
   *         created:[ c-record ],    // right now only contains a single key property
   *         updated:[ ids ],         // list of IDs that have been updated
   *         deleted:[ ids ]          // list of IDs that have been deleted
   *         dirtied:[ ids ]          // list of IDs that have been updated
   *
   * To register a bulk data change listener the following should be done:
   *   adf.mf.api.addBatchDataChangeListener(variables, providers);
   *
   * Then we you will received data change events as follows:
   *   fa(["#{a}", "{#!a}", "#{a + b}"],
   *      {myCollectionModel:{itemized:true, created:[0: {key: UID-3464; }], updated:[], deleted:[], dirtied:[]})
   *
   */
  var dataChangeListeners                    = {};

  /**
   * INTERNAL: the array of global batch data change listeners
   */
  adf.mf.internal.batchDataChangeListeners   = [];

  /**
   * INTERNAL: the array of pending requests
   */
  adf.mf.internal.batchRequest               = undefined;

  /**
   * INTERNAL: storage for batching missing get local values.
   *
   *   @see adf.mf.api.startGetValueBatchRequest
   *  @see adf.mf.api.flushGetValueBatchRequest
   */
  adf.mf.internal.el.getValueBatch           = undefined;

  /**
   * INTERNAL FUNCTION used to log all errors coming back from the JVM.
   */
  adf.mf.internal.logError = function(req, resp)
  {
    var msg = adf.mf.resource.getInfoString("ADFErrorBundle", "ERROR_IN_REQUEST");
    adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal", "logError", msg);

    // For security, only log the error at a FINE level
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal", "logError",
        "Error in request: " + adf.mf.util.stringify(req) + ". Response: " +
        adf.mf.util.stringify(resp));
    }
  };
  adf.mf.internal.errorHandlers = [adf.mf.internal.logError];

  /**
   * PUBLIC FUNCTION used to add a new data change listener (callback) for a given el expression (variable)
   *
   * e.g.
   *   adf.mf.api.addDataChangeListeners("#{bindings.apple}",                   appleChangedCallback);
   *   adf.mf.api.addDataChangeListeners("#{bindgins.apple + bindings.orange}", appleOrOrangeChangedCallback);
   *
   *    adf.mf.api.addDataChangeListeners("#{!bindings.foo}",                    bindingsFooChangedCallback);
   *
   *   where the callback would looks something like this:
   *   bindingsFooChangedCallback = function(id)
   *   {
   *      document.write("DataChangeNotification 1 notification for ID: " + id);
   *   }
   *
   * If the same expression/listener combination is registered several times, duplicates are discarded.
   *
   * For more details see @Understanding_DataChangeListeners
   *
   * @export
   */
  adf.mf.api.addDataChangeListeners = function(expression, callback)
  {
    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);
    var variables  = expression.dependencies();
    var id         = expression;

    var perf = adf.mf.internal.perf.startMonitorCall("Add a new data change listener", adf.mf.log.level.FINE,
      "adf.mf.api.addDataChangeListeners");
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addDataChangeListeners",
          ("addDataChangeListeners " + expression + " ==> " + variables.length + " ==> " + variables.join()));
    }

    for (var v = 0; v < variables.length; ++v)
    {
      var alreadyRegistered = false;
      var variable          = variables[v];
      var dcl               = (variable.slice(0, "bindings".length) == "bindings")?
          currentBindingInstance.dataChangeListeners : dataChangeListeners;

      if (dcl[variable] === undefined)
      {   /* if currently we don't have a DCL record for this variable, create it */
        dcl[variable] = {"id":[], "callback":[]};
      };

      /* add the expression id to the dataChangeListeners */
      alreadyRegistered = false;
      for (var i = 0; i < dcl[variable]["id"].length; ++i)
      {
        if (dcl[variable]["id"][i] == id)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.api", "addDataChangeListeners",
                ("addDataChangeListener " + variable + " id=" + id + " was already registered."));
          }
          alreadyRegistered = true;
          break;  /* you only need to find one match */
        }
      }
      if (!alreadyRegistered)
      {
        dcl[variable]["id"].push(id);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
              ("there are now " + dcl[variable]["id"].length + " different listener's IDs."));
        }
      }

      alreadyRegistered = false;
      for (var i = 0; i < dcl[variable]["callback"].length; ++i)
      {
        if (dcl[variable]["callback"][i].toString() == callback.toString())
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
                ("variable " + variable + " already has this callback registered."));
          }

          alreadyRegistered = true;
          break;  /* you only need to find one match */
        }
      }
      if (!alreadyRegistered)
      {
        dcl[variable]["callback"].push(callback);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
              ("there are now " + dcl[variable]["callback"].length + " different callbacks registered."));
        }
      }

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addDataChangeListeners",
            ("adding the " + variable + " " +  adf.mf.util.stringify(dcl[variable]) + " listener."));
      }
    }
    perf.stop();
  };

  /**
   * PUBLIC FUNCTION used to add a new bulk data change listener (callback)
   *
   * e.g.
   *   adf.mf.api.addBatchDataChangeListener(printBatchDataChangeEvent);
   *
   *   where the callback would looks something like this:
   *
   *   printBatchDataChangeEvent = function(variables, providers) {
   *     if(variables != undefined) {
   *       document.write("Batch DCE -- <br> variables = " + adf.mf.util.stringify(variables)+ "<br>");
   *     }
   *     if(providers!= undefined) {
   *       document.write(" providers =" + adf.mf.util.stringify(providers) + "<br>");
   *     }
   *   };
   *
   * If the same listener is registered several times, duplicates are discarded.
   *
   * NOTE: if the providers detail will only contain itemized changes provided the 'itemized'
   *       property exists and is true.  Otherwise the entire collection model should be updated
   *       since no detailed information is known.
   *
   * For more details see @Understanding_DataChangeListeners
   *
   * @export
   */
  adf.mf.api.addBatchDataChangeListener = function(callback)
  {
    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      if (adf.mf.internal.batchDataChangeListeners[i] == callback) return
    }
    adf.mf.internal.batchDataChangeListeners.push(callback);
  };

  /**
   * PUBLIC FUNCTION used to add a new error handler (callback)
   *
   * e.g.
   *   adf.mf.api.addErrorHandler(myErrorHandler);
   *
   *   where the callback would looks something like this:
   *   myErrorHandler = function(adfexception)
   *   {
   *      document.write("Error Handler 1 notification for: " + adfexception);
   *   }
   *
   * If the same handler is registered several times, duplicates are discarded.
   *
   * For more details see @Understanding_ErrorHandlers
   *
   * @export
   */
  adf.mf.api.addErrorHandler = function(callback)
  {
    for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
    {
      if (adf.mf.internal.errorHandlers[i] == callback) return
    }
    adf.mf.internal.errorHandlers.push(callback);
  };


  /**
   * PUBLIC FUNCTION used to get the current context ID.
   *
   * e.g. adf.mf.api.getContextId(successCallback, failedCallback);
   *
   * @deprecated
   * @export
   */
  /* void */
  adf.mf.api.getContextId = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextId", success, failed);
  };


  /**
   * PUBLIC FUNCTION used to get the current context's pagedef.
   *
   * e.g. adf.mf.api.getContextId(success, failed);
   *
   * @export
   */
  /* void */
  adf.mf.api.getContextPageDef = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextPageDef", success, failed);
  };


  /**
   * PUBLIC FINCTION used to get the current context's instance ID
   *
   * @export
   */
  /* void */
  adf.mf.api.getContextInstanceId = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextInstanceId", success, failed);
  };



  /**
   * PUBLIC FUNCTION used to invoke method in any class in classpath.
   *
   * e.g. adf.mf.api.invokeMethod(classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
   *
   * @param {string}                               classname  - name of the class
   * @param {string}                               methodname - name of the method
   * @param {Array.<string>}                       params     - parameters
   * @param {Array.<function(Object,Object):void>} success    - invoked when the method is successful invoked
   *                                                            (signature: success(request, response))
   * @param {Array.<function(Object,Object):void>} failed     - invoked when an error is encountered
   *                                                            (signature: failed(request, response))
   *
   * Examples:
   *      adf.mf.api.invokeMethod("TestBean", "setStringProp", "foo", success, failed);
   *      adf.mf.api.invokeMethod("TestBean", "getStringProp", success, failed);
   *      adf.mf.api.invokeMethod("TestBean", "testSimpleIntMethod", "101", success, failed); // Integer parameter
   *      adf.mf.api.invokeMethod("TestBean", "testComplexMethod",
   *              {"foo":"newfoo","baz":"newbaz",".type":"TestBeanComplexSubType"}, success, failed); // Comples parameter
   *      adf.mf.api.invokeMethod("TestBean", "getComplexColl", success, failed); // No parameter
   *      adf.mf.api.invokeMethod("TestBean", "testMethodStringStringString", "Hello ", "World", success, failed); // 2 string parameter
   */
  adf.mf.api.invokeMethod = function()
  {
    var args = [].splice.call(arguments,0);   // convert arguments into a real array

    var updatedArgs = [null];  // adding the default communication id

    adf.mf.internal.api.invokeMethod.apply(this, updatedArgs.concat(args));
  };

  /**
   * PUBLIC FUNCTION used to invoke Security Methods
   */
  adf.mf.api.invokeSecurityMethod = function(command, username, password, tenantname, success, failed)
  {
    adf.mf.internal.context.invokeSecurityMethod(command, username, password, tenantname, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to remove all data change listeners associated with the variable
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.removeDataChangeListeners = function(expression)
  {
    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);
    var variables  = expression.dependencies();
    var id         = expression;

    for (var i = 0; i < variables.length; ++i)
    {
      var v   = variables[i];
      var dcl = ((v.slice(0, "bindings".length) == "bindings")?
          currentBindingInstance.dataChangeListeners : dataChangeListeners);

      try
      {
        var ida = dcl[v]["id"];
        for (var j = 0; j < ida.length; ++j)
        {
          if (ida[j] === id)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf", "removeDataChangeListeners",
                  ("removing the " + adf.mf.util.stringify(ida[j]) + " listener."));
            }
            ida.splice(j,1);
          }
        }
        if (ida.length == 0)
        {
          // clean up the dataChangeListener all together
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf", "removeDataChangeListeners",
              ("removing the " + ida + " listener all together."));
          }
          delete dcl[v];
        }
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf", "removeDataChangeListeners",
              ("All the current data change listeners in the system:<br> " +
                  adf.mf.util.stringify(dcl)));
        }
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.SEVERE))
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.api.removeDataChangeListeners", "ERROR_EXCEPTION");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.api", "removeDataChangeListeners",
              "Exception: " + e);
          }
        }
      }
    }
  };


  /**
   * PUBLIC FUNCTION used to remove a bulk data change listener
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.removeBatchDataChangeListener = function(callback)
  {
    var temp = [];

    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      if (adf.mf.internal.batchDataChangeListeners[i] != callback)
      {
        temp.push(adf.mf.internal.batchDataChangeListeners[i]);
      }
    }
    adf.mf.internal.batchDataChangeListeners = temp;
  };


  /**
   * PUBLIC FUNCTION used to remove an error handler
   *
   * For more details see @Understanding_ErrorHandlers
   */
  adf.mf.api.removeErrorHandler = function(callback)
  {
    var temp = [];

    for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
    {
      if (adf.mf.internal.errorHandlers[i] != callback)
      {
        temp.push(adf.mf.internal.errorHandlers[i]);
      }
    }
    adf.mf.internal.errorHandlers = temp;
  };


  /**
   * PUBLIC FUNCTION used to reset context. Call this before setting new context.
   * This is exactly the same as calling adf.mf.api.setContext with an empty context name.
   *
   * e.g. adf.mf.api.removeContextInstance(successCallback, failedCallback);
   */
  adf.mf.api.removeContextInstance = function(pageDef, instanceId, success, failed)
  {
    adf.mf.internal.el.resetBindingContext();
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model",
        "removeContextInstance", pageDef, instanceId, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to reset context. Call this before setting new context.
   * This is exactly the same as calling adf.mf.api.setContext with an empty context name.
   *
   * e.g. adf.mf.api.resetContext(successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.resetContext = function(success, failed)
  {
    adf.mf.api.setContext("", success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set context for the specified name
   *
   * e.g. adf.mf.api.setContext("MyPage", "MyPage-1", true, true, successCallback, failedCallback);
   *
   * pageDef    - name of the page definition
   * instanceId - unique id for the instance
   * resetState - reset the bindings associated with this instance
   * reSync     - re-send the initial bindings structure to the container
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  adf.mf.api.setContextInstance = function(pageDef, instanceId, resetState, /* boolean */reSync, success, failed)
  {
    adf.mf.api.setCurrentContext(pageDef, resetState, reSync, true, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set the current context.
   *
   * e.g. adf.mf.api.setCurrentContext("MyPage", true, true, true, successCallback, failedCallback);
   *
   * pageDef      - name of the page definition
   * resetState   - reset the bindings associated with this instance
   * reSync       - re-send the initial bindings structure to the container
   * newViewScope - should a new viewScope also be initialized, releasing the previous one?
   */
  adf.mf.api.setCurrentContext = function(pageDef, resetState, reSync, newViewScope, success, failed)
  {
    try
    {
      if ((pageDef === undefined) || (pageDef === null) || (pageDef.length < 1))
      {
        //
        // clear all the bindings and listeners associated with this context.
        //
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf", "setCurrentContext",
            ("\n\n*******\nBindings = " +
            adf.mf.util.stringify(adf.mf.api.getLocalValue("#{bindings}")) + "\n*******\n\n"));
        }
        adf.mf.api.removeContextInstance(pageDef, null, success, failed);
      }
      else
      {
        adf.mf.internal.el.switchBindingInstance(pageDef);
        adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setCurrentContext",
            pageDef, resetState, reSync, newViewScope, success, failed);
      }
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setCurrentContext", "ERROR_SET_CONTEXT_EXCEPTION");

      // For security, only log the error at a FINE level
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setCurrentContext", ge);
    }
  };


  /**
   * PUBLIC FUNCTION used to clear and then set context for the specified name
   *
   * @param name    - name of the context
   * @param success - call on success
   * @param failed  - call on failed
   *
   * this is the same as calling adf.mf.internal.api.setContext(name, true, success, failed);
   *
   * e.g. adf.mf.api.setContext("myContextName", successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.clearAndSetContext = function(/* context name */ name, success, failed)
  {
    adf.mf.internal.api.setContext(name, true, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set context for the specified name
   *
   * @param name    - name of the context
   * @param success - call on success
   * @param failed  - call on failed
   *
   * this is the same as calling adf.mf.internal.api.setContext(name, false, success, failed);
   *
   * e.g. adf.mf.api.setContext("myContextName", successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.setContext = function(/* context name */ name, success, failed)
  {
    adf.mf.internal.api.setContext(name, false, success, failed);
  };

  /**
   * INTERNAL FUNCTION used to set context for the specified name
   *
   * @param name       - name of the context
   * @param clearPrior - true for clear the current context
   * @param success    - call on success
   * @param failed     - call on failed
   *
   * e.g. adf.mf.api.setContext("myContextName", true, successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.internal.api.setContext = function(/* String */ name, /* boolean */clearPrior, success, failed)
  {
    adf.mf.api.setCurrentContext(name, true, true, true, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as adding
   * a variable to the root namespace for variables.
   *
   * i.e. adf.mf.api.addVariable("name", some_object);
   *
   * addVariable/removeVariable are used to add and then remove
   * temporary variables, like loop iterator variables along with
   * longer lasting variables.
   */
  /* void */
  adf.mf.el.addVariable = function(/* variable name */ name, /* new value */ value)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addVariable", name);
    adf.mf.internal.context.setVariable(name, value);
  };
  adf.mf.api.addVariable = adf.mf.el.addVariable;


  /**
   * PUBLIC FUNCTION will evaluate the passed in expression against
   * the local cache ONLY.  If there are terms that are currently
   * not cached or any function calls then undefined will be returned.
   * If the adf.mf.api.startGetValueBatchRequest has been called any
   * EL expression cache misses will be queued to fetched on the
   * adf.mf.api.flushGetValueBatchRequest call.
   *
   * @see adf.mf.api.addVariable
   * @see adf.mf.api.removeVariable
   *
   * @see adf.mf.api.getValue
   * @see adf.mf.api.setValue
   * @see adf.mf.api.setLocalValue
   *
   * @see adf.mf.api.startGetValueBatchRequest
   * @see adf.mf.api.flushGetValueBatchRequest
   */
  adf.mf.el.getLocalValue = function(/* expression */ expression)
  {
    var val = undefined;

    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);

    var addToBatch = false;
    var context = adf.mf.internal.context;

    try
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "getLocalValue", expression.getExpression());
      adf.mf.internal.el.indexedExpressionUnresolved = false;
      val = expression.evaluate(context);

      // Check if the and indexed expression was unable to get its value. If so
      // no error is thrown, so add the term to the batch
      if (adf.mf.internal.el.indexedExpressionUnresolved)
      {
        addToBatch = true;
      }

      // If the return value of a local value is an object that has yet to be loaded from the embedded side, force
      // it to undefined and treat it as a cache miss to go and fetch the value
      if (val instanceof Object && val[".loaded"] === false)
      {
        addToBatch = true;
        val = undefined;
      }
    }
    catch(e1)
    {
      addToBatch = true;
    }
    finally
    {
      delete adf.mf.internal.el.indexedExpressionUnresolved;
    }

    if (addToBatch)
    {
      // expression was not found
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getLocalValue",
          ("unable to resolve '" + expression.getExpression() + "' locally."));
      }

      // NOTE: only if the internal batch is defined will we batch the
      // expression to fetch when adf.mf.api.flushGetValueBatchRequest.
      if (adf.mf.internal.el.getValueBatch !== undefined)
      {
        var batch = adf.mf.internal.el.getValueBatch;

        try
        {
          var exp   = expression.stripLocalValues(true, undefined, true);
          var terms = exp.getELTerms();

          for (var t = 0; t < terms.length; ++t)
          {
            var term = terms[t];

            addToBatch = false;

            try
            {
              // Detect when properties were not found in indexed expressions
              // (no exceptions thrown for those)
              adf.mf.internal.el.indexedExpressionUnresolved = false;

              var result = term.evaluate(context);

              if (adf.mf.internal.el.indexedExpressionUnresolved ||
                (result instanceof Object && result[".loaded"] === false))
              {
                addToBatch = true
              }
            }
            catch(e3)
            {
              addToBatch = true;
            }
            finally
            {
              delete adf.mf.internal.el.indexedExpressionUnresolved;
            }

            if (addToBatch)
            {
              batch.push(term.getExpression());

              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.api", "getLocalValue",
                    "we currently do not have term: " + term + " cached, adding to the batch.");
              }
            }
          }
        }
        catch(e2)
        {
          // the only way you would get here is if the EL Expression can not be parsed

          // Look to see if there is any registered error handlers and call them.
          adf.mf.internal.api.notifyErrorHandlers(expression.getExpression (), e2);


          // Since the bulk of the callers do not handle exceptions well we are going
          // to simply return the exception as the value.  This is similar to what we
          // do in getValues so there is no difference here.  The UI should look at
          // the value and handle it correctly.
          val = e2;
        }
      }
    }

    return val;
  };

  adf.mf.api.getLocalValue = adf.mf.el.getLocalValue;

  /**
   * startGetValueBatchRequest is responsible for starting a new get value
   * batch so theproper "behind the scene" call to get the values can be
   * called at the flushGetValueBatchRequest call.
   *
   * @see adf.mf.api.startGetValueBatchRequest
   */
  /* void */
  adf.mf.el.startGetValueBatchRequest = function()
  {
    if (adf.mf.internal.el.getValueBatch !== undefined)
    {
      throw new adf.mf.ELException("GetValueBatchRequest already started");
    }
    else
    {
      adf.mf.internal.el.getValueBatch = [];
    }
  };
  adf.mf.api.startGetValueBatchRequest = adf.mf.el.startGetValueBatchRequest;

  /**
   * @returns the list of all terms used in any of the ELs
   */
  /* String[] */
  adf.mf.internal.el.getListOfTerms = function(/* array */ els)
  {
    var variables = els || [];
    var terms     = [];
    var length    = 0;

    variables = adf.mf.internal.util.is_array(variables)? variables : [variables];
    length    = variables.length;

    for (var i = 0; i < length; ++i)
    {
      var ele   = adf.mf.internal.el.parser.parse(variables[i]);

      if ((ele !== undefined) || (ele !== null))
      {
        terms  = terms.concat(ele.dependencies());
      }
    }
    return terms;
  };


  /**
   * flushGetValueBatchRequest is responsible for closing off the current
   * batch and make the proper "behind the scene" call to get the values.
   *
   * @see adf.mf.api.startGetValueBatchRequest
   */
  /* void */
  adf.mf.el.flushGetValueBatchRequest = function()
  {
    if (adf.mf.internal.el.getValueBatch !== undefined)
    {
      if (adf.mf.internal.el.getValueBatch.length > 0)
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Close current batch request", adf.mf.log.level.FINER,
          "adf.mf.api.flushGetValueBatchRequest");

        adf.mf.api.getValue(adf.mf.util.removeDuplicates(adf.mf.internal.el.getValueBatch),
          function(a,b)
          {
            try
            {
              var terms = adf.mf.internal.el.getListOfTerms(a.params[0]);

              adf.mf.internal.api.notifyDataChangeListeners(terms);
              perf.stop();
            }
            catch(e)
            {
              perf.stop();
            }
          },
          function(a, b)
          {
            perf.stop();
          });
      }

      adf.mf.internal.el.getValueBatch = undefined;
    }
    else
    {
      throw new adf.mf.IllegalStateException("No get value batch started.");
    }
  };
  adf.mf.api.flushGetValueBatchRequest = adf.mf.el.flushGetValueBatchRequest;



  /**
   * PUBLIC FUNCTION used to evaluate the expression(s) passed in and return the associated
   * value(s) via the success callback.  Since not all variables may not be resolved only the
   * resolved expressions will be returned in the 'response' property of the success callback.
   *
   * Given that you can use this method to get the value for:
   *
   * Evaluation of a single EL expression:
   * e.g. adf.mf.api.getValue("#{100+2*20/3}", success, failed);
   * e.g. adf.mf.api.getValue("#{bindings.userName.inputValue}", success, failed);
   *
   * Evaluation of an array of EL expressions:
   * e.g. adf.mf.api.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
   * e.g. adf.mf.api.getValue(["#{bindings.foo}", "#{applicationScope.username}"], success, failed);
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.getValue("#{100+2*20/3}", success, failed);
   *        success(["#{100+2*20/3}"], [ {name:"#{100+2*20/3}", value:"113.33"} ] )
   *
   *   e.g. adf.mf.api.getValue("#{bindings.userName.inputValue}", success, failed);
   *        success(["#{bindings.userName.inputValue}"], [ {name:"#{bindings.userName.inputValue}", value:"me"} ] )
   *
   *   e.g. adf.mf.api.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
   *        success(["#{100+2*20/3}", "#{500/2}"],
   *                [ {name:"#{100+2*20/3}", value:"113.33"}, {name:"#{500/2}", value:"250"} ] )
   *
   * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
   * e.g. adf.mf.api.getValue( ["#{bindings.foo}", "#{bindings.bar}"], success, failed);
   *        success(["#{bindings.foo}", "#{bindings.bar}"],
   *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
   *          *** notice: binding.bar was not part of the result array
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   *
   * There also exists another way to invoke the getValue used to resolve a property from an already
   * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
   * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
   * the "right thing to do" based on the 'base' and 'property' variables:
   *
   * e.g. adf.mf.api.getValue(base, property);
   *   where the value returned is value of the property or nil if it does not exists.
   **/
  adf.mf.el.getValue = function()
  {
    var argv  = arguments;
    var argc  = arguments.length;

    if (argc!=4 && argc!=3 && argc!=2)
    {
      throw new adf.mf.ELException("Wrong number of arguments");
    }

    try
    {
      if (typeof(argv[1])!='object' && (argv[1] instanceof Function))
      {
        /*
         * Note: in order to make [gs]etValue individual errors show up in the error view
         *       we will inject a nvpSimulatedErrors callback into the success callback vector.
         *       We only need to include it in the success because the failed will automatically
         *       be routed to the error handlers (see JavaScriptContext.nonBlockingCall)
         */
        var expression     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
        var success        = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
        var failed         = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];
        var errorHandler   = ((argc == 4) && (argv[3] == true))?
            adf.mf.internal.api.nvpEatErrors :
              adf.mf.internal.api.nvpSimulatedErrors;
        var perf           = adf.mf.internal.perf.startMonitorCall("Evaluate EL expression", adf.mf.log.level.FINER,
          "adf.mf.api.getValue");
        var scb            = [errorHandler,
                              function() { perf.stop(); }];
        var fcb            = [function() { perf.stop(); }];

        expression = arrayToEL (expression);
        try
        {
          var count = expression.length;
          var nvpa  = [];

          for (var i = 0; i < count; i++)
          {
            var temp = undefined;

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.el","getValue", "evaluating locally" + expression[i].getExpression());
            }

            if ((temp = expression[i].evaluate(adf.mf.internal.context)) === undefined)
            {
              throw new adf.mf.PropertyNotFoundException(expression[i].getExpression());
            }
            else
            {
              nvpa.push({"name":expression[i].getExpression(), "expression":expression[i], "value":temp});
            }
          }

          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
                ("adfmf- did not call the server for " + expression.join(", ")));
          }

          // Found everything locally
          perf.stop();
          for (var i = 0; i < success.length; ++i)
          {
            try
            {
              success[i](expression, nvpa);
            }
            catch(fe)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.api.getValue", "ERROR_GETVALUE_SUCCESS_CB_ERROR", i);

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue", fe);
            }
          }
        }
        catch (e)
        {
          var terms = getTerms (expression);

          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
                ("adfmf- needs to call the server for " + terms.join(", ")));
          }
          /* inject the addtional callbacks for: caching and peformance */
          scb     = scb.concat(adf.mf.internal.el.cacheResult, success);
          fcb     = fcb.concat(failed);
          adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getValue", terms, scb, fcb);
        }
      }
      else
      {
        var base = argv[0];
        var property = argv[1];
        value = adf.mf.internal.context.getELResolver().getValue(adf.mf.internal.context, base,
          property);
      }
    }
    catch(ge)
    {
      var expression = (adf.mf.internal.util.is_array(argv[0])) ? argv[0] : [argv[0]];
      var failed = (adf.mf.internal.util.is_array(argv[2])) ? argv[2] : [argv[2]];

      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.getValue", "ERROR_EXCEPTION_RESOLVING");

      // For security, only log the EL expression and exception at a FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
          "Error evaluting EL expression: " + expression.join(", ") + " exception: " + ge);
      }

      perf.stop();
      for (var i = 0; i < failed.length; ++i)
      {
        try
        {
          failed[i](expression, ge);
        }
        catch(fe)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.api.getValue", "ERROR_GETVALUE_FAILED_CB_ERROR", i);

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue", fe);
        }
      }
    }
  };
  adf.mf.api.getValue = adf.mf.el.getValue;

  /**
   * Returns array of terms for given array of expressions.
   *
   * @param {Array} expressions
   * @returns {Array}
   */
  function getTerms(expressions)
  {
    var map = {};
    for (var i = 0; i < expressions.length; i++)
    {
      var exp = expressions[i];
      var terms = exp.getELTerms();

      for (var j = 0; j < terms.length; j++)
      {
        var term = adf.mf.internal.context.uncompressReference(terms[j]);

        //  If the term is the same as the original expression then we don't want
        //  add it to the result collection a second time.
        if (term.getExpression() != exp.getExpression())
        {
          map[term.getExpression()] = true;
        }
      }
    }
    var result = [];
    for (var i = 0; i < expressions.length; i++)
    {
      result.push(expressions[i].getExpression());
    }
    for (var t in map)
    {
      result.push (t);
    }

    return result;
  }

  /**
   * Converts array of strings to array of ELExpressions.
   *
   * @param {type} expressions
   * @returns {Array}
   */
  function arrayToEL(expressions)
  {
    if (expressions[0].tokens)
      return expressions;
    var elExpressions = [];
    for (var i = 0; i < expressions.length; i++)
    {
      elExpressions.push (adf.mf.internal.el.parser.parse (expressions[i]));
    }
    return elExpressions;
  }

  /**
   * PUBLIC FUNCTION used to used to invoke a method expression in the java environment.
   *
   * expression: is the method expression itself
   *             i.e. #{bean.method}  #{applicationScope.bean.method}
   * params    : is an array of zero or more values that should be passed as the method parameters
   *             i.e. []                      - to invoke bean.method()
   *             or ["Hello"]                 - to invoke bean.method(String)
   *             or [[false, false], "Hello"] - to invoke bean.method(boolean[], String)
   * returnType: is the return type
   *             i.e. void                    -
   *             i.e. String                  - return type is a string
   * types     : i.e. []                      - no parameters
   *             i.e. [java.lang.String]      - one parameter of type String
   *             i.e. [java.lang.String, int] - parameter-1 of type String, parameter-2 of type int
   *
   * Given this information the correct method will be looked up and invoked from the given method.
   *
   * Evaluation of a single EL expression:
   * e.g. invoke("#{Bean.foobar}", [parameters], [parameter-types], success, failed);
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.invoke("#{Bean.foobar}", [], "java.lang.String", [], success, failed);
   *        success({method:"#{Bean.foobar}" arguments:[]}, {result:....} )
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   **/
  adf.mf.el.invoke = function(expression, params, returnType, types, success, failed)
  {
    if (expression && expression.getExpression)
      expression = expression.getExpression ();
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "evaluateMethodExpression",
        expression, params, returnType, types, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to update a value for a given variable expression.
   * Since variable expressions are the only type of expressions that can be LHS
   * (left-hand-side) expressions we can rule out all literal, complex, and method
   * expressions from the possible input.
   *
   * A simple name-value-pair object is used to denote the variable expression (name)
   * with it's desired value (value).  An example of this would be:
   *       { "name":"#{applicationScope.foo}", value:"foobar" }
   *
   * Similar to the getValue function, the setValue can take a single name-value-pair
   * or an array of them for doing batch sets.  The following examples will highlight
   * these cases:
   *
   * Passing only a single name-value-pair
   * e.g. adf.mf.api.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
   *      resulting in the bindings.foo variable being assigned foo
   *
   * Passing an array of name-value-pairs
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *      resulting in the bindings.foo variable being assigned foo and
   *                       bindings.bar variable being assigned bar
   *
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
   *        success(["{ "name": "#{bindings.foo}", "value": "foo" }"], [ { "name": "#{bindings.foo}", "value": "foo" } ] )
   *
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *        success([{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }],
   *                [{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }] )
   *
   * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *        success([{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }],
   *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
   *          *** notice: binding.bar was not part of the result array
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   *
   * There also exists another way to invoke the setValue used to set a property from an already
   * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
   * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
   * the "right thing to do" based on the 'base' and 'property' variables:
   *
   * e.g. adf.mf.api.setValue(base, property, value);
   *   where the base.property is assigned the value of 'value'
   *
   **/
  adf.mf.el.setValue = function()
  {
    var argv  = arguments;
    var argc  = arguments.length;

    if (argc != 3)
    {
      throw new adf.mf.ELException("Wrong number of arguments");
    }

    try
    {
      /*
       * Note: in order to make [gs]etValue individual errors show up in the error view
       *       we will inject a nvpSimulatedErrors callback into the success callback vector.
       *       We only need to include it in the success because the failed will automatically
       *       be routed to the error handlers (see JavaScriptContext.nonBlockingCall)
       */
      var nvp     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
      var success = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
      var failed  = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];
      var scb     = [];
      var fcb     = [];
      var perf    = adf.mf.internal.perf.startMonitorCall("Set EL value", adf.mf.log.level.FINER, "adf.mf.api.setValue");

      if (success[0] instanceof Function)
      {
        if (adf.mf.internal.isJavaAvailable())
        {  /* since java is available we need to also do the remote write */
          var nvp1 = [];
          for (var i = 0; i < nvp.length; ++i)
          {
            if (!nvp[i].expression)
              nvp[i].expression = adf.mf.internal.el.parser.parse(nvp[i].name);
            var uncompressedEL = adf.mf.internal.context.uncompressReference(nvp[i].expression);
            nvp[i].expression = uncompressedEL;
            var uncompressedELString = uncompressedEL.getExpression ();
            var v = {name: uncompressedELString, value: nvp[i].value};
            if (nvp[i][adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]])
            {
              v[adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]] = true;
            }
            nvp1.push (v);
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
            "We now have the uncompressed terms.");

          var rscb = [];

          rscb = rscb.concat([adf.mf.internal.api.nvpSimulatedErrors]);
          rscb = rscb.concat([function() { perf.stop(); }]);
          rscb = rscb.concat(success);

          scb = scb.concat(function()
          {
            adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setValue", nvp1, rscb, failed);
          });
          fcb = scb.concat(failed);
        }
        else
        {
          // since java is _NOT_ available store the value locally and notify the data change
          // listeners (ndcl)
          for (var i = 0; i < nvp.length; ++i)
          {
            if (!nvp[i].expression)
              nvp[i].expression = adf.mf.internal.el.parser.parse(nvp[i].name);
            var uncompressedEL = adf.mf.internal.context.uncompressReference(nvp[i].expression);
            nvp[i].expression = uncompressedEL;
            nvp[i].name = uncompressedEL.getExpression();
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
            "We now have the uncompressed terms.");

          var  ndcl = undefined;

          ndcl = [
            function()
            {
              for (var v = 0; v < nvp.length; ++v)
              {
                var terms = nvp[v].expression.dependencies();
                adf.mf.internal.api.notifyDataChangeListeners(terms);
              }
            }];

          scb = ndcl.concat(function() { perf.stop(); });
          scb = scb.concat(success);

          fcb = ndcl.concat(function() { perf.stop(); });
          fcb = fcb.concat(failed);
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "adf.mf.api.setValue", "WARN_SKIP_REMOTE_WRITE");
        }

        adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
          "now calling setLocalValue");

        adf.mf.api.setLocalValue(nvp, scb, fcb);
      }
      else
      {
        var base     = argv[0];
        var property = argv[1];
        var value    = argv[2];

        adf.mf.internal.context.getELResolver().setValue(adf.mf.internal.context, base, property,
          value);
        perf.stop();
      }
    }
    catch(ge)
    {
      perf.stop();
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setValue", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setValue", fe);
    }
    finally
    {
      // nothing more that needs to be done here.
    }
  };
  adf.mf.api.setValue = adf.mf.el.setValue;

  /**
   * PUBLIC FUNCTION used to set the value only on the javascript side.
   *
   * @see adf.mf.api.setValue
   */
  adf.mf.el.setLocalValue = function()
  {
    // no-value

    try
    {
      if (arguments.length != 3)
      {
        var errMsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
          "ERROR_INCORRECT_NUM_ARGS_PASSED");
        throw new adf.mf.ELException(errMsg);
      }

      var argv    = arguments;
      var nvp     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
      var success = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
      var failed  = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];

      if (success[0] instanceof Function)
      {
        try
        {
          var count = nvp.length;
          for (var i = 0; i < count; i++)
          {
            var nvpi = nvp[i];
            var n = nvpi.name;
            if (!nvpi.expression)
              nvpi.expression = adf.mf.internal.el.parser.parse(nvpi.name);
            var v = nvpi.value;

            if (nvpi != null &&
              nvpi[adf.mf.internal.api.constants.VALUE_REF_PROPERTY] !== undefined)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                  ("adfmf- not caching '" + n + "' because it is value reference."));
              }
            }
            else
              if (nvpi != null &&
                nvpi[adf.mf.internal.api.constants.TRANSIENT_FLAG_PROPERTY] !== undefined)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                    ("adfmf- not caching '" + n + "' because it is transient."));
                }
              }
              else
              {
                nvpi.expression.setValue(adf.mf.internal.context, v);

                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                    ("adfmf- setting local value : " + n));
                }
              }
          }
        }
        catch(e1)
        {
          try
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_FAILED");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", e1);

            for (var i = 0; i < failed.length; ++i)
            {
              failed[i](nvp, e1);
            }

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                ("set local value failed callback has been executed."));
            }
          }
          catch(e2)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_FAILED_CB");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", fe);
          }
          return;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
            "set local value is now complete and now calling the success callback(s)");
        }

        for (var i = 0; i < success.length; ++i)
        {
          try
          {
            success[i](nvp, nvp);
          }
          catch(fe)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_SUCCESS_CB_FAILED", i);

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", fe);
          }
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
            "set local value is now complete and " + success.length +
            " success callback has been executed.");
        }
      }
      else
      {
        var base     = argv[0];
        var property = argv[1];
        var value    = argv[2];

        adf.mf.internal.context.getELResolver().setValue(adf.mf.internal.context, base, property,
          value);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "adf.mf.api", "setLocalValue",
            "context.getELResolver().setValue" + base + "." + property);
        }
      }
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setLocalValue", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", ge);
    }
    finally
    {
      // no-value
    }
  };
  adf.mf.api.setLocalValue = adf.mf.el.setLocalValue;


  /**
   * PUBLIC FUNCTION used to remove a top-level variable
   * from the context.  This should be thought of as removing
   * a variable from the root namespace for variables.
   *
   * i.e. adf.mf.api.removeVariable("name");
   */
  /* void */
  adf.mf.el.removeVariable = function(/* variable name */ name)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "removeVariable", name);
    adf.mf.internal.context.removeVariable(name);
    // no-value
  };
  adf.mf.api.removeVariable = adf.mf.el.removeVariable;

  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as adding
   * a variable to the root namespace for variables.
   *
   * i.e. adf.mf.api.setVariable("name", some_object);
   *
   * Most of the time the 'some_object' will be a property
   * map.  So we can do things like:
   *   adf.mf.api.getValue("${name.property}");
   */
  /* void */
  adf.mf.el.setVariable = function(/* variable name */ name, /* new value */ value)
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Add a top-level variable", adf.mf.log.level.FINEST,
      "adf.mf.api.setVariable");
    try
    {
      adf.mf.internal.context.setVariable(name, value);
      adf.mf.internal.api.notifyDataChangeListeners(name);
    }
    finally
    {
      perf.stop();
    }
  };
  adf.mf.api.setVariable = adf.mf.el.setVariable;

  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as pushing
   * a variable onto the root namespace for variables.
   *
   * i.e. adf.mf.api.pushVariable("name", some_object);
   *
   * Most of the time the 'some_object' will be a property
   * map.  So we can do things like:
   *   adf.mf.api.getValue("${name.property}");
   *
   * NOTE: This call will _NOT_ generate a data change event.
   */
  /* void */
  adf.mf.el.pushVariable = function(/* variable name */ name, /* new value */ value)
  {
    adf.mf.internal.context.pushVariable(name, value);
  };
  adf.mf.api.pushVariable = adf.mf.el.pushVariable;

  /**
   * PUBLIC FUNCTION used to pop a top-level variable
   * from the context.  This should be thought of as poping
   * a variable off the root namespace for variables.
   *
   * i.e. adf.mf.api.popVariable("name");
   *
   * NOTE: This call will _NOT_ generate a data change event.
   */
  /* void */
  adf.mf.el.popVariable = function(/* variable name */ name)
  {
    adf.mf.internal.context.popVariable(name);
  };
  adf.mf.api.popVariable = adf.mf.el.popVariable;

  /**
   * PUBLIC FUNCTION used to process the data change event associated with response messages.
   *
   * DataChangeEvents can be sent as their own request message or as part of _any_ response
   * message.  This event is sent to inform the javascript side that some data was side-effected
   * in the CVM layer and should be propagated into the javascript cache as well as notify the
   * user interface of the change.  This event has the following JSON represention:
   *
   * DataChangeEvent
   * {
   *    variableChanges: {
   *         elExpression:value
   *         ...
   *    }
   *    providerChanges: {
   *      providerId: {
   *         <operation>:{
   *            current_row_key: { properties filtered by node }
   *            ...
   *         }
   *             ...
   *      }
   *      ...
   *    }
   * }
   *
   * Given that, we need to do the following for each data change event:
   * Variable Changes:
   *    set the value in the local cache
   *    notify anyone interested in that variable, that it has changed.
   *
   * Provider Changes:
   *    on Create:
   *      set the value in the local cache
   *    on Update:
   *      set the value in the local cache
   *      notify anyone interested in that variable, that it has changed.
   *    on Create:
   *      remove the value from the local cache
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.processDataChangeEvent = function(/* DataChangeEvent */ dce)
  {
    var dcevs  = [];  /* data change event variables  */
    var pdces  = {};  /* provider data change details */

    var perfOp = adf.mf.internal.perf.startMonitorOperation("Process data change event", adf.mf.log.level.FINER,
      "adf.mf.api.processDataChangeEvent");

    try
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent",
            ("processing a data change event with " + adf.mf.util.stringify(dce)));
      }

      try
      {
        var hasMoreKeysVariableChanges = {};
        var va;
        // Due to the way the API was created, the embedded side will always fire hasMoreKeys
        // data change events even when the value does not change (the API has no concept of the
        // current value, so has nothing to compare against). The problem with this is that
        // data change events may be expensive to process (like an AMX node tree visit). It
        // should be faster to check these values and ensure that these are broadcast as
        // changes when the value is actually changed.
        for (va in dce.variableChanges)
        {
          if (adf.mf.util.stringEndsWith(va, ".collectionModel.treeNodeBindings.hasMoreKeys"))
          {
            hasMoreKeysVariableChanges[va] = (true == adf.mf.el.getLocalValue("#{" + va + "}"));
          }
        }

        adf.mf.internal.api.updateGenericCacheElement(dce.variableChanges, false); // only update the cache

        /* add to the batch data change events */
        for (va in dce.variableChanges)
        {
          dcevs.push(va);

          if ((weakref = adf.mf.internal.context.getWeakReference(va)) !== undefined)
          {
            dcevs.push(weakref);
          }

          // Look to see if the variable is of type TreeBindings and if so, add it to the provider
          // change list
          var variableChange = dce.variableChanges[va];

          // Check to see if the variable change is for the hasMoreKeys property of a collection
          // model's tree node bindings property. If so, treat it as an itemized provider change
          var hasMoreKeysOldValue = hasMoreKeysVariableChanges[va];
          if (hasMoreKeysOldValue != null)
          {
            // EL including the ".collectionModel":
            var collectionModelEl = va.substring(0, va.length - 29);

            // If another property has not changed on the tree bindings, then we can handle a
            // hasMoreKeys change in an optimized fashion.
            if (pdces[collectionModelEl] == null)
            {
              var hasMoreKeysNewValue = (true == adf.mf.el.getLocalValue("#{" + va + "}"));

              if (hasMoreKeysOldValue != hasMoreKeysNewValue)
              {
              // Notify the listeners that the hasMoreKeys property has changed
              pdces[collectionModelEl] = { itemized:true, hasMoreKeysChanged:true };
              dcevs.push(collectionModelEl); // for individual dce notifications
            }
          }
          }
          else if (adf.mf.util.isType(variableChange, "TreeBindings"))
          {
            pdces[va] = { itemized:false };
            dcevs.push(va); // for individual dce notifications
          }
          else if (adf.mf.util.stringEndsWith(va, ".collectionModel.treeNodeBindings.keys"))
          {
            // If the keys array has changed and there are no itemized set of changes in the
            // provider changes, then the entire collection model has changed and a
            // non-itemized change set should be recorded.
            var providerEl = va.substring(0, va.length - 38);
            if (dce.providerChanges[providerEl] == null)
            {
              pdces[collectionModelEl] = { itemized:false };
              dcevs.push(collectionModelEl); // for individual dce notifications
            }
          }
        }
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
          "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_VAR_CHANGES");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent", e);
      }

      var perf = adf.mf.internal.perf.startMonitorCall("Process provider changes",
        adf.mf.log.level.FINER, "adf.mf.api.processDataChangeEvent:providerChanges");
      try
      {
        if (dce.providerChanges !== undefined)
        {
          for (var p in dce.providerChanges)
          {
            // each property key is the name of the provider that has a change
            var pdce = dce.providerChanges[p];

            adf.mf.internal.api.updateGenericCacheElement(pdce.columnAttributes, true);

            if (pdce.providers)
            {
              // these are changes to the column attributes
              var cmpn   = p + ".collectionModel";
              var cmn    = "#{" + cmpn + "}";
              var cm     = adf.mf.api.getLocalValue(cmn);
              var create = pdce.providers.create || {};
              var update = pdce.providers.update || {};
              var dirty  = pdce.providers.dirty  || {};
              var remove = pdce.providers.remove || {};

              if (cm === undefined)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                    "processDataChangeEvent",
                    ("Warning: received a data change event before " + cmn +
                      " has been cached.  Ignoring the change."));
                }
                break;
              }

              // See if the record was already added by a variable change
              var pd = pdces[cmpn];

              if (pd == null)
              {
                pd = { itemized:true };
                pdces[cmpn] = pd;
                dcevs.push(cmpn); // for individual dce notifications
              }

              pd.created = []; // Objects with "key" property
              pd.updated = []; // Key strings
              pd.deleted = []; // Key strings
              pd.dirtied = []; // Key strings

              // Ensure there is a providers object to access
              var tnb = cm.treeNodeBindings;
              tnb.providers = tnb.providers || {};

              for (var k in create)
              {
                try
                {
                  // Make sure we got the keys so we can actually see this new provider :-)
                  pd.created.push({key:k});
                  tnb.providers[k] = create[k];
                }
                catch(e)
                {
                  adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                    "adf.mf.api.processDataChangeEvent",
                    "WARN_PROCESSING_CREATE_DATA_CHANGE");

                  // For security, only log the EL and exception at a FINE level
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                  {
                    adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                      "processDataChangeEvent", "Error with create data change event. EL: " + p +
                      " Error: " + e);
                  }
                }
              }

              for (var k in update)
              {
                try
                {
                  // Please note, this will add the provider if it is currently not in the cache
                  pd.updated.push(k);
                  tnb.providers[k] = update[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent",
                      "WARN_PROCESSING_UPDATED_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with update data change event. EL: " + p +
                         " Error: " + e);
                    }
                  }
                }
              }

              for (var k in dirty)
              {
                try
                {
                  // Actually removed the provider, if it is still there
                  pd.dirtied.push(k);
                  delete tnb.providers[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_REMOVE_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with dirty data change event. EL: " + p +
                        " Error: " + e);
                    }
                  }
                }
              }

              for (var k in remove)
              {
                try
                {
                  // Actually removed the provider, if it is still there
                  pd.deleted.push(k);
                  delete tnb.providers[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_REMOVE_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with remove data change event. EL: " + p +
                        " Error: " + e);
                    }
                  }
                }
              }
            }
          }
        }
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_PROVIDER_CHANGES");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api", "processDataChangeEvent", e);
        }
      }
      finally
      {
        perf.stop();
      }

      /* notify all the data change listeners (registered either individually or batch wise) */
      adf.mf.internal.api.notifyDataChangeListeners(dcevs, pdces);
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.processDataChangeEvent", "ERROR_PROCESSING_DATA_CHANGE_EVENT");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent", ge);
    }
    finally
    {
      perfOp.stop();
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent",
        "process data change event done");
    }
  };

  /* String */
  adf.mf.internal.api.getWeakReference = function(/* String */ fqn)
  {
    return adf.mf.internal.context.getWeakReference(fqn);
  };

  /* String */
  adf.mf.internal.api.addCompressedReference = function(/* String */ reference)
  {
    return adf.mf.internal.context.addCompressedReference(reference);
  };

  /**
   * INTERNAL FUNCTION used to determine if Java is available or not.
   */
  adf.mf.internal.isJavaAvailable = function()
  {
    return window !== undefined &&
      window.container !== undefined &&
      window.container.internal !== undefined &&
      window.container.internal.device !== undefined &&
      window.container.internal.device.integration !== undefined &&
      window.container.internal.device.integration.vmchannel !== undefined;
  };


  /**
   * INTERNAL FUNCTION used to determine if we are or not in design time mode.
   */
  adf.mf.internal.isDesignTime = function()
  {
    return false;  /* TBD: add the ajax call to determine if this should be true or false */
  };


  /**
   * INTERNAL FUNCTION used to caches value for an expression
   */
  adf.mf.internal.el.cacheResult = function (request, response)
  {
    if (adf.mf.internal.util.is_array(response))
    {
      // we have an array of name value pairs
      for (var i = 0; i < response.length; ++i)
      {
        var nvp = response[i];

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "cacheResult",
              ("adfmf- caching " + response.length + " values."));
        }

        /* we need to make sure we only try to cache individual terms */
                // old way: if (! adf.mf.internal.el.parser.parse(nvp.name).isComplexExpression())
        if (adf.mf.internal.util.isAssignable(nvp.name))
        {
          if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.el", "cacheResult",
                "Caching [" + nvp.name + "] as an exception - " + adf.mf.util.stringify(nvp));
            }
          }
          adf.mf.api.setLocalValue(nvp, function() {}, function() {});
        }
        else
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "cacheResult",
                ("not caching complex expression [" + nvp.name + "]."));
          }
        }
      }
    }
  };


  /**
   * INTERNAL FUNCTION used by the processDataChangeEvent handler to update generic
   * properties in the cache.
   *
   * @param values
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.internal.api.updateGenericCacheElement = function(/* arguments */)
  {
    var values = (arguments.length > 0)? arguments[0] : null;
    var notify = (arguments.length > 1)? arguments[1] : true;

    /* update the cache's modification id */
    adf.mf.internal.context.updateModId();
    if (values !== undefined)
    {   /* each variable change property is an scalar property that was changed */
      var nvp    = [];

      for (var va in values)
      {
        var vk = '#{' + va + '}';
        var pvk = adf.mf.internal.el.parser.parse(vk);
        nvp.push({'name':vk, 'expression':pvk, 'value':values[va]});
      }

      if (nvp.length > 0)
      {
        try
        {
          adf.mf.api.setLocalValue(nvp,
            function(a, b)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
                  "updateGenericCacheElement",
                  ("updated the java script cache variables " + adf.mf.util.stringify(b)));
              }
            },
            function(a, b)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.SEVERE))
              {
                adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                  "adf.mf.internal.api.updateGenericCacheElement",
                  "ERROR_UNABLE_TO_SET_DATA_CHANGE_VALS");

                // For security, only log the EL at a FINE level
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api",
                    "updateGenericCacheElement", "Return value: " + df.mf.util.stringify(b));
                }
              }
            });

          if (notify) adf.mf.internal.api.notifyDataChangeListeners(values, null);
        }
        catch(e)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
          {
            adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
              "adf.mf.internal.api.updateGenericCacheElement", "WARN_UPDATING_CACHE");
          }
        }
      }
    };
  };


  /**
   * INTERNAL FUNCTION used to notify all the registered batch listeners
   * that the given variables have changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyBatchDataChangeListeners = function(variables, details)
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Notify registered batch data change listeners", adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyBatchDataChangeListeners");

    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      try
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER,
            "adf.mf.internal.api",
            "notifyBatchDataChangeListeners",
            "notify listener " + i + "th bulk data change callback");
        }
        adf.mf.internal.batchDataChangeListeners[i](variables, details);
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.api.notifyBatchDataChangeListeners",
          "ERROR_IN_BULK_NOTIFICATION_CALLBACK");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api", "notifyBatchDataChangeListeners", e);
      }
    }

    perf.stop();
  };


  /**
   * INTERNAL FUNCTION used to notify all the registered listeners
   * that the given variable has changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyIndividualDataChangeListeners = function(variable)
  {
    /* ensure values is an array */
    var values = (adf.mf.internal.util.is_array(variable))? variable : [ variable ];

    var perf = adf.mf.internal.perf.startMonitorCall("Notify individual data change listeners",
      adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyIndividualDataChangeListeners");

    for (var i = 0; i < values.length; ++i)
    {
      var  v  = values[i];
      var  la = (v.slice(0, "bindings".length) == "bindings")?
      currentBindingInstance.dataChangeListeners[v] : dataChangeListeners[v];

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api",
          "notifyIndividualDataChangeListeners",
          ("**NDCL** Variable " + i + ": " + v + " has changed (" +
            adf.mf.api.getLocalValue(v)  + ") "));
      }
      if (la !== undefined)
      {
        for (var j = 0; j < la["callback"].length; ++j)
        {
          var k = 0;  /* declared out here so we can use it in the exception log message */

          try
          {
            for (k = 0; k < la["id"].length; ++k)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
                  "notifyDataChangeListeners",
                  ("notify listener " + j + "th callback in " + adf.mf.util.stringify(la) +
                    " listeners"));
              }
              la["callback"][j](la["id"][k]);
            }
          }
          catch(e)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.notifyIndividualDataChangeListeners",
              "ERROR_IN_INDIVIDUAL_NOTIFICATION_CALLBACK");

            // For security, only log the details at a FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.internal.api",
                "notifyIndividualDataChangeListeners",
                "Error in notifying callback with data: " + la["id"][k] +
                " Error: " + e);
            }
          }
        }
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER,
            "adf.mf.internal.api",
            "notifyIndividualDataChangeListeners",
            ("no listener set is defined for " + values[i]));
        }
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to notify all the registered listeners
   * that the given variable has changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyDataChangeListeners = function(vars, pdces)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.api", "notifyDataChangeListeners",
        "with variables " + adf.mf.util.stringify(vars));
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.api", "notifyDataChangeListeners",
        "with provider details" + adf.mf.util.stringify(pdces));
    }

    /* notify the individual listeners */
    adf.mf.internal.api.notifyIndividualDataChangeListeners(vars);

    /* notify the batched listeners */
    adf.mf.internal.api.notifyBatchDataChangeListeners(vars, pdces);
  };

  /**
   * PRIVATE FUNCTION used to eat standard errors for any name-value exceptions values
   */
  adf.mf.internal.api.nvpEatErrors = function(request, response)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api", "nvpEatErrors", "eat standard errors");
  };


  /**
   * PRIVATE FUNCTION used to simulate standard errors for any batch or array values
   */
  adf.mf.internal.api.arraySimulatedErrors = function(request, response)
  {
    /* ensure response is an array */
    var requests  = (adf.mf.internal.util.is_array(request ))? request  : [request ];
    var responses = (adf.mf.internal.util.is_array(response))? response : [response];
    var length    = responses.length;

    var perf = adf.mf.internal.perf.startMonitorCall(
      "Simulate standard errors for any batch or array values",
      adf.mf.log.level.FINER, "adf.mf.internal.api.arraySimulatedErrors");

    for (var i = 0; i < length; ++i)
    {
      var rv = (adf.mf.internal.util.is_array(responses[i]))? responses[i][0] : responses[i];
      if (adf.mf.util.isType(rv, "NameValuePair"))
      {
        /*
         * if the response type is a NVP or and array of them simply forward
         * that request/response to nvpSimulatedErrors handler to do the work
         */
        adf.mf.internal.api.nvpSimulatedErrors(requests[0], responses[i]);
      }
      else if (adf.mf.util.isException(responses[i]))
      {
        try
        {
          /* notify the error handlers */
          adf.mf.internal.api.notifyErrorHandlers(requests[0], responses[i]);
        }
        catch(e)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.arraySimulatedErrors", "ERROR_IN_ERROR_CALLBACK");
        }
      }
    }
    perf.stop();
  };

  /**
   * PRIVATE FUNCTION used to simulate standard errors for any name-value exceptions values
   */
  adf.mf.internal.api.nvpSimulatedErrors = function(request, response)
  {
    /* ensure response is an array */
    var responses = (adf.mf.internal.util.is_array(response))? response : [response];

    var perf = adf.mf.internal.perf.startMonitorCall(
      "Simulate standard errors for any name-value exceptions values",
      adf.mf.log.level.FINER, "adf.mf.internal.api.nvpSimulatedErrors");

    for (var i = 0; i < responses.length; ++i)
    {
      var nvp = responses[i];

      if (adf.mf.util.isType(nvp, "NameValuePair"))
      {
        if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] !== undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.api", "nvpSimulatedErrors",
              "this is an exception: " + adf.mf.util.stringify(nvp));
          }

          /* lets be sure and make sure the value is true */
          if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] == true)
          {
            try
            {
              /* notify the error handlers */
              adf.mf.internal.api.notifyErrorHandlers(nvp.name, nvp.value);
            }
            catch(e)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.nvpSimulatedErrors", "ERROR_IN_ERROR_CALLBACK");
            }
          }
        }
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
          "nvpSimulatedErrors",
          "response element " + i + " was not of type NameValuePair - " +
          adf.mf.util.stringify(nvp));
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to notify all the registered error handlers
   */
  adf.mf.internal.api.notifyErrorHandlers = function(req, resp)
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Notify all registered error handlers",
      adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyErrorHandlers.callback");

    if ((resp != undefined) && (resp != null) &&
      (resp[adf.mf.internal.api.constants.DEFERRED_PROPERTY] != true))
    {
      for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
      {
        try
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
              "notifyErrorHandlers", "notify error handler " + i + " of the error");
          }
          adf.mf.internal.errorHandlers[i](req, resp);
        }
        catch(e)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.notifyErrorHandlers", "ERROR_CALLING_ERROR_HANDLERS");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api", "notifyErrorHandlers", e);
        }
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to clear all the binding variables
   * currently registered.
   */
  adf.mf.internal.el.resetBindingContext = function()
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Reset binding context",
      adf.mf.log.level.FINER,
      "adf.mf.internal.el.resetBindingContext");

    try
    {
      adf.mf.api.removeVariable('bindings');
      adf.mf.api.addVariable('bindings', {});
      adf.mf.internal.el.clearWeakReferences();
      adf.mf.internal.el.parser.cache.clear();

      // now clean up all the bindings data change listeners
      currentBindingInstance.dataChangeListeners = {};
    }
    catch(e)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.el.resetBindingContext", "ERROR_RESETTING_BINDING_CONTEXT");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.el", "resetBindingContext", e);
    }
    finally
    {
      perf.stop();
    }
  };

  /**
   * INTERNAL FUNCTION used to clear all weak references in the system.
   */
  /* void */
  adf.mf.internal.el.clearWeakReferences = function()
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.el", "clearWeakReferences", name);
    adf.mf.internal.context.clearWeakReferences();
  };


  adf.mf.el.removeCache = function(keys)
  {
    count = keys.length;
    for (var i = 0; i < count; i++)
    {
      elCache.kill(keys[i]);
    }
  };


  adf.mf.internal.el.getBindingInstance = function(/* String */ id)
  {
    var  bi = bindingInstances[id];

    if (bi == null)
    {
      bi = {"bindings": {}, "dataChangeListeners": {}};
      bindingInstances[id] = bi;
    }

    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "purgeCache",
          ("getBindingInstance for '" + id + "' = " + adf.mf.util.stringify(bi)));
    }

    return bi;
  };

  adf.mf.internal.el.switchBindingInstance = function(id)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "switchBindingInstance",
          ("switchBindingInstance to '" + id + "'"));
    }

    currentBindingInstance = adf.mf.internal.el.getBindingInstance(id);

    adf.mf.api.removeVariable('bindings');
    adf.mf.api.addVariable('bindings',   currentBindingInstance.bindings);
    // adf.mf.internal.el.clearWeakReferences();
    adf.mf.internal.el.parser.cache.clear();
  };

  /**
   * PUBLIC FUNCTION used to add a performance monitor observation.  Can be called with or without the description parameter.
   * @param monitorId      - monitor ID
   * @param description    - description for the given monitor (optional)
   * @param duration       - observation duration.  This is the quantity value that is observed.
   * @param successCB      - success callback
   * @param failureCB      - failure callback
   *
   * e.g. adf.mf.api.addMonitorObservation("MyCategory.methodFoo", 123, successCB, failureCB);
   * e.g. adf.mf.api.addMonitorObservation("MyCategory.methodFoo", "Measures time spent in method Foo", 123, successCB, failureCB);
   *
   */
  /* void */
  adf.mf.api.addMonitorObservation = function()
  {
    var args = [].splice.call(arguments,0);   // convert arguments into a real array
    var updatedArgs = ["oracle.adfmf.framework.api.Model", "addMonitorObservation"];
    adf.mf.api.invokeMethod.apply(this, updatedArgs.concat(args));
  };

  /*
   * Initialize the default binding instance for HTML base interactions
   */
  var currentBindingInstance = adf.mf.internal.el.getBindingInstance("default");
})();



/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adfel.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfelBridge.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfelBridge.js ---------------------- */
// @requires Adfel


var adf                    = window.adf                 || {};
adf.el                     = adf.el                     || {};
adf.log                    = adf.log                    || {};

adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.api.adf             = adf.mf.api.adf             || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};


/**
 * PUBLIC FUNCTION used to add a new data change listener (callback) for a given el expression (variable)
 * 
 * e.g.
 *   adf.addDataChangeListeners("#{bindings.apple}",                   appleChangedCallback); 
 *   adf.addDataChangeListeners("#{bindgins.apple + bindings.orange}", appleOrOrangeChangedCallback);
 *                              
 * 	 adf.addDataChangeListeners("#{!bindings.foo}",                    bindingsFooChangedCallback);
 * 
 *   where the callback would looks something like this:
 *   bindingsFooChangedCallback = function(id)
 *   {
 *      document.write("DataChangeNotification 1 notification for ID: " + id);
 *   }
 *   
 * If the same expression/listener combination is registered several times, duplicates are discarded.
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.addDataChangeListeners = function(expression, callback) 
{
	adf.mf.api.addDataChangeListeners.apply(this, arguments);
};

adf.mf.api.adf.loadADFMessageBundles = function(baseUrl, loadMessageBundleCallback)
{
	adf.mf.resource.loadADFMessageBundles.apply(this, arguments);
};

adf.mf.api.adf.getInfoString = function(bundleName, key)
{
	adf.mf.resource.getInfoString.apply(this, arguments);
};

adf.mf.api.adf.getErrorId = function(bundleName, key)
{
	adf.mf.resource.adf.getErrorId.apply(this, arguments);
};

adf.mf.api.adf.getErrorCause = function(bundleName, key)
{
	adf.mf.resource.getErrorCause.apply(this, arguments);
};

adf.mf.api.adf.getErrorAction = function(bundleName, key)
{
	adf.mf.resource.getErrorAction.apply(this, arguments);
};

adf.mf.api.adf.logAndThrowErrorResource = function(bundleName, methodName, key)
{
	adf.mf.log.logAndThrowErrorResource.apply(this, arguments);
};

adf.mf.api.adf.logInfoResource = function(bundleName, level, methodName, key)
{
	  adf.mf.log.logInfoResource.apply(this, arguments);
};




/**
 * PUBLIC FUNCTION used to get the current context ID. 
 *
 * e.g. adf.getContextId(success, failed);
 * 
 * @deprecated
 */
/* void */
adf.getContextId = function(success, failed) 
{ 
	adf.mf.api.getContextId.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to get the current context's pagedef. 
 *
 * e.g. adf.getContextId(success, failed);
 * 
 */
adf.getContextPageDef = function(success, failed)
{
	adf.mf.api.getContextPageDef.apply(this, arguments);
};

/**
 * PUBLIC FINCTION used to get the current context's instance ID
 */
adf.getContextInstanceId = function(success, failed)
{
	adf.mf.api.getContextInstanceId.apply(this, arguments);
};


/**
 * setContext
 * pageDef    - name of the page definition
 * instanceId - unique id for the instance
 * resetState - reset the bindings associated with this instance
 * reSync     - resend the initial bindings structure to the container
 */
adf.setContextInstance = function(pageDef, instancedId, resetState, /* boolean */reSync, success, failed)
{
	adf.mf.api.setContextInstance.apply(this, arguments);
};

adf.removeContextInstance = function(pageDef, instanceId, success, failed)
{
	adf.mf.api.removeContextInstance.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to invoke method in any class in classpath.
 * 
 * e.g. adf.invokeMethod(classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
 *
 * Examples:
 *      adf.invokeMethod("TestBean", "setStringProp", "foo", success, failed);                  
 *      adf.invokeMethod("TestBean", "getStringProp", success, failed);                  
 *      adf.invokeMethod("TestBean", "testSimpleIntMethod", "101", success, failed); // Integer parameter              
 *      adf.invokeMethod("TestBean", "testComplexMethod", 
 *              {"foo":"newfoo","baz":"newbaz",".type":"TestBeanComplexSubType"}, success, failed); // Comples parameter
 *      adf.invokeMethod("TestBean", "getComplexColl", success, failed); // No parameter
 *      adf.invokeMethod("TestBean", "testMethodStringStringString", "Hello ", "World", success, failed); // 2 string parameter
 *
 * @param classname  - name of the class
 * @param methodname - name of the method
 * @param params     - parameters
 * @param success    - invoked when the method is successfull invoked
 *                     (signature: success(request, response))
 * @param failed     - invoked when an error is encountered 
 *                     (signature: failed(request, response))
 */
adf.invokeMethod = function() 
{ 
	adf.mf.api.invokeMethod.apply(this, arguments);
};

/**
 * PUBLIC FUNCTION used to invoke IDM Mobile SDK methods
 */
adf.invokeSecurityMethod = function(command, username, password, tenantname)  
{ 
	adf.mf.security.invokeSecurityMethod.apply(this, arguments); 
};

/**
 * PUBLIC FUNCTION used to remove all data change listeners associated with the variable
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.removeDataChangeListeners = function(expression) 
{
	adf.mf.api.removeDataChangeListeners.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to reset context. Call this before setting new context.
 * This is exactly the same as calling adf.setContext with an empty context name.
 *
 * e.g. adf.resetContext(successCallback, failedCallback);
 */
/* void */
adf.resetContext = function(success, failed) 
{ 
	adf.mf.api.resetContext.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to set context for the specified name
 * 
 * e.g. adf.setContext("myContextName", successCallback, failedCallback);
 */
/* void */
adf.setContext = function(/* context name */ name, success, failed) 
{
	adf.mf.api.setContext.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to create a top-level variable
 * into the context.  This should be thought of as adding
 * a variable to the root namespace for variables.
 * 
 * i.e. adf.el.addVariable("name", some_object);
 * 
 * addVariable/removeVariable are used to add and then remove
 * temporary variables, like loop iterator variables along with
 * longer lasting variables.
 */
/* void */
adf.el.addVariable = function(/* variable name */ name, /* new value */ value) 
{ 
	adf.mf.api.addVariable.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION will evaluate the passed in expression against
 * the local cache ONLY.  If there are terms that are currently
 * not cached or any function calls then undefined will be returned.
 * 
 * @see adf.el.addVariable
 * @see adf.el.removeVariable
 * 
 * @see adf.el.getValue
 * @see adf.el.setValue
 * @see adf.el.setLocalValue
 */
adf.el.getLocalValue = function(/* expression */ expression) 
{
	return adf.mf.api.getLocalValue.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to evaluate the expression(s) passed in and return the associated 
 * value(s) via the success callback.  Since not all variables may not be resolved only the
 * resolved expressions will be returned in the 'response' property of the success callback.
 *  
 * Given that you can use this method to get the value for:
 * 
 * Evaluation of a single EL expression:
 * e.g. adf.el.getValue("#{100+2*20/3}", success, failed);
 * e.g. adf.el.getValue("#{bindings.userName.inputValue}", success, failed);
 * 
 * Evaluation of an array of EL expressions:
 * e.g. adf.el.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
 * e.g. adf.el.getValue(["#{bindings.foo}", "#{applicationScope.username}"], success, failed);
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.getValue("#{100+2*20/3}", success, failed);
 *        success(["#{100+2*20/3}"], [ {name:"#{100+2*20/3}", value:"113.33"} ] )
 *        
 *   e.g. adf.el.getValue("#{bindings.userName.inputValue}", success, failed);
 *        success(["#{bindings.userName.inputValue}"], [ {name:"#{bindings.userName.inputValue}", value:"me"} ] )
 * 
 *   e.g. adf.el.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
 *        success(["#{100+2*20/3}", "#{500/2}"], 
 *                [ {name:"#{100+2*20/3}", value:"113.33"}, {name:"#{500/2}", value:"250"} ] )
 * 
 * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
 * e.g. adf.el.getValue( ["#{bindings.foo}", "#{bindings.bar}"], success, failed);
 *        success(["#{bindings.foo}", "#{bindings.bar}"], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
 *          *** notice: binding.bar was not part of the result array
 *          
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 *   
 * There also exists another way to invoke the getValue used to resolve a property from an already 
 * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
 * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
 * the "right thing to do" based on the 'base' and 'property' variables:
 * 
 * e.g. adf.el.getValue(base, property);
 *   where the value returned is value of the property or nil if it does not exists.
 **/
adf.el.getValue = function() 
{
	adf.mf.api.getValue.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to used to invoke a method expression in the java environment.
 * 
 * expression: is the method expression itself
 *             i.e. #{bean.method}  #{applicationScope.bean.method}
 * params    : is an array of zero or more values that should be passed as the method parameters
 *             i.e. []                      - to invoke bean.method()
 *             or ["Hello"]                 - to invoke bean.method(String)
 *             or [[false, false], "Hello"] - to invoke bean.method(boolean[], String)
 * returnType: is the return type
 *             i.e. void                    - 
 *             i.e. String                  - return type is a string
 * types     : i.e. []                      - no parameters
 *             i.e. [java.lang.String]      - one parameter of type String
 *             i.e. [java.lang.String, int] - parameter-1 of type String, parameter-2 of type int
 *               
 * Given this information the correct method will be looked up and invoked from the given method.
 * 
 * Evaluation of a single EL expression:
 * e.g. invoke("#{Bean.foobar}", [parameters], [parameter-types], success, failed);
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.invoke("#{Bean.foobar}", [], "java.lang.String", [], success, failed);
 *        success({method:"#{Bean.foobar}" arguments:[]}, {result:....} )
 *          
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 **/
adf.el.invoke = function(expression, params, returnType, types, success, failed) 
{
	adf.mf.api.invoke.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to update a value for a given variable expression.
 * Since variable expressions are the only type of expressions that can be LHS
 * (left-hand-side) expressions we can rule out all literal, complex, and method 
 * expressions from the possible input.
 * 
 * A simple name-value-pair object is used to denote the variable expression (name)
 * with it's desired value (value).  An example of this would be: 
 *       { "name":"#{applicationScope.foo}", value:"foobar" } 
 * 
 * Similar to the getValue function, the setValue can take a single name-value-pair
 * or an array of them for doing batch sets.  The following examples will highlight
 * these cases:
 * 
 * Passing only a single name-value-pair
 * e.g. adf.el.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
 *      resulting in the bindings.foo variable being assigned foo
 *      
 * Passing an array of name-value-pairs
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *      resulting in the bindings.foo variable being assigned foo and 
 *                       bindings.bar variable being assigned bar
 *      
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
 *        success(["{ "name": "#{bindings.foo}", "value": "foo" }"], [ { "name": "#{bindings.foo}", "value": "foo" } ] )
 *        
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *        success([{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }] )
 * 
 * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *        success([{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
 *          *** notice: binding.bar was not part of the result array
 * 
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 *   
 * There also exists another way to invoke the setValue used to set a property from an already 
 * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
 * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
 * the "right thing to do" based on the 'base' and 'property' variables:
 * 
 * e.g. adf.el.setValue(base, property, value);
 *   where the base.property is assigned the value of 'value'
 **/
adf.el.setValue = function(nvp, success, failed) 
{
	adf.mf.api.setValue.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to set the value only on the javascript side.
 * 
 * @see adf.el.setValue
 */
adf.el.setLocalValue = function() 
{
	adf.mf.api.setLocalValue.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to remove a top-level variable
 * from the context.  This should be thought of as removing
 * a variable from the root namespace for variables.
 * 
 * i.e. adf.el.removeVariable("name");
 */
/* void */
adf.el.removeVariable = function(/* variable name */ name) 
{
	adf.mf.api.removeVariable.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to create a top-level variable
 * into the context.  This should be thought of as adding
 * a variable to the root namespace for variables.
 * 
 * i.e. adf.el.setVariable("name", some_object);
 * 
 * Most of the time the 'some_object' will be a property
 * map.  So we can do things like:
 *   adf.el.getValue("${name.property}");
 */
/* void */
adf.el.setVariable = function(/* variable name */ name, /* new value */ value) 
{
	adf.mf.api.setVariable.apply(this, arguments);
};

 /**
 * PUBLIC FUNCTION used to process the data change event associated with response messages.
 * 
 * DataChangeEvents can be sent as their own request message or as part of _any_ response
 * message.  This event is sent to inform the javascript side that some data was side-effected
 * in the CVM layer and should be propagated into the javascript cache as well as notify the 
 * user interface of the change.  This event has the following JSON represention:
 *   
 * DataChangeEvent
 * {
 *  	variableChanges: {
 * 	    	elExpression:value
 * 	    	...
 *  	}
 *  	providerChanges: {
 *  		providerId: {
 *  		   <operation>:{ 
 *  		      current_row_key: { properties filtered by node }
 *  		      ...
 *  		   }
 *             ...
 *  		}
 *  		...
 *  	}
 * }
 * 
 * Given that, we need to do the following for each data change event:
 * Variable Changes:
 *    set the value in the local cache
 *    notify anyone interested in that variable, that it has changed.
 *    
 * Provider Changes:
 *    on Create:
 *      set the value in the local cache
 *    on Update:
 *      set the value in the local cache
 *      notify anyone interested in that variable, that it has changed.
 *    on Create:
 *      remove the value from the local cache
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.processDataChangeEvent = function(/* DataChangeEvent */ dce)
{
	adf.mf.api.processDataChangeEvent.apply(this, arguments);
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfelBridge.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-resource.js ------------------ */
/* ------------------------------------------------------ */

// base-adfel.js defines all of the other namespaces
if (!window.adf) window.adf = {};
                  adf.mf              = adf.mf              || {};
                  adf.mf.api          = adf.mf.api          || {};
/** @namespace */ adf.mf.api.amx      = adf.mf.api.amx      || {};
                  adf.mf.internal     = adf.mf.internal     || {};
/** @namespace */ adf.mf.internal.amx = adf.mf.internal.amx || {};
                  adf.mf.resource     = adf.mf.resource     || {};
if (!window.amx) window.amx = {}; /* deprecated */

// --------- Config Initialization --------- //
(function()
{
  // define the names of the 2 known message bundles here
  adf.mf.resource.AMXErrorBundleName = "AMXErrorBundle";
  adf.mf.resource.AMXInfoBundleName  = "AMXInfoBundle";
})();
// --------- /Config Initialization --------- //

// --------- Utilities --------- //
(function()
{
  function loadTrinidadLocaleElements(baseUrl, localeList, callback)
  {
    var getLocaleElementsUrl = function(locale)
    {
      return baseUrl + "/resource/LocaleElements_" + adf.mf.locale.getJavaLanguage(locale) + ".js";
    };

    var isLocaleElementsLoaded = function(locale)
    {
      var suffix = "_" + adf.mf.locale.getJavaLanguage(locale);
      if (typeof window["LocaleSymbols" + suffix] !== "undefined")
      {
        return true;
      }
      return false;
    };

    adf.mf.api.amx.loadJavaScriptByLocale(
      localeList,
      getLocaleElementsUrl,
      isLocaleElementsLoaded,
      callback,
      true);
  }

  function loadTrinidadMessageBundle(baseUrl, languageList, callback)
  {
    var getMessageBundleUrl = function(language)
    {
      var url = baseUrl + "/resource/MessageBundle";
      if (language.indexOf("en") == 0)
      {
        return url + ".js";
      }
      return url + "_" + adf.mf.locale.getJavaLanguage(language) + ".js";
    };

    var isMessageBundleLoaded = function(locale)
    {
      return typeof TrMessageFactory._TRANSLATIONS !== "undefined";
    };

    adf.mf.api.amx.loadJavaScriptByLocale(
      languageList,
      getMessageBundleUrl,
      isMessageBundleLoaded,
      callback,
      true);
  }

  function loadOtherMessageBundles(baseUrl, languageList)
  {
    /* first load the ADF message bundles */
    adf.mf.resource.loadADFMessageBundles(
      baseUrl,
      languageList.slice(0),
      true);

    /* now load the AMX message bundles */
    adf.mf.resource.loadMessageBundle(
      adf.mf.resource.AMXErrorBundleName,
      baseUrl,
      languageList.slice(0),
      true);
    adf.mf.resource.loadMessageBundle(
      adf.mf.resource.AMXInfoBundleName,
      baseUrl,
      languageList.slice(0),
      true);
  }

  // --------- /Private helper methods --------- //

  // --------- Public methods --------- //

  adf.mf.api.amx.loadJavaScriptByLocale = function(localeList, constructor, predicate, callback, async)
  {
    // clone the array before calling the load method since it will actually
    // modify the array as it searches
    var clonedList = [].concat(localeList);

    var loadedResolve = null;
    var loadedPromise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        loadedResolve = resolve;
      });
    var wrappedCallback = function(result)
    {
      loadedResolve();
      callback(result);
    };
    adf.mf.internal.resource.loadJavaScriptByLocale(clonedList, constructor, predicate,
      wrappedCallback, async);
    return loadedPromise;
  };

  adf.mf.api.amx.loadTrinidadResources = function(baseUrl) /* used by base-controller.js */
  {
    // before doing anything, we need to register the error handler
    adf.mf.api.addErrorHandler(adf.mf.internal.amx.errorHandlerImpl);

    // Bootstrap the Trinidad locale globals
    _df2DYS = null;

    // Return global variable _locale if it is non-null; otherwise return the browser language
    _locale = adf.mf.locale.getUserLocale();
    var language = adf.mf.locale.getUserLanguage();

    var localeList = adf.mf.locale.generateLocaleList(_locale, true);
    var languageList = adf.mf.locale.generateLocaleList(language, false);

    loadTrinidadLocaleElements(baseUrl, localeList,
      function(locale)
      {
        if (locale === null)
        {
          // for this low-level method, always send in the english string (do not translate)
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "amx", "loadTrinidadResources",
              "MSG_FAILED_TO_LOAD_LOCALE",
              "Failed to load LocaleElements");
          }
        }
        else
        {
          // Reassign global locale (necessary since Trinidad does not fallback to en-US).
          _locale = locale;
        }
      });

    loadTrinidadMessageBundle(baseUrl, languageList, function(language)
    {
      if (language === null)
      {
        // for this low-level method, always send in the english string (do not translate)
        if(adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "amx", "loadTrinidadResources",
            "Failed to load MessageBundle");
        }
      }
    });

    // load any other message bundles that the js system depends on
    loadOtherMessageBundles(baseUrl, languageList);
  };
  // --------- /Public methods --------- //

}) ();
//--------- /Utilities --------- //
/* Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* --------------- amx-elDependencies.js ---------------- */
/* ------------------------------------------------------ */

(function()
{
  /**
   * Object to parse the EL dependencies for attributes and maintain a map for what EL
   * dependencies are used by certain attributes. Internal object used by AmxTag and
   * AmxNode.
   * @constructor adf.mf.internal.amx.AmxElDependencies
   * @augments adf.mf.api.AdfObject
   */
  function AmxElDependencies(
    attributes)
  {
    this.Init(attributes);
  }

  adf.mf.internal.amx.AmxElDependencies = AmxElDependencies;
  adf.mf.api.AdfObject.createSubclass(
    adf.mf.internal.amx.AmxElDependencies,
    adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxElDependencies");

  /**
   * Initialization method. Using adf.mf.internal.amx.acceptAttributeForElProcessing, this function
   * will gather all the EL dependencies of the attributes so that they may be hooked into the
   * data change event framework.
   *
   * @param {Object.<string, string>} a map of the attribute names as keys and the raw value from
   *                                  the amx or amxf file for the attribute.
   * @protected
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.Init = function(attributes)
  {
    AmxElDependencies.superclass.Init.call(this);

    this._attributeElDependencies = {};
    this._elTokens = [];

    for (var attrName in attributes)
    {
      var attrVal = attributes[attrName];
      if (typeof attrVal == "string" || attrVal instanceof String)
      {
        attrVal = adf.mf.internal.el.parser.parse(attrVal);
      }

      if (adf.mf.internal.amx.acceptAttributeForElProcessing(attrName, attrVal))
      {
        var dependencies = attrVal.getIndexedDependencies();
        for (var i = 0, size = dependencies.length; i < size; ++i)
        {
          var dependency = dependencies[i];
          var attrDependencies = this._attributeElDependencies[dependency];
          if (attrDependencies == null)
          {
            this._attributeElDependencies[dependency] = [ attrName ];
          }
          else
          {
            attrDependencies.push(attrName);
          }

          // Avoid duplicates:
          if (this._elTokens.indexOf(dependency) == -1)
          {
            this._elTokens.push(dependency);
          }
        }
      }
    }
  };

  /**
   * Get the names of the attributes that are affected by a change
   * to the given EL dependency.
   *
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   *        containing one term
   * @return {Array.<string>} array of attribute names.
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.getAttributesForElDependency = function(
    valueExpression)
  {
    var attrs = this._attributeElDependencies[valueExpression.getIndexedRepresentation()];
    return attrs == null ? [] : attrs;
  };

  /**
   * Get the EL tokens that all the attributes are dependent on.
   *
   * @return {Array.<string>} the EL tokens
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.getElTokens = function()
  {
    return this._elTokens;
  };

})();
/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* -------------------- amx-tag.js ---------------------- */
/* ------------------------------------------------------ */

(function()
{
  // ------ AMX Tag ------ //
  /**
   * AMX tag object. JS object representation of the AMX node definition from the AMX page.
   * Constructor should only be by the framework.
   *
   * @param {(adf.mf.api.amx.AmxTag|null)} parentTag the parent tag or null for the root.
   * @param {Node} xmlNode the XML DOM node from the AMX page
   * @param {Array.<number>} nextAutoGeneratedId an array with a single integer (to be able
   *        to change the value) for tags without IDs, the next auto-generated
   *        one to use.
   * @constructor adf.mf.api.amx.AmxTag
   * @augments adf.mf.api.AdfObject
   */
  function AmxTag(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    this.Init(parentTag, xmlNode, nextAutoGeneratedId);
  }

  adf.mf.api.amx.AmxTag = AmxTag;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.AmxTag, adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxTag");

  adf.mf.api.amx.AmxTag.prototype.Init = function(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    AmxTag.superclass.Init.call(this);

    // TODO assert that xmlNode != null and xmlNode.nodeType == 1
    this._parent = parentTag;
    // The native xml parser in UWP has namespaceUri vs namespaceURI
    this._ns = xmlNode.namespaceURI || xmlNode.namespaceUri;
    this._prefixedName = xmlNode.tagName;
    this._name = xmlNode.localName;
    this._nsPrefixedName = this._ns + ":" + this._name;
    this._textContent = "";
    this._elDependencies = null;
    this._attr = {};
    this._uiTag = null;

    if (this._name == "parsererror")
    {
      // The native xml parser in UWP has innerText vs textContent
      var errorText = xmlNode.textContent || xmlNode.innerText;
      if (adf.mf.environment.profile.mockData)
        console.log("*** " + errorText); // make more obvious error for mock mode
      throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
        "ERROR_XML_PARSING_ERROR", errorText));
    }

    var attrs = xmlNode.attributes;
    var i, size;
    var idFound = false;

    for (i = 0, size = attrs.length; i < size; ++i)
    {
      var a = attrs[i];
      this._attr[a.name] = a.value;
      if (idFound == false && a.name == "id")
      {
        idFound = true;
      }
    }

    if (!idFound)
    {
      // Assign a unique ID to the tag
      if (nextAutoGeneratedId == null)
      {
        nextAutoGeneratedId = [ 0 ];
      }

      this._attr["id"] = "_auto" + (nextAutoGeneratedId[0]++);
    }

    this._children = [];
    var children = xmlNode.childNodes;
    for (i = 0, size = children.length; i < size; ++i)
    {
      var child = children[i];

      switch (child.nodeType)
      {
        case 1: // element
          var tag = new adf.mf.api.amx.AmxTag(this, child, nextAutoGeneratedId);
          this._children.push(tag);
          break;
        case 3: // text node
        case 4: // CDATA node
          if (this._textContent == null)
          {
            // First text or CDATA node encountered. Note: innerText is for UWP
            this._textContent = child.textContent || child.innerText;
          }
          else
          {
            // Subsequent text or CDATA nodes. Note: innerText is for UWP
            this._textContent += child.textContent || child.innerText;
          }
          break;
      }
    }
  };

  AmxTag.NAMESPACE_AMX = "http://xmlns.oracle.com/adf/mf/amx";
  AmxTag.NAMESPACE_DVTM = AmxTag.NAMESPACE_AMX + "/dvt";

  /**
   * Get the XML namespace URI for the tag.
   * @return {string} the namespace URI
   */
  adf.mf.api.amx.AmxTag.prototype.getNamespace = function()
  {
    return this._ns;
  };

  /**
   * @deprecated
   */
  adf.mf.api.amx.AmxTag.prototype.getPrefixedName = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "AmxTag.getPrefixedName", "MSG_DEPRECATED", "amxTag.getPrefixedName",
      "Use amxTag.getNsPrefixedName instead.");
    return this._prefixedName;
  };

  /**
   * Return the tag name including the namespace prefix (not the local xmlns prefix).
   * This is the full XML name like "http://xmlns.example.com/custom:custom".
   * @return {string} the tag name with the prefix
   */
  adf.mf.api.amx.AmxTag.prototype.getNsPrefixedName = function()
  {
    return this._nsPrefixedName;
  };

  /**
   * Get the tag name. This is the local XML tag name without the prefix.
   * @return {string} the tag name
   */
  adf.mf.api.amx.AmxTag.prototype.getName = function()
  {
    return this._name;
  };

  /**
   * Get the parent tag.
   * @return {(adf.mf.api.amx.AmxTag|null)} the parent tag or null for the top level
   *         tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getParent = function()
  {
    return this._parent;
  };

  /**
   * Returns the text content of the tag.
   * @return {string} the text content, or an empty string.
   */
  adf.mf.api.amx.AmxTag.prototype.getTextContent = function()
  {
    return this._textContent;
  };

  /**
   * Recursively search the tag hierarchy for tags with the given
   * namespace and tag name. Returns the current tag if a match as well.
   *
   * @param {string} namespace the namespace of the children to retrieve.
   * @param {string} tagName the name of the tags to return.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching tags.
   */
  adf.mf.api.amx.AmxTag.prototype.findTags = function(
    namespace,
    tagName)
  {
    var tags = [];
    if (tagName == this.getName() && this.getNamespace() == namespace)
    {
      tags.push(this);
    }

    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      var result = child.findTags(namespace, tagName);
      if (result.length > 0)
      {
        tags = tags.concat(result);
      }
    }

    return tags;
  };

  /**
   * Get the children of the tag. Provides for optional filtering of the children
   * namespaces and tag names.
   * @param {(string|null)} namespace the namespace to filter the children by. If
   *        null all the children will be returned.
   * @param {(string|null)} tagName the name of the tag to filter the children by.
   *        Only considered if the namespace parameter is non-null. If null, the
   *        children will not be filtered by tag name.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching children tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildren = function(
    namespace,
    tagName)
  {
    var result = [];
    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      if ((namespace == null || namespace == child.getNamespace()) &&
        (tagName == null || tagName == child.getName()))
      {
        result.push(child);
      }
    }

    return result;
  };

  /**
   * Convenience function to get all of the children facet tags. Meant to assist
   * the creation of the AMX node process.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the facet tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenFacetTags = function()
  {
    return this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
  };

  /**
   * Convenience function to get the facet tag with the given name. Meant to assist
   * the code if the presence of a facet changes the behavior of a type handler.
   * @param {string} name the name of the facet to find.
   * @return {(adf.mf.api.amx.AmxTag|null)} the child facet tag or null if none has been
   *         provided with the given name.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildFacetTag = function(name)
  {
    var facetTags = this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
    for (var i = 0, size = facetTags.length; i < size; ++i)
    {
      var tag = facetTags[i];
      if (tag.getAttribute("name") == name)
      {
        return tag;
      }
    }

    return null;
  };

  /**
   * Convenience function to get all children tags that are UI tags. Meant to assist
   * the creation of the AMX node process. Does not return any facet tags.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the children UI tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenUITags = function()
  {
    var children = this.getChildren();
    var result = children.filter(
      function(tag, index, array)
      {
        return tag.isUITag();
      });

    return result;
  };

  /**
   * Get all of the defined attribute names for the tag.
   * @return {Array.<string>} all of the attribute names for the attributes that were
   *         specified on the tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributeNames = function()
  {
    var names = [];
    for (var name in this._attr)
    {
      names.push(name);
    }

    return names;
  };

  /**
   * Get if the given attribute is bound to an EL expression.
   * @param {string} name the name of the attribute to check.
   * @return {boolean} true if there is EL in the attribute value or false if the value
   *         is static or if the attribute was not defined.
   */
  adf.mf.api.amx.AmxTag.prototype.isAttributeElBound = function(name)
  {
    return AmxTag.__isELExpression(this.getAttribute(name));
  };

  /**
   * Get the attribute value (may be an EL string) for the attribute of the given name.
   * @param {string} name the name of the attribute
   * @return {string|undefined} the attribute value or undefined if the attribute was not specified.
   *         Returns the expression string for EL attributes.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttribute = function(name)
  {
    return this._attr[name];
  };

  /**
   * Get a k/v pair map of the attributes and their values.
   * @return {Object.<string, value>} map of name to value pairs.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributes = function()
  {
    return this._attr;
  };

  /**
   * Get if the node is a UI tag with a type handler and renders content.
   * @return {boolean} true if a UI tag
   */
  adf.mf.api.amx.AmxTag.prototype.isUITag = function()
  {
    if (this._uiTag == null)
    {
      // Lazily load the value. This ensures that the tag resources are loaded before we check
      // for a tag handler in case the tag handler is registered inside of a resource.
      var hasTagHandler = adf.mf.internal.amx.AmxTagHandler.__hasTagHandler(this._nsPrefixedName);
      this._uiTag = !hasTagHandler;
    }

    return this._uiTag;
  };

  /**
   * Get the tags for the children of this facet and the name of the facet if this tag
   * is a facet tag. Convenience function for building the AMX node tree.
   * @return {({name:string, children:Array.<adf.mf.api.amx.AmxTag>}|null)} an object with the
   *         name of the facet and the children tags of the facet. Returns null if the tag
   *         is not an AMX facet tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getFacet = function()
  {
    if (this._nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":facet")
    {
      var children = this.getChildren();
      var facetName = this.getAttribute("name");

      return { "name": facetName, "children": children };
    }

    return null;
  };

  /**
   * Create a new instance of an AMX node for this tag given the stamp ID. If the tag
   * is a facet tag, the tag will create the node for the child tag. This function does
   * not initialize the node.
   *
   * @param {(adf.mf.api.amx.AmxNode|null)} parentNode the parent AMX node or null if the
   *        tag/node is the root
   * @param {(Object|null)} key the stamp key to identify the node with the given key. May
   *        be null for non-iterating parent tags.
   * @return {(adf.mf.api.amx.AmxNode|null)} an un-initialized AMX node object or null
   *         for non-UI tags
   */
  adf.mf.api.amx.AmxTag.prototype.buildAmxNode = function(
    parentNode,
    key)
  {
    if (!this.isUITag())
    {
      // Currently do nothing for other non-UI tags, but we should consider adding
      // behaviors and other types of tags in the future to remove the hard-coded nature
      // of processing tags like the AMX setPropertyListener tag.
      return null;
    }

    return new adf.mf.api.amx.AmxNode(parentNode, this, key);
  };

  /**
   * Get the type handler for this tag.
   * @return {Object} the type handler
   */
  adf.mf.api.amx.AmxTag.prototype.getTypeHandler = function()
  {
    if (this._typeHandler === undefined)
    {
      var typeHandler = null;
      if (this._nsPrefixedName)
      {
        typeHandler = adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName];
        if (typeHandler == null)
        {
          var typeHandlerClass = adf.mf.api.amx.TypeHandler._classDictionary[this._nsPrefixedName];
          if (typeHandlerClass != null)
          {
            typeHandler = new typeHandlerClass();
            adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName] = typeHandler;
          }
        }
      }

      if (typeHandler === undefined && adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        // Could not find an associated TypeHandler.
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.api.amx.AmxTag", "getTypeHandler",
          "Unable to find TypeHandler for namespace = " + this._ns + ", ns prefixed name = " +
          this._nsPrefixedName + ", local name = " + this._name);
      }

      this._typeHandler = typeHandler;
    }

    return this._typeHandler;
  };

  /**
   * Internal function to check if the given value is an EL expression.
   * @param {(string|null)} value the value to check
   * @return {boolean} true if there is EL in the value or false if the value
   *         is static or if the value is null.
   * @ignore
   */
  adf.mf.api.amx.AmxTag.__isELExpression = function(value)
  {
    return value != null && value.indexOf("#{") >= 0;
  };

  /**
   * Get a type handler function (JavaScript class) for the given namespace and name.
   * Primarily used by the test JavaScript files to extend an existing type handler prototype.
   *
   * @param {string} tagNs the tag namespace
   * @param {string} tagName the tag name
   * @return {function} the type handler function if found, otherwise null
   */
  AmxTag.getTypeHandlerFunction = function(tagNs, tagName)
  {
    // Internal usage is for the first param to be the prefixed name
    var nsPrefixedName = arguments.length == 1 ? tagNs : tagNs + ":" + tagName;

    return adf.mf.api.amx.TypeHandler._classDictionary[nsPrefixedName];
  };

})();
/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ---------------- amx-tagInstance.js ------------------ */
/* ------------------------------------------------------ */

(function()
{
  /**
   * @namespace
   */
  adf.mf.internal.amx.AmxTagInstanceStates =
  {
    /** EL based attributes needed for rendering have not been fully loaded yet */
    "WAITING_ON_EL_EVALUATION": 0,
    /** EL attributes have been loaded, the node has not yet been rendered */
    "LOADED": 1
  };

  /**
   * Constructor for a tag instance. The tag instance represents a non-UI tag of an AMX
   * node and store node specific information. In the case of fragments, the tag instance
   * holds onto replaced EL strings that are specific to each individual node.
   *
   * @param {adf.mf.api.amx.AmxNode} parentAmxNode the AMX node that this tag instance
   *        belongs to
   * @param {adf.mf.internal.amx.AmxTagInstance} parentTagInstance the parent tag instance if
   *        nested
   * @param {adf.mf.api.amx.AmxTag} tag the refence to the tag for this instance
   * @constructor adf.mf.internal.amx.AmxTagInstance
   * @augments adf.mf.api.AdfObject
   */
  function AmxTagInstance(
    parentAmxNode,
    parentTagInstance,
    tag)
  {
    this.Init(parentAmxNode, parentTagInstance, tag);
  }

  adf.mf.internal.amx.AmxTagInstance = AmxTagInstance;
  adf.mf.api.AdfObject.createSubclass(adf.mf.internal.amx.AmxTagInstance, adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxTagInstance");

  /**
   * Initialize the tag instance. This function will evaluate the EL expressions, storing the
   * cached values into the object so that the values may be retrieved later without EL
   * evaluation. It also sets up the EL dependencies that will be used for data change events
   * to ensure the cached values are kept up to date.
   *
   * @param {adf.mf.api.amx.AmxNode} parentAmxNode the AMX node that this tag instance
   *        belongs to
   * @param {adf.mf.internal.amx.AmxTagInstance} parentTagInstance the parent tag instance if
   *        nested
   * @param {adf.mf.api.amx.AmxTag} tag the refence to the tag for this instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.Init = function(
    parentAmxNode,
    parentTagInstance,
    tag)
  {
    AmxTagInstance.superclass.Init.call(this);

    this._parentAmxNode = parentAmxNode;
    this._parentTagInstance = parentTagInstance;
    this._tag = tag;
    this._elAttributeMap = {}; // maps string (attribute name) to ELExpression (attribute value)
    this._tagHandler = adf.mf.internal.amx.AmxTagHandler.__getHandler(
      tag.getNsPrefixedName());

    this._attributesWaitingOnEl = 0;
    this._attributeNamesWaitingOnEl = {};
    this._state = adf.mf.internal.amx.AmxTagInstanceStates["LOADED"];

    // Create a set of the attributes that have their values stored on the tag instance
    this._cachedAttributes = {};

    // A map of the local (cached) attribute values
    this._attrs = {};

    var attrs = tag.getAttributes();
    for (var attrName in attrs)
    {
      var value = attrs[attrName];

      if (attrName != "id" && adf.mf.api.amx.AmxTag.__isELExpression(value))
      {
        var elExpression = adf.mf.internal.el.parser.parse(value);
        var expr = adf.mf.api.amx.AmxNode.__performElSubstitutions(elExpression);
        this._elAttributeMap[attrName] = expr;

        if (this._tagHandler.shouldPrefetchAttribute(attrName, expr))
        {
          var value = adf.mf.internal.amx.evaluateExpression(expr);
          this._attrs[attrName] = value;
          this._cachedAttributes[attrName] = true;
          if (value === undefined)
          {
            this._state = adf.mf.internal.amx.AmxTagInstanceStates["WAITING_ON_EL_EVALUATION"];
            ++this._attributesWaitingOnEl;
            this._attributeNamesWaitingOnEl[attrName] = true;
          }
        }
      }
    }

    this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(this._elAttributeMap);

    this._tagHandler.initializeTagInstance(this);

    this._children = [];

    if (parentTagInstance != null)
    {
      parentTagInstance._children.push(this);
    }
  };

  /**
   * @return {adf.mf.api.amx.AmxNode} get the AMX node that this tag instance belongs to
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getParentAmxNode = function()
  {
    return this._parentAmxNode;
  };

  /**
   * @return {(adf.mf.internal.amx.AmxTagInstance|null)} get the parent tag instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getParentTagInstance = function()
  {
    return this._parentTagInstance;
  };

  /**
   * @return {adf.mf.api.amx.AmxTag} get the tag for this instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getTag = function()
  {
    return this._tag;
  };

  /**
   * @param {(string|null)} namespace the namespace to filter the children by
   * @param {(string|null)} tagName the tag name to filter the children by (requires namespace to be
   *        provided)
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} the children tag instances
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getChildren = function(
    namespace,
    tagName)
  {
    var children = [];
    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      if (namespace != null)
      {
        var tag = child.getTag();
        if ((tagName != null && tagName != tag.getName()) ||
          namespace != tag.getNamespace())
        {
          continue;
        }
      }

      children.push(child);
    }
    return children;
  };

  /**
   * Get an EL expression for an attribute. For fragments, the EL expression will be already
   * replaced.
   *
   * @return {(ELExpression|null)} for EL bound attributes, returns the ELExpression of an attribute.
   *         Returns undefined for attributes that are not EL bound.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getAttributeExpression = function(name)
  {
    return this._elAttributeMap[name];
  };

  /**
   * Get an attribute value
   *
   * @param {string} name the name of the attribute to get the value
   * @param {boolean=} evaluateEl if not given, or true EL based attributes will be evaluated. If
   *        false, the EL string will be returned for EL based attributes.
   * @return {(Object|string)} returns the attribute value or the EL expression for the attribute.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getAttribute = function(
    name,
    evaluateEl)
  {
    // Default evaluateEl not being passed to a true value
    if (evaluateEl === undefined)
    {
      evaluateEl = true;
    }

    // Check to see if this is an attribute that has its value cached
    if (evaluateEl && this._cachedAttributes[name] == true)
    {
      return this._attrs[name];
    }

    var expr = this.getAttributeExpression(name);
    if (expr == null)
    {
      return this.getTag().getAttribute(name);
    }

    // If not evaluating the EL, return the expression
    return evaluateEl ? adf.mf.internal.amx.evaluateExpression(expr) : expr.getExpression ();
  };

  /**
   * Called from the node when a markNodeForUpdate call is being processed. This is
   * usually called as a result of a data change event.
   *
   * @param {Array.<string>} attributeNames the names of the attributes that should be
   *        updated. Any cached attributes in this array will re-evaluate their EL
   *        values to get the current values.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.updateAttributes = function(
    attributeNames)
  {
    var oldValues = {};

    for (var a = 0, numAttrs = attributeNames.length; a < numAttrs; ++a)
    {
      var attrName = attributeNames[a];

      if (this._cachedAttributes[attrName] == true)
      {
        var expr = this.getAttributeExpression(attrName);
        var val = adf.mf.internal.amx.evaluateExpression(expr);

        var oldValue = this._attrs[attrName];
        oldValues[attrName] = oldValue;

        this._attrs[attrName] = val;

        // Notify the tag handler that a cached attribute's value has been changed
        this._tagHandler.attributeUpdated(this, attrName, oldValue, val);

        if (val !== undefined && this._attributeNamesWaitingOnEl[attrName])
        {
          delete this._attributeNamesWaitingOnEl[attrName];
          if (--this._attributesWaitingOnEl == 0)
          {
            this._state = adf.mf.internal.amx.AmxTagInstanceStates["LOADED"];
          }
        }
      }
    }
  };

  /**
   * Set a local value for an attribute on a tag instance. Allows type handlers and
   * tag instance handlers to store attributes on a tag instance
   *
   * @param {string} attributeName the name of the attribute
   * @param {Object} value the value to store. If undefined is passed, the attribute
   *        is removed from the cache
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.setAttribute = function(
    attributeName,
    value)
  {
    if (value === undefined)
    {
      delete this._cachedAttributes[attributeName];
      delete this._attrs[attributeName];
    }
    else
    {
      this._cachedAttributes[attributeName] = true;
      this._attrs[attributeName] = value;
    }
  };

  /**
   * Get the EL dependencies of this tag instance
   *
   * @return {adf.mf.internal.amx.AmxElDependencies} EL dependencies object
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getElDependencies = function()
  {
    return this._elDependencies;
  };

  adf.mf.internal.amx.AmxTagInstance.prototype.getState = function()
  {
    return this._state;
  };
})();
/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ----------------- amx-tagHandler.js ------------------ */
/* ------------------------------------------------------ */

(function()
{

  var handlerClassMap = {};
  var handlerInstanceMap = {};
  /**
   * The base class for handlers of non-UI tags.
   * This class is currently internal and the API is very rudimentary at the moment.
   * @constructor adf.mf.internal.amx.AmxTagHandler
   * @augments adf.mf.api.AdfObject
   */
  function AmxTagHandler()
  {
    this.Init();
  }

  // Make this internal as the API should not be exposed at this time until a full and
  // stable API can be designed.
  adf.mf.internal.amx.AmxTagHandler = AmxTagHandler;
  adf.mf.api.AdfObject.createSubclass(adf.mf.internal.amx.AmxTagHandler, adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxTagHandler");

  /**
   * Register a tag handler with a namespace and name.
   * @param {string} namespace the xmlns for the tag
   * @param {string} tagName the name of the tag (no namespace)
   * @param {(adf.mf.internal.amx.AmxTagHandler|null)} precreatedClass optional pre-created class to
   *        register
   * @return {Function} the registered adf.mf.internal.amx.AmxTagHandler subclass
   */
  adf.mf.internal.amx.AmxTagHandler.register = function(
    namespace,
    tagName,
    precreatedClass)
  {
    // make sure that our class is initialized, since we are using a Factory Method
    adf.mf.api.AdfObject.ensureClassInitialization(AmxTagHandler);
    var registeredClass = precreatedClass;

    if (namespace != null && tagName != null)
    {
      if (registeredClass == null)
      {
        // Create the new class and make it inherit from adf.mf.internal.amx.AmxTagHandler:
        registeredClass =
          function RegisteredTagHandler()
          {
            this.Init();
          };

        adf.mf.api.AdfObject.createSubclass(
          registeredClass,
          adf.mf.internal.amx.AmxTagHandler,
          "TagHandler[" + namespace + ":" + tagName + "]");
      }

      // Make the association so we can find the class:
      var id = namespace + ":" + tagName;
      handlerClassMap[id] = registeredClass;
    }
    else // invalid registration, do not register the TagHandler class
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.amx.AmxTagHandler.register", "MSG_INVALID_TYPE_HANDLER_REGISTRATION",
        namespace, tagName);
    }

    return registeredClass;
  };

  /**
   * Function used by the tag instances to retrieve a tag handler instance.
   *
   * @param {string} nsPrefixedTagName the namespace and tag name separated by a colon
   * @return {(adf.mf.internal.amx.AmxTagHandler|null)} an instance of a tag handler if one
   *         is registered for the given name, otherwise null is returned.
   * @ignore
   */
  adf.mf.internal.amx.AmxTagHandler.__getHandler = function(
    nsPrefixedTagName)
  {
    var instance = handlerInstanceMap[nsPrefixedTagName];

    if (instance == null)
    {
      var cls = handlerClassMap[nsPrefixedTagName];

      if (cls != null)
      {
        instance = new cls();
        handlerInstanceMap[nsPrefixedTagName] = instance;
      }
    }

    return instance;
  };

  /**
   * Check if a tag handler has been specified for the prefixed name. If
   * there is no tag handler, the tag is a UI tag.
   *
   * @param {string} nsPrefixedTagName the namespace then a colon then the tag name
   * @return {boolean} true if there is a registered tag handler
   * @ignore
   */
  adf.mf.internal.amx.AmxTagHandler.__hasTagHandler = function(
    nsPrefixedTagName)
  {
    return AmxTagHandler.__getHandler(nsPrefixedTagName) != null;
  };

  adf.mf.internal.amx.AmxTagHandler.prototype.Init = function()
  {
    AmxTagHandler.superclass.Init.call(this);
  };

  /**
   * Check if the tag attribute with the given EL expression should
   * be pre-fetched during the construction of the tag instance.
   * This ensures that the value is present in the cache when the
   * value should be retrieved. It also ensures that no EL values will
   * be evaluated during rendering.
   *
   * @param {string} attrName the name of the tag attribute
   * @param {string} elExpression the EL expression for the attribute.
   *        In the case of fragments, it will already have been resolved
   *        of any fragment attribute names.
   * @return {boolean} true if the attribute should be evaluated during
   *         tag instance construction
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.shouldPrefetchAttribute = function(
    attrName,
    elExpression)
  {
    // By default pre-fetch all EL bound attribute values
    return true;
  };

  /**
   * Callback after all of the attributes for the tag instance have been
   * fetched. Allows the tag handler to perform any initialization. The base
   * implementation will mark the parent AMX node as waiting on EL evaluation
   * if any of the attributes were not in the EL cache.
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the tag instance
   *        being initialized
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.initializeTagInstance = function(
    tagInstance)
  {
  };

  /**
   * Callback to notify the tag handler that an attribute has been updated on
   * the tag instance. Typically called as a result of a data change event.
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the tag instance
   *        that was updated
   * @param {string} attributeName the name of the attribute that was updated
   * @param {Object} oldValue the old value of the attribute
   * @param {Object} newValue the new value of the attribute
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.attributeUpdated = function(
    tagInstance,
    attributeName,
    oldValue,
    newValue)
  {
    var amxNode = tagInstance.getParentAmxNode();
    if (newValue == undefined && tagInstance.getAttributeExpression(attributeName) != null &&
      amxNode.isReadyToRender())
    {
      amxNode.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
  };

})();
/* Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ---------------- amx-tagHandlers.js ------------------ */
/* ------------------------------------------------------ */

(function()
{
  // This file houses the built in tag (non-UI) handlers. The tag handlers are currently mostly
  // place holders until a full tag API can be designed.

  var AmxTagHandler = adf.mf.internal.amx.AmxTagHandler;

  // --------- Temporary handlers --------- //
  // Register tag handlers for tags that have no behavior in this file (other tags
  // handle the logic)
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attributeList",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attributeSet",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "transition", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "loadingIndicatorBehavior",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationBehavior",
    AmxTagHandler);

  // TODO: introduce a special API for converters. For now, just let them use the default handler
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "convertNumber", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "convertDateTime", AmxTagHandler);

  // TODO: introduce an action/behavior tag to process events. For now, use the default
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "showPopupBehavior", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "closePopupBehavior", AmxTagHandler);
  // --------- /Temporary handlers --------- //

  // --------- attribute --------- //
  // Tag handler for AMX fragment attributes. Prevent the fetching of the value attribute by default
  // in case the EL points to a method and not a value expression.
  var attributeTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attribute",
    AmxTagHandler);
  attributeTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "value";
  };
  // --------- /attribute --------- //


  // --------- actionListener --------- //
  // Use a custom tag handler for the actionListener tag to prevent the EL evaluation of the binding
  // attribute during tag instance construction
  var actionListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "actionListener");

  actionListenerTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "binding";
  };
  // --------- /actionListener --------- //

  // --------- clientListener --------- //
  var clientListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "clientListener");

  clientListenerTagHandler._NON_DOM_EVENT_TYPES = {
    "move": true,
    "rangeChange": true,
    "selection": true,
    "valueChange": true
  };

  clientListenerTagHandler.prototype.initializeTagInstance = function(tagInstance)
  {
    // Get the attribute type. If none is specified assume an action attribute.
    var attrType;
    var type = tagInstance.getAttribute("type");
    if (type != null)
      attrType = adf.mf.internal._getEventTypeResolvedForBidi(type);
    else // use default type
      attrType = "action";

    // Only add types that are DOM events (non-DOM events are already handled):
    if (!clientListenerTagHandler._NON_DOM_EVENT_TYPES[attrType])
    {
      // The parent AMX node will have a list without duplication (map with dummy keys) that indicate
      // which clientListener events the app developer wants the TypeHandler to support.
      var parentAmxNode = tagInstance.getParentAmxNode();
      var clientListenerTypesKey = "data-clientListenerTypes";
      var clientListenerTypes = parentAmxNode.getAttribute(clientListenerTypesKey);
      if (clientListenerTypes == null)
      {
        clientListenerTypes = {};
        parentAmxNode.setAttributeResolvedValue(clientListenerTypesKey, clientListenerTypes);
      }

      clientListenerTypes[attrType] = true;
    }
  };
  // --------- /clientListener --------- //

  // --------- navigationDragBehavior --------- //
  // Use a custom tag handler for the navigationDragBehavior tag to prevent the EL evaluation of the action
  // attribute during tag instance construction
  var navigationDragBehaviorTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "navigationDragBehavior");

  navigationDragBehaviorTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "action";
  };
  // --------- /navigationDragBehavior --------- //
  
  // --------- setPropertyListener --------- //
  // Use a custom tag handler for the setPropertyListener tag to prevent the EL evaluation of the
  // attributes during tag instance construction
  var setPropertyListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "setPropertyListener");

  setPropertyListenerTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return false;
  };
  // --------- /setPropertyListener --------- //

  // --------- loadBundle --------- //
  // Use a custom tag handler for the loadBundle tag to prevent the EL evaluation of the
  // basename attribute during tag instance construction
  var loadBundleTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "loadBundle");

  loadBundleTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "basename";
  };
  // --------- /loadBundle --------- //
  
  // --------- systemActionBehavior --------- //
  // Use a custom tag handler for the systemActionBehavior tag to prevent the EL evaluation of the actionListener
  // and action attributes during tag instance construction
  var systemActionBehaviorTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "systemActionBehavior");

  systemActionBehaviorTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return (name != "actionListener" && name != "action");
  };
  // --------- /systemActionBehavior --------- //
})();
/* Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------ amx-nodeUpdateArguments.js -------------- */
/* ------------------------------------------------------ */

(function()
{
  /**
   * Internal object for the arguments to the markNodeForUpdate function
   * @constructor adf.mf.api.amx.AmxNodeUpdateArguments
   * @augments adf.mf.api.AdfObject
   */
  function AmxNodeUpdateArguments()
  {
    this.Init();
  }

  /**
   * @deprecated
   */
  adf.mf.internal.amx.AmxNodeUpdateArguments = AmxNodeUpdateArguments;

  /*
   * Object for the arguments passed into the adf.mf.api.amx.markNodeForUpdate function.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments = AmxNodeUpdateArguments;

  adf.mf.api.AdfObject.createSubclass(
    adf.mf.api.amx.AmxNodeUpdateArguments,
    adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxNodeUpdateArguments");

  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.Init = function()
  {
    AmxNodeUpdateArguments.superclass.Init.call(this);
    this._amxNodes = [];
    this._affectedAttributes = {};
    this._collectionChanges = {};
    this._affectedTagInstances = {};
    this._affectedTagInstanceAttributes = {};
    this._canceled = false;
  };

  /**
   * Check if the update has been canceled
   * @return {boolean} true if canceled
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.isCanceled = function()
  {
    return this._canceled;
  };

  /**
   * Request that the update be canceled. If the update has been queued, calling this function
   * will prevent the update from being executed. This may be used if an asynchronous event has
   * occurred while the update has been queued that makes the update undesirable. If the update
   * has already run or is in progress this function will not have an effect.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.cancel = function()
  {
    this._canceled = true;
  };

  /**
   * Get an array of affected AmxNodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getAffectedNodes = function()
  {
    return this._amxNodes;
  };

  /**
   * Get an object representing the affected attributes for a given AmxNode ID
   * @param {string} amxNodeId the AmxNode ID
   * @return {Object<string, boolean>} an object with the changed
   *         attributes as keys and "true" as the value.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getAffectedAttributes = function(amxNodeId)
  {
    var affected = this._affectedAttributes[amxNodeId];
    return affected == null ? {} : affected;
  };

  /**
   * Get the collection changes for a given AmxNode and property
   * @param {string} amxNodeId the AmxNode ID
   * @return {(Object<string, adf.mf.api.amx.AmxCollectionChange>|undefined)} an object with the
   *         attributes as keys and the collection change objects for the values. May
   *         be undefined if there are no changes for a given AmxNode
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getCollectionChanges = function(amxNodeId)
  {
    return this._collectionChanges[amxNodeId];
  };

  /**
   * Mark an attribute of an AmxNode as affected
   * @param {adf.mf.api.amx.AmxNode} amxNode the affected AmxNode
   * @param {string} attributeName the name of the affected attribute
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.setAffectedAttribute = function(
    amxNode,
    attributeName)
  {
    var amxNodeId = amxNode.getId();
    var affected = this._affectedAttributes[amxNodeId];
    if (affected == null)
    {
      affected = {};
      this._affectedAttributes[amxNodeId] = affected;

      // Mark the node dirty if it hasn't already
      if (this._affectedTagInstances[amxNode] == null)
      {
        this._amxNodes.push(amxNode);
      }
    }

    affected[attributeName] = true;
  };

  /**
   * Set the collection changes for a given AmxNode's attribute
   * @param {string} amxNodeId the AMX node ID
   * @param {string} attributeName the name of the attribute that the collection had changes
   * @param {adf.mf.api.amx.AmxCollectionChange} collectionChanges the changes for the collection
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.setCollectionChanges = function(
    amxNodeId,
    attributeName,
    collectionChanges)
  {
    var obj = this._collectionChanges[amxNodeId];
    if (obj == null)
    {
      obj = {};
      this._collectionChanges[amxNodeId] = obj;
    }

    obj[attributeName] = collectionChanges;
  };

  /**
   * Internal function to get a list of affected tag instance IDs for a given AMX node.
   *
   * @param {string} amxNodeId the AMX node ID
   * @return {Array.<string>} IDs of the affected tag instances. Will return an empty array if
   *         there are not IDs.
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__getAffectedTagInstanceIds = function(
    amxNodeId)
  {
    var affected = this._affectedTagInstances[amxNodeId];
    return affected == null ? [] : affected;
  };

  /**
   * Internal function to get the affected attribute names for an AMX node and its tag instance ID
   *
   * @param {string} amxNodeId the ID of the affected AMX node
   * @param {string} amxTagId the ID of the affected AMX tag ID
   * @return {Array.<string>} array of affected attributes. Will return an empty array if there are
   *         none.
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__getAffectedAttributesForTagInstance = function(
    amxNodeId,
    amxTagId)
  {
    var key = amxNodeId + "/" + amxTagId;
    var affected = this._affectedTagInstanceAttributes[key];
    return affected == null ? [] : affected;
  };

  /**
   * Internal function to mark a tag's attribute as dirty
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the affected tag instance
   * @param {string} attributeName the name of the affected attribute
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__setAffectedAttributeForTagInstance = function(
    tagInstance,
    attributeName)
  {
    var amxNode = tagInstance.getParentAmxNode();
    var amxTagId = tagInstance.getTag().getAttribute("id");
    var amxNodeId = amxNode.getId();
    var affectedTagInstanceIds = this._affectedTagInstances[amxNodeId];

    // Mark the instance dirty
    if (affectedTagInstanceIds == null)
    {
      affectedTagInstanceIds = [ amxTagId ];
      this._affectedTagInstances[amxNodeId] = affectedTagInstanceIds;

      // Mark the node dirty if it has not already
      if (this._affectedAttributes[amxNodeId] == null)
      {
        this._amxNodes.push(amxNode);
      }
    }
    else if (affectedTagInstanceIds.indexOf(amxTagId) == -1)
    {
      // Mark the instance as dirty
      affectedTagInstanceIds.push(amxTagId);
    }

    // Mark the attribute dirty
    var key = amxNodeId + "/" + amxTagId;

    var affectedAttributes = this._affectedTagInstanceAttributes[key];

    if (affectedAttributes == null)
    {
      this._affectedTagInstanceAttributes[key] = [ attributeName ];
    }
    else if (affectedAttributes.indexOf(attributeName) == -1)
    {
      affectedAttributes.push(attributeName);
    }
  };

})();
/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-node.js ---------------------- */
/* ------------------------------------------------------ */

(function()
{
  var nodeToElMap = {};

  // ------ AMX Node ------ //
  /**
   * AMX node definition. The AMX node constructor is private and only the framework
   * may create new node objects.
   * (parameters TBD)
   * @constructor adf.mf.api.amx.AmxNode
   * @augments adf.mf.api.AdfObject
   */
  function AmxNode(
    parentNode,
    tag,
    key)
  {
    this.Init(parentNode, tag, key);
  }

  adf.mf.api.amx.AmxNode = AmxNode;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.AmxNode, adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxNode");

  AmxNode.prototype.Init = function(
    parentNode,
    tag,
    key)
  {
    AmxNode.superclass.Init.call(this);

    this._tag = tag;
    this._parent = parentNode;
    this._children = {};
    this._facets = {};
    this._attr = {};
    this._modifiableEl = {};
    this._key = key === undefined ? null : key;
    this._state = adf.mf.api.amx.AmxNodeStates["INITIAL"];
    this._childrenCreated = false;
    this._id = null;
    this._converterTag = null;
    this._converter = null;
    this._elDependencies = null;
    this._elAttributeMap = null;

    // Store the tag instances for all children non-UI tags
    this._tagInstances = null;

    // Variables to track what EL is not yet cached that is required
    this._tagInstancesWaitingOnEl = 0;
    this._tagInstanceIdsWaitingOnEl = {};
    this._attributesWaitingOnEl = 0;
    this._attributeNamesWaitingOnEl = {};

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "Init",
        "Created AMX node for tag " + tag.getNsPrefixedName() + " and ID attribute " +
        tag.getAttribute("id"));
    }

    // Increment the number of nodes waiting
    adf.mf.internal.amx._pageBusyTracker.increment();
  };

  /**
   * Get the unique identifier for this node. This is used as the ID on the root HTML element
   * rendered by this node.
   */
  AmxNode.prototype.getId = function()
  {
    return this._id;
  };

  /**
   * Get the AMX tag that created this node.
   * @return {adf.mf.api.amx.AmxTag} the tag that created the node
   */
  AmxNode.prototype.getTag = function()
  {
    return this._tag;
  };

  /**
   * Get the type handler for this node.
   * @return {Object} the type handler
   */
  AmxNode.prototype.getTypeHandler = function()
  {
    return this.getTag().getTypeHandler();
  };

  /**
   * Fetches the client state for this AMX node based on its ID that was previously stored.
   * TypeHandlers would call this to retrieve old state in render(), refresh(), or postDisplay().
   * @return {Object} undefined or the client state data that was previously stored in this view instance
   */
  AmxNode.prototype.getClientState = function()
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      // The client side state map may not be available if this call is performed on a view that
      // is being destroyed. For example, when a task flow return has been executed, the map will
      // be set to null until the new page context has been setup
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx.AmxNode", "getClientState",
          "State not able to be retrieved, client state map is not available for AmxNode " +
          amxNodeId);
      }
      return undefined;
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * Stores/replaces the client state for this AMX node based on its ID (if the ID changes, you won't
   * get the same data).
   * Preferrably, TypeHandler functions would call this whenever a state change happens (i.e. something
   * you want to cache so that when the user navigates to a new page and later comes back, you will be
   * able to restore it like a scroll position).
   * However, it is not always feasible to detect when a state change happens so you may need
   * to update the state for your component just before the view is going to be
   * discarded. There are 2 possible scenarios that you will need to account for:
   * - Renderer refresh() (for navigating to the same view again)
   * - Renderer preDestroy() (for navigating to a new view and navigating back at a later time)
   * @param {String} amxNodeId the amxNode.id that uniquely identifies the stored data
   * @param {Object} payloadJsonObject the client state data to store for the lifetime of this view instance
   */
  AmxNode.prototype.setClientState = function(payloadJsonObject)
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      // The client side state map may not be available if this call is performed on a view that
      // is being destroyed. For example, when a task flow return has been executed, the map will
      // be set to null until the new page context has been setup
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx.AmxNode", "setClientState",
          "State not being saved, client state map is not available for AmxNode " + amxNodeId);
      }
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Fetches the volatile state for this AMX node based on its ID that was previously stored.
   * TypeHandlers would call this to retrieve old state in render(), refresh(), or postDisplay().
   * @return {Object} undefined or the volatile state data that was previously stored since the last navigation
   */
  AmxNode.prototype.getVolatileState = function()
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getVolatileStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
	  			stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * Stores/replaces the AMX volatile state for the specified AMX node ID.
   * Preferrably, renderers would call this whenever a volatile state change happens (i.e. something you want
   * to forget when navigating to a new AMX page but might want to keep around in case a component gets redrawn.
   * @param {Object} payloadJsonObject the volatile state data to store until navigation
   */
  AmxNode.prototype.setVolatileState = function(payloadJsonObject)
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getVolatileStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
	  			stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Get the converter, if set, for this node.
   */
  AmxNode.prototype.getConverter = function()
  {
    return this._converter;
  };

  /**
   * Set the converter for this node.
   */
  AmxNode.prototype.setConverter = function(converter)
  {
    this._converter = converter;
  };

  /**
   * For an attribute, create and store an EL expression that may be used to set EL values
   * into the model. The value is context insensitive and may be used to set a value at any
   * time. Common use is to set a value based on user interaction. May be called by type
   * handlers.
   *
   * @param {string} name the name of the attribute
   * @return {(string|null)} the modifyable EL. Also stored on the node. Returns null if the
   *         attribute in question is not bound to an EL value.
   */
  AmxNode.prototype.storeModifyableEl = function(name)
  {
    var tag = this.getTag();
    if (tag.isAttributeElBound(name))
    {
      var el = this.getAttributeExpression(name, false, true);
      el = el.toContextFreeExpression();
      this._modifiableEl[name] = el;
      return el;
    }
    else
    {
      return null;
    }
  };

  /**
   * Initializes the node, performing any EL evaluation and any other pre-render logic.
   * Called by the framework. It is expected for the state to be WAITING_ON_EL_EVALUATION,
   * ABLE_TO_RENDER or UNRENDERED after invoking this function. This function also creates
   * the children AMX nodes once the status is WAITING_ON_EL_EVALUATION, but does not
   * initialize them.
   */
  AmxNode.prototype.init = function()
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Initialize AMX node", adf.mf.log.level.FINEST, null);
    var state = this.getState();
    var tag = this.getTag();
    var attr = tag.getAttributes();
    var name = null;

    try
    {
      // Create a unique ID that is based on the stamped key, if present.
      this._createUniqueId();

      // Set Call instance name after unique id has been created
      var instanceName = tag.getName() + ":" + this.getId();
      perf.setInstanceName(instanceName);

      // TODO: although no types currently need to customize how attributes
      // are loaded, we really need a method to allow the type handlers to
      // control what attributes are processed and how they are processed.
      // Due to time constraints and the desire to make sure the API is solid,
      // it is not being added at this time.

      // Process the rendered attribute if we haven't already
      var cacheMiss = this._processAttribute("rendered");

      if (cacheMiss)
      {
        // Ensure the state is still INITIAL so that the building
        // of the node hierarchy does not continue
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);

        // At this time, only setup the data change events for the rendered attribute
        this._registerRenderedAttributeForDataChange();

        return;
      }

      if (!this.getAttribute("rendered"))
      {
        if (this.getAttributeExpression("rendered") != null)
        {
          // Hookup data change events on the rendered attribute when EL bound
          this._registerRenderedAttributeForDataChange();
        }

        // Update the state
        this.setState(adf.mf.api.amx.AmxNodeStates["UNRENDERED"]);
        return;
      }

      for (name in attr)
      {
        // ID and rendered attributes have already been processed
        if (name == "rendered" || name == "id")
        {
          continue;
        }

        this._processAttribute(name);
      }

      // Now, look for a converter tag
      this._processConverterTag();

      // Update the state to reflect if all the EL is available
      this.setState(this._tagInstancesWaitingOnEl == 0 &&
        this._attributesWaitingOnEl == 0 ?
        adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"] :
        adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);

      state = this.getState();
      if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
        state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
      {
        // Once all the necessary EL has been loaded, create the children nodes,
        // but do not initialize them
        this._createChildren();

        state = this.getState();
        if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
          state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
        {
          if (this._processConverter())
          {
            this._convertValue();
          }
        }
      }

      // Setup validation of the input value of this node if there is one
      this._setupInputValueValidation();

      // Finally hook up the data change events
      this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(
        this._getAttributesExpressionMap());
      this._postProcessForDataChangeNotification(true);
    }
    finally
    {
      perf.stop();
    }
  };

  /**
   * Get the stamp key for the AMX node. The stamp key identifies AMX nodes that are produced inside of
   * iterating containers. This is provided by the parent node. An example tag that uses stamp keys is
   * the AMX iterator tag.
   * @return {(Object|null)} the key or null if the node was not stamped
   */
  AmxNode.prototype.getStampKey = function()
  {
    return this._key;
  };

  /**
   * Get a list of the attribute names that have been defined for this node.
   * @return {Array.<string>} array of the attribute names
   */
  AmxNode.prototype.getDefinedAttributeNames = function()
  {
    var names = [];
    for (var name in this._attr)
    {
      names.push(name);
    }
    return names;
  };

  /**
   * Gets an attribute value for the attribute of the given name.
   * @param {string} name the name of the attribute
   * @return {(Object|null|undefined)} returns the value (may be null) or
   *         undefined if the attribute is not set or is not yet loaded.
   */
  AmxNode.prototype.getAttribute = function(name)
  {
    return this._attr[name];
  };

  /**
   * Given the name of an attribute, get the EL expression.
   *
   * @param {string} name the name of the attribute
   * @param {boolean=} returnStaticValue if true and the attribute is not EL bound, the string
   *        value of the attribute from the tag will be returned or undefined if the attribute is
   *        not defined on the tag
   * @param {boolean} returnEL if true, the ELExpression value of the attribute from the tag
   *        will be returned or undefined if the attribute is not defined on the tag.
   *        If false, it will return String representation of EL Expression.
   * @return {(string|null)} the EL expression if the attribute is EL bound, otherwise null.
   */
  AmxNode.prototype.getAttributeExpression = function(
    name,
    returnStaticValue,
    returnEL)
  {
    var tag = this.getTag();

    // See if this attribute is an EL expression
    if (!tag.isAttributeElBound(name))
    {
      return (returnStaticValue === true) ? tag.getAttribute(name) : null;
    }

    var expr;
    if (this._elAttributeMap != null)
    {
      expr = this._elAttributeMap[name];
      if (expr != null)
      {
        return returnEL ? expr: expr.getExpression();
      }
    }

    var value = tag.getAttribute(name);

    var expr = adf.mf.internal.el.parser.parse(value);
    expr = AmxNode.__performElSubstitutions(expr);

    if (expr != null)
    {
      if (this._elAttributeMap == null)
      {
        this._elAttributeMap = {};
      }

      this._elAttributeMap[name] = expr;
    }

    return returnEL ? expr : expr.getExpression();
  };

  /**
   * Used by the type handler or the framework to store the attribute value for an attribute onto
   * the node. This function does not update the model.
   * @param {string} name the name of the attribute
   * @param {object} value the value of the attribute
   */
  AmxNode.prototype.setAttributeResolvedValue = function(name, value)
  {
    this._attr[name] = value;
  };

  /**
   * For use by type handlers to set the value of an attribute on the model. This value will be sent
   * to the Java side to update the EL value. The value on the AMX node will not be updated by this
   * call, it is expected that a data change event will result to update the AMX node.
   * @param {string} name the name of the attribute
   * @param {object} value the new value of the attribute
   */
  AmxNode.prototype.setAttribute = function(name, value)
  {
    var that = this;
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        var el = that._modifiableEl[name];

        if (el == null)
        {
          var tag = that.getTag();

          // If the EL is null, then this will not work if the node is
          // not in context. Try to set the EL using the raw EL from the tag
          //
          // First, ensure the attribute is EL bound
          if (tag.isAttributeElBound(name))
          {
            el = that.getTag().getAttribute(name);
          }
        }

        that.setAttributeResolvedValue(name, value);

        if (el == null)
        {
          // If this attribute was not EL based, just resolve the promise
          resolve();
        }
        else
        {
          var oldValue = that.getAttribute(name);
          var p = {"name": el, "value": value};
          if (!el.indexOf) {
              p["name"] = el.getExpression();
              p["expression"] = el;
          }
          amx.setElValue(p)
            .then(
              function()
              {
                resolve();
              },
              function()
              {
                that.setAttributeResolvedValue(name, oldValue);
              });
        }
      }); // TODO We do not want to support/document that this returns a promise object resolved once the
          //      value has been set. Instead, we ought to provide success/failed callbacks as parameters.
  };

  /**
   * Check if the attribute has been specified.
   * @param {string} name the name of the attribute
   * @return {boolean} true if the attribute was defined by the user
   */
  AmxNode.prototype.isAttributeDefined = function(name)
  {
    return this._tag.getAttribute(name) !== undefined;
  };

  /**
   * Get the parent AMX node.
   * @return {(adf.mf.api.amx.AmxNode|null)} the parent node or null for the top level
   *         node.
   */
  AmxNode.prototype.getParent = function()
  {
    return this._parent;
  };

  /**
   * Adds a child AMX node to this node. Should only be called by the framework or the type handler.
   * @param {adf.mf.api.amx.AmxNode} child the child to add
   * @param {(string|null)} facetName the name of the facet or null if the child does not belong in a
   *        facet.
   */
  AmxNode.prototype.addChild = function(child, facetName)
  {
    var key = child.getStampKey();
    var children;
    if (facetName == null)
    {
      children = this._children[key];
      if (children == null)
      {
        this._children[key] = children = [];
      }
    }
    else
    {
      var facets = this._facets[key];
      if (facets == null)
      {
        facets = this._facets[key] = {};
      }
      children = facets[facetName];
      if (children == null)
      {
        facets[facetName] = children = [];
      }
    }

    children.push(child);
  };

  /**
   * Remove a child node from this node. Note that the AMX node will be removed from the hierarchy,
   * but not the DOM for that node. It is up to the caller to remove the DOM. This is to allow
   * type handlers to handle animation and other transitions when DOM is replaced.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode the node to remove
   * @return {boolean} true if the node was found and removed.
   */
  AmxNode.prototype.removeChild = function(amxNode)
  {
    var key = amxNode.getStampKey();
    var nodeId = amxNode.getId();
    var state = amxNode.getState();
    var result = this._findChildIndexAndFacetName(key, nodeId);

    if (result == null)
    {
      return false;
    }

    amxNode._removeFromDataChangeNotification(true);

    var facetName = result["facetName"];
    var childrenArray = null;
    var index = result["index"];

    if (facetName == null)
    {
      childrenArray = this._children[key];
    }
    else
    {
      childrenArray = this._facets[key][facetName];
    }

    // Splice updates the array in place
    childrenArray.splice(index, 1);

    return true;
  };

  /**
   * Removes any children that are present with the given stamp key
   * @param {object} stampKey the key to use to find the nodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of the nodes removed
   */
  AmxNode.prototype.removeChildrenByKey = function(
    stampKey)
  {
    var removed = [];

    // Note, slice used to create a copy so it will not be modified during changes
    var children = this.getChildren(null, stampKey).slice();

    for (var c = 0, numChildren = children.length; c < numChildren; ++c)
    {
      var child = children[c];
      if (this.removeChild(child))
      {
        removed.push(child);
      }
    }

    return removed;
  };

  /**
   * Replace a child node with a new node.
   * @param {adf.mf.api.amx.AmxNode} oldNode the node to replace
   * @param {adf.mf.api.amx.AmxNode} newNode the replacement node
   * @return {boolean} true if the old node was found and replaced.
   */
  AmxNode.prototype.replaceChild = function(
    oldNode,
    newNode)
  {
    var key = oldNode.getStampKey();
    var nodeId = oldNode.getId();
    var result = this._findChildIndexAndFacetName(key, nodeId);
    if (result == null)
    {
      return false;
    }

    oldNode._removeFromDataChangeNotification(true);

    var facetName = result["facetName"];
    if (facetName == null)
    {
      this._children[key][result["index"]] = newNode;
    }
    else
    {
      var facetChildren = this._facets[key][facetName];
      facetChildren[result["index"]] = newNode;
    }

    return true;
  };

  /**
   * Get the children AMX nodes.
   * @param {(string|null|undefined)} facetName the name of the facet to retrieve the children
   *        or null to get the non-facet children.
   * @param {(Object|null|undefined)} key An optional key to specify for stamping. If provided, it will retrieve
   *        the children AMX nodes for a given stamping key.
   * @return {Array.<adf.mf.api.amx.AmxNode>} an array of the children AMX nodes. Returns an empty array
   *         if no children exist or if there are no children for the given stamp key.
   */
  AmxNode.prototype.getChildren = function(facetName, key)
  {
    if (key === undefined)
    {
      key = null;
    }

    var children;
    if (facetName == null)
    {
      children = this._children[key];
    }
    else
    {
      var facets = this._facets[key];
      if (facets == null)
      {
        return [];
      }

      children = facets[facetName];
    }

    return children == null ? [] : children;
  };

  /**
   * Get all of the facets of the AMX node.
   * @param {(Object|null|undefined)} key An optional key to specify for stamping. If provided, it will retrieve
   *        the facet AMX nodes for a given stamping key.
   * @return {Object.<string, Array.<adf.mf.api.amx.AmxNode>>} map of facets defined for the node
   */
  AmxNode.prototype.getFacets = function(key)
  {
    if (key === undefined)
    {
      key = null;
    }

    var facets = this._facets[key];
    return facets == null ? {} : facets;
  };

  /**
   * Perform a tree visitation starting from this node.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visit = function(
    context,
    callback)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "visit"))
    {
      return th.visit(this, context, callback);
    }

    if (context.isVisitAll() || context.getNodesToVisit().indexOf(this) >= 0)
    {
      var result = callback(context, this);
      switch (result)
      {
        case adf.mf.api.amx.VisitResult["ACCEPT"]:
          return this.visitChildren(context, callback);

        case adf.mf.api.amx.VisitResult["REJECT"]:
          return false;

        case adf.mf.api.amx.VisitResult["COMPLETE"]:
        default:
          return true;
      }
    }

    return this.visitChildren(context, callback);
  };

  /**
   * Perform a tree visitation of the children of the node.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visitChildren = function(
    context,
    callback)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "visitChildren"))
    {
      return th.visitChildren(this, context, callback);
    }

    return this.visitStampedChildren(null, null, null,
      context, callback);
  };

  /**
   * Convenience function for type handlers that stamp their children to
   * visit the children AMX nodes from inside of a custom visitChildren
   * function.
   *
   * @param {object} key the stamp key of the children to visit.
   * @param {(Array.<string>|null)} facetNamesToInclude list of facet names to visit.
   *        If empty the facets will not be processed for this
   *        stamp. If null, all the facets will be processed. To visit the children of
   *        non-facets, include null in the array.
   * @param {(function|null)} filterCallback an optional function to filter the children
   *        to visit. The function will be invoked with this node,
   *        the stamp key, and the child node.
   *        Function must return a boolean. If true, the tag will be used to create
   *        children, if false the tag will not be processed.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visitStampedChildren = function(
    key,
    facetNamesToInclude,
    filterCallback,
    visitContext,
    visitCallback)
  {
    var visitAll = visitContext.isVisitAll();
    var nodesToWalk = visitContext.getNodesToWalk();

    var facetNames;
    if (facetNamesToInclude == null)
    {
      facetNames = [];
      var facets = this.getFacets(key);
      for (var name in facets)
      {
        facetNames.push(name);
      }
      facetNames.push(null);
    }
    else
    {
      facetNames = facetNamesToInclude;
    }

    for (var f = 0, numFacets = facetNames.length; f < numFacets; ++f)
    {
      var facetName = facetNames[f];
      var children = this.getChildren(facetName, key);
      // Loop through all the children, note if the facet name is null
      // then we are visiting the direct (non-facet) children.
      for (var i = 0, size = children.length; i < size; ++i)
      {
        var child = children[i];
        // See if we are visiting all or if the node is one to be visited
        if (visitAll || nodesToWalk.indexOf(child) >= 0)
        {
          // If there is a filter function, call it to see if this node
          // should be visited
          if (filterCallback == null ||
            filterCallback(this, key, child))
          {
            if (child.visit(visitContext, visitCallback))
            {
              return true;
            }
          }
        }
      }
    }

    return false;
  };

  /**
   * Get the rendered children of the AMX node.
   * @param {(string|null)} facetName the name of the facet to retrieve the rendered children for
   *        or null to get the rendered children outside of the facets.
   * @param {(Object|null)} key An optional key to specify for stamping. If provided, it will
   *        retrieve the children AMX nodes for a given stamping key.
   * @return {Array.<adf.mf.api.amx.AmxNode>} the children that should be rendered for the given
   *         stamp key. This function will flatten any flattenable components and will not return
   *         any non-rendered nodes.
   */
  AmxNode.prototype.getRenderedChildren = function(facetName, key)
  {
    var result = [];
    var children = this.getChildren(facetName, key);

    for (var i = 0, size = children.length; i < size; ++i)
    {
      var vc = new adf.mf.api.amx.VisitContext();
      var child = children[i];

      child.visit(vc,
        function (context, node)
        {
          if (!node.isReadyToRender())
          {
            return adf.mf.api.amx.VisitResult["REJECT"];
          }

          // Skip over any flattened nodes. Note that this means that the type handler
          // will never be called for preDestroy and destroy as those functions are currently
          // based on DOM nodes, not AMX nodes.
          if (node.isFlattenable())
          {
            // To support the functionality of amx:facetRef, use a "__getRenderedChildren" method
            // to allow the facet reference to resolve the children to be rendered as the children
            // of the fragment facet tag. The "__" prefix is used as this should not be consumed
            // by 3rd party type handlers, it is specifically for internal use only.
            var th = node.getTypeHandler();
            if (adf.mf.internal.amx.implementsFunction(th, "__getRenderedChildren"))
            {
              var nodes = th.__getRenderedChildren(node);
              result.push.apply(result, nodes);
              return adf.mf.api.amx.VisitResult["REJECT"];
            }

            return adf.mf.api.amx.VisitResult["ACCEPT"];
          }

          result.push(node);
          return adf.mf.api.amx.VisitResult["REJECT"];
        });
    }

    return result;
  };

  /**
   * Get if the node is flattenable. A flattened node produces no HTML but instead provides
   * information to the parent or about how the children should be handled. Allows for customizing
   * the creation of children nodes as well.
   *
   * @return {boolean} true if the node is flattenable
   */
  AmxNode.prototype.isFlattenable = function()
  {
    var th = this.getTypeHandler();
    return adf.mf.internal.amx.implementsFunction(th, "isFlattenable") && th.isFlattenable(this);
  };

  /**
   * Get the current state of the node.
   * @return {int} the current state, as a constant value from adf.mf.api.amx.AmxNodeStates.
   */
  AmxNode.prototype.getState = function()
  {
    return this._state;
  };

  /**
   * Moves the state of the node. Should only be called by the framework or the node's type handler.
   * @param {int} state the new state of the node
   */
  AmxNode.prototype.setState = function(state)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "setState",
        "Setting state of AmxNode " + this.getId() + " to " +
        adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
    }

    // Check the new state and see if the page busy tracker needs to
    // be updated
    switch (state)
    {
      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
      case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
      {
        switch (this._state)
        {
          case adf.mf.api.amx.AmxNodeStates["UNRENDERED"]:
          case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
          case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
          {
            // The node was "resolved" but now will be waiting on a condition. Mark the node as
            // being in a pending state
            adf.mf.internal.amx._pageBusyTracker.increment();
            break;
          }
        }
        break;
      }
      // ABLE_TO_RENDER, RENDERED, UNRENDERED
      default:
      {
        switch (this._state)
        {
          case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
          case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
          case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
          {
            // The node was waiting on a condition but now is "resolved"
            adf.mf.internal.amx._pageBusyTracker.decrement();
            break;
          }
        }
        break;
      }
    }
    this._state = state;
  };

  /**
   * @deprecated use render instead
   */
  AmxNode.prototype.renderNode = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderNode", "MSG_DEPRECATED", "amxNode.renderNode", "amxNode.render");

    var renderResult = this.render();
    return renderResult;
  };

  /**
   * Render the AmxNode.
   *
   * @return {(HTMLElement|null)} the root HTML element for this AmxNode or null if there is no type
   *   handler for this node
   */
  AmxNode.prototype.render = function()
  {
    var domNode = null;

    // facet are not rendered as they should be handled by the parent
    var tag = this.getTag();
    if (tag.isUITag())
    {
      // if there are a "rendered" property set to false, then, we do not render
      if (this.getAttribute("rendered") === false)
      {
        // domNode will be null
      }
      else
      {
        var nodeTypeHandler = this.getTypeHandler();

        // if renderer found
        if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "render"))
        {
          var id = this.getId();
          if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.api.amx.AmxNode", "renderNode",
              "Rendering AmxNode " + id);
          }

          domNode = nodeTypeHandler.render(this, id);

          // render the AmxNode
          try
          {
            domNode.setAttribute("id", id);
          }
          catch (ex)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle",
              adf.mf.log.level.SEVERE, "renderNode", "MSG_AMX_NODE_RENDER_FAILED",
              this.getTag().getNsPrefixedName());

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx.AmxNode", "render",
                "Setting the ID attribute failed for tag " +
                this.getTag().getNsPrefixedName() + " with ID " + id + " error: " + ex);
            }

            return null;
          }

          try
          {
            // Add this AmxNode to init and post display queues
            if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "init"))
            {
              amx.queueForInit(this);
            }
            if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "postDisplay"))
            {
              amx.queueForPostDisplay(this);
            }

            adf.mf.internal.amx._setNonPrimitiveElementData(domNode, "amxNode", this);

            // add the amx classes
            domNode.classList.add("amx-node");
            if (tag._rootClassName == null)
            {
              var theNamespace = tag.getNamespace();
              if (theNamespace == adf.mf.api.amx.AmxTag.NAMESPACE_AMX)
              {
                tag._rootClassName = "amx-" + tag.getName();
              }
              else if (theNamespace == adf.mf.api.amx.AmxTag.NAMESPACE_DVTM)
              {
                tag._rootClassName = "dvtm-" + tag.getName();
              }
              else
              {
                tag._rootClassName = ""; // custom components should add their own class names
              }
            }
            if (tag._rootClassName != "")
            {
              domNode.classList.add(tag._rootClassName);
            }
            var styleClass = this.getAttribute("styleClass");
            if (styleClass != null && styleClass != "")
            {
              if (adf.mf.environment.profile.dtMode)
              {
                // if adf.mf.environment.profile.dtMode, remove el
                styleClass = styleClass.replace(/#\{(.*?)\}/ig, ' ');
              }
              var splits = styleClass.split(" ");
              for (var i=0, count=splits.length; i<count; ++i)
              {
                var split = splits[i];
                if ("" != split)
                  domNode.classList.add(split);
              }
            }
            if (adf.mf.api.amx.isValueTrue(this.getAttribute("readOnly")))
            {
              domNode.classList.add("amx-readOnly");
            }
            if (adf.mf.api.amx.isValueTrue(this.getAttribute("disabled")))
            {
              domNode.classList.add("amx-disabled");
            }
            if (typeof nodeTypeHandler.destroy === "function")
            {
              domNode.classList.add("amx-has-destroy");
            }
            if (typeof nodeTypeHandler.preDestroy === "function")
            {
              domNode.classList.add("amx-has-predestroy");
            }

            // add the eventual inlineStyle
            var inlineStyle = this.getAttribute("inlineStyle");
            if (inlineStyle)
            {
              if (adf.mf.environment.profile.dtMode)
              {
                // if adf.mf.environment.profile.dtMode, remove el
                inlineStyle = inlineStyle.replace(/#\{(.*?)\}/ig, ' ');
              }
              var existingStyle = domNode.getAttribute("style");
              if (existingStyle == null)
                domNode.setAttribute("style", inlineStyle);
              else
                domNode.setAttribute("style", existingStyle + ";" + inlineStyle);
            }

            this._applyClientListenerAssociations(domNode);
          }
          catch (ex)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.amx.AmxNode.render", "MSG_AMX_NODE_RENDER_FAILED",
              this.getTag().getNsPrefixedName());

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx.AmxNode", "render",
                "Error rendering tag " +
                this.getTag().getNsPrefixedName() + " with ID " + this.getId() + " error: " + ex);
            }
          }
        }
        else
        {
          adf.mf.log.logInfoResource("AMXInfoBundle",
            adf.mf.log.level.WARNING, "render", "MSG_NO_RENDERER",
            this.getTag().getNsPrefixedName());
        }
      }
    }

    if (this.getState() != adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"])
    {
      this.setState(adf.mf.api.amx.AmxNodeStates["RENDERED"]);
    }

    return domNode;
  };

  /**
   * Apply clientListener event type associations.
   * @param {HTMLElement} rootElement the root element of this component
   */
  AmxNode.prototype._applyClientListenerAssociations = function(rootElement)
  {
    var clientListenerTypes = this.getAttribute("data-clientListenerTypes");
    if (clientListenerTypes)
    {
      var amxNodeId = this.getId();
      var th = this.getTypeHandler();
      for (var eventType in clientListenerTypes)
        th.__experimentalCLAssociation(
          this,
          amxNodeId,
          eventType,
          rootElement); // TODO what if the type or method changes due to DCEs?
    }
  };

  /**
   * @deprecated
   */
  AmxNode.prototype.renderSubNodes = function(facetName, key)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amxNode.renderSubNodes", "MSG_DEPRECATED",
      "amxNode.renderSubNodes", "amxNode.renderDescendants");

    var arrayOfHtmlElements = this.renderDescendants(facetName, key);
    var subNodes = [];
    for (var i=0, size=arrayOfHtmlElements.length; i<size; ++i)
    {
      var elementToAdd = arrayOfHtmlElements[i];
      subNodes.push(elementToAdd);
    }
    return subNodes;
  };

  /**
   * Renders the sub-AmxNodes of this AmxNode.
   * @param {(string|null)} facetName the name of the facet to render the children for or null
   *        to render the non-facet children.
   * @param {(Object|null)} key An optional key to specify for stamping. If provided, it will render
   *        the children AMX nodes for a given stamping key.
   * @return {Array<HtmlElement>} array of all of the rendered HTML nodes
   */
  AmxNode.prototype.renderDescendants = function(facetName, key)
  {
    var arrayOfHtmlElements = [];
    var children = this.getRenderedChildren(facetName, key);
    for (var i=0, size=children.length; i<size; ++i)
    {
      var childAmxNode = children[i];
      var subElement = childAmxNode.render();
      if (subElement)
      {
        arrayOfHtmlElements.push(subElement);
      }
    }

    return arrayOfHtmlElements;
  };

  /**
   * @deprecated
   */
  AmxNode.prototype.rerenderNode = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amxNode.rerenderNode", "MSG_DEPRECATED", "amxNode.rerenderNode", "amxNode.rerender");

    this.rerender();
  };

  /**
   * Re-renders the AmxNode.
   */
  AmxNode.prototype.rerender = function()
  {
    var oldDomNode = document.getElementById(this.getId());
    if (oldDomNode == null)
    {
      var amxNode = this.__getRenderingParent().__getClosestRenderedNode();
      if (amxNode != null)
      {
        amxNode.rerender();
      }
      return;
    }

    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "rerenderNode",
        "Re-rendering AmxNode " + this.getId());
    }

    var newDomNode = this.render();
    if (newDomNode)
    {
      oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
    }
    adf.mf.api.amx.removeDomNode(oldDomNode);
    // rerender function is called independently from outside of the amx core so
    // init and postDisplay have to be invoked now to ensure that the node
    // will be fully initialized
    if (amx.mustProcessQueues === true)
    {
      amx.processAndCleanInitQueue();
      amx.processAndCleanPostDisplayQueue();
    }
  };

  /**
   * Checks the state of the node to see if the node was rendered or is able to be be rendered.
   * The node is considered to be renderable if it is in the ABLE_TO_RENDER,
   * RENDERED or PARTIALLY_RENDERED state.
   *
   * @return {boolean} true if the node was rendered or should be rendered.
   */
  AmxNode.prototype.isReadyToRender = function()
  {
    switch (this.getState())
    {
      case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
      case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        return true;
      default:
        return false;
    }
  };

  /**
   * Checks if a node was rendered and the DOM is still present on the page.
   *
   * @return {boolean} true if the node was rendered and it's DOM node is present on the page
   */
  AmxNode.prototype.isRendered = function()
  {
    switch (this.getState())
    {
      // Note that WAITING_ON_EL_EVALUATION may be the state if updateAttributes set it to that
      // value after the state was previously PARTIALLY_RENDERED
      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
      case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        return document.getElementById(this.getId()) != null;
      default:
        return false;
    }
  };

  /**
   * Called to refresh the HTML of a node. This method is called after the updateChildren
   * method and should be implemented by type handlers that wish to update their DOM in
   * response to a change.
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {(adf.mf.api.amx.AmxDescendentChanges|null)} descendentChanges the changes for any
   *        descendent nodes that need to be refreshed.
   */
  AmxNode.prototype.refresh = function(attributeChanges, descendentChanges)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "refresh"))
    {
      th.refresh(this, attributeChanges, descendentChanges);
    }
  };

  /**
   * Applies any attribute changes. Usually called as a result of the data change
   * framework.
   *
   * @param {Object.<string, boolean>} affectedAttributes object with keys of the
   *        attribute names that have changed and a value of true.
   * @param {Object.<string, adf.mf.api.amx.AmxCollectionChange>} collectionChanges the change
   *        details for collection attributes that have changed
   * @return {adf.mf.api.amx.AmxAttributeChange} returns the changed properties and their old
   *         values.
   */
  AmxNode.prototype.updateAttributes = function(affectedAttributes, collectionChanges)
  {
    // First, update the attributes that have changed
    var changes = new adf.mf.api.amx.AmxAttributeChange();
    var cacheMiss = false;

    // See if one of the affected attributes is the rendered attribute
    if (affectedAttributes["rendered"])
    {
      var oldValue = this.getAttribute("rendered");
      var cacheMiss = this._processAttribute("rendered");

      if (cacheMiss)
      {
        // The new value is not in the EL cache
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);
        changes.__addChangedAttribute("rendered", oldValue);
        return changes;
      }

      // Ensure a boolean type
      var newValue = this.getAttribute("rendered");
      if (oldValue != newValue)
      {
        changes.__addChangedAttribute("rendered", oldValue, null);

        if (!newValue)
        {
          // The node is no longer rendered. Remove any children and any other
          // properties that do not need to be kept anymore
          this._removeFromDataChangeNotification(false);
          this._facets = {};
          this._children = {};
          this._modifiableEl = {};
          this._childrenCreated = false;
          this._converter = null;
          this._tagInstances = null;
          this._elDependencies = null;
          this._tagInstanceIdsWaitingOnEl = {};
          this._tagInstancesWaitingOnEl = 0;

          // Update the state
          this.setState(adf.mf.api.amx.AmxNodeStates["UNRENDERED"]);

          // Register for data change events only on the rendered attribute
          this._registerRenderedAttributeForDataChange();

          // Don't process any more attribute changes on unrendered nodes.
          return changes;
        }

        // The node was not rendered but now is. Allow the rest of the attributes
        // to be process. First, change the state to INITIAL so that the children
        // may be built. This will result in the init method being called again for this
        // node.
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);

        // Return the old values to the caller
        return changes;
      }
    }

    // If the node is not rendered, then do not process any other attributes
    if (this.getState() == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
    {
      return changes;
    }

    // At this point, the rendered attribute has not changed, just process the changed
    // attributes
    for (var attrName in affectedAttributes)
    {
      if (attrName == "rendered")
      {
        continue;
      }

      var oldValue = this.getAttribute(attrName);
      cacheMiss = this._processAttribute(attrName) || cacheMiss;

      var collectionChange = collectionChanges == null ? null : collectionChanges[attrName];
      changes.__addChangedAttribute(attrName, oldValue, collectionChange);
    }

    // Update the state to reflect if all the EL is available
    if (cacheMiss && this.isReadyToRender())
    {
      // Update the state, if necessary, to reflect that the node does not have all
      // the required attributes.
      this.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
    else if (this._tagInstancesWaitingOnEl == 0 && this._attributesWaitingOnEl == 0 &&
      this.getState() == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"])
    {
      this.setState(adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]);
    }

    return changes;
  };

  /**
   * Process any necessary updates to the children AMX nodes during an attribute
   * change. This is called after the updateAttributes function and before the refresh
   * function. Type handlers may implement a function updateChildren with the amx node and
   * the old attribute values as the parameters. The implementation of the function should
   * remove any old children and create and add any new children to the AMX node. The
   * framework will initialize the children and call the refresh function on the nodes
   * once they are ready to render.
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  AmxNode.prototype.updateChildren = function(attributeChanges)
  {
    // See if the node ever created children
    if (this._childrenCreated)
    {
      var th = this.getTypeHandler();

      // Do not call the type handler if no attributes have changed. This will happen if the
      // tag instances have changed and not any attributes
      if (attributeChanges.getSize() > 0)
      {
        if (adf.mf.internal.amx.implementsFunction(th, "updateChildren"))
        {
          // Note that the type handler should check for styleClass and
          // inlineStyle and return REFRESH for those if implementing a custom
          // updateChildren or use the result from defaultUpdateChildren
          return th.updateChildren(this, attributeChanges);
        }

        return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
      }
      else
      {
        // Do not rerender nodes if only the tag instances have been updated
        return adf.mf.api.amx.AmxNodeChangeResult["NONE"];
      }
    }
    else
    {
      // The node never created its children, so use the _createChildren
      // method instead of the updateChildren
      state = this.getState();
      if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
        this.isReadyToRender())
      {
        this._createChildren();
      }

      return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
    }
  };

  /**
   * Convenience function for type handlers that stamp their children to
   * create the children AMX nodes from inside of a custom createChildrenNodes
   * function. It will create children for any UI tags.
   *
   * @param {object} key the stamp key to use
   * @param {(Array.<string>|null)} facetNamesToInclude list of facet names to create
   *        children for. If empty the facets will not be processed for this
   *        stamp. If null, all the facets will be processed. Include a null value
   *        inside the array to create children for non-facet tags.
   * @param {(function|null)} filterCallback an optional function to filter the children
   *        to create the children for. The function will be invoked with the node,
   *        the stamp key, the child tag and the facet name (or null for non-facets).
   *        Function must return a boolean. If true, the tag will be used to create
   *        children, if false the tag will not be processed.
   * @return {Array.<adf.mf.api.amx.AmxNode>} the children that were created
   */
  AmxNode.prototype.createStampedChildren = function(
    key,
    facetNamesToInclude,
    filterCallback)
  {
    var tag = this.getTag();
    var node, i, size;
    var created = [];

    // First create the AMX nodes for the facets
    if (facetNamesToInclude == null || facetNamesToInclude.length > 0)
    {
      var facetTags = tag.getChildrenFacetTags();
      for (i = 0, size = facetTags.length; i < size; ++i)
      {
        var facetData = facetTags[i].getFacet();
        var facetName = facetData["name"];

        if (facetNamesToInclude != null &&
          facetNamesToInclude.length > 0 &&
          facetNamesToInclude.indexOf(facetName) == -1)
        {
          continue;
        }

        var facetTagChildren = facetData["children"];

        for (var j = 0, facetChildrenSize = facetTagChildren.length;
          j < facetChildrenSize; ++j)
        {
          var facetTag = facetTagChildren[j];
          if (!facetTag.isUITag())
          {
            continue;
          }

          if (filterCallback == null ||
            filterCallback(this, key, facetTag, facetName))
          {
            node = facetTag.buildAmxNode(this, key);
            created.push(node);
            this.addChild(node, facetName);
          }
        }
      }
    }

    // Create the nodes for the children
    if (facetNamesToInclude == null ||
      facetNamesToInclude.indexOf(null) >= 0)
    {
      var childrenUiTags = tag.getChildrenUITags();
      for (i = 0, size = childrenUiTags.length; i < size; ++i)
      {
        var childTag = childrenUiTags[i];

        if (filterCallback == null ||
          filterCallback(this, key, childTag, null))
        {
          node = childTag.buildAmxNode(this, key);
          created.push(node);
          this.addChild(node);
        }
      }
    }

    return created;
  };

  /**
   * Attempts to find a parent AMX node by its tag's namespace and tag name
   *
   * @param {string} ns the namespace
   * @param {string} tagName the tag name
   * @return {(adf.mf.api.amx.AmxNode|null)} the ancestor AMX node or null if not found
   */
  AmxNode.prototype.findAncestorByTag = function(
    ns,
    tagName)
  {
    for (var amxNode = this.getParent(); amxNode != null; amxNode = amxNode.getParent())
    {
      var tag = amxNode.getTag();
      if (tag.getName() == tagName && tag.getNamespace() == ns)
      {
        return amxNode;
      }
    }

    return null;
  };

  /**
   * Attempts to find an AMX node relative to the current node by its XML ID. This will search in
   * the current naming container for the given node. If not found, it will look in the parent
   * naming container. By providing colons in the string, the code will search for children of
   * found parent nodes.
   *
   * @param {string} xmlIdSearchExpression the XML ID optionally separated by colons for a hierarchy of nodes.
   * @param {boolean} if true the code will search in parent files. If false, it will only check
   *        the current file
   * @return {(adf.mf.api.amx.AmxNode|null)} the node if found
   */
  AmxNode.prototype.findRelativeAmxNode = function(
    xmlIdSearchExpression,
    searchAcrossMultiplePages)
  {
    var namingContainerInfo = this._findNamingContainerAndStampKey();
    var idsToFind = xmlIdSearchExpression.split(":");
    var ncAmxNode = namingContainerInfo["amxNode"];
    var amxNode = ncAmxNode;

    for (var i = 0, numIds = idsToFind.length; i < numIds && amxNode != null; ++i)
    {
      amxNode = amxNode._findAmxNode(idsToFind[0], i == 0 ? namingContainerInfo["stampKey"] : null);
    }

    if (amxNode == null)
    {
      var tag = ncAmxNode.getTag();
      var parent = ncAmxNode.getParent();

      if (parent == null ||
        (tag.getName() == "fragment" && tag.getNamespace() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX &&
          searchAcrossMultiplePages != true))
      {
        return null;
      }

      // Search the naming container above the current one
      return parent.findRelativeAmxNode(xmlIdSearchExpression, searchAcrossMultiplePages);
    }

    return amxNode;
  };

  /**
   * Update the tag instance attributes. This is usually called as a result of a data change
   * event. Currently internal until a formal API can be fully designed
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the arguments to the
   *                                                markNodeForUpdate call.
   * @ignore
   */
  AmxNode.prototype.__updateTagInstanceAttributes = function(nodeUpdateArguments)
  {
    var amxNodeId = this.getId();
    var affectedInstanceIds = nodeUpdateArguments.__getAffectedTagInstanceIds(amxNodeId);
    var numInstances = affectedInstanceIds.length;

    if (numInstances > 0)
    {
      var th = this.getTypeHandler();
      // Delegate to the type handler if the custom function has been provided
      var typeHandlerHasNotifyMethod = adf.mf.internal.amx.implementsFunction(
        th, "__tagInstanceUpdated");

      for (var i = 0; i < numInstances; ++i)
      {
        var tagInstanceId = affectedInstanceIds[i];
        var affectedAttributes = nodeUpdateArguments.__getAffectedAttributesForTagInstance(
          amxNodeId, tagInstanceId);

        var tagInstance = this._tagInstances[tagInstanceId];
        tagInstance.updateAttributes(affectedAttributes);

        if (this._tagInstanceIdsWaitingOnEl[tagInstanceId] &&
          tagInstance.getState() == adf.mf.internal.amx.AmxTagInstanceStates["LOADED"])
        {
          delete this._tagInstanceIdsWaitingOnEl[tagInstanceId];
          --this._tagInstancesWaitingOnEl;
        }

        if (typeHandlerHasNotifyMethod)
        {
          // Use a temporary API to notify the type handler that a tag instance has been updated.
          // This API needs to be improved before making public (same with the entire tag instance
          // API)
          th.__tagInstanceUpdated(this, tagInstance);
        }
      }

      // See if the node is now ready to render (if all the EL is now loaded)
      if (this._tagInstancesWaitingOnEl == 0 && this._attributesWaitingOnEl == 0 &&
        this.getState() == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"])
      {
        this.setState(adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]);
      }
    }
  };

  /**
   * Checks to see if the converter needs to be re-created and the value re-converted as a result
   * of a change.
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the arguments to the
   *                                                markNodeForUpdate call
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the attribute changes created by
   *                                            the updateAttributes call
   */
  AmxNode.prototype.__processConverterChanges = function(
    nodeUpdateArguments,
    attributeChanges)
  {
    if (this._converterTag == null)
    {
      // There is no converter
      return;
    }

    var id = this.getId();
    var converterTagId = this._converterTag.getAttribute("id");
    var affectedTagInstanceIds = nodeUpdateArguments.__getAffectedTagInstanceIds(id);
    var converterAffected = affectedTagInstanceIds.indexOf(converterTagId) >= 0;
    var valueAffected = nodeUpdateArguments.getAffectedAttributes(id)["value"];

    var hasConverter = this.getConverter() != null;

    if (converterAffected || hasConverter == false)
    {
      // Force the re-creation of the converter, if necessary
      this._converter = null;

      if (this._processConverter())
      {
        // Check if the the node has a "value" attribute. This is a work-around for bug 17055533
        // where DVT is using converters on AMX nodes that do not have value attributes.
        if (this.getTag().getAttribute("value") !== undefined)
        {
          var oldValue = this.getAttribute("value");

          // If the value was not changed in this update and the converter was set
          // before, then we need a clean copy of the value
          if (hasConverter && valueAffected != true && !adf.mf.environment.profile.dtMode)
          {
            var valueEl = this.getAttributeExpression("value");
            this.setAttributeResolvedValue("value",
              adf.mf.internal.amx.evaluateExpression(valueEl));
          }

          this._convertValue();
          attributeChanges.__addChangedAttribute("value", oldValue, null);
        }
      }
    }
    else if (valueAffected)
    {
      this._convertValue();
    }
  };

  /**
   * The AMX facetRef allows facets to be relocated for purposes of rendering (rendered in a
   * location that they are not defined in). In these cases, the framework must be able to
   * determine the parent AMX node responsible for rendering a node instead of the one that
   * is used to define it. This function normally returns the parent, but for facets used by
   * amx:facetRef, this function will return the facetRef.
   *
   * @return {adf.mf.api.amx.AmxNode} the parent node for rendering purposes.
   */
  AmxNode.prototype.__getRenderingParent = function()
  {
    return this._renderingParent == null ? this.getParent() : this._renderingParent;
  };

  /**
   * See __getRenderingParent
   */
  AmxNode.prototype.__setRenderingParent = function(renderingParent)
  {
    this._renderingParent = renderingParent;
  };

  /**
   * Function to push a map of EL tokens that should be replaced and their replacement
   * values onto a stack. Allows EL aliasing. Used internally for amx:fragmentDef to perform
   * attribute aliasing.
   *
   * @param {Object.<string, string>} map a map with the name to replace as a key and the
   *        token replacement as a value.
   */
  AmxNode.prototype.__pushElReplacements = function(map)
  {
    AmxNode._pushElReplacements(map);
  };

  /**
   * Function to push a map of EL tokens that should be replaced and their replacement
   * values onto a stack. Allows EL aliasing. Used internally for amx:fragmentDef to perform
   * attribute aliasing.
   *
   * @param {Object.<string, string>} map a map with the name to replace as a key and the
   *        token replacement as a value.
   */
  AmxNode.prototype.__popElReplacements = function()
  {
    AmxNode._popElReplacements();
  };

  AmxNode.prototype.__getConverterTag = function()
  {
    return this._converterTag;
  };

  /**
   * Returns the node closest to the this node, which may
   * be the current node, that is rendered and returns it.
   * @param {(boolean|null)} checkAbleToRenderNodes if true nodes in the ABLE_TO_RENDER state
   *        will be checked if rendered. This is useful during the data change event processing
   *        where a node's state may have been altered
   * @return {(adf.mf.api.amx.AmxNode|null)} the closest rendered node or null if no
   *         nodes are rendered.
   */
  AmxNode.prototype.__getClosestRenderedNode = function(checkAbleToRenderNodes)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    var targetNodeId = null;
    if (isFinestLoggingEnabled)
    {
      targetNodeId = this.getId();
    }

    for (var amxTargetNode = this; amxTargetNode != null;
      amxTargetNode = amxTargetNode.__getRenderingParent())
    {
      var state = amxTargetNode.getState();
      switch (state)
      {
        case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
        case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
          // If in the ABLE_TO_RENDER, only use if checkAbleToRenderNodes is true
          if (checkAbleToRenderNodes !== true &&
            state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
          {
            continue;
          }

          // Verify that the DOM node still exists (state is consistent)
          if (document.getElementById(amxTargetNode.getId()) != null)
          {
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.api.amx.AmxNode", "__getClosestRenderedNode",
                "Closest rendered ancestor node of node " + targetNodeId +
                " was found to be " + amxTargetNode.getId());
            }
            return amxTargetNode;
          }
          break;
      }
    }

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "__getClosestRenderedNode",
        "No rendered ancestor node could be found for node " + targetNodeId);
    }

    return null;
  };

  AmxNode.prototype.__getDescendentChangeAction = function(changes)
  {
    var th = this.getTypeHandler();
    // Delegate to the type handler if the custom function has been provided
    if (adf.mf.internal.amx.implementsFunction(th, "getDescendentChangeAction"))
    {
      return th.getDescendentChangeAction(this, changes);
    }

    // If a custom handler function has not been provided, the default behavior is
    // to re-render the closest rendered ancestor AMX node if any of the children
    // have had their rendered state changed.
    var changedAmxNodes = changes.getAffectedNodes();
    for (var i = 0, size = changedAmxNodes.length; i < size; ++i)
    {
      var descendentAmxNode = changedAmxNodes[i];
      var oldState = changes.getPreviousNodeState(descendentAmxNode);
      var rendered = descendentAmxNode.isReadyToRender();
      var wasRendered = (
          oldState == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"] ||
          oldState == adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"] ||
          oldState == adf.mf.api.amx.AmxNodeStates["RENDERED"]
        ) && document.getElementById(descendentAmxNode.getId()) != null;

      if ((rendered == false && wasRendered) ||
       (rendered && wasRendered == false))
      {
        // The descendent AMX node's rendered state has changed.
        // We need to re-render the ancestor to reflect the change in the UI
        // since the ancestor is not configured to handle the change itself
        return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
      }
    }

    // If none of the changes result in a rendered state change, by default
    // we do not need to take any action.
    return adf.mf.api.amx.AmxNodeChangeResult["NONE"];
  };

  /**
   * Get the names of the attributes that are affected by a change
   * to the given EL dependency.
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   * @return {Array.<string>} array of attribute names.
   */
  AmxNode.prototype.__getAttributesForElDependency = function(valueExpression)
  {
    var attrs = null;
    if (this._elDependencies != null)
    {
      attrs = this._elDependencies.getAttributesForElDependency(valueExpression);
    }
    else
    {
      attrs = [];
    }

    return attrs;
  };

  /**
   * Populates the AMX node update arguments for the tag instances
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the object
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   */
  AmxNode.prototype.__processTagInstancesForElDependency = function(
    nodeUpdateArguments,
    valueExpression)
  {
    var tagInstances = this.__getAllTagInstances();
    for (var i = 0, numInstances = tagInstances.length; i < numInstances; ++i)
    {
      var tagInstance = tagInstances[i];
      var elDependencies = tagInstance.getElDependencies();
      var affectedAttributes = elDependencies.getAttributesForElDependency(valueExpression);

      for (var a = 0, numAttrbitues = affectedAttributes.length; a < numAttrbitues; ++a)
      {
        nodeUpdateArguments.__setAffectedAttributeForTagInstance(
          tagInstance, affectedAttributes[a]);
      }
    }
  };

  /**
   * Internal function to retrieve the tag instances that are present under this node for
   * a specific namespace and tag name.
   *
   * @param {string} namespace the XML namespace of the tag
   * @param {string} tagName the tag name
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} array of all the tag instances for
   *         the given namespace and tag name
   */
  AmxNode.prototype.__getTagInstances = function(
    namespace,
    tagName)
  {
    var result = [];
    for (var id in this._tagInstances)
    {
      var instance = this._tagInstances[id];

      // Skip instances underneath another instance
      if (instance.getParentTagInstance() == null)
      {
        var tag = instance.getTag();
        if (tag.getName() == tagName &&
          tag.getNamespace() == namespace)
        {
          result.push(instance);
        }
      }
    }

    return result;
  };

  /**
   * Internal function to get an array of all the tag instances for this AMX node. Includes
   * tag instances that are nested under other tag instances as well (flattens the hierarchy).
   * Not meant to be used outside of amx-core.js.
   *
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} array of all the tag instances
   *         for the node
   */
  AmxNode.prototype.__getAllTagInstances = function()
  {
    var result = [];
    for (var id in this._tagInstances)
    {
      result.push(this._tagInstances[id]);
    }

    return result;
  };

  AmxNode.prototype.__findPopup = function(
    popupId)
  {
    if (popupId == null)
    {
      return null;
    }

    // See if the pop-up points to a child of a fragment
    var index = popupId.indexOf(":");
    var th;

    if (index == -1)
    {
      for (var amxNode = this; amxNode != null; amxNode = amxNode.getParent())
      {
        th = amxNode.getTypeHandler();

        if (adf.mf.internal.amx.implementsFunction(th, "findPopup"))
        {
          return th.findPopup(amxNode, popupId, true);
        }
      }

      return null;
    }

    var fragmentId = popupId.substring(0, index);
    var fragmentAmxNode = this.findRelativeAmxNode(fragmentId, false);

    if (fragmentAmxNode != null)
    {
      var children = fragmentAmxNode.getChildren();
      if (children.length > 0)
      {
        var fragmentDefAmxNode = children[0];

        th = fragmentDefAmxNode.getTypeHandler();

        if (adf.mf.internal.amx.implementsFunction(th, "findPopup"))
        {
          return th.findPopup(fragmentDefAmxNode, popupId.substring(index + 1), false);
        }
      }
    }

    return null;
  };

  /**
   * Internal function to get the attribute that should be validated
   *
   * @return {string} the name of the attribute to validate or null if the node has no input
   *         value to validate.
   */
  AmxNode.prototype.__getAttributeToValidate = function()
  {
    return this._attributeToValidate;
  };

  /**
   * Find the naming container node and the stamp key for the current node.
   *
   * @return {{amxNode: adf.mf.api.amx.AmxNode, stampKey: object}} the naming container for the
   *         current node
   */
  AmxNode.prototype._findNamingContainerAndStampKey = function()
  {
    for (var amxNode = this; true; amxNode = amxNode.getParent())
    {
      var stampKey = amxNode.getStampKey();
      if (stampKey != null)
      {
        return { "amxNode": amxNode.getParent(), "stampKey": stampKey };
      }
      else if (amxNode._isNamingContainer() || amxNode.getParent() == null)
      {
        return { "amxNode": amxNode, "stampKey": null };
      }
    }

    // This code will not be reached
    return null;
  };

  AmxNode.prototype._findAmxNode = function(
    xmlId,
    stampKey)
  {
    var childrenToSearch = this.getChildren(null, stampKey);
    var facets = this.getFacets(stampKey);

    for (var facetName in facets)
    {
      childrenToSearch = childrenToSearch.concat(facets[facetName]);
    }

    var numChildren = childrenToSearch.length;
    var c;

    // Look to see if it is one of the children
    for (c = 0; c < numChildren; ++c)
    {
      var child = childrenToSearch[c];
      var tagId = child.getTag().getAttribute("id");

      if (tagId == xmlId)
      {
        return child;
      }
    }

    // Search the decedents of the children
    for (c = 0; c < numChildren; ++c)
    {
      var child = childrenToSearch[c];

      // Do not search into child naming containers
      if (child._isNamingContainer())
      {
        continue;
      }

      var amxNode = child._findAmxNode(xmlId, null);
      if (amxNode != null)
      {
        return amxNode;
      }
    }

    return null;
  };

  /**
   * Function called when there is a cache miss on the rendered attribute or the EL expression
   * for the rendered attribute resolves to false. Only wires the rendered attribute for data change
   * events and ignores other attributes.
   */
  AmxNode.prototype._registerRenderedAttributeForDataChange = function()
  {
    if (this._elDependencies == null)
    {
      var el = this.getAttributeExpression("rendered", false, true);
      this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(
        { "rendered": el });
      this._postProcessForDataChangeNotification(false);
    }
  };

  var iteratorEL = adf.mf.internal.el.parser.parse ("#{iterator}");
  var nullEL = adf.mf.internal.el.parser.parse("#{null}");

  /**
   * Handles the evaluation and conversion of an attribute. Called by both the initialization
   * code as well as the update code.
   *
   * @param {string} attrName the name of the attribute to be processed
   * @return {boolean} whether an EL bound attribute had a cache miss
   */
  AmxNode.prototype._processAttribute = function(attrName)
  {
    var cacheMiss = false;

    var tag = this.getTag();
    if (!tag.isAttributeElBound(attrName))
    {
      // Do not process non-EL attributes if they have already been loaded
      if (this.getAttribute(attrName) !== undefined)
      {
        return cacheMiss;
      }

      var value = tag.getAttribute(attrName);

      // Convert the rendered to a boolean
      if (attrName == "rendered")
      {
        value = value === undefined || adf.mf.api.amx.isValueTrue(value);
      }

      // Do not process attributes not on the tag
      if (value == undefined)
      {
        return cacheMiss;
      }

      this.setAttributeResolvedValue(attrName, value);
      return cacheMiss;
    }

    var el = this.getAttributeExpression(attrName, false, true);

    if (adf.mf.environment.profile.dtMode)
    {
      this.setAttributeResolvedValue(attrName, attrName == "rendered" ? true : el.getExpression());
      return cacheMiss;
    }

    // TODO: move the acceptAttributeForElProcessing into the AmxNode class
    // instead of a global function
    //
    if (!acceptAttributeForElProcessing(attrName, el))
    {
      return cacheMiss;
    }

    var value = adf.mf.internal.amx.evaluateExpression(el);
    if (value === undefined)
    {
      cacheMiss = true;
      if (this._attributeNamesWaitingOnEl[attrName])
      {
        // If this is the second time that we had a cache miss on the same attribute,
        // check to make sure that the EL is valid. For example, a complex EL statement
        // cannot be cached within the JS EL cache and therefore the value would
        // never come back as having a value.
        var unassignableDependency = this._checkForUnassignableEl(el);
        if (unassignableDependency != null)
        {
          // First, replace the EL on the node so that we do not try to evaluate it again:
          this._elAttributeMap[attrName] = nullEL;
          // Second, throw an error to let the user/developer know that the EL is not valid
          throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
            "ERROR_UNASSIGNABLE_ATTRIBUTE", this.getId(), attrName, unassignableDependency));
        }
      }
      else
      {
        // Record that at least one EL was not available so that we update
        // the state appropriately
        this._attributeNamesWaitingOnEl[attrName] = true;
        ++this._attributesWaitingOnEl;
      }
    }
    else
    {
      if (this._attributeNamesWaitingOnEl[attrName])
      {
        delete this._attributeNamesWaitingOnEl[attrName];
        --this._attributesWaitingOnEl;
      }

      // Convert the rendered to a boolean
      if (attrName == "rendered")
      {
        value = adf.mf.api.amx.isValueTrue(value);
      }
      // Temporary hack for backwards compatibility is needed here. The old code, when getting
      // a collection model, would first look up the collection model via EL but then use the
      // javascript iterator as the returned attribute value. As a result, we first need to
      // get the collection model (ensuring the value is not an array), and only if that is
      // not undefined, get the iterator and store that.
      else if (attrName == "value" && tag.getAttribute("var") != null &&
         value != null && !Array.isArray(value))
      {
        // If this code is reached, then the value variable is the collection model, but we
        // need the JavaScript iterator for the type handlers. Temporarily "hack" the code so that
        // we now get the iterator from EL
        var iteratorEl = el.concat(iteratorEL);
        value = adf.mf.internal.amx.evaluateExpression(iteratorEl);
        if (value === undefined)
        {
          cacheMiss = true;
        }
      }

      // Store on the node
      this.setAttributeResolvedValue(attrName, value);
    }

    return cacheMiss;
  };

  AmxNode.prototype._checkForUnassignableEl = function(el)
  {
    var elDependencies = el.dependencies();
    for (var i = 0, numDeps = elDependencies.length; i < numDeps; ++i)
    {
      var dependency = elDependencies[i];
      if (!adf.mf.internal.util.isAssignable(dependency))
      {
        return dependency;
      }
    }

    return null;
  };

  AmxNode.prototype._createChildren = function()
  {
    // By default only create the children once
    if (this._childrenCreated)
    {
      return;
    }

    this._childrenCreated = true;

    // Create the non-UI tag instances
    this._createNonUITagInstances();

    var th = this.getTypeHandler();
    // Delegate to the type handler if the custom function has been provided
    if (adf.mf.internal.amx.implementsFunction(th, "createChildrenNodes"))
    {
      var createChildrenNodesResult = th.createChildrenNodes(this);
      if (this.getState() == adf.mf.api.amx.AmxNodeStates["INITIAL"] ||
        createChildrenNodesResult == adf.mf.api.amx.AmxNodeCreateChildrenNodesResult["DEFERRED"])
      {
        // If the type handler moves the state to INITIAL, call the createChildrenNodes
        // again.
        // Similarly, also if the display is deferred (to display a temporary placeholder).
        this._childrenCreated = false;
        return;
      }

      if (createChildrenNodesResult == adf.mf.api.amx.AmxNodeCreateChildrenNodesResult["HANDLED"])
      {
        return;
      }
    }

    // Create the non-facet children (non-stamped)
    this.createStampedChildren(null, null, null);
  };

  AmxNode.prototype._processConverterTag = function()
  {
    var tags = this.getTag().getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX);
    for (var i = 0, size = tags.length; i < size; ++i)
    {
      var tag = tags[i];
      var tagName = tag.getName();
      if (tagName == "convertNumber" || tagName == "convertDateTime")
      {
        this._converterTag = tag;

        // TODO: make this into an official API for registering converters
        break;
      }
    }
  };

  /**
   * Create the converter if it has not already been created
   *
   * @return {boolean} true if a converter was created during this call, otherwise false
   */
  AmxNode.prototype._processConverter = function()
  {
    if (this._converter != null || this._converterTag == null ||
      adf.mf.environment.profile.dtMode == true)
    {
      return false;
    }

    var convTag = this._converterTag;
    var convTagName = convTag.getName();
    var dirty = false;

    // Only process the converter if the node is in a state ready to be rendered
    if (this.isReadyToRender())
    {
      var converterTagInstance = this._tagInstances[convTag.getAttribute("id")];

      if (convTagName == "convertNumber" && amx.createNumberConverter)
      {
        var label = this.isAttributeDefined("label") ? this.getAttribute("label") : null;
        this.setConverter(amx.createNumberConverter(converterTagInstance, label));
        dirty = true;
      }
      else if (convTagName == "convertDateTime" && amx.createDateTimeConverter)
      {
        var label = this.isAttributeDefined("label") ? this.getAttribute("label") : null;
        this.setConverter(amx.createDateTimeConverter(converterTagInstance, label));
        dirty = true;
      }

      // Notify the type handler that the converter has been changed if desired.
      // This is currently only present for DVT and not a publicly supported API at this
      // time.
      var th = this.getTypeHandler();
      if (adf.mf.internal.amx.implementsFunction(th, "__converterCreated"))
      {
        th.__converterCreated(this, this._converter);
      }
    }

    return dirty;
  };

  AmxNode.prototype._convertValue = function()
  {
    if (this._converter != null)
    {
      this.setAttributeResolvedValue("value",
        this._converter.getAsString(this.getAttribute("value")));
    }
  };

  AmxNode.prototype._isNamingContainer = function()
  {
    var tag = this.getTag();
    var ns = tag.getNamespace();
    var name = tag.getName();

    // This function only needs to return true for tags that do not stamp but need
    // to have unique name containers. So list view and the itertor tags are not needed
    // here since they are stamping nodes.
    return (name == "fragment" || name == "facetRef") &&
      ns == adf.mf.api.amx.AmxTag.NAMESPACE_AMX;
  };

  /**
   * Creates the tag instances for the node. Only creates them once, may be called
   * multiple times. Called from the _createChildren method before the AMX children nodes
   * are created.
   * @param {adf.mf.internal.amx.AmxTagInstance=} parentTagInstance the parent tag instance or null
   */
  AmxNode.prototype._createNonUITagInstances = function(parentTagInstance)
  {
    if (parentTagInstance == null)
    {
      // Only execute once per AMX node
      if (this._tagInstances != null)
      {
        return;
      }

      this._tagInstances = {};
    }

    // No need to create non-UI AmxTagInstance if in DT mode.
    if (adf.mf.environment.profile.dtMode)
    {
      return;
    }

    var tag = parentTagInstance == null ? this.getTag() : parentTagInstance.getTag();

    var children = tag.getChildren();
    for (var i = 0, size = children.length; i < size; ++i)
    {
      var childTag = children[i];
      if (childTag.isUITag() == false)
      {
        // Skip amx:facet as there is no need for that tag to have instances
        if (!(childTag.getName() == "facet" &&
          childTag.getNamespace() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX))
        {
          var id = childTag.getAttribute("id");
          var instance = new adf.mf.internal.amx.AmxTagInstance(this, parentTagInstance, childTag);

          this._tagInstances[id] = instance;

          if (instance.getState() ==
            adf.mf.internal.amx.AmxTagInstanceStates["WAITING_ON_EL_EVALUATION"])
          {
            ++this._tagInstancesWaitingOnEl;
            this._tagInstanceIdsWaitingOnEl[id] = true;
          }

          // Process any nested tag instances
          this._createNonUITagInstances(instance);
        }
      }
    }

    if (this._tagInstancesWaitingOnEl > 0 && this.isReadyToRender())
    {
      // Make the node wait to render until the needed EL is loaded for all tag
      // instances
      this.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
  };

  AmxNode.prototype._createUniqueId = function()
  {
    var id = this.getAttribute("id");
    if (id === undefined)
    {
      id = this.getTag().getAttribute("id");
      this.setAttributeResolvedValue("id", id);
    }

    var parent = this.__getRenderingParent();

    if (parent == null)
    {
      this._id = id;
    }
    else
    {
      var parentId = parent.getId();
      var stampKey = this.getStampKey();
      var parentIsNamingContainer = parent._isNamingContainer();

      if (stampKey == null || parentIsNamingContainer)
      {
        if (parentIsNamingContainer)
        {
          this._id = parentId + ":" + id;
        }
        else
        {
          // Find the portion af the parent with a colon in the ID
          var idx = parentId == null ? -1 : parentId.lastIndexOf(":");
          if (idx == -1)
          {
            // The parent is not "namespaced"
            this._id = id;
          }
          else
          {
            // Get the parent's "namespace" from the ID and use that as this node's prefix
            var prefix = parentId.substring(0, idx + 1);
            this._id = prefix + id;
          }
        }
      }
      else
      {
        var re = /[^\w\.\-]/g;
        var strVal = stampKey.toString();
        // Replace any non-ID friendly values with a sequence of characters unlikely to appear in the
        // value. This assumes that most characters
        // of the iterationKey will be valid and will therefore produce a unique key. Using a token
        // cache would address this if this assumption becomes an issue. If we end up with duplicate
        // IDs due to escaping, we'll have to create a token cache approach.
        strVal = strVal.replace(re, "._.");

        this._id = parentId + ":" + strVal + ":" + id;
      }
    }
  };

  AmxNode.prototype._findChildIndex = function(
    stampKey,
    nodeId,
    facetName)
  {
    var children = this.getChildren(facetName, stampKey);

    for (var i = 0, size = children.length; i < size; ++i)
    {
      var node = children[i];
      if (node.getId() == nodeId)
      {
        return i;
      }
    }

    return -1;
  };

  AmxNode.prototype._findChildIndexAndFacetName = function(
    stampKey,
    nodeId)
  {
    var foundFacetName = null;
    // First search for the child in the children
    var index = this._findChildIndex(stampKey, nodeId, null);
    if (index == -1)
    {
      // If it was not found as a child, look for it as a facet child
      var facets = this.getFacets(stampKey);
      for (var facetName in facets)
      {
        index = this._findChildIndex(stampKey, nodeId, facetName);
        if (index >= 0)
        {
          foundFacetName = facetName;
          break;
        }
      }
    }

    return index == -1 ? null :
      {
        "index": index,
        "facetName": foundFacetName
      };
  };

  /**
   * Function to handle any necessary code to properly notify the node of changes from the model.
   *
   * @param {boolean} includeTagInstances if true the EL in the tag instances will also be
   *        registered.
   */
  AmxNode.prototype._postProcessForDataChangeNotification = function(
    includeTagInstances)
  {
    var elTokens = this._elDependencies.getElTokens();

    if (includeTagInstances)
    {
      var tagInstances = this.__getAllTagInstances();
      for (var i = 0, numInstances = tagInstances.length; i < numInstances; ++i)
      {
        var tagInstance = tagInstances[i];
        elTokens = elTokens.concat(tagInstance.getElDependencies().getElTokens());
      }
    }

    for (var t = 0, numTokens = elTokens.length; t < numTokens; ++t)
    {
      var token = elTokens[t];
      var nodes = nodeToElMap[token];

      if (nodes == null)
      {
        nodes = [ this ];
        nodeToElMap[token] = nodes;
      }
      else
      {
        if (nodes.indexOf(this) == -1)
        {
          nodes.push(this);
        }
      }
    }

    // Cache the value for the removal code
    this._registeredElTokens = elTokens;
  };

  /**
   * Removes the node and descendents from listening to data change events.
   *
   * @param {boolean} nodeWillBeRemoved if true, the a notification will be fired
   *        to the type handler to be notified that the AMX node is going to be removed
   *        from the hierarchy.
   */
  AmxNode.prototype._removeFromDataChangeNotification = function(nodeWillBeRemoved)
  {
    // Notify the type handler this node will be removed or is now unrendered
    this._fireNotification(adf.mf.api.amx.AmxNodeNotifications[
      nodeWillBeRemoved ? "PRE_REMOVAL" : "UNRENDERED"]);

    if (nodeWillBeRemoved)
    {
      // If the state of the node is not "resolved", decrement the node waiting count
      // so that we are not waiting on a removed node
      switch (this.getState())
      {
        case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
        case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
        case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
          adf.mf.internal.amx._pageBusyTracker.decrement();
          break;
      }
    }

    // Remove this node from notifications
    var tokens = this._registeredElTokens;

    if (tokens != null)
    {
      for (var i = 0, size = tokens.length; i < size; ++i)
      {
        var token = tokens[i];
        var nodes = nodeToElMap[token];
        if (nodes != null)
        {
          var index = nodes.indexOf(this);
          if (index >= 0)
          {
            nodes.splice(index, 1);
          }
        }
      }
    }

    this._registeredElTokens = null;

    this._removeChildrenFromDataChangeNotification();
  };

  /**
   * Removes this node's children from being notified of any data changes. Typically this is called
   * when the node is being set to an un-rendered state or when the node is being removed from the
   * node hierarchy.
   */
  AmxNode.prototype._removeChildrenFromDataChangeNotification = function()
  {
    var i, size, children, stampKey = null;

    for (stampKey in this._children)
    {
      children = this._children[stampKey];
      for (i = 0, size = children.length; i < size; ++i)
      {
        children[i]._removeFromDataChangeNotification(true);
      }
    }

    for (stampKey in this._facets)
    {
      var facets = this._facets[stampKey];
      for (var facetName in facets)
      {
        children = facets[facetName];
        for (i = 0, size = children.length; i < size; ++i)
        {
          children[i]._removeFromDataChangeNotification(true);
        }
      }
    }
  };

  /**
   * Fires a notification of an AMX node event to the type handler
   *
   * @param {string} one of the adf.mf.api.amx.AmxNodeNotifications constants
   */
  AmxNode.prototype._fireNotification = function(
    notificationType)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "handleNotification"))
    {
      th.handleNotification(this, notificationType);
    }
  };

  /**
   * Get the EL expression map for the node. This will get all the EL expressions with
   * replacement for any EL bound attributes.
   *
   * @return {Object.<string, string>} map of the attribute name to the replaced EL expression
   */
  AmxNode.prototype._getAttributesExpressionMap = function()
  {
    var tag = this.getTag();
    var attrs = tag.getAttributes();
    var replacedAttrs = {};
    for (var name in attrs)
    {
      var expr = this.getAttributeExpression(name, false, true);

      if (expr != null)
      {
        replacedAttrs[name] = expr;
      }
    }

    return replacedAttrs;
  };

  /**
   * Called during initialization to set the input value attribute of the node, allowing validation
   * of that parameter to take place and sets up the EL to permit context free usage during the
   * posting of the changes back to the model.
   */
  AmxNode.prototype._setupInputValueValidation = function()
  {
    // Note, if this function is changed at all, the amx-core.js function amx.registerInputValue
    // must also be changed as it has the deprecated version of this code.
    var th = this.getTypeHandler();

    if (this._attributeToValidate === undefined)
    {
      var attr = adf.mf.internal.amx.implementsFunction(th, "getInputValueAttribute") ?
        th.getInputValueAttribute() :
        null;
      this._attributeToValidate = attr;

      if (attr != null)
      {
        // Convert the EL to a context free EL string to be able to safely call back into the model
        // without any local javascript variables
        this.storeModifyableEl(attr);
      }
    }
  };

  /**
   * Given an HTML element, find the closest AMX node
   * @param {HTMLElement} element the DOM element
   * @return {adf.mf.api.amx.AmxNode|null} the node if found or null
   */
  AmxNode.getAmxNodeForElement = function(element)
  {
    for (var e = element; e != null && e.classList != null; e = e.parentNode)
    {
      if (e.classList.contains("amx-node"))
      {
        return adf.mf.internal.amx._getNonPrimitiveElementData(e, "amxNode");
      }
    }

    return null;
  };

  /**
   * Performs any EL substitutions for the given EL expression. Must be called in-context so that
   * EL variables are correctly recognized and substituted.
   *
   * @param {string} expr the EL expression
   * @return {string} the EL expression with any EL replacements made
   */
  AmxNode.__performElSubstitutions = function(expr)
  {
    if (!expr.tokens)
        expr = adf.mf.internal.el.parser.parse(expr);

    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    var replacementStack = AmxNode._elReplacementsStack;
    var origExpr = expr;

    try
    {
        expr = adf.mf.internal.util.stripLocalValues(expr, true, replacementStack);
    }
    catch (e)
    {
        // If the replacement fails, log the error and fall back to using the non-replaced EL.
        // This will make it easier to track down the EL expression that had caused the error.
        amx.log.error(e.message);
        return origExpr;
    }

    if (isFinestLoggingEnabled)
    {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.api.amx.AmxNode", "__performElSubstitutions",
            "Original expression: " + origExpr + ". Replacement: " + expr);
    }

    return expr;
  };

  /**
   * Pushes a new map of EL expressions onto the EL replacement stack.
   *
   * @param {Object.<string, string>} map of the EL variable name to
   *        the EL string replacement to be made.
   */
  AmxNode._pushElReplacements = function(map)
  {
    var stack = AmxNode._elReplacementsStack;
    if (stack == null)
    {
      AmxNode._elReplacementsStack = [ map ];
    }
    else
    {
      stack.unshift(map);
    }
  };

  /**
   * Removes the last EL replacement map from the stack
   *
   * @return {Object.<string, string>} the map that was removed
   */
  AmxNode._popElReplacements = function()
  {
    var stack = AmxNode._elReplacementsStack;
    var item = stack.shift();

    if (stack.length == 0)
    {
      delete AmxNode._elReplacementsStack;
    }

    return item;
  };

  /**
   * Sort nodes of in an array so that parents appear first
   * and descendents later.
   */
  AmxNode.__sortNodesByDepth = function(nodes)
  {
    function getNodeDepth(node)
    {
      var depth = 0;
      for (var n = node; n != null; n = n.getParent())
      {
        ++depth;
      }

      return depth;
    }

    function nodeCompare(n1, n2)
    {
      if (n1 == n2)
      {
        return 0;
      }

      var n1p = n1.getParent();
      var n2p = n2.getParent();

      if (n1p == n2p)
      {
        // If in the same parent, first compare the stamp keys
        var s1 = n1.getStampKey();
        var s2 = n2.getStampKey();

        if (s1 == s2)
        {
          // The nodes are in the same parent with the same stamp key,
          // return the order of the nodes in the children array
          var n1data = n1p._findChildIndexAndFacetName(s1, n1.getId());
          var n2data = n2p._findChildIndexAndFacetName(s2, n2.getId());

          var n1f = n1data["facetName"];
          var n2f = n2data["facetName"];


          if (n1f == n2f)
          {
            // They have the same facet (may be null), so just compare the
            // indexes
            return n1data["index"] - n2data["index"] < 0 ? -1 : 1;
          }
          else
          {
            if (n1f == null)
            {
              return 1;
            }
            else if (n2f == null)
            {
              return -1;
            }

            return n1f < n2f ? -1 : 1;
          }
        }
        else // The stamp keys are not the same
        {
          // Use a string comparisson of the keys
          return (("" + s1) < ("" + s2)) ? -1 : 1;
        }
      }
      else // The parents are not the same
      {
        var d1 = getNodeDepth(n1);
        var d2 = getNodeDepth(n2);

        var tmp1 = n1;
        var tmp2 = n2;
        var origD1 = d1;
        var origD2 = d2;

        // Ensure that they are the same depth
        if (d1 != d2)
        {
          while (d1 > d2)
          {
            tmp1 = tmp1.getParent();
            --d1;
          }

          while (d2 > d1)
          {
            tmp2 = tmp2.getParent();
            --d2;
          }

          if (tmp1 == tmp2)
          {
            // The nodes are the same, return the one that was more shallow
            return origD1 < origD2 ? -1 : 1;
          }

          if (tmp1.getParent() == tmp2.getParent())
          {
            // If they have the same parent at this level, then recursively
            // use this function
            return nodeCompare(tmp1, tmp2);
          }
        }

        // At this point, we have nodes at the same depth, but the parents are not the same.
        // We need to walk up the parent hierarchy until we find nodes that share the same parent.
        for (var depth = d1; depth > 0; --depth)
        {
          var tmp1p = tmp1.getParent();
          var tmp2p = tmp2.getParent();

          if (tmp1p == tmp2p)
          {
            // We found the parents that are the same, use a recursive call
            return nodeCompare(tmp1, tmp2);
          }

          // Keep looking up the ancestory chain
          tmp1 = tmp1p;
          tmp2 = tmp2p;
        }

        // We should not have reached here as there is only one root node. This would only
        // happen if the nodes are from different hierarchies, which is not valid.
        // Throw an error so that we know it failed.
        throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
          "ERROR_FAILED_TO_SORT_AMX_NODES"));
      }
    }

    nodes.sort(nodeCompare);
  };

  /**
   * Internal function called from amx-core.js in the handling of data change events
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression
   *        the value expression to get the nodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that are registered for the EL token
   */
  AmxNode.__getNodesDependentOnElToken = function(valueExpression)
  {
    var token = valueExpression.getIndexedRepresentation();

    // Now get the nodes
    var nodes = nodeToElMap[token];
    return nodes == null ? [] : nodes;
  };

  AmxNode.__clearBindings = function()
  {
    nodeToElMap = {};
  };

  // ------ /AMX Node ------ //

  // return true if this attribute/value needs to be EL resolved
  acceptAttributeForElProcessing.noProcessAttributes =
  {
    valueChangeListener:true,
    from:true,
    to:true,
    selectionChangeListener:true,
    actionListener:true,
    action:true,
    binding:true,
    rangeChangeListener:true
  };

  function acceptAttributeForElProcessing(attrName, attrValue)
  {
    var accept = (!acceptAttributeForElProcessing.noProcessAttributes[attrName] &&
      attrValue);
    accept = accept && (attrName.indexOf("Listener") === -1);
    return accept;
  }

  adf.mf.internal.amx.acceptAttributeForElProcessing = acceptAttributeForElProcessing;

})();
/*
** Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
** Important:
** - This file is designed to be shared verbatim among the ADFui products.
** - Do not add framework-specific dependencies in this file (it must be self-contained).
** - Do not change this file without testing it in other ADFui products (ADF Faces, ADF Mobile, etc.).
*/
if (!window.adf) {
  /**
   * @expose
   * @namespace adf
   */
  window.adf = {}
};

/** @namespace */
adf.shared = adf.shared || {};

/** @namespace */
adf.shared.impl = adf.shared.impl || {}; // ONLY IMPL FOR NOW, CONSIDER PROMOTING TO API IN FUTURE

/** @namespace */
adf.shared.impl.animationUtils = new Object(); // must be explicitly assigned to the window.adf.shared.impl object for cross-framework sharing

/** @private */
adf.shared.impl.animationUtils._browserSpecificNames = {};

// ======================= AnimationUtils Internal APIs =======================

/**
 * Perform a transition animation between 2 elements.
 * - Requirements and prerequisites for calling this function:
 * <ul>
 * <li>The 2 elements must be siblings,
 * <li>Your finishedFunction is responsible for firing trigger resize notifications if applicable,
 * <li>Your finishedFunction is responsible for cleaning up objects associated with and removing the old currentElement,
 * <li>The provided elements must not be using display:none.
 * </ul>
 * When this animation is complete, the currentElement will get display:none and there may be other styles added.
 * If desirable, you may want to save off the styles for restoration if you are not discarding the element in your
 * finished function.
 * @param {string} transitionType the type of transition desired (fade, flipUp, flipDown, flipStart, flipEnd,
 *                                slideUp, slideDown, slideStart, slideEnd, or none)
 * @param {HTMLElement} currentElement the DOM element to be replaced or null if not applicable
 * @param {HTMLElement} newElement the DOM element that will remain or null if not applicable
 * @param {Object} properties a map of properties for the animation:
 * <ul>
 * <li>"dimensionsFromParent" boolean whether dimensions are from the parent (stretching layout structure)
 * <li>"finishedFunction" an optional function to invoke once the animation is completed
 * <li>"callbackParams" an object that will be passed into the finishedFunction or returned from the cancel function
 * <li>"animationEnabled" boolean whether animation should be disabled
 * <li>"isRtl" boolean whether the reading direction is right-to-left
 * <li>"fineLogger" a logger function that will be used for fine-level messages
 * <li>"parentFlipAllowed" boolean whether the parent of the new/current elements can be flipped for an inset effect (gives a flip effect without worry about truncation); In order to do the inset flip, we have to be able to flip the parent element. We need special permission for that because:
 *   <ul>
 *   <li>There might be other elements inside of that parent that (if visible to the user)
 *       would be flipped which may not be desirable.
 *   <li>We cannot create a new temporary parent element on the fly either because we would
 *       then lose scroll positions on all scrollable containers within the subtrees of those
 *       flipped elements.
 *   <li>The parent and grandparent elements must have the same dimensions;
 *       if we applied the perspective to the grandparent (parent of the common ancestor),
 *       then the dimensions of the parent element would not be respected when the rotations
 *       are applied; you'd see the elements flip outside of the dimensions of the parent element.
 *   </ul>
 * </ul>
 * @return {function} function to invoke if you want to cancel an animation that is currently in progress
 */
adf.shared.impl.animationUtils.transition = function(
  transitionType,
  currentElement,
  newElement,
  properties)
{
  var dimensionsFromParent = properties["dimensionsFromParent"];
  var finishedFunction = properties["finishedFunction"];
  var callbackParams = properties["callbackParams"];
  var animationEnabled = properties["animationEnabled"];
  var isRtl = properties["isRtl"];
  var fineLogger = properties["fineLogger"];
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var animationUtils    = adf.shared.impl.animationUtils;
  var animationContext  = new animationUtils.AnimationContext(finishedFunction, callbackParams);
  var cancelFunction    = function() {};
  animationUtils._isRtl = isRtl;
  animationUtils._fineLogger = fineLogger;

  if (animationUtils._agentTypeAndVersion == null)
  {
    // Do a 1-time agent initialization
    animationUtils._agentTypeAndVersion = animationUtils._getAgentTypeAndVersion(navigator.userAgent);
  }

  try
  {
    // If any of the prerequisities are violated, do not attempt a transition:
    var nothingToAnimate = false;
    if (!hasCurrent && !hasNew)
      nothingToAnimate = true; // no elements to animate
    else if (hasCurrent && hasNew && currentElement.parentNode != newElement.parentNode)
    {
      nothingToAnimate = true; // common parent prerequisite was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition common parent prerequisite was violated");
    }
    if (hasCurrent && currentElement.style.display == "none")
    {
      nothingToAnimate = true; // display != none was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition currentElement display != none prerequisite was violated");
    }
    if (hasNew && newElement.style.display == "none")
    {
      nothingToAnimate = true; // display != none was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition newElement display != none prerequisite was violated");
    }
    if (nothingToAnimate)
    {
      if (finishedFunction != null)
        adf.shared.impl.animationUtils._requestAnimationFrame(
          animationUtils.getProxyFunction(animationContext, animationContext._performFinish));

      return cancelFunction; // do not attempt a transition
    }

    if (!animationEnabled)
    {
      transitionType = "none";
    }

    var transitionFunction = null;
    var direction = null;
    var sendCurrent = true;
    var sendNew = true;

    if (transitionType != null) // default to "none"
    {
      var agentType = animationUtils._agentTypeAndVersion[0];
      var agentVersion = animationUtils._agentTypeAndVersion[1];

      if (transitionType.indexOf("slide") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(5).toLowerCase();
        transitionFunction = animationUtils._slide;
      }
      else if (transitionType.indexOf("flip") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 19, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 19, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(4).toLowerCase();
        transitionFunction = animationUtils._flip;
      }
      else if (transitionType == "fade" &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        transitionFunction = animationUtils._fade;
      }
      else if (transitionType.indexOf("cover") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(5).toLowerCase();
        // reuse slide animation to animate cover eff
        transitionFunction = animationUtils._slide;
        if (hasNew)
        {
          // only slide new incomming div
          sendCurrent = false;
        }
      }
      else if (transitionType.indexOf("reveal") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(6).toLowerCase();
        transitionFunction = animationUtils._slide;
        if (hasCurrent)
        {
          // only slide old div out
          sendNew = false;
          // keep current element always on top
          properties["currentOnTop"] = true;
        }
      }
    }

    if (direction == "")
      direction = "start";

    if (transitionFunction == null ||
      ((hasCurrent && !currentElement.addEventListener) || (hasNew && !newElement.addEventListener)))
    {
      // There was no transition specified or this browser doesn't support it, just hide the currentElement:
      animationUtils._restoreStyles(currentElement);
      animationUtils._restoreStyles(newElement);
      if (hasCurrent)
        currentElement.style.display = "none";

      // let the control proceed and immediately after invoke finish since there was nothing to animate
      adf.shared.impl.animationUtils._requestAnimationFrame(
        animationUtils.getProxyFunction(animationContext, animationContext._performFinish));
    }
    else // we can do an animation
    {
      if (hasCurrent && hasNew && !dimensionsFromParent)
      {
        // Add some styles to compensate for it so currentElement won't be pushed down by the newElement when dimensionsFrom == "children":
        var currentElementStyle = currentElement.style;
        var currentWidth = currentElement.offsetWidth;
        var currentHeight = currentElement.offsetHeight;
        currentElementStyle.position = "absolute";
        currentElementStyle.top = "0px";
        currentElementStyle.width = currentWidth + "px";
        currentElementStyle.height = currentHeight + "px";
      }

      if (sendCurrent === false)
      {
        currentElement = null;
      }

      if (sendNew === false)
      {
        newElement = null;
      }

      cancelFunction = transitionFunction(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction);
    }
  }
  catch (problem)
  {
    // Should not get here but in case we do, log the problem:
    animationUtils._fineLogger("AdfAnimationUtils: unable to perform transition due to problem:");
    animationUtils._fineLogger(problem);
  }

  return cancelFunction;
};

/**
 * Creates a function instance that will call back the passed in function with the specified owner as the "this" variable.
 * @param {Object} owner the proxy owner of the proxied function (exposed via the "this" variable inside the function)
 * @param {function} func the function to proxy
 * @return {function} the proxied function
 */
adf.shared.impl.animationUtils.getProxyFunction = function(owner, func)
{
  // create a function that sets up "this" and delegates all of the parameters
  // to the passed in function
  var proxyFunction = new Function(
    "var f=arguments.callee; return f._func.apply(f._owner, arguments);");

  // attach ourselves as "this" to the created function
  proxyFunction["_owner"] = owner;

  // attach function to delegate to
  proxyFunction["_func"] = func;

  return proxyFunction;
};

/**
 * Since a transition end event will not be triggered when an element is
 * hidden, use this API to add the one-time listener with a fallback
 * invocation if the event doesn't happen within a set time.
 * @param {HTMLElement} transitioningElement the DOM element that is transitioning
 * @param {function} callback the function (zero parameters) to invoke
 */
adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe = function(
  transitioningElement,
  callback)
{
  if (transitioningElement != null && callback != null)
  {
    var transitionEndEventName =
      adf.shared.impl.animationUtils._getTransitionEndEventName();
    var context = {
      "timerId": null,
      "handler": null,
      "handled": false
    };

    // Define the handler for either the transitionend or failsafe:
    context["handler"] =
      function()
      {
        try
        {
          if (!context["handled"])
          {
            // This was the first time the handler was invoked so mark it as
            // handled and then invoke the callback:
            context["handled"] = true;
            callback();
          }
        }
        finally
        {
          // Unregister the listener and clear the timeout:
          transitioningElement.removeEventListener(
            transitionEndEventName,
            context["handler"],
            true);
          window.clearTimeout(context["handler"]);
        }
      };

    // Register the listener and add the timeout:
    transitioningElement.addEventListener(
      transitionEndEventName,
      context["handler"],
      true);
    context["timerId"] = window.setTimeout(context["handler"], 1000);
  }
};

// ======================= priavte transition functions =======================

/**
 * Perform a fade animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._fade = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  if (hasCurrent)
  {
    animationUtils._setOpacity(currentElement, "1");
  }
  if (hasNew)
  {
    animationUtils._saveStyles(newElement);
    animationUtils._setOpacity(newElement, "0");
    newElement.style.zIndex = "1";
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, "opacity", 1);
  }

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all .2s ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all .2s ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        currentElement.style.display = "none";
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
      });
    }

    if (hasCurrent)
      animationUtils._setOpacity(currentElement, "0");
    if (hasNew)
      animationUtils._setOpacity(newElement, "1");
  });

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Perform a slide animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._slide = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var parentElement = null;
  if (hasCurrent)
  {
    parentElement = currentElement.parentNode;
  }
  else if (hasNew)
  {
    parentElement = newElement.parentNode;
  }
  if (hasNew)
  {
    animationUtils._saveStyles(newElement);
  }
  if (hasCurrent)
  {
    animationUtils._saveStyles(currentElement);
  }

  var vertical = false; // whether we move along the y-axis (true) or x-axis (false)
  var back = false; // the code below is written in one direction, this toggles whether we reverse the direction

  if (direction == "up" || direction == "down")
  {
    vertical = true;
  }

  if (direction == "right" || direction == "down")
  {
    back = true;
  }

  if (animationUtils._isRtl)
  {
    if (direction == "start")
    {
      back = true;
    }
  }
  else // ltr
  {
    if (direction == "end")
    {
      back = true;
    }
  }

  // Use fading of the current element if in flowing mode for a better effect.
  // When stretching, this fading effect is not as desirable so don't use it in that case.
  var fadeCurrent = !dimensionsFromParent;

  // We have to also apply opacity in case the viewport does not truncate:
  if (hasCurrent && fadeCurrent)
  {
    animationUtils._setOpacity(currentElement, "1");
  }
  // set z-index to the currentElement to keep it always on above the new element
  // this properties will be erased on the animation end
  if (hasCurrent && properties["currentOnTop"])
  {
    currentElement.style.zIndex = 10;
  }
  var translateDistance, size, offsetShift;
  var offsetProperty = vertical ? "offsetHeight" : "offsetWidth";
  if (back) // down or right
  {
    // We want to move down the distance of the new element if present
    if (hasNew)
      size = newElement[offsetProperty];
    else // must hasCurrent
      size = currentElement[offsetProperty];
  }
  else // up or left
  {
    // We want to move up the distance of the old element if present
    if (hasCurrent)
      size = currentElement[offsetProperty];
    else // must hasNew
      size = newElement[offsetProperty];
  }
  offsetShift = back ? (-1) * size : size;
  translateDistance = offsetShift * -1;
  if (hasNew)
  {
    if (vertical)
      animationUtils._setTransformTranslate(newElement, "0," + offsetShift + "px");
    else
      animationUtils._setTransformTranslate(newElement, offsetShift + "px,0");
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all 125ms ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all 125ms ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        animationUtils._restoreStyles(currentElement);
        currentElement.style.display = "none";
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
      });
    }

    // Animate the translated distance:
    if (vertical)
    {
      if (hasCurrent)
        animationUtils._setTransformTranslate(currentElement, "0," + translateDistance + "px");
      if (hasNew)
        animationUtils._setTransformTranslate(newElement, "0,0");
    }
    else
    {
      if (hasCurrent)
        animationUtils._setTransformTranslate(currentElement, translateDistance + "px,0");
      if (hasNew)
        animationUtils._setTransformTranslate(newElement, "0,0");
    }

    // Animate the opacity:
    if (hasCurrent && fadeCurrent)
      animationUtils._setOpacity(currentElement, "0");
  });

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Perform a flip animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._flip = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var parentElement = null;
  if (hasCurrent)
    parentElement = currentElement.parentNode;
  else if (hasNew)
    parentElement = newElement.parentNode;
  if (hasCurrent)
    animationUtils._saveStyles(currentElement);
  if (hasNew)
    animationUtils._saveStyles(newElement);
  animationUtils._saveStyles(parentElement);
  var vertical = false; // whether we flip up/down about the x-axis (true) or left/right about the y-axis (false)
  var back = false; // the code below is written in one direction, this toggles whether we reverse the direction

  if (direction == "up" || direction == "down")
    vertical = true;

  if (direction == "right" || direction == "up")
    back = true;

  if (animationUtils._isRtl)
  {
    if (direction == "start")
      back = true;
  }
  else // ltr
  {
    if (direction == "end")
      back = true;
  }

  // Ideally we want to perform an inset flip rather than a flip on the plane of the page so that
  // there wouldn't be any potential for undesirable truncation when the content flips toward the
  // user
  // There are several considerations that may prevent an inset flip from being used:
  // 1.) Internet Explorer 10 doesn't support nested 3D transforms so it will have to use the
  //     less-than ideal flipping on the plane of the page implementation.
  // 2.) In order to do the inset flip, we have to be able to flip the parent element. We need
  //     special permission for that because:
  //     a.) There might be other elements inside of that parent that (if visible to the user)
  //         would be flipped which may not be desirable.
  //     b.) We cannot create a new temporary parent element on the fly either because we would
  //         then lose scroll positions on all scrollable containers within the subtrees of those
  //         flipped elements.
  //     c.) The parent and grandparent elements must have the same dimensions:
  //         If we applied the perspective to the grandparent (parent of the common ancestor),
  //         then the dimensions of the parent element would not be respected when the rotations
  //         are applied; you'd see the elements flip outside of the dimensions of the parent element.
  var agentType = animationUtils._agentTypeAndVersion[0];
  var doInsetFlip = (true == properties["parentFlipAllowed"] && "trident" != agentType);
  if ("webkit" == agentType && 534.3 > animationUtils._agentTypeAndVersion[1]) // Android 4.1.1 == 534.3
    doInsetFlip = false; // old versions of WebKit cannot handle it

  if (doInsetFlip)
    animationUtils._flipInset(
      animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back, dimensionsFromParent);
  else // fallback to safest flip
    animationUtils._flipOnPageLayer(
      animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back);

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Helper for the _flip transition that performs the less-than ideal (but simpler) flip transition.
 * @private
 */
adf.shared.impl.animationUtils._flipOnPageLayer = function(
  animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back)
{
  // We want matching dimensions for a smooth flip:
  var offsetWidth = 0;
  var offsetHeight = 0;
  if (hasNew)
  {
    offsetWidth = newElement.offsetWidth;
    offsetHeight = newElement.offsetHeight;
  }
  if (hasCurrent)
  {
    offsetWidth = Math.max(offsetWidth, currentElement.offsetWidth);
    offsetHeight = Math.max(offsetHeight, currentElement.offsetHeight);
  }
  if (hasNew)
  {
    animationUtils._setBackfaceVisibility(newElement, "hidden");
    animationUtils._setTransformStyle(newElement, "preserve-3d");
    newElement.style.width = offsetWidth + "px";
    newElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformRotateX(newElement, (back?"-180deg":"180deg"));
    else
      animationUtils._setTransformRotateY(newElement, (back?"-180deg":"180deg"));
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }
  if (hasCurrent)
  {
    animationUtils._setBackfaceVisibility(currentElement, "hidden");
    animationUtils._setTransformStyle(currentElement, "preserve-3d");
    currentElement.style.width = offsetWidth + "px";
    currentElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformRotateX(currentElement, "0deg");
    else
      animationUtils._setTransformRotateY(currentElement, "0deg");
  }

  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  var agentVersion = adf.shared.impl.animationUtils._agentTypeAndVersion[1];
  if ("webkit" == agentType)
  {
    // Older versions of the Android browser cannot handle perspective flipping
    if ("webkit" == agentType && 534.3 <= agentVersion) // Android 4.1.1 == 534.3
    {
      var perspectiveProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("perspective");
      parentElement.style[perspectiveProperty] = "2000px";
    }
  }
  else if ("trident" != agentType) // inhibit for IE since IE10 doesn't support it properly
    parentElement.style.perspective = "2000px";

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all .2s ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all .2s ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        currentElement.style.display = "none";
        animationUtils._restoreStyles(currentElement);
        animationUtils._restoreStyles(parentElement);
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
        animationUtils._restoreStyles(parentElement);
      });
    }

    if (vertical)
    {
      if (hasCurrent)
        animationUtils._setTransformRotateX(currentElement, (back?"180deg":"-180deg"));
      if (hasNew)
        animationUtils._setTransformRotateX(newElement, "0deg");
    }
    else
    {
      if (hasCurrent)
        animationUtils._setTransformRotateY(currentElement, (back?"180deg":"-180deg"));
      if (hasNew)
        animationUtils._setTransformRotateY(newElement, "0deg");
    }
  });
};

/**
 * Helper for the _flip transition that performs the more desirable (but more complicated) flip transition.
 * @private
 */
adf.shared.impl.animationUtils._flipInset = function(
  animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back, dimensionsFromParent)
{
  // This kind of flip requires an extra layer of DOM elements:
  // - the parent will be flipping so no other siblings should be present
  // - the parent flips within perspective of the grandparent so parent and grandparent should share equal dimensions
  var grandparentElement = parentElement.parentNode;
  animationContext.addExtraCancelFunction(function()
  {
    // Restore the 2 children back into the "grandparent" and purge the "parent"
    animationUtils._flipInsetExtraCancel(currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement);
  });

  animationUtils._saveStyles(grandparentElement);
  var perspectiveProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("perspective");
  grandparentElement.style[perspectiveProperty] = "2000px";

  // The parent needs preserve-3d because we are nesting rotations:
  animationUtils._setTransformStyle(parentElement, "preserve-3d");

  // We want matching dimensions among the children for a smooth flip.
  // The new element starts on the reverse side so we need to rotate it.
  var offsetWidth = 0;
  var offsetHeight = 0;
  if (hasNew)
  {
    offsetWidth = newElement.offsetWidth;
    offsetHeight = newElement.offsetHeight;
  }
  if (hasCurrent)
  {
    offsetWidth = Math.max(offsetWidth, currentElement.offsetWidth);
    offsetHeight = Math.max(offsetHeight, currentElement.offsetHeight);
  }
  if (hasNew)
  {
    animationUtils._setBackfaceVisibility(newElement, "hidden");
    newElement.style.width = offsetWidth + "px";
    newElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformValue(newElement, "perspective(2000px) rotateX(" + (back?"180deg":"-180deg") + ")");
    else
      animationUtils._setTransformValue(newElement, "perspective(2000px) rotateY(" + (back?"-180deg":"180deg") + ")");
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }
  if (hasCurrent)
  {
    animationUtils._setBackfaceVisibility(currentElement, "hidden");
    currentElement.style.width = offsetWidth + "px";
    currentElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformValue(currentElement, "perspective(2000px) rotateX(0deg)");
    else
      animationUtils._setTransformValue(currentElement, "perspective(2000px) rotateY(0deg)");
  }

  // In order to produce an inset flip, we need to change the transform origin, later we will also translate
  if (vertical)
    animationUtils._setTransformOrigin(parentElement, (back?"center bottom":"center top"));
  else
    animationUtils._setTransformOrigin(parentElement, (back?"left center":"right center"));

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    animationUtils._setTransition(parentElement, "all .2s ease-in-out");

    animationContext.addTransitionEndA(parentElement, function()
    {
      if (hasCurrent)
      {
        animationUtils._restoreStyles(currentElement);
        currentElement.style.display = "none";
      }
      if (hasNew)
        animationUtils._restoreStyles(newElement);

      // Restore the 2 children back into the "grandparent" and purge the "parent"
      animationUtils._flipInsetExtraCancel(currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement);
    });

    if (vertical)
      animationUtils._setTransformValue(
        parentElement,
        "perspective(2000px) " + (back?"translateY(-100%) rotateX(180deg)":"translateY(100%) rotateX(-180deg)"));
    else
      animationUtils._setTransformValue(
        parentElement,
        "perspective(2000px) " + (back?"translateX(100%) rotateY(180deg)":"translateX(-100%) rotateY(-180deg)"));
  });
};

/**
 * Restore the styles of the "grandparent" and "parent" elements.
 * @private
 */
adf.shared.impl.animationUtils._flipInsetExtraCancel = function(
  currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement)
{
  var animationUtils = adf.shared.impl.animationUtils;
  animationUtils._restoreStyles(parentElement);
  animationUtils._restoreStyles(grandparentElement);
};

// ======================= private agent helpers =======================

/**
 * Ensures that the specified style has a computed style that is different
 * than the one passed in.
 * @param {HTMLElement} element the DOM element whose style we are computing
 * @param {string} propertyName the browser-specific style property name
 * @param {string} valueItShouldNotBe the value the property should not be
 * @private
 */
adf.shared.impl.animationUtils._ensureAppliedStyle = function(
  element,
  propertyName,
  valueItShouldNotBe)
{
  if (element.ownerDocument.defaultView.getComputedStyle != null) // not IE8
  {
    // Chrome 37, 40 and Safari 8 have a bug where intermittently a style
    // property assignment does not always get applied which means it is not
    // possible for a CSS transition animation to occur.
    // By asking for a computed style, we are able to work around this issue and
    // force the browser to recognize the need for a transition.
    var actualValue =
      element.ownerDocument.defaultView.getComputedStyle(element)[propertyName];
    if (actualValue == valueItShouldNotBe)
      adf.shared.impl.animationUtils._fineLogger(
        "AdfAnimationUtils: computed style had unexpected value: " +
        actualValue);
  }
};

/**
 * Gets the name of the event used by this browser when a CSS transition ends.
 * @return {string} the transition-end event name
 * @private
 */
adf.shared.impl.animationUtils._getTransitionEndEventName = function()
{
  if (adf.shared.impl.animationUtils._transitionEndEventName == null)
  {
    var eventName = "transitionend";
    var element = document.createElement("div");
    var possibleEventNames = {
      "WebkitTransition": "webkitTransitionEnd",
      "transition":       "transitionend",
      "OTransition":      "oTransitionEnd",
      "MozTransition":    "transitionend"
    };

    for (var stylePropertyName in possibleEventNames)
    {
      if (element.style[stylePropertyName] !== undefined)
      {
        eventName = possibleEventNames[stylePropertyName];
        break;
      }
    }
    adf.shared.impl.animationUtils._transitionEndEventName = eventName;
  }
  return adf.shared.impl.animationUtils._transitionEndEventName;
};

/**
 * Gets the name of the style property used by this browser for a CSS transform.
 * @param {string} baseName the non-browser-specific style property name
 * @return {string} the transform style property name
 * @private
 */
adf.shared.impl.animationUtils._getBrowserSpecificName = function(baseName)
{
  if (adf.shared.impl.animationUtils._browserSpecificNames[baseName] == null)
  {
    var name = baseName;
    var capitalizedName = baseName.charAt(0).toUpperCase() + baseName.substring(1);
    var element = document.createElement("div");
    var possibleNames = {};
    possibleNames["Webkit" + capitalizedName] = "webkit" + capitalizedName;
    possibleNames[name] = name;
    possibleNames["O" + capitalizedName] = "o" + capitalizedName;
    possibleNames["Moz" + capitalizedName] = "moz" + capitalizedName;

    for (var stylePropertyName in possibleNames)
    {
      if (element.style[stylePropertyName] !== undefined)
      {
        //name = possibleNames[stylePropertyName];
        name = stylePropertyName;
        break;
      }
    }
    adf.shared.impl.animationUtils._browserSpecificNames[baseName] = name;
  }
  return adf.shared.impl.animationUtils._browserSpecificNames[baseName];
};

/**
 * Allow the browser to paint before invoking the given callback.
 * @param {function} callback the function to invoke after painting
 * @private
 */
adf.shared.impl.animationUtils._requestAnimationFrame = function(callback)
{
  var lastTime = 0;
  var vendors = ['webkit', 'ms', 'moz', 'o'];
  for (var x=0; x<vendors.length && !window.requestAnimationFrame; ++x)
  {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame =
      window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame)
  {
    window.requestAnimationFrame =
      function(callback)
      {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16-(currTime-lastTime));
        var id = window.setTimeout(
          function()
          {
            callback(currTime+timeToCall);
          },
          timeToCall);
        lastTime = currTime+timeToCall;
        return id;
      };
  }

  if (!window.cancelAnimationFrame)
  {
    window.cancelAnimationFrame =
      function(id)
      {
        clearTimeout(id);
      };
  }

  window.requestAnimationFrame(callback);
};

/**
 * Gets whether the specified agent minimum requirements are met or exceeded.
 * Every 2 arguments past actualAgentType and actualAgentVersion must correspond
 * to a minimum required agent type and floating point version number.
 * @param {string} actualAgentType the actual agent type ("trident", "webkit", "gecko")
 * @param {number} actualAgentVersion the actual agent version number as a floating point number
 * @return {boolean} whether the specified agent minimums are met
 * @private
 */
adf.shared.impl.animationUtils._isMinimumAgentMet = function(actualAgentType, actualAgentVersion)
{
  var argCount = arguments.length;
  if (argCount % 2 == 1) // odd number
  {
    adf.shared.impl.animationUtils._fineLogger("AdfAnimationUtils: invalid number of minimum agent requirement arguments: " + argCount);
    return false;
  }

  // Loop through each requirement pair to see if we match one
  for (var i=2; i<=argCount-2; i+=2)
  {
    var requriementType = arguments[i];
    if (actualAgentType == requriementType)
    {
      // We found an agent type match so now see if the actual version is greater than or equal
      // to the requirement version number:
      var requirementVersion = arguments[1+i];
      if (actualAgentVersion >= requirementVersion)
        return true; // met requirement
      else
        return false; // failed requirement
    }
  }
  return false; // no agent type match found; failed requirement
};

/**
 * Gets the agent type and version.
 * @param {string} givenUserAgentString the navigator's userAgent property
 * @return {Array.<Object>} with 2 members, a String for the agent type ("trident", "webkit", "gecko") and a Float for the agent version
 * @private
 */
adf.shared.impl.animationUtils._getAgentTypeAndVersion = function(givenUserAgentString)
{
  var versionParser = adf.shared.impl.animationUtils._parseFloatVersion;
  var agentType = null;
  var agentVersion = -1;
  var userAgent = givenUserAgentString.toLowerCase();
  if (userAgent.indexOf("msie") != -1 || userAgent.indexOf("trident") != -1)
  {
    agentType = "trident";
    var possibleVersion = versionParser(userAgent, /trident\/(\d+[.]\d+)/);
    if (possibleVersion != -1)
    {
      // 6.0 = IE10
      // 5.0 = IE9
      // 4.0 = IE8
      agentVersion = possibleVersion;
    }
    else
    {
      possibleVersion = versionParser(userAgent, /msie (\d+\.\d+);/);
      if (possibleVersion == -1)
        possibleVersion = versionParser(userAgent, /msie (\d+\.\d+)b;/); // expression for betas
      agentVersion = possibleVersion - 4; // Trident versions are 4 behind IE numbers
    }
    if (document.documentMode != null)
    {
      // If a documentMode is provided, it would be an IE number and Trident versions are 4 behind IE numbers.
      // The actual Trident version in use would be the smaller of the 2 numbers:
      agentVersion = Math.min(agentVersion, document.documentMode - 4);
    }
  }
  else if (userAgent.indexOf("applewebkit") != -1)
  {
    agentType = "webkit";
    // 536.26.17 = Mac Desktop Safari 6.0.2
    // 535.1 = Chrome 13.0.782.1
    // 534.46 = Safari 5.1 or iOS 5
    // 525.18 = Mac/Windows Desktop Safari 3.1.1
    // 420.1 = iOS 3
    agentVersion = versionParser(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
  }
  else if (userAgent.indexOf("gecko/")!=-1)
  {
    agentType = "gecko";
    // rv:5 = Firefox 5
    // rv:2 = Firefox 4
    // rv:1.9 = Firefox 3
    // rv:1.8.1 = Firefox 2
    // rv:1.8 = Firefox 1.5
    agentVersion = versionParser(userAgent, /rv:(\d+[.]\d+)/);
  }
  return [ agentType, agentVersion ];
};

/**
 * Parses the float version out of of the specified agent string using
 * a regular expression to identify the version portion of the string.
 * @param {string} userAgent the lowercase navigator user agent string
 * @param {RegExp} versionNumberPattern the regular expression pattern used to extract a number that will be parsed into a float
 * @private
 */
adf.shared.impl.animationUtils._parseFloatVersion = function(userAgent, versionNumberPattern)
{
  var matches = userAgent.match(versionNumberPattern);
  if (matches)
  {
    var versionString = matches[1];
    if (versionString)
      return parseFloat(versionString);
  }
  return -1;
};

/**
 * Save the current styles to be later restored via _restoreStyles.
 * @param {HTMLElement} element the DOM element whose style attribute is to be cached in a data attribute
 * @private
 */
adf.shared.impl.animationUtils._saveStyles = function(element)
{
  if (element != null && element.getAttribute && element.setAttribute)
  {
    // It is invalid to save styles if there was a pending restoreStyle call
    var styles = element.getAttribute("data-adf-original-style");
    if (styles != null)
    {
      adf.shared.impl.animationUtils._fineLogger("AdfAnimationUtils: save while pending restore");
      adf.shared.impl.animationUtils._restoreStyles(element); // restore just in case as a last resort
    }

    styles = element.getAttribute("style");
    if (styles == null)
      styles = "";
    element.setAttribute("data-adf-original-style", styles);
  }
};

/**
 * Restore the original styles that were saved via _saveStyles.
 * @param {HTMLElement} element the DOM element whose style attribute is to be restored from a data attribute
 * @private
 */
adf.shared.impl.animationUtils._restoreStyles = function(element)
{
  if (element != null && element.getAttribute && element.setAttribute)
  {
    var styles = element.getAttribute("data-adf-original-style");
    if (styles != null)
    {
      element.setAttribute("style", styles);
      if (element.removeAttribute)
        element.removeAttribute("data-adf-original-style");
    }
  }
};

/**
 * Opacity was not supported in old browsers.
 * @param {HTMLElement} element the opacity will be applied to
 * @param {string} opacityValue the opacity value
 * @private
 */
adf.shared.impl.animationUtils._setOpacity = function(element, opacityValue)
{
  element.style.opacity = opacityValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transition will be applied to
 * @param {string} transitionValue the transition value
 * @private
 */
adf.shared.impl.animationUtils._setTransition = function(element, transitionValue)
{
  var transitionProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transition");
  element.style[transitionProperty] = transitionValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform will be applied to
 * @param {string} transformValue the transform value
 * @private
 */
adf.shared.impl.animationUtils._setTransformValue = function(element, transformValue)
{
  var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
  element.style[transformProperty] = transformValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the translate will be applied to
 * @param {string} translateValues the translate value
 * @private
 */
adf.shared.impl.animationUtils._setTransformTranslate = function(element, translateValues)
{
  var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
  element.style[transformProperty] = "translate(" + translateValues + ")";
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the rotateX will be applied to
 * @param {string} rotateXValues the rotateX value
 * @private
 */
adf.shared.impl.animationUtils._setTransformRotateX = function(element, rotateXValues)
{
  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  if ("trident" == agentType)
  {
    // At least IE10 requires this hack plus removal of the ancestor perspective
    // to support hidden backface-visibility:
    element.style.transform = "perspective(2000px) rotateX(" + rotateXValues + ")";
  }
  else
  {
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    element.style[transformProperty] = "rotateX(" + rotateXValues + ")";
  }
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the rotateY will be applied to
 * @param {string} rotateYValues the rotateY value
 * @private
 */
adf.shared.impl.animationUtils._setTransformRotateY = function(element, rotateYValues)
{
  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  if ("trident" == agentType)
  {
    // At least IE10 requires this hack plus removal of the ancestor perspective
    // to support hidden backface-visibility:
    element.style.transform = "perspective(2000px) rotateY(" + rotateYValues + ")";
  }
  else
  {
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    element.style[transformProperty] = "rotateY(" + rotateYValues + ")";
  }
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the backface visibility will be applied to
 * @param {string} backfaceVisibility the backface visibility value
 * @private
 */
adf.shared.impl.animationUtils._setBackfaceVisibility = function(element, backfaceVisibility)
{
  var backfaceVisibilityProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("backfaceVisibility");
  element.style[backfaceVisibilityProperty] = backfaceVisibility;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform-style will be applied to
 * @param {string} transformStyle the transform-style value
 * @private
 */
adf.shared.impl.animationUtils._setTransformStyle = function(element, transformStyle)
{
  var transformStyleProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transformStyle");
  element.style[transformStyleProperty] = transformStyle;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform-origin will be applied to
 * @param {string} transformOrigin the transform-origin value
 * @private
 */
adf.shared.impl.animationUtils._setTransformOrigin = function(element, transformOrigin)
{
  var transformOriginProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transformOrigin");
  element.style[transformOriginProperty] = transformOrigin;
};

// ======================= private context object =======================

/**
 * This context object allows us to:<ul>
 * <li> maintain flags for whether each animation has finished
 * <li> when both listeners have finished, invoke the finishedFunction (if non-null)
 * <li> when each listener is called, unregister it to prevent re-invocation
 * <li> provide a cancel function that will prevent the finishedFunction from being called</ul>
 * @param {function} finishedFunction the function to invoke if the registered transition end events are invoked (and not cancelled)
 * @param {Object} callbackParams an object that will be passed to the finishedFunction when invoked
 * @constructor
 */
adf.shared.impl.animationUtils.AnimationContext = function(finishedFunction, callbackParams)
{
  this.Init(finishedFunction, callbackParams);
};

adf.shared.impl.animationUtils.AnimationContext.prototype = new Object();
if (window.AdfObject != null)
  adf.shared.impl.animationUtils.AnimationContext.prototype.constructor = window.AdfObject; // this will not work in ADF Mobile (no AdfObject exists)

/**
 * Object instance initializer.
 * @param {function} finishedFunction the function to invoke if the registered transition end events are invoked (and not cancelled)
 * @param {Object} callbackParams an object that will be passed to the finishedFunction when invoked
 * @protected
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.Init = function(finishedFunction, callbackParams)
{
  this._finishedFunction = finishedFunction;
  this._callbackParams = callbackParams;
  this._handledA = true; // initialize to true in case no "A" element is involved
  this._handledB = true; // initialize to true in case no "B" element is involved
};

/**
 * When implementing a custom transition, you are given an animationContext object.
 * Your transition function must return a proxied version of this function in the scope of the animationContext object.
 * This method will unregister the transition end handlers and restore the styles of the elements involved in the transition.
 * The ADF Faces deck component will invoke this method if a new transition comes in while another is processing.
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.cancelFunction = function()
{
  // Remove the finishedFunction so it won't be called and remove the listeners:
  this._finishedFunction = null;
  var callbackParams = this._callbackParams;
  this._callbackParams = null;
  var animationUtils = adf.shared.impl.animationUtils;
  animationUtils._restoreStyles(this._elementA);
  animationUtils._restoreStyles(this._elementB);
  var parentElement;
  if (this._elementA != null)
  {
    parentElement = this._elementA.parentNode;
    animationUtils._restoreStyles(parentElement);
    if (parentElement != null)
      animationUtils._restoreStyles(parentElement.parentNode);
    
  }
  else if (this._elementB != null)
  {
    parentElement = this._elementB.parentNode;
    animationUtils._restoreStyles(parentElement);
    if (parentElement != null)
      animationUtils._restoreStyles(parentElement.parentNode);
  }
  this._removeTransitionEndA();
  this._removeTransitionEndB();
  if (this._extraCancelFunction)
  {
    try
    {
      this._extraCancelFunction();
    }
    catch (problem)
    {
      // Should only get here if there is a problem in the transition implementation:
      animationUtils._fineLogger("AdfAnimationUtils: unable to complete extra cancel function due to problem:");
      animationUtils._fineLogger(problem);
    }
    this._extraCancelFunction = null;
  }
  return callbackParams;
};

/**
 * This method cleans up the context and performs the finished function given at context creation time.
 * @private
 */
adf.shared.impl.animationUtils.AnimationContext.prototype._performFinish = function()
{
  // invode the finish function and perform cleanup
  var finishedFunction      = this._finishedFunction;
  var callbackParams        = this._callbackParams;
  this._finishedFunction    = null;
  this._extraCancelFunction = null;
  this._callbackParams      = null;
  if (finishedFunction != null)
    finishedFunction(callbackParams);
};

/**
 * Adds a function that will be called if this animation gets cancelled.
 * This allows extra cleanup to be performed if necessary.
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addExtraCancelFunction = function(extraCancelFunction)
{
  this._extraCancelFunction = extraCancelFunction;
};

/**
 * When implementing a custom transition, you need to register transition end events for any element
 * transitioning so that the finished function is properly invoked after the transition ends.
 * See also the addTransitionEndB function if you have a second element involved.
 * @param {HTMLElement} element the element whose transition end event you want to listen for
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addTransitionEndA = function(element, extraHandler)
{
  // Add the event listeners and save a reference to the element:
  this._elementA = element;
  this._handleProxyA = adf.shared.impl.animationUtils.getProxyFunction(this, this._handleTransitionEndA);
  this._handledA = false; // an "A" element is involved so re-initialize this to false
  var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
  if (extraHandler != null)
  {
    this._extraHandlerA = extraHandler;
    element.addEventListener(transitionEndEventName, extraHandler, true);
  }
  element.addEventListener(transitionEndEventName, this._handleProxyA, true);
};
adf.shared.impl.animationUtils.AnimationContext.prototype._removeTransitionEndA = function()
{
  // Remove the event listeners and remove the reference to the element:
  var element = this._elementA;
  if (element != null)
  {
    var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
    if (this._extraHandlerA != null)
    {
      element.removeEventListener(transitionEndEventName, this._extraHandlerA, true);
      this._extraHandlerA = null;
    }
    element.removeEventListener(transitionEndEventName, this._handleProxyA, true);
    this._elementA = null;
  }
  this._handleProxyA = null;
};
adf.shared.impl.animationUtils.AnimationContext.prototype._handleTransitionEndA = function()
{
  if (!this._handledA)
  {
    // Mark this element's event as being handled, remove the listeners:
    this._handledA = true;
    this._removeTransitionEndA();

    // If both elements' events were handled, invoke the finishFunction:
    if (this._handledB)
      this._performFinish(); // both events were handled
  }
};

/**
 * When implementing a custom transition, you need to register transition end events for any element
 * transitioning so that the finished function is properly invoked after the transition ends.
 * See also the addTransitionEndA function if you have a second element involved.
 * @param {HTMLElement} element the element whose transition end event you want to listen for
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addTransitionEndB = function(element, extraHandler)
{
  // Add the event listeners and save a reference to the element:
  this._elementB = element;
  this._handleProxyB = adf.shared.impl.animationUtils.getProxyFunction(this, this._handleTransitionEndB);
  this._handledB = false; // a "B" element is involved so re-initialize this to false
  var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
  if (extraHandler != null)
  {
    this._extraHandlerB = extraHandler;
    element.addEventListener(transitionEndEventName, extraHandler, true);
  }
  element.addEventListener(transitionEndEventName, this._handleProxyB, true);
};
/** @private */
adf.shared.impl.animationUtils.AnimationContext.prototype._removeTransitionEndB = function()
{
  // Remove the event listeners and remove the reference to the element:
  var element = this._elementB;
  if (element != null)
  {
    var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
    if (this._extraHandlerB != null)
    {
      element.removeEventListener(transitionEndEventName, this._extraHandlerB, true);
      this._extraHandlerB = null;
    }
    element.removeEventListener(transitionEndEventName, this._handleProxyB, true);
    this._elementB = null;
  }
  this._handleProxyB = null;
};
/** @private */
adf.shared.impl.animationUtils.AnimationContext.prototype._handleTransitionEndB = function()
{
  if (!this._handledB)
  {
    // Mark this element's event as being handled, remove the listeners:
    this._handledB = true;
    this._removeTransitionEndB();

    // If both elements' events were handled, invoke the finishFunction:
    if (this._handledA)
      this._performFinish(); // both events were handled
  }
};
/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-core.js ---------------------- */
/* ------------------------------------------------------ */

adf.mf.log.AMX = adf.mf.log.AMX ||
  new adf.mf.log.logger("oracle.adfmf.amx");

// --------- Config Initialization --------- //
(function()
{
  amx.dtmode = false; // TODO deprecated, use adf.mf.environment.profile.dtMode instead
  // this boolean value will be set directly via the Selenium scripts
  amx.testmode = amx.testmode || false;
  amx.failsafeinvoked = false;

  // GREGOR
  amx.CALL_IDX = 1;

  if (adf.mf.environment.profile.dtMode != null)
  {
    amx.dtmode = adf.mf.environment.profile.dtMode;
  }

  /**
   * Gets the agent type and version.
   * @param {string} givenUserAgentString the navigator's userAgent property
   * @return {Object} with members: a String for the agent type ("iOS", "Android", "trident",
   *                  "webkit", "gecko"), a String for the agent subtype if applicable ("Chrome",
   *                  "Generic", null), and a Number for the agent version
   * @private
   */
  function _getAgentTypeAndVersion(givenUserAgentString)
  {
    var versionParser = _parseFloatVersion;
    var agentType = "unknown";
    var agentSubtype = null;
    var agentVersion = -1;
    var incompatible = false;
    var userAgent = givenUserAgentString.toLowerCase();
    if (userAgent.indexOf("msie") != -1 || userAgent.indexOf("trident") != -1)
    {
      agentType = "trident";
      var possibleVersion = versionParser(userAgent, /trident\/(\d+[.]\d+)/);
      if (possibleVersion != -1)
      {
        // 7.0 = IE11
        // 6.0 = IE10
        // 5.0 = IE9
        // 4.0 = IE8
        agentVersion = possibleVersion;
      }
      else
      {
        possibleVersion = versionParser(userAgent, /msie (\d+\.\d+);/);
        if (possibleVersion == -1)
          possibleVersion = versionParser(userAgent, /msie (\d+\.\d+)b;/); // expression for betas
        agentVersion = possibleVersion - 4; // Trident versions are 4 behind IE numbers
      }
      if (document.documentMode != null)
      {
        // If a documentMode is provided, it would be an IE number and Trident versions are 4 behind IE numbers.
        // The actual Trident version in use would be the smaller of the 2 numbers:
        agentVersion = Math.min(agentVersion, document.documentMode - 4);
      }
      incompatible = _getReasonIfUnsupported(agentVersion, 6);
    }
    else if (userAgent.indexOf("edge") !== -1)
    {
      agentType = "UWP";

      // we do not need a agentSubtype for now since it will always be edge

      agentVersion = versionParser(userAgent, /edge\/(\d+([.]\d+)*)/);

      // for now it will be compatible until we move to a newer edge for input type="time" etc.
      incompatible = false;
    }
    else if (userAgent.indexOf("applewebkit") != -1)
    {
      agentType = "webkit";
      // 536.26.17 = Mac Desktop Safari 6.0.2
      // 535.1 = Chrome 13.0.782.1
      // 534.46 = Safari 5.1 or iOS 5
      // 525.18 = Mac/Windows Desktop Safari 3.1.1
      // 420.1 = iOS 3
      agentVersion = versionParser(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
      if (userAgent.match(/ip(hone|ad|od)/))
      {
        agentType = "iOS";
        var mobileSafariVersion = versionParser(userAgent, /version\/(\d+([.]\d+)*)/);
        if (mobileSafariVersion != -1) // WebView won't contain version info
          incompatible = _getReasonIfUnsupported(mobileSafariVersion, 6.0);
      }
      else if (userAgent.match(/android/))
      {
        if (userAgent.match(/chrome\//))
        {
          agentType = "Android";
          agentSubtype = "Chrome";
        }
        else // pre-KitKat aka 4.4
        {
          agentType = "Android";
          agentSubtype = "Generic";
        }
        var androidVersion = versionParser(userAgent, /android (\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(androidVersion, 4);
      }
      else if (userAgent.match(/chrome/)) // desktop Chrome
      {
        var chromeVersion = versionParser(userAgent, /chrome\/(\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(chromeVersion, 29);
      }
      else // desktop Safari
      {
        var safariVersion = versionParser(userAgent, /version\/(\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(safariVersion, 6.1);
      }
    }
    else if (userAgent.indexOf("gecko/")!=-1)
    {
      agentType = "gecko";
      // rv:5 = Firefox 5
      // rv:2 = Firefox 4
      // rv:1.9 = Firefox 3
      // rv:1.8.1 = Firefox 2
      // rv:1.8 = Firefox 1.5
      agentVersion = versionParser(userAgent, /rv:(\d+[.]\d+)/);
      incompatible = _getReasonIfUnsupported(agentVersion, 28);
    }

    var agentClass = " amx-" + agentType.toLowerCase();
    if (agentSubtype)
      agentClass += "-" + agentSubtype.toLowerCase();
    document.documentElement.className += agentClass;

    if (incompatible)
    {
      // Append the given User Agent string in case it is simply a matter of it
      // being in an unexpected format.
      incompatible += "; " + givenUserAgentString;
    }

    return {
      "type": agentType,
      "subtype": agentSubtype,
      "version": agentVersion,
      "incompatible": incompatible
    };
  }

  function _getReasonIfUnsupported(versionFound, versionRequired)
  {
    if (versionFound < versionRequired)
      return "" + versionFound + " < " + versionRequired;
    return false;
  }

  /**
   * Parses the float version out of of the specified agent string using
   * a regular expression to identify the version portion of the string.
   * @param {string} userAgent the lowercase navigator user agent string
   * @param {RegExp} versionNumberPattern the regular expression pattern used to extract a number that will be parsed into a float
   * @private
   */
  function _parseFloatVersion(userAgent, versionNumberPattern)
  {
    var matches = userAgent.match(versionNumberPattern);
    if (matches)
    {
      var versionString = matches[1];
      if (versionString)
        return parseFloat(versionString);
    }
    return -1;
  }

  // Add agent marker classes:
  adf.mf.internal.amx.agent = _getAgentTypeAndVersion(navigator.userAgent);

  adf.mf.internal.amx.agent.getTransitionEndEventName = function()
  {
    if (adf.mf.internal.amx.agent._transitionEndEventName == null)
    {
      var transitionEndEventName = "transitionend";
      var element = document.createElement("div");
      var transitions = {
        "WebkitTransition": "webkitTransitionEnd",
        "transition": "transitionend",
        "OTransition": "oTransitionEnd",
        "MozTransition": "transitionend"
      };

      for (var t in transitions)
      {
        if (element.style[t] !== undefined)
        {
          transitionEndEventName = transitions[t];
          break;
        }
      }
      adf.mf.internal.amx.agent._transitionEndEventName = transitionEndEventName;
    }
    return adf.mf.internal.amx.agent._transitionEndEventName;
  };

  /**
   * Internal cache of the isTransitionAfterRender result.
   */
  adf.mf.internal.amx.transitionAfterRender = null;

  /**
   * WARNING - This function and property are not supported and will be removed
   *           without any notice.
   * Internal flag that specifies whether we should render before transitioning or
   * display an empty placeholder for immediate transitioning.
   * @param {boolean} isFirstPage whether this is the initial page render
   * @return true for rendering before or false for immediate transitioning
   */
  adf.mf.internal.amx.isTransitionAfterRender = function(isFirstPage)
  {
    // See if an unsupported override was specified as an adf-property in the adf-config.xml file.
    // <adf-property name="amxTransitionMode" value="placeholder"/>
    var transitionAfterRender = adf.mf.internal.amx.transitionAfterRender;
    if (transitionAfterRender == null)
    {
      transitionAfterRender = true;

      // Get the value from the adf-config.xml object (might not be defined):
      var amxTransitionModeELExpression = adf.mf.internal.el.parser.parse ("#{applicationScope.configuration.amxTransitionMode}");
      var amxTransitionMode =
        adf.mf.environment.profile.mockData ?
          null :
        adf.mf.el.getLocalValue(amxTransitionModeELExpression);

      if ("placeholder" == amxTransitionMode)
        transitionAfterRender = false; // fast but ugly
      else
        transitionAfterRender = true; // pretty but slow

      if (isFirstPage)
      {
        // Unfortunately, applicationScope.configuration is not made available automatically
        // so we have to kick off an extra request for it so that the next time this method
        // gets called, we will know what the value is.
        // (Just before the first adf.mf.api.setContext call, we kicked off a request so
        // it will be available by the time we transition.)
        // Also, since we don't know what it is yet, we won't save off a cached result yet.
      }
      else
      {
        // Save it off so we don't have to continuously re-evaluate it.
        adf.mf.internal.amx.transitionAfterRender = transitionAfterRender;
      }
    }
    return transitionAfterRender;
  };

  amx.config =
  {
    debug:
    {
      enable: false,
      onScreen: false
    }
  };

  // TODO this and any of its uses need to be removed
  amx.log = {};

  function addToOnScreenAmxLog(text)
  {
    if (amx.config.debug.onScreen && !amx.amxDebug)
    {
      var debugDiv = document.createElement("div");
      debugDiv.setAttribute("id", "amxDebug");
      document.body.appendChild(debugDiv);
      amx.amxDebug = debugDiv;
      }

    if (amx.amxDebug)
      {
      if (amx.amxDebug.childNodes.length == 1)
        amx.amxDebug.appendChild(document.createElement("br"));
      else
        amx.amxDebug.insertBefore(document.createElement("br"), amx.amxDebug.firstChild);
      amx.amxDebug.insertBefore(document.createTextNode(text), amx.amxDebug.firstChild);
      }
  };

  amx.log.debug = function(text)
      {
    if (amx.config.debug.enable)
    {
      addToOnScreenAmxLog(text);
        console.log(text);
      }
  };

  amx.log.error = function(text)
  {
    text = "AMX-ERROR: " + text;
    addToOnScreenAmxLog(text);
    console.log(text);
  };

  amx.log.warn = function(text)
  {
    text = "AMX-WARN: " + text;
    addToOnScreenAmxLog(text);
      console.log(text);
  };

  // Add the AMX-specific loading contributors so that base-core's
  // adf.mf.api.isLoading() API will consider AMX's needs:
  adf.mf.api.addLoadingContributor(function()
    {
      // Return true if these things are all idle/finished or false if at least
      // one is still busy/processing.
      var isIdle =
        adf.mf.api.amx.acceptEvent() &&
        (adf.mf.internal.amx._showLoadingCalls == 0) &&
        (adf.mf.internal.getUnresolvedCallDepth() == 0) &&
        (amx.getCurrentPageName() != null) &&
        adf.mf.internal.amx._pageBuildPromiseResolve == null &&
        !adf.mf.internal.amx.isUIChangePaused();
      if (!isIdle)
        return false; // short circuit; busy, still loading

      var animatingElements = document.getElementsByClassName("amx-animating")
      var animatingElementsCount = animatingElements.length;
      if (animatingElementsCount > 0)
      {
        // We need to look at every animating element and check whether it is using
        // display none styling
        for (var i = 0; i < animatingElementsCount; ++i)
        {
          if (animatingElements[i].style.display != "none")
            return false; // short circuit; found one non-display:none animation; busy
        }
      }

      var deferredLoadingElements = document.getElementsByClassName("amx-deferred-loading")
      var deferredLoadingElementCount = deferredLoadingElements.length;
      if (deferredLoadingElementCount > 0)
      {
        // We need to look at every deferred loading element and check whether it is using
        // display  none styling
        for (var i=0; i<deferredLoadingElementCount; ++i)
        {
          if (deferredLoadingElements[i].style.display != "none")
            return false; // short circuit; found one non-display:none indicator; busy
        }
      }

      return true; // idle, not loading
    });

})();

/**
 * Internal function for looping over object members.
 * @private
 */
adf.mf.internal.amx._each = function(obj, callback)
{
  for (var key in obj)
  {
    if (obj.hasOwnProperty(key))
      callback(key, obj[key]);
  }
};

// --------- /Config Initialization --------- //
/**
 * A counter for the numnber of calls made to showLoading indicator. This is required because there are several starting
 * points that can occur for long operations. The issue is that they can overlap so you are calling the start more then
 * once. The solution to this problem is to keep a count of the number of calls to start and increment this value. There
 * will be a corresponding number if calls to hide and when we get to zero we will do hiding.
 * @type {number}
 * @private
 */
adf.mf.internal.amx._showLoadingCalls = 0;

/**
 * Internal function called to bring up the loading indicator.
 * @private
 */
adf.mf.internal.amx._showLoadingIndicator = function()
{
  var loadingDiv = document.getElementById("amx-loading");
  var cl = loadingDiv.classList;
  cl.remove("hidden");        // get rid of the display:none
  cl.add("beforeShowing");    // now at display:block but with opacity:0
  cl.remove("beforeShowing"); // get rid of opacity:0
  cl.add("showing");          // animate to opacity:1

  // Let WAI-ARIA users know the page is loading
  var loadingLiveRegion = document.getElementById("amx-loading-live-region");
  if (loadingLiveRegion != null)
  {
    var msgLoading = adf.mf.resource.getInfoString("AMXInfoBundle", "MSG_LOADING");
    if (msgLoading == null) // will be null if too soon (e.g. initial page load)
      msgLoading = "Loading";
    loadingLiveRegion.textContent = msgLoading;
  }
};

/**
 * This function shows the busy indicator.
 * You are responsible for hiding the indicator or else it will be shown longer than necessary.
 * First consider whether you really need to use this API.
 * This function is generally targeted for component developers.
 * If you are an app developer, you might simply need to use amx:loadingIndicatorBehavior tag in
 * your page with its failSafeDuration attribute.
 * @param {number} failSafeDuration The approximate duration (non-negative integer in milliseconds) that the framework
 *                                  will wait between showing and hiding the loading indicator (assuming some other
 *                                  trigger has not already shown the indicator); if null or not specified, 10000 (10
 *                                  seconds) will be used instead.
 * @param {function() : string} failSafeClientHandler The optional JavaScript function that will be invoked when the failSafeDuration
 *                                         has been reached. This function can be used to decide how to proceed. This
 *                                         function must return a String that is one of these values:
 *                                         (a) "hide" (meaning just hide the indicator like the default fail-safe),
 *                                         (b) "repeat" (meaning restart the timer for another duration where the function
 *                                             may get invoked again), or
 *                                         (c) "freeze" (meaning keep the indicator up and wait indefinitely; the page may
 *                                             become stuck in a frozen state until restarted).
 */
adf.mf.api.amx.showLoadingIndicator = function(failSafeDuration, failSafeClientHandler)
{
  // This will set a timer to actually launch the busy indicator.
  // This is set on a timer to allow us to cancel this and not show any busy indicator if the action being
  // performed is less then 250ms.

  // If this is the first call to showing the Loading/Busy Indicator and we are not starting of the feature
  // then we have to set the timer to show the loading/busy indicator.
  if (adf.mf.internal.amx._showLoadingCalls == 0 && adf.mf.internal.amx._loadingIndicatorNotFirstTime == true)
  {
    adf.mf.internal.amx._showLoadingIndicator();

    // Need a failsafe timer that will guarantee that the loading indicator is removed.

    // The amx:view tag supports an amx:loadingIndicatorBehavior which lets you
    // define defaults for the page (see amx:view's render() function):
    var actualFailSafeDuration = adf.mf.internal.amx._failSafeDuration; // default is 10 seconds (10,000 ms)
    var actualFailSafeClientHandler = adf.mf.internal.amx._failSafeClientHandler;

    // If passed-in overrides were given, use those instead of the defaults:
    if (failSafeDuration !== undefined)
      actualFailSafeDuration = failSafeDuration;
    if (failSafeClientHandler !== undefined)
      actualFailSafeClientHandler = failSafeClientHandler;

    var failSafeTimerHandler = function()
    {
      var result = "hide";
      try
      {
        if (actualFailSafeClientHandler != null)
          result = actualFailSafeClientHandler();
      }
      catch (problem)
      {
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "adf.mf.api.amx.showLoadingIndicator", "MSG_PROBLEM_WHILE_INVOKING_FAIL_SAFE_HANDLER");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx", "showLoadingIndicator", problem);
      }

      if (adf.mf.internal.amx._failSafeTimer != null) // if still applicable
      {
        if (result == "freeze")
          return;
        else if (result == "repeat")
          adf.mf.internal.amx._failSafeTimer =
            window.setTimeout(failSafeTimerHandler, actualFailSafeDuration);
        else // "hide"
          adf.mf.internal.amx.killLoadingIndicator();
      }
    };

    adf.mf.internal.amx._failSafeTimer =
      window.setTimeout(failSafeTimerHandler, actualFailSafeDuration);
    // Set the number of calls to 1
    adf.mf.internal.amx._showLoadingCalls = 1;
  }
  else
  {
    // This is not the first call so we need to just increase the number of calls. This is neeeded as we will decrement
    // this value and when we hit zero then we will remove the loading/busy indicator.
    adf.mf.internal.amx._showLoadingCalls = adf.mf.internal.amx._showLoadingCalls + 1;
  }
};

/**
 * To ensure that the loading/busy indicator for some unknown reason is removed we have a failsafe timer that will
 * ensure that this is removed. This is required because the user will be unable to interact with the page as loading/
 * busy indicator is blocking all input.
 */
adf.mf.internal.amx.killLoadingIndicator = function()
{
  // Since the failsafe had to kick in we need to clear the timer and also delete the old timer.
  // Clear the timer so it is not called again.
  window.clearTimeout(adf.mf.internal.amx._failSafeTimer);
  // Need to delete the old timer
  delete adf.mf.internal.amx._failSafeTimer;
  // Need to reset the calls to 0
  adf.mf.internal.amx._showLoadingCalls = 0;
  // Transition the loading/busy indicator off.
  var loadingDiv = document.getElementById("amx-loading");
  var transitionEndFunction =
    function()
    {
      loadingDiv.classList.remove("hiding"); // no longer animating
      loadingDiv.classList.add("hidden");    // set display:none

      // Blank out the loading WAI-ARIA live region so that you won't hear the text when not loading
      var loadingLiveRegion = document.getElementById("amx-loading-live-region");
      if (loadingLiveRegion != null)
      {
        loadingLiveRegion.textContent = "";
      }

      // We are done with showing the initial HTML for the page:
      adf.mf.internal.api.queueShowPageComplete();
      adf.mf.internal.amx.addBuildGestureIfApplicable();
    };
  adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe(
    loadingDiv,
    transitionEndFunction);

  loadingDiv.classList.remove("showing"); // get rid of opacity:1
  loadingDiv.classList.add("hiding");     // animate to opacity:0

  // if we are in test mode, then set the failsafe invoked flag
  if (amx.testmode)
  {
    amx.failsafeinvoked = true;
  }
};

/**
 * Hides one instance of the loading indicator.
 */
adf.mf.api.amx.hideLoadingIndicator = function()
{
  // This function will decrement the showLoadingIndicator calls.
  // Once attribute and when it goes to zero will start the process for hiding the loading/busy indicator.

  if (adf.mf.internal.amx._showLoadingCalls == 0)
    return;

  adf.mf.internal.amx._showLoadingCalls = adf.mf.internal.amx._showLoadingCalls - 1;
  if (adf.mf.internal.amx._showLoadingCalls == 0)
  {
    var loadingDiv = document.getElementById("amx-loading");
    var cl = loadingDiv.classList;
    cl.remove("showing"); // get rid of opacity:1
    cl.add("hiding");     // animate to opacity:0
    cl.remove("hiding");  // no longer animating
    cl.add("hidden");     // set display:none

    // Clear the failsafe timer so it is not called.
    window.clearTimeout(adf.mf.internal.amx._failSafeTimer);

    // Need to delete the old failsafe timer
    delete adf.mf.internal.amx._failSafeTimer;

    // Blank out the loading WAI-ARIA live region so that you won't hear the text when not loading
    var loadingLiveRegion = document.getElementById("amx-loading-live-region");
    if (loadingLiveRegion != null)
    {
      loadingLiveRegion.textContent = "";
    }
  }
};

/**
 * This is a special case for clearing the loading/busy indicator. On the initial load of the feature we set the style
 * on the DIV to show the loading indicator. This means there will be no call to hiding and instead call this function.
 * Unfortunalty this function will get called multiple times based on where this call had to put. This means we need
 * to make sure this is only called the once and we rely on the attribute being set for this.
 */
adf.mf.api.amx.hideLoadingIndicatorOnlyIfFirstTime = function()
{
  // If this is the first time this function is called then we will hide the loading/busy indicator.
  if (adf.mf.internal.amx._loadingIndicatorNotFirstTime == null)
  {
    // Based on the path taken to all this function there may have been other calls to showing. We need to ensure that
    // the counter has been set back to zero.
    adf.mf.internal.amx._showLoadingCalls = 0;
    adf.mf.internal.amx._loadingIndicatorNotFirstTime = true;
    var loadingDiv = document.getElementById("amx-loading");
    var transitionEndFunction = function()
      {
        loadingDiv.classList.remove("hiding"); // no longer animating
        loadingDiv.classList.add("hidden");    // set display:none

        // We are done with showing the initial HTML for the page:
        adf.mf.internal.api.queueShowPageComplete();
        adf.mf.internal.amx.addBuildGestureIfApplicable();
      };
    adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe(
      loadingDiv,
      transitionEndFunction);

    loadingDiv.classList.remove("showing"); // get rid of opacity:1
    loadingDiv.classList.add("hiding");     // animate to opacity:0

    // MAX's use of iframes makes computed styles unfeasible; this may cause
    // other problems for MAX.
    if (adf.mf.internal.amx.getComputedStyle(loadingDiv).opacity == 0 ||
        adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
    {
      // Already at zero opacity so no transition will take place, clean up now:
      transitionEndFunction();
    }

    var incompatible = adf.mf.internal.amx.agent["incompatible"];
    if (incompatible)
    {
      // Log the warning:
      adf.mf.log.logInfoResource(
        "AMXInfoBundle",
        adf.mf.log.level.SEVERE,
        "_getAgentTypeAndVersion",
        "MSG_ERROR_UNSUPPORTED_BROWSER",
        incompatible);

      // Show the warning to the user so they can take action:
      if (!adf.mf.environment.profile.dtMode && // not in DT mode
        !adf.suppressUnsupportedBrowserError) // isn't suppressing the warning
      {
        var unsupportedBrowserError =
          adf.mf.resource.getInfoString(
            "AMXInfoBundle",
            "MSG_ERROR_UNSUPPORTED_BROWSER",
            incompatible);
        alert(unsupportedBrowserError);
      }
    }
  }
  else
  {
    adf.mf.api.amx.hideLoadingIndicator();
  }
};

/**
 * When an app is deployed using debug mode, allow repeated taps on the page
 * that occur within a set time limit to cause build information to be displayed
 * to the user.
 */
adf.mf.internal.amx.addBuildGestureIfApplicable = function()
{
  if (adf._debugBodyPageTapCount == null)
  {
    adf._debugBodyPageTapCount = [ 0, 0 ]; // tap count, timestamp
    var bodyPage = document.getElementById("bodyPage");
    if (bodyPage != null &&
        bodyPage.classList.contains("amx-debug"))
    {
      adf.mf.api.amx.addBubbleEventListener(
        bodyPage,
        "touchend",
        function(event)
        {
          var currentTime = (new Date()).getTime();

          // Have we surpassed the limit for repeated tapping?
          if (currentTime - adf._debugBodyPageTapCount[1] > 3000)
            adf._debugBodyPageTapCount = [ 1, currentTime ]; // exceeded time limit
          else
            ++adf._debugBodyPageTapCount[0]; // increment the tap counter

          if (adf._debugBodyPageTapCount[0] == 10) // tapped enough times
          {
            var buildInfo = adf.mf.internal.BUILD_INFO;
            if (buildInfo != null)
            {
              var productVersion = buildInfo["PRODUCT_VERSION"];
              var jobName = buildInfo["JOB_NAME"];
              var buildNumber = buildInfo["BUILD_NUMBER"];

              // Do not show an alert if there is nothing to display or if we are
              // in automation mode (don't want to interfere with testing when
              // rapidly tapping).
              if (productVersion != "?" &&
                document.getElementById("bodyPage").className.indexOf("amx-automation") == -1)
              {
                var buildInfo = "Oracle MAF " + productVersion + " - " + jobName + " " + buildNumber;
                adf.mf.api.amx.addMessage("info", buildInfo, null, null);
              }
            }
          }
        });
    }
  }
};

/**
 * Bulk load a set of providers so they cached and accessibly locally.
 * @param {Object} treeNodeIterator is the tree node iterator to load the provider from
 * @param {number} startingPoint to load from, typically 0 but recursive calls will change those to
 *        be page/set boundary markers
 * @param {number} numberOfRows to load up to the number of providers in the collection. Represents
 *        the total number of rows, not relative to the starting point
 * @param {function} success the callback to invoke when all the providers have been loaded
 * @param {function} failed the callback to invoke on error
 */
adf.mf.api.amx.bulkLoadProviders = function(
  treeNodeIterator,
  startingPoint,
  numberOfRows,
  success,
  failed)
{
  // Do not process bulk loads during navigation
  if (adf.mf.internal.amx._navigationInProgress)
  {
    if (failed != null)
    {
      var loadIgnoredMessage = adf.mf.resource.getInfoString(
        "AMXErrorBundle", "ERROR_BULK_LOAD_IGNORED_DUE_TO_NAVIGATION");

      failed(loadIgnoredMessage, null); // invoke failure callback; load was invalid
    }

    return;
  }

  var navigationIdAtStart = adf.mf.internal.amx._navigationId;
  var scb = success;
  var fcb = failed;

  var tnb = treeNodeIterator.getTreeNodeBindings();

  // Get the number of cached rows after the starting point
  var cachedRows = treeNodeIterator.getCachedRowCount(startingPoint);
  // Get the total number of rows in the collection model (not just cached)
  var maxRows = tnb.keys.length;
  // Get the desired number of rows that should be cached (from 0, aka total)
  var desiredRowCount =
    (
      (numberOfRows == -1) ||
      (maxRows < numberOfRows &&
        (
          !tnb ||
          !tnb.hasMoreKeys
        )
      )
    ) ? maxRows : numberOfRows;

  if (cachedRows + startingPoint < desiredRowCount)
  {
    // fetch more data - note this will call nextSet and then recurse to fetch any remaining rows
    // if need be
    var newIndex = startingPoint + cachedRows;
    var isFetchingMoreRows = false;
    if (newIndex < 0)
    {
      newIndex = 0;
    }
    else if (newIndex >= maxRows)
    {
      newIndex = maxRows - 1;
      isFetchingMoreRows = true;
    }
    treeNodeIterator.setCurrentIndex(newIndex);

    var hasMoreKeys = tnb.hasMoreKeys;

    treeNodeIterator.nextSet(
      function()
      {
        // If the page has been navigated when we got here after we started the load, then
        // there's nothing for us to do with the fetched data so we must ignore it:
        if (navigationIdAtStart != adf.mf.internal.amx._navigationId || adf.mf.internal.amx._navigationInProgress)
        {
          var loadIgnoredMessage =
            adf.mf.resource.getInfoString(
              "AMXErrorBundle", "ERROR_BULK_LOAD_IGNORED_DUE_TO_NAVIGATION");
          fcb(loadIgnoredMessage, null); // invoke failure callback; load was invalid
          return;
        }

        // See if the last call was supposed to load more than the maximum number of rows
        if (isFetchingMoreRows)
        {
          tnb = treeNodeIterator.getTreeNodeBindings();
          var newMaxRows = tnb.keys.length;
          if (newMaxRows <= maxRows)
          {
            if (!tnb.hasMoreKeys && hasMoreKeys)
            {
              // If the flag for hasMoreKeys was true but is now false, then the load was
              // successful but there were no rows to be loaded
              scb(null, null);
              return;
            }
            else
            {
              // See if the number of cached rows changed. If so, then call the success callback,
              // else treat this as a failure since no rows were loaded with no apparent reason
              var newCachedRows = treeNodeIterator.getCachedRowCount(startingPoint);

              // Get the total number of rows in the collection model (not just cached)
              if (newCachedRows > cachedRows)
              {
                scb(null, null);
              }
              else
              {
                fcb(null, null);
              }
              return;
            }
          }
        }

        if (isFetchingMoreRows)
        {
          ++newIndex;
        }
        adf.mf.api.amx.bulkLoadProviders(treeNodeIterator, newIndex, desiredRowCount,
          success, failed);
      },
      fcb);
  }
  else
  {
    // we have the data already cached
    try
    {
      scb(null, null);
    }
    catch(fe)
    {
      fcb(fe, null);
    }
  }
};

// ------ amx UI ------ //
(function()
{
  // this tells if the app is transitioning something (events should be frozen when doing so)
  amx.transitioning = false;

  amx.acceptEvent = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amx.acceptEvent", "MSG_DEPRECATED", "amx.acceptEvent", "adf.mf.api.amx.acceptEvent");
    return adf.mf.api.amx.acceptEvent();
  };

  /**
   * Determines whether an event can be processed.
   * @return {Boolean} whether it is safe to proceed with event processing (not in the middle of a transition)
   */
  adf.mf.api.amx.acceptEvent = function()
  {
    return !amx.transitioning && !adf.mf.environment.profile.dtMode;
  };

  amx.getCurrentPageName = function()
  {
    var currentPage = document.querySelector(".amx-view-container.current");
    if (currentPage != null)
      return currentPage.getAttribute("data-pagename");
    return null;
  };

  /**
   * Determines whether the environmentMode is set to mobileApplicationAccelerator.
   * @return {Boolean} true if environmentMode is set to mobileApplicationAccelerator, otherwise false.
   */
  adf.mf.internal.amx.isMobileApplicationAcceleratorMode = function ()
  {
    if (adf.mf.environment.profile.environmentMode == "mobileApplicationAccelerator")
    {
      return true;
    }
    return false;
  };

  amx.hooks = {};
  // ------ Public API ------ //
  var isFirstPage = true;
  var initPromise = null;

  //  Let the navigation handler manage view history and the MfContextInstance.
  adf.mf.internal.useNavHandlerViewHistory = true;

  /**
   * @deprecated Use amxNode.getVolatileState instead.
   */
  adf.mf.api.amx.getVolatileState = function(amxNodeId)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.getVolatileState", "MSG_DEPRECATED", "adf.mf.api.amx.getVolatileState",
      "amxNode.getVolatileState");

    var stateValue = adf.mf.internal.amx._getVolatileStateMap();

    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * @deprecated Use amxNode.setVolatileState instead.
   */
  adf.mf.api.amx.setVolatileState = function(amxNodeId, payloadJsonObject)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.setVolatileState", "MSG_DEPRECATED", "adf.mf.api.amx.setVolatileState",
      "amxNode.setVolatileState");

    var stateValue = adf.mf.internal.amx._getVolatileStateMap();

    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  adf.mf.internal.amx._getVolatileStateMap = function()
  {
    if (adf.mf.environment.profile.dtMode && adf.mf.internal.amx._volatileStateMap == null)
    {
      // This is needed because the controller will not call setMfContextInstance in DT mode:
      adf.mf.internal.amx._volatileStateMap = {};
    }
    return adf.mf.internal.amx._volatileStateMap;
  };

  /**
   * @deprecated Use amxNode.getClientState instead.
   */
  adf.mf.api.amx.getClientState = function(amxNodeId)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.getClientState", "MSG_DEPRECATED", "adf.mf.api.amx.getClientState",
      "amxNode.getClientState");

    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * @deprecated Use amxNode.setClientState instead.
   */
  adf.mf.api.amx.setClientState = function(amxNodeId, payloadJsonObject)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.setClientState", "MSG_DEPRECATED", "adf.mf.api.amx.setClientState",
      "amxNode.setClientState");
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Using true for the following flag results in "oracle.adfmf.framework - adf.mf.el - setValue] Since the
   * java is not available we will skip the remote write." failure messages when attempting to navigate.
   * @private
   */
  adf.mf.internal.amx._useBruceApproach = (adf.mf.api.getQueryStringParamValue(adf.mf.api.getQueryString(), "useBruceWay") == "true");

  adf.mf.internal.amx._getClientStateMap = function()
  {
    var stateValue;
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var stateName = "#{bindings.amxInternalClientState}";
      if ((stateValue = adf.mf.el.getLocalValue(stateName)) === undefined)
      {
        stateValue = {};
        var getFailed  = function(req, message)
        {
          throw new Error(
            adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_ACCESS_FAILED",
              message));
        };
        adf.mf.el.setLocalValue({"name":stateName, "value":stateValue}, function(){}, getFailed);
      }
    }
    else // don't use Bruce's way
    {
      if (adf.mf.environment.profile.dtMode && adf.mf.internal.amx._nonBruceClientStateMap == null)
      {
        // This is needed because the controller will not call setMfContextInstance in DT mode:
        adf.mf.internal.amx._nonBruceClientStateMap = {};
      }
      stateValue = adf.mf.internal.amx._nonBruceClientStateMap;
    }

    return stateValue;
  };

  /**
   * Establish (or re-establish) the mfContext instance for the page that the user will now be interacting with.
   * Used by the controller's navigation handler during tansition to a new view.
   * @param viewHistoryItem  the view history stack entry associtated with the current view.
   * @param brandNewInstance is this a new view instance or an existing one (e.g. a back navigation)?
   * @export
   */
  adf.mf.internal.amx.setMfContextInstance = function(viewHistoryItem, brandNewInstance)
  {
    // Prepare the client state map (the bucket that survives navigation):
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var pageDef    = viewHistoryItem.amxPage;
      var resetState = false; // per Bruce, use false here (may in the future consider how brandNewInstance plays into it)
      var reSync     = false; // per Bruce, use false here (may in the future consider how brandNewInstance plays into it)
      var resetViewScope = adf.mf.internal.lastNavIsDifferentView;
      var setFailed  = function(req, message)
      {
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_MF_CONTEXT_SET_FAILED",
            message));
      };
      adf.mf.api.setCurrentContext(pageDef, resetState, reSync, resetViewScope, function(){}, setFailed);
    }
    else // don't use Bruce's way
    {
      if (viewHistoryItem._nonBruceClientStateMap == null)
      {
        viewHistoryItem._nonBruceClientStateMap = {};
      }
      adf.mf.internal.amx._nonBruceClientStateMap = viewHistoryItem._nonBruceClientStateMap;
    }

    // Prepare a fresh volatile state map (the bucket that resets at navigation):
    adf.mf.internal.amx._volatileStateMap = {};
  };

  /**
   * Remove the mfContext instance for the page that the user will now be leaving.
   * Used by the controller's navigation handler during tansition to a new view.
   * @param viewHistoryItem  the view history stack entry associtated with the view to be removed.
   * @export
   */
  adf.mf.internal.amx.removeMfContextInstance = function(viewHistoryItem)
  {
    // Purge the client state map (the bucket that survives navigation) since this instance will never be used again:
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var pageDef      = viewHistoryItem.amxPage;
      var instanceId   = viewHistoryItem.itemId;
      var removeFailed = function(req, message)
      {
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_MF_CONTEXT_REMOVE_FAILED",
            message));
      };
      adf.mf.api.removeContextInstance(pageDef, instanceId, function(){}, removeFailed);
    }
    else // don't use Bruce's way
    {
      adf.mf.internal.amx._nonBruceClientStateMap = null;
    }
  };

  adf.mf.internal.amx._purgeOnNav = function()
  {
    // Purge any elements that might be disconnected from the bodyPage.
    // Examples: inputDate and selectManyChoice pickers on Android.
    var elementsToPurge = document.getElementsByClassName("amx-purge-on-nav");
    for (var i=elementsToPurge.length-1; i>=0; --i)
      adf.mf.api.amx.removeDomNode(elementsToPurge[i]);
  };

  adf.mf.internal.amx._handlePageTransition = function(transitionType, isBack, currentElement, newElement, alwaysFunction)
  {
    if (adf.mf.internal.amx._pageTransitionCancelFunction != null)
      adf.mf.internal.amx._pageTransitionCancelFunction();

    // Ensure prerequisites are met:
    currentElement.style.display = "block";
    newElement.style.display = "block";
    newElement.classList.remove("new");
    newElement.classList.add("current");

    var properties = {};
    properties["parentFlipAllowed"] = true; // no other visible siblings plus parent and grandparent have equal dimensions
    properties["dimensionsFromParent"] = true;
    properties["finishedFunction"] = alwaysFunction;
    properties["callbackParams"] = [];
    properties["animationEnabled"] = true;
    properties["isRtl"] = document.documentElement.dir == "rtl";
    properties["fineLogger"] = function(message)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINER,
        "adf.mf.internal.amx", "_handlePageTransition", message);
    };

    if (isBack)
    {
      if (transitionType.indexOf("Start") != -1)
        transitionType = transitionType.replace(/Start/, "End");
      else if (transitionType.indexOf("End") != -1)
        transitionType = transitionType.replace(/End/, "Start");
      else if (transitionType.indexOf("Left") != -1)
        transitionType = transitionType.replace(/Left/, "Right");
      else if (transitionType.indexOf("Right") != -1)
        transitionType = transitionType.replace(/Right/, "Left");
      else if (transitionType.indexOf("Up") != -1)
        transitionType = transitionType.replace(/Up/, "Down");
      else if (transitionType.indexOf("Down") != -1)
        transitionType = transitionType.replace(/Down/, "Up");
      else if ("slide" == transitionType)
        transitionType = "slideEnd";
      else if ("flip" == transitionType)
        transitionType = "flipEnd";
    }

    adf.mf.internal.amx._pageTransitionCancelFunction =
      adf.shared.impl.animationUtils.transition( // WARNING this is impl (not a public API) and will change without notice
        transitionType,
        currentElement,
        newElement,
        properties);
  };

  /**
   * Checks and logs windows event leaks in debug mode.
   * @param callerFunctionName name of caller function to display in log
   * @private
   */
  adf.mf.internal.amx._checkForWindowsEventLeaks = function(callerFunctionName)
  {
      if ("release" != adf.mf.internal.BUILD_CONFIGURATION) // if debug mode...
      {
        // Check for window event leaks:
        var windowEventDebugString = adf.mf.api.amx.getEventDebugString(window, 200);
        if ("DOM events: \n  n/a\nSpecial events:\n  n/a" != windowEventDebugString)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle",
                                      adf.mf.log.level.SEVERE,
                                      callerFunctionName,
                                      "MSG_WINDOW_EVENT_LEAKS",
                                      "\n" + windowEventDebugString);
        }
      }
  };

  /**
   * @deprecated
   */
  amx.doNavigation = function(outcome)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "doNavigation",
      "MSG_DEPRECATED", "amx.doNavigation", "adf.mf.api.amx.doNavigation");
    adf.mf.api.amx.doNavigation.apply(this, arguments);
  };

  adf.mf.api.amx.doNavigation = function(outcome)
  {
    // Trigger the amxnavigatestart event prior to the critical section lock
    adf.mf.internal.triggerEvent(
      document,
      "Events",
      "amxnavigatestart",
      false,
      false,
      null,
      {
        "outcome": outcome
      });

    adf.mf.internal.amx._queueCriticalSectionFunction(
      doNavigationImpl,
      this,
      false,
      outcome);
  };

  // Global value to indicate if the last navigation resulted in a different view.
  adf.mf.internal.lastNavIsDifferentView = true;

  function doNavigationImpl(outcome)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Perform navigation", adf.mf.log.level.FINE, "adf.mf.api.amx.doNavigation");
    adf.mf.api.amx.showLoadingIndicator();

    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    if (!amx.containsELExpressions (outcome))
    {
      // no el expressions detected, just pass outcome as-is
          resolve(outcome);
    }
    else
    {
      var invokeCallback = function(req,res)
      {
            resolve(res);
      };
      try
      {
        // Assume that this is a method expression that returns a String.
        // Also, we do not care if it is a success or failure - any exception passed back
        // will be converted properly below via the amx.getObjectValue call.
        adf.mf.el.invoke(outcome,[],"java.lang.String",[], invokeCallback, invokeCallback);
      }
      catch(e)
      {
        // just invoke the callback
        invokeCallback(outcome, e);
      }
    }
      });

    promise.then(
      function(outcome)
    {
      var navRequest = {};
      navRequest.currentViewId = adf.mf.internal.controller.ViewHistory.peek().viewId;
      // be sure to convert from any json type structures to something
      // usable by javascript
      navRequest.outcome = amx.getObjectValue(outcome);

      var navSuccess = function(req, result)
      {
        var transitionType = result.getTransitionType();
        var amxPage = result.getVdlDocumentPath();
        var isBack = result.isBackNavigation();
        adf.mf.internal.lastNavIsDifferentView = result.isDifferentViewId();

        if (transitionType == "none")
          transitionType = null;

        // We did not find a target for navigation, so exit early. This is a valid case
        // and Faces behaves similarly. It allows developers to return "null" or an invalid
        // target and stay on the same page. If we do not exit here, the bindings will be
        // cleared and not re-initialized
        if (amxPage == null)
        {
          adf.mf.api.amx.hideLoadingIndicator();
          return;
        }

        // before attempting to navigate, make sure all popups are closed
        // NOTE: amx-popup is lazily loaded, so we must check for the existence
        // of the function before calling it
        if (adf.mf.internal.amx.closePopups)
        {
          adf.mf.internal.amx.closePopups();
        }

        // Before we strip off the IDs, call the destroy methods on any AMX nodes
          var current = document.querySelector("#bodyPageViews > .current");
          adf.mf.internal.amx.processDestroy(current);

        // Strip off any ID attributes on the old page's elements. This will prevent any issues
        // with getElementById finding elements on the old page instead of the new page.
          if (current != null)
        {
            adf.mf.internal.amx.stripIds(current);
        }

        if (adf.mf.internal.amx.isTransitionAfterRender(false)) // render before transitioning
        {
            adf.mf.api.amx.displayAmxPage(amxPage).then(function(page)
          {
            var perf = adf.mf.internal.perf.startMonitorCall("Transition to page", adf.mf.log.level.FINER, "adf.mf.api.amx.doNavigation:transition");

            try
            {
                var newPage = page;

              if (transitionType != null)
              {
                amx.transitioning = true;

                // Purge any elements that might be disconnected from the bodyPage:
                adf.mf.internal.amx._purgeOnNav();

                adf.mf.internal.amx._handlePageTransition(
                    transitionType, isBack, current, newPage,
                  function()
                  {
                    amx.transitioning = false;
                    adf.mf.api.amx.hideLoadingIndicator();
                      adf.mf.api.amx.removeDomNode(current);
                    adf.mf.internal.amx._pageTransitionCancelFunction = null;
                    adf.mf.internal.triggerEvent(
                      document,
                      "Events",
                      "amxnavigateend",
                      false,
                      false,
                      null,
                      {
                        "outcome": outcome,
                        "amxPage": amxPage
                      });
                    perf.stop();
                  });
              }
              else
              {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
                  "doNavigation", "MSG_NOT_TRANSITIONING");
                amx.transitioning = true;

                // Purge any elements that might be disconnected from the bodyPage:
                adf.mf.internal.amx._purgeOnNav();

                // we just show it.
                  current.classList.remove("current");
                  current.classList.add("old");
                  newPage.classList.remove("new");
                  newPage.classList.add("current");
                  adf.mf.internal.amx.processDestroy(current);
                  adf.mf.api.amx.removeDomNode(current);
                amx.transitioning = false;
                adf.mf.api.amx.hideLoadingIndicator();
                adf.mf.internal.triggerEvent(
                  document,
                  "Events",
                  "amxnavigateend",
                  false,
                  false,
                  null,
                  {
                    "outcome": outcome,
                    "amxPage": amxPage
                  });
                perf.stop();
              }
            }
            catch (e)
            {
              perf.stop();
              throw e;
            }
          });
        }
        else // use placeholder transitioning
        {
          // Transition to blank immediately, don't wait for the new page to be present:
          amx.transitioning = true;

          // Purge any elements that might be disconnected from the bodyPage:
          adf.mf.internal.amx._purgeOnNav();

          amx._stillTransitioningAway = true;
          amx._stillDisplayingAmxPage = true;
          var viewContainerElement = adf.mf.internal.amx._createViewContainerElement();
            var newPage = viewContainerElement;
          if (transitionType != null)
          {
            adf.mf.internal.amx._handlePageTransition(transitionType, isBack, current,
              viewContainerElement,
              function()
            {
              amx._stillTransitioningAway = false;
              amx.transitioning = (amx._stillDisplayingAmxPage || amx._transitioningAway);
                adf.mf.api.amx.removeDomNode(current);
              adf.mf.internal.amx._pageTransitionCancelFunction = null;
            });
          }
          else
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "doNavigation",
              "MSG_NOT_TRANSITIONING");
            amx._stillTransitioningAway = false;
            // we just show it.
              current.classList.remove("current");
              current.classList.add("old");
              newPage.classList.remove("new");
              newPage.classList.add("current");
              adf.mf.internal.amx.processDestroy(current);
              adf.mf.api.amx.removeDomNode(current);
          }

          adf.mf.api.amx.displayAmxPage(amxPage).then(
            function(page)
          {
            amx._stillDisplayingAmxPage = false;
            amx.transitioning = (amx._stillDisplayingAmxPage || amx._stillTransitioningAway);
            adf.mf.api.amx.hideLoadingIndicator();
            adf.mf.internal.triggerEvent(
              document,
              "Events",
              "amxnavigateend",
              false,
              false,
              null,
              {
                "outcome": outcome,
                "amxPage": amxPage
              });
          });
        }
      };

      var navFailed = function(req, message)
      {
        adf.mf.api.amx.hideLoadingIndicator();
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_NAVIGATION_FAILED", message));
      };

      // Give renderers a chance to save off anything they want to preserve (e.g. scroll positions):
        var current = document.querySelector("#bodyPageViews > .current");
        adf.mf.internal.amx.processPreDestroy(current);

      // if debug mode...
      // Check for window event leaks
      adf.mf.internal.amx._checkForWindowsEventLeaks("doNavigation");

      adfc.NavigationHandler.handleNavigation(navRequest, navSuccess, navFailed);

        perfOp.stop();
      },
      function()
      {
        perfOp.stop();
      });

    return promise;
  }

  var initQueue = [];
  var postDisplayQueue = [];

  /**
   * This should only be called by adf.mf.api.amx.removeDomNode().
   * Remove an AMXNode for a given DOM node. Calls any pre-destroy and destroy methods
   * on the type handlers for nodes removed as a result of this call and then removes
   * the HTML from the page.
   * @param  {Node} domNode the HTML DOM node to remove. Must be a root DOM node for an
   *         AMX node.
   * @return {boolean} true if the node is a DOM node that represents an AMX node and
   *         was removed.
   */
  adf.mf.internal.amx.removeAmxDomNode = function(domNode)
  {
    var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
    if (amxNode != null)
    {
      adf.mf.internal.amx.processPreDestroy(domNode);
      adf.mf.internal.amx.processDestroy(domNode);
      return true;
    }

    return false;
  };

  adf.mf.internal.amx.processPreDestroy = function(parent)
  {
    // Find all elements that have a preDestroy implementation (including parent)
    var childrenWithPreDestroy = parent.querySelectorAll(".amx-has-predestroy");

    var handlePreDestroy =
      function(domNode)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
        var nodeTypeHandler = amxNode.getTypeHandler();
        if (nodeTypeHandler && nodeTypeHandler.preDestroy)
        {
          // Prevent duplicate preDestroy calls:
          if (domNode.getAttribute("data-predestroyed") == null)
          {
            domNode.setAttribute("data-predestroyed", true);

            /**
             * Renderer function so you can be notified just before the current view is destroyed;
             * when about to navigate to a new view.
             * @param domNode the root DOM node associated with this renderer
             * @param amxNode the AMX component object associated with this renderer
             */
            nodeTypeHandler.preDestroy(domNode, amxNode);
          }
        }
      };

    if (parent.classList.contains("amx-has-predestroy"))
      handlePreDestroy(parent);
    for (var i=0, count=childrenWithPreDestroy.length; i<count; ++i)
      handlePreDestroy(childrenWithPreDestroy[i]);
  };

  adf.mf.internal.amx.processDestroy = function(parent)
  {
    // Find all elements that have a destroy implementation (including parent)
    var childrenWithDestroy = parent.querySelectorAll(".amx-has-destroy");

    var handleDestroy =
      function(domNode)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
        var nodeTypeHandler = amxNode.getTypeHandler();
        if (nodeTypeHandler && nodeTypeHandler.destroy)
        {
          // Prevent duplicate destroy calls:
          if (domNode.getAttribute("data-destroyed") == null)
          {
            domNode.setAttribute("data-destroyed", true);

            nodeTypeHandler.destroy(domNode, amxNode);
          }
        }
      };

    if (parent.classList.contains("amx-has-predestroy"))
      handleDestroy(parent);
    for (var i=0, count=childrenWithDestroy.length; i<count; ++i)
      handleDestroy(childrenWithDestroy[i]);
  };

  /**
   * This function processes the amxNodes registered by the amx.queueForInit and
   * calls 'init' function on their related typeHandlers.
   *
   * The processing of the queue takes place immediatelly after the rendering
   * of the amx tree or application of the updates to the amx tree.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   */
  amx.processAndCleanInitQueue = function()
  {
    _processAndCleanQueue(initQueue, "init");
  };

  /**
   * This function processes the amxNodes registered by the amx.queueForPostDisplay and
   * calls 'postDisplay' function on their related typeHandlers.
   *
   * The processing of the queue takes place immediatelly after the processing of the
   * init queue.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * The amxNodes that are currently outside of the document will not be processed.
   */
  amx.processAndCleanPostDisplayQueue = function()
  {
    _processAndCleanQueue(postDisplayQueue, "postDisplay");
  };

  /**
   * This is implementation of the queue processing used for the init and post display queues.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param queue {Array<Object>} queue which will be processed.
   * @param method {String} function to be called on typeHandler of each amxNode in the queue.
   */
  var _processAndCleanQueue = function(queue, method)
  {
    if (queue.length > 0 && method != null)
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      // sort queue by depth to ensure that the nodes are processed in hierarchical order
      adf.mf.api.amx.AmxNode.__sortNodesByDepth(queue);
      // processing the queue with shift enable to handle concurent addition of the
      // amxNodes into the queue
      var amxNode;
      while ((amxNode = queue.shift()) != null)
      {
        // try to get fresh domNode
        // using getElementById ensures that the domNode is already in document
        // in all other cases there is no reason to process it since it is
        // not initable or displayable amxNode
        var domNode = document.getElementById(amxNode.getId());
        if (domNode != null)
        {
          var nodeTypeHandler = amxNode.getTypeHandler();
          // verify that the typeHandler implements current method
          if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, method))
          {
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "amx", "_processAndCleanQueue",
                "Invoking the \'" + method + "\' method on the type handler for node " +
                amxNode.getId());
            }
            // invoke typeHandler function for current AmxNode
            nodeTypeHandler[method](domNode, amxNode);
          }
          else
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
              "_processAndCleanQueue", "MSG_CANT_" + method.toUpperCase() + "_NODE", domNode);
          }
        }
      }
    }
  };

  /**
   * This function enques the amxNode to the end of the init processing queue.
   *
   * The queue itself will be processed after the render phase where all
   * newly rendered or rerendered amxNodes are inserted into the document.
   *
   * Nodes that are currently outside of the document will not be processed.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param amxNode {Object} node which typeHandler supports init method
   */
  amx.queueForInit = function(amxNode)
  {
    if (amxNode != null)
    {
      initQueue[initQueue.length] = amxNode;
    }
  };

  /**
   * This function enques the amxNode to the end of the post display processing queue.
   *
   * The queue itself will be processed after the init phase where all
   * amxNodes from init queue (registered by the #queueForInit function)
   * are processed.
   *
   * Nodes that are currently outside of the document will not be processed.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param amxNode {Object} node which typeHandler supports postDisplay method
   */
  amx.queueForPostDisplay = function(amxNode)
  {
    if (amxNode != null)
    {
      postDisplayQueue[postDisplayQueue.length] = amxNode;
    }
  };

  /**
   * Create and insert a new view container element (no content yet).
   * @return {HTMLElement} the newly-created view container element
   * @private
   */
  adf.mf.internal.amx._createViewContainerElement = function()
  {
    var viewContainerElement = document.createElement("div");
    viewContainerElement.className = "amx-view-container new";
    // TODO consider injecting placeholder DOM here so it isn't completely blank
    document.getElementById("bodyPageViews").appendChild(viewContainerElement);
    return viewContainerElement;
  };

  /**
   * Processes all the bundles on the page
   * @private
   * @param {adf.mf.api.amx.AmxTag} amxTag the root tag of the page
   * @return {Object} promise object that is resolved once all bundles have been loaded
   */
  function loadBundles(amxTag)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    if (adf.mf.environment.profile.dtMode)
    {
          resolve();
    }
    else
    {
      // amx:loadBundle only allowed under the root tag of the page
      // or the fragment
      var bundles = amxTag.getChildren(
        adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
        "loadBundle");

          var childPromises = [];
      var numBundles = bundles.length;

      if (numBundles == 0)
      {
            resolve();
      }
      else
      {
        for (var i = 0; i < numBundles; ++i)
        {
          var bundleTag = bundles[i];
          var basename = bundleTag.getAttribute("basename");
          var variable = bundleTag.getAttribute("var");

              var loadPromise = amx.loadBundle(basename, variable);
              childPromises.push(loadPromise);

              adf.mf.internal.BasePromise.all(childPromises).then(
              function()
              {
                  resolve();
                },
              function()
              {
                  reject.apply(null, arguments);
              });
        }
      }
    }
      });
  }

  /**
   * Load and display an AMX page.
   * @param {Object} amxPageName the name of the page to load
   * @return {Object} promise object that is resolved once the page has been rendered. Currently
   *         resolved with the DOM node for the view container element
   */
  adf.mf.api.amx.displayAmxPage = function(amxPageName) /* used by base-controller.js */
  {
    adf.mf.api.amx.showLoadingIndicator();
    var that = this;
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        adf.mf.internal.amx._queueCriticalSectionFunction(
          displayAmxPageImpl,
          that,
          false,
          amxPageName,
          {
            "resolve": resolve,
            "reject": reject
          });
      });
  };

  /**
   * Object to track AMX nodes that are busy. This is used for performance to track when a page has
   * fully loaded or after a page has fully reacted to a data change event after an AMX event has
   * been queued.
   *
   * @constructor
   */
  function PageBusyTracker()
  {
    this._operations = [];
    this._nodeCount = 0;
  }

  /**
   * Sets the node count to zero. Used when a new page is being loaded
   */
  PageBusyTracker.prototype.reset = function()
  {
    this._nodeCount = 0;

    adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.amx._pageWaitingInformation", "reset",
      "Node count has been reset");
  };

  /**
   * Increments the number of nodes waiting on a condition.
   */
  PageBusyTracker.prototype.increment = function()
  {
    ++this._nodeCount;

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "increment",
        "Nodes in a waiting state is now " + this._nodeCount);
    }
  };

  /**
   * Decrements the number of nodes waiting on a condition.
   */
  PageBusyTracker.prototype.decrement = function()
  {
    --this._nodeCount;

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "decrement",
        "Nodes in a waiting state is now " + this._nodeCount);
    }
  };

  /**
   * Notifies the tracker that a top level operation has begun that should not be stopped until all
   * the nodes are in a resolved state (not INITIAL, WAITING_ON_EL_EVALUATION or
   * PARTIALLY_RENDERED).
   *
   * @param {boolean} stopCurrent if true and there already is an active operation, it will be
   *        stopped as part of this call. If not, the new operation will be stopped along with
   *        the current one.
   * @param {string} operationName the name of the operation
   * @param {Object} the logging level for this operation
   * @param {string} operationDescription the description of the operation
   * @param {string} instance name for this operation. For example, event name
   */
  PageBusyTracker.prototype.startOperation = function(
    stopCurrent,
    operationName,
    level,
    operationDescription,
    instanceName)
  {
    var numOper = this._operations.length;
    if (numOper)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "startOperation",
          "An operation was already running: " + this.getActiveOperation() +
          "\n  New operation: " + operationName + " " + instanceName);
      }

      if (stopCurrent)
      {
        for (var i = 0; i < numOper; ++i)
        {
          this._operations[i].stop();
        }

        this._operations = [];
      }
    }

    var oper = adf.mf.internal.perf.startMonitorOperation(operationName, level, operationDescription, instanceName);
    this._operations.push(oper);
  };

  /**
   * Checks if all AMX nodes are in a resolved state, and if so, stops any ongoing operations.
   */
  PageBusyTracker.prototype.checkComplete = function()
  {
    var numOper = this._operations.length;
    if (numOper && this._nodeCount == 0)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
          "Operation is complete: " + this.getActiveOperation());
      }

      for (var i = 0; i < numOper; ++i)
      {
        this._operations[i].stop();
      }

      this._operations = [];
    }
    else if (numOper)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
          "Operation is not complete yet. Waiting count: " + this._nodeCount);
      }
    }
    else
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
        "checkComplete called when there was no active operation");
    }
  };

  /**
   * Gets if an operation is active
   *
   * @return {boolean} true if there is an active operation
   */
  PageBusyTracker.prototype.isOperationActive = function()
  {
    return this._operations.length > 0;
  };

  /**
   * Get the active operation if there is one
   *
   * @return {Object|null} the active operation or null
   */
  PageBusyTracker.prototype.getActiveOperation = function()
  {
    return this.isOperationActive() ? this._operations[0] : null;
  };

  /**
   * Check if there are any AMX nodes in a waiting state
   *
   * @return {boolean} true if there are nodes waiting
   */
  PageBusyTracker.prototype.areNodesWaiting = function()
  {
    return this._nodeCount > 0;
  };

  adf.mf.internal.amx._pageBusyTracker = new PageBusyTracker();

  function displayAmxPageImpl(amxPageName, promiseCallbacks)
  {
    // Return a promise object that holds the critical section
    // as long as needed
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        // Start a new page off with a node waiting count of 0
        adf.mf.internal.amx._pageBusyTracker.reset();

        adf.mf.internal.amx._pageBusyTracker.startOperation(
            false,
            "Load page",
            adf.mf.log.level.INFO,
            "Time to fully render the page", amxPageName);

        // Track the time to the initial page rendering (not fully-loaded)
        var perfOp = adf.mf.internal.perf.startMonitorOperation(
          "Initial page render",
          adf.mf.log.level.FINE,
          "adf.mf.api.amx.displayAmxPage");

        adf.mf.api.addBatchDataChangeListener(adf.mf.internal.amx._handleBatchDataChangeListener);

        // Store the current page name. This is used by the fragment to resolve relative URIs
        adf.mf.internal.amx._currentPageName = amxPageName;

        // Get the page (this must be a promise because it is an AJAX call)
        var amxPageTagPromise = getAmxTagForPage(adfc.Util.addFeatureRootPrefix(amxPageName), false);

        var initDataPromise = initData(amxPageName); // initializes the context

        // clear the bindings
        amx.clearBindings();

        // When amxPage, initData, and initUI resolve, we continue:
        var promises = [ amxPageTagPromise, initDataPromise, initUI() ];
        adf.mf.internal.BasePromise.all(promises).then(
          function(params)
            {
              // Load the message bundles before evaluating any EL
            var amxPageTag = params[0];
            loadBundles(amxPageTag).then(
                  function()
                  {
                    // Build the AMX node tree once the tags have been loaded
                var buildAmxNodeTreePromise = buildAmxNodeTree(amxPageName, amxPageTag);

                    // Resume any queued critical section requests, from this point
                    // on we are not operating in the critical section
                    resolve();

                    // Wait for the EL to arrive so that we may render the page
                buildAmxNodeTreePromise.then(
                        function(amxPageNode)
                        {
                          //debugPrintAmxNodeTree(amxPageNode);

                          // We render the page
                          var perfRender = adf.mf.internal.perf.startMonitorCall("Render AMX page",
                             adf.mf.log.level.FINER, "adf.mf.api.amx.displayAmxPage:render", amxPageName);
                    var pageContentElement;
                          // set flag to prevent independent processing of the init and postDisplay queues
                          // only wait if there is some render event which enqueues the rendered node into
                          // the processing queue and process these queues after the whole render phase is complete
                          amx.mustProcessQueues = false;
                          try
                          {
                      pageContentElement = amxPageNode.render();
                          }
                          finally
                          {
                            perfRender.stop();
                          }

                    var perfAfterRender =
                      adf.mf.internal.perf.startMonitorCall(
                        "After render AMX page",
                        adf.mf.log.level.FINER,
                        "adf.mf.api.amx.displayAmxPage:afterRender",
                        amxPageName);

                          try
                          {
                      var viewContainer;
                            if (adf.mf.internal.amx.isTransitionAfterRender(isFirstPage)) // render before transitioning
                            {
                              // TODO: remove jQ code and stop using string concatination with HTML
                        viewContainer = document.createElement("div");
                        viewContainer.setAttribute("data-pageName", amxPageName);
                        viewContainer.className = "amx-view-container";
                        viewContainer.classList.add("new");

                        document.getElementById("bodyPageViews").appendChild(viewContainer);
                            }
                            else // use placeholder transitioning
                            {
                              var viewContainerElement;
                              if (isFirstPage)
                              {
                                // Since we are not doing a navigation, we have to create the element ourselves:
                                viewContainerElement = adf.mf.internal.amx._createViewContainerElement();
                              }
                              else
                              {
                                // The element was already created in the doNavigation code (where it might kick off a
                                // transition animation) so just get it and use it:
                                var viewContainerElements = document.getElementsByClassName("amx-view-container");
                                viewContainerElement = viewContainerElements[viewContainerElements.length - 1];
                              }
                              viewContainerElement.setAttribute("data-pageName", amxPageName);
                              adf.mf.api.amx.emptyHtmlElement(viewContainerElement);
                            }

                      if (pageContentElement != null)
                        viewContainer.appendChild(pageContentElement);

                            //TODO: needs to move this refresh above
                            // We process and clean the initQueue
                            amx.processAndCleanInitQueue();

                            //If it is the first page, we handler the display
                            if (isFirstPage)
                            {
                        viewContainer.classList.remove("new");
                        viewContainer.classList.add("current");
                              isFirstPage = false;
                            }

                            amx.processAndCleanPostDisplayQueue();

                      promiseCallbacks["resolve"](viewContainer);
                          }
                          finally
                          {
                            perfAfterRender.stop();
                            adf.mf.api.amx.hideLoadingIndicatorOnlyIfFirstTime();
                            perfOp.stop();
                            // reset mustProcessQueues to true
                            // every call of the rerender outside of the data change event
                            // will immediatelly trigger processing of the init and postDisplay
                            // queues
                            amx.mustProcessQueues = true;
                            // Check if the page has finished rendering
                            adf.mf.internal.amx._pageBusyTracker.checkComplete();
                          }
                 },
                 function()
                 {
                   perfOp.stop();
                   adf.mf.internal.amx._pageBusyTracker.checkComplete();
                       });
              },
              function()
              {
                perfOp.stop();
                adf.mf.internal.amx._pageBusyTracker.checkComplete();
                // Reject the promise return
                reject();
                  });
          },
          function()
          {
            // TODO: print error
            adf.mf.api.amx.hideLoadingIndicator();
            perfOp.stop();
            // Reject the promise return
            reject();
            });
      });
  }

  // ------ resource loading ------ //
  var loadedJavaScriptResources = {};
  var loadedCssResources = {};
  var loadingCssLinks = [];
  var cssLoadingCheckInterval = null;
  var cssLoadingWaitStarted = 0;
  var cssLastCheckSheetCount = 0;

  /**
   * Internal function for loading XML files
   * @param {string} resourceName the resource to load
   * @param {boolean} async whether the request should be asynchronous
   * @param {function} successCB the XML file could be parsed
   * @param {function} errorCB the XML file could not be parsed
   * @private
   */
  adf.mf.internal.amx._loadXmlFile = function(resourceName, async, successCB, errorCB)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Load XML file", adf.mf.log.level.FINE, "adf.mf.internal.amx._loadXmlFile", resourceName);
    var perf = adf.mf.internal.perf.startMonitorCall("Load XML file", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.load");

    //  Load the XML:
    adf.mf.api.resourceFile._loadFileWithAjax(
      resourceName,
      async,
      function(responseText)
      {
        perf.stop();
        if ((responseText != null) && (responseText.length > 0))
        {
          perf = adf.mf.internal.perf.startMonitorCall("Parse XML file", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.parse");
          var isUWP = (adf.mf.internal.amx.agent["type"] === "UWP");
          var amxPage;

          // Unfortunately Edge browser has a limit of 128 characters for attribute values.
          // This causes issues with long EL statements in UWP page. So on UWP use a native
          // xml parser
          if (!adf.mf.environment.profile.mockData && isUWP)
          {
            amxPage = new Windows.Data.Xml.Dom.XmlDocument();

            var xmlLoadSettings = new Windows.Data.Xml.Dom.XmlLoadSettings();
            xmlLoadSettings.elementContentWhiteSpace = false;

            amxPage.loadXml(responseText, xmlLoadSettings);
          }
          else
          {
            var parser = new DOMParser();
            amxPage = parser.parseFromString(responseText, "text/xml");
          }
          var firstTag = null;
          var possibleFirstTag = amxPage.firstChild;
          while (firstTag == null && possibleFirstTag != null)
          {
            if (possibleFirstTag.nodeType == 1) // an element
              firstTag = possibleFirstTag;
            else
              possibleFirstTag = possibleFirstTag.nextSibling;
          }

          perf.stop();
          if (firstTag != null)
          {
            try
            {
              perf = adf.mf.internal.perf.startMonitorCall("Parse tags", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.parseTags");
              var amxPageTag = new adf.mf.api.amx.AmxTag(null, firstTag);
              perf.stop();

              var promise = adf.mf.internal.amx._preProcessTagTree(amxPageTag);
              promise.then(
                function()
                {
                  perfOp.stop();
                  successCB(amxPageTag);
                });
            }
            catch (e)
            {
              perfOp.stop();
              errorCB(e);
            }
          }
          else
          {
            perfOp.stop();
            errorCB("No root view tag found");
          }
        }
        else
        {
          perfOp.stop();
          errorCB("Empty response");
        }
      },
      function()
      {
        perfOp.stop();
        errorCB.apply(window, arguments);
      });
  };

  /**
   * Function to load a JavaScript file
   * @param {string} src the URI to the JavaScript file
   * @return {Object} a promise for when the loading is complete
   */
  amx.includeJs = function(src)
  {
    var loadState = loadedJavaScriptResources[src];
    if (loadState == null) // possibilities are null, a promise, or true
    {
      // Never attempted to load this file so load it:
      var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
        {
      // Use an XHR to retrieve the JavaScript. Usage of an XHR allows us to be notified
      // of when the script has been loaded, or has failed to load to be able to correctly
          // invoke the correct promise method.
      adf.mf.api.resourceFile.loadJsFile(
        src,
        true,
        function()
        {
          loadedJavaScriptResources[src] = true;
              resolve();
        },
        function()
        {
          adf.mf.api.adf.logInfoResource(
            "AMXInfoBundle",
            adf.mf.log.level.SEVERE,
            "amx.includeJs",
            "MSG_FAILED_TO_LOAD",
            src);
              reject();
        },
        null);
        });
      loadedJavaScriptResources[src] = promise;
      return promise;
    }
    else if (loadState === true) // other options are undefined and false
    {
      // File was already loaded successfully:
      return adf.mf.internal.BasePromise.resolve();
    }
    else // a promise
    {
      // File was already requested to be loaded with this promise:
      return loadState;
    }
  };

  /**
   * Function that checks for the completion of loading CSS files
   * (polls from a callback from a window interval)
   */
  function waitTillCssLoaded()
  {
    var styleSheets = document.styleSheets;
    var numStyleSheets = styleSheets.length;

    // Don't bother checking if the count has not changed from the last poll
    if (cssLastCheckSheetCount == numStyleSheets)
    {
      return;
    }
    cssLastCheckSheetCount = numStyleSheets;
    // Loop through all the nodes that we are still waiting to finish loading
    for (var i = 0; i < loadingCssLinks.length; ++i)
    {
      var obj = loadingCssLinks[i];
      var nonLoadedNode = obj["node"];

      for (var j = 0; j < numStyleSheets; ++j)
      {
        var linkNode = styleSheets[j].ownerNode;
        // See if this style sheet is for the node we are waiting to be loaded.
        if (nonLoadedNode == linkNode)
        {
          // When the style sheet appears in the styleSheets collection,
          // it has finished loading
          obj["resolve"](linkNode);

          // Remove the item from the array
          loadingCssLinks.splice(i--, 1);

          if (loadingCssLinks.length == 0)
          {
            // We are not waiting on any more nodes
            window.clearInterval(cssLoadingCheckInterval);
            cssLoadingCheckInterval = null;
            return;
          }

          break;
        }
      }
    }

    var timeWaiting = new Date().getMilliseconds() - cssLoadingWaitStarted;
    // Since the code is not notified of CSS files that failed to load, only way for a maximum
    // of 5 seconds for all CSS files to load and then throw an error
    if (timeWaiting >= 5000)
    {
      for (var index = 0, size = loadingCssLinks.length; i < size; ++i)
      {
        var obj = loadingCssLinks[index];
        // Notify the listener that the resource failed to load
        obj["reject"]();
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "amx.includeCss",
          "MSG_FAILED_TO_LOAD", obj["path"]);
      }
      loadingCssLinks = [];
      window.clearInterval(cssLoadingCheckInterval);
      cssLoadingCheckInterval = null;
    }
  };

  /**
   * Function to load a CSS file
   * @param {string} path the URI to the CSS file
   * @return {Object} promise that is resolved once the style sheet has been loaded.
   */
  amx.includeCss = function(path)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    if (loadedCssResources[path])
    {
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "amx", "includeCss",
          "CSS file has already been loaded: " + path);
      }

      // Return a promise object already resolved to indicate that the source
      // has already been loaded
      return adf.mf.internal.BasePromise.resolve();
    }

    var isUWP = (adf.mf.internal.amx.agent["type"] === "UWP");

    // Currently, the only supported means in WebKit browsers to determine if a style sheet has
    // finished loading is to check for the style sheet to appear in the document.styleSheets
    // collection. There are no events that are associated with the loading, so polling this
    // collection is the only means, at the moment, to determine this information.
    //
    // We need to use a <link> tag so that the URLs in the CSS are preserved. If we were to
    // attempt to use a <style> tag and inject the content from the CSS file into the page, the
    // relative URLs would no longer work.

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "amx", "includeCss",
        "Loading CSS file : " + path);
    }
    loadedCssResources[path] = true;

    // Create a link element
    var node = document.createElement("link");
    node.setAttribute("rel", "stylesheet");
    node.setAttribute("type", "text/css");

    var perf = null;
    // Currently UWP has issues with loading resource from local directory.
    // So we have to workaround it by loading the resource as data uri
    if (isUWP && window.AdfmfCallback && AdfmfCallback.isLocalResource(path))
    {
      perf = adf.mf.internal.perf.startMonitorCall("Include CSS file", adf.mf.log.level.FINER, "amx.includeCss");

      // use callback interface from windows to get data uri from a file
      // and return the base promise
      return AdfmfCallback.setDataURIForLocalResource(node, path).then(
        function()
        {
          // href is loaded successfully add the node to DOM
          document.head.appendChild(node);

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "amx", "includeCss",
              "Successfully loaded CSS file: " + path);
          }
          perf.stop();
        },
        function()
        {
          // append the node with the invalid href
          node.setAttribute("href", path);
          document.head.appendChild(node);

          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "amx.includeCss",
          "MSG_FAILED_TO_LOAD", path);

          perf.stop();
        });
    }
    else
    {
      node.setAttribute("href", path);
      document.head.appendChild(node);
    }

    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        // Store an object with the promise object to be able to notify when loaded,
    // and the node to check to see when the loading has completed.
    loadingCssLinks.push(
      {
        "path": path,
        "node": node,
            "resolve": resolve,
            "reject": reject
      });

    // See if a timer has already been started, if not start one to poll the document.styleSheets
    // collection
    if (cssLoadingCheckInterval == null)
    {
      // Use a 10ms timeout. These resources are local to the device, so it should not take long
      // for them to be loaded.
      cssLoadingCheckInterval = window.setInterval(waitTillCssLoaded, 10);
    }

    // Set or reset when we started to wait for the CSS to load. This leaves a maximum wait time
    // of 5 seconds from the last CSS file added.
    cssLoadingWaitStarted = new Date().getMilliseconds();

        // Return the promise object so that the caller may be notified once the CSS file has been
    // completely loaded
    var perf = adf.mf.internal.perf.startMonitorCall("Include CSS file", adf.mf.log.level.FINER, "amx.includeCss");
      }).then(
      function()
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "amx", "includeCss",
            "Successfully loaded CSS file: " + path);
        }

          if (perf != null)
        perf.stop();
      });
  };
  // ------ /resource loading ------ //

  // TODO: add more comments to the iterator implementation classes below
  /**
   * Iterator object to support iterating over a JavaScript items array with hasNext and next methods
   * @constructor
   */
  function ArrayIterator(items)
  {
    // Empty arrays are currently sent to the JavaScript side as nulls by the embedded side. As
    // such, convert the value into an empty array
    this._items = items || [];
    this._index = -1;
    this._length = this._items.length;
  }

  ArrayIterator.prototype =
  {
    next: function()
    {
      return this.hasNext() ? this._items[++this._index] : undefined;
    },

    hasNext: function()
    {
      return this._index + 1 < this._length;
    },

    previous: function()
    {
      return this.hasPrevious() ? this._items[--this._index] : undefined;
    },

    hasPrevious: function()
    {
      return this._index > 0 && this._index - 1 < this._length;
    },

    getCurrent: function()
    {
      return this._index >= 0 && this._index <= this._length ? this._items[this._index] : undefined;
    },

    getCurrentIndex: function()
    {
      return this._index;
    },

    isTreeNodeIterator: function()
    {
      return false;
    },

    isAllDataLoaded: function()
    {
      // Arrays cannot implement the behavior of notifying the consumer that more data may be able
      // to be loaded. It is up to the page author to configure the loading of more information
      // manually
      return true;
    },

    getAvailableCount: function()
    {
      return this._length;
    },

    getTotalCount: function()
    {
      return this._length;
    },

    getRowKey: function()
    {
      if (this._index == -1)
      {
        return null;
      }

      var currentItem = this._items[this._index];
      return currentItem == null ? null :
        typeof currentItem["rowKey"] === "function" ?
          currentItem.rowKey() : this._index;
    },

    /**
     * Sets the index to the value specified. Note that calling next will cause
     * the item after this index to be returned. Therefore, calling the function
     * with -1 will cause the next item to load to be the first item (index 0).
     */
    setCurrentIndex: function(index)
    {
      this._index = index;
    },

    /**
     * Sets the current item by the row key
     * @param {string} rowKey the row key
     * @return {boolean} true if the rowKey was found, false otherwise
     */
    setCurrentRowKey: function(rowKey)
    {
      this._index = -1;
      while (this.hasNext())
      {
        this.next();
        if (this.getRowKey() == rowKey)
        {
          return true;
        }
      }

      return false;
    }
  };

  /**
   * Iterator object to use with TreeNodeIterator with hasNext and next methods
   * @constructor
   */
  function TreeNodeIteratorWrapper(items)
  {
    this._first = true;
    this._items = items;
    // cache available size of the iterator to avoid
    // multiple calculations
    // Iterator is not suppose to life longer than one iteration
    // so this is safe to do here since any data change
    // during the iteration will corrupt data anyway and it should
    // be avoided in a code that uses this iterator.
    this._availableCount = items.getCachedRowCount(0);
    this._totalCount = items.getTreeNodeBindings().keys.length;
  }

  TreeNodeIteratorWrapper.prototype =
  {
    /**
     * @return {TreeNode} representation of the next row in the collection
     */
    next: function()
    {
      if (this._first)
      {
        this._first = false;
        return this._items.localFirst();
      }

      return this._items.localNext();
    },

    /**
     * @return {Boolean} true if the next row is available in local collection
     */
    hasNext: function()
    {
      if (this._first)
      {
        return this._items.localFirst() !== undefined;
      }
      return this._items.getCurrentIndex() < this._availableCount - 1;
    },

    /**
     * @return {TreeNode} representation of the previous row in the collection or undefined
     *         if already at the beginning
     */
    previous: function()
    {
      return this._first ? undefined : this._items.localPrevious();
    },

    /**
     * @return {Boolean} true if the previous row is available in local collection
     */
    hasPrevious: function()
    {
      return this._first == false;
    },

    /**
     * @return {TreeNode} representation of the row on current index
     */
    getCurrent: function()
    {
      return this._items.getCurrentRow();
    },

    /**
     * @return {Integer} index of the current position in collection
     */
    getCurrentIndex: function()
    {
      return this._items.getCurrentIndex();
    },

    isTreeNodeIterator: function()
    {
      return true;
    },

    /**
     * @return true if there are more data to be loaded from the backend
     */
    isAllDataLoaded: function()
    {
      return this._items.getTreeNodeBindings().hasMoreKeys !== true;
    },

    /**
     * @return {Integer} number of all available items on the backend
     */
    getAvailableCount: function()
    {
      return this._availableCount;
    },

   /**
    * @return {Integer} total number of items in collection on backend
    */
    getTotalCount: function()
    {
      return this._totalCount;
    },

   /**
    * @return {String} rowKey of the current position in collection
    */
    getRowKey: function()
    {
      if (this._first)
      {
        return null;
      }

      return this._items.getCurrentKey();
    },

    /**
     * Sets the index to the value specified. Note that calling next will cause
     * the item after this index to be returned. Therefore, calling the function
     * with -1 will cause the next item to load to be the first item (index 0).
     */
    setCurrentIndex: function(index)
    {
      this._items.setCurrentIndex(index);
      this._first = index == -1;
    },

    /**
     * Sets the current item by the row key
     * @param {string} rowKey the row key
     * @return {boolean} true if the rowKey was found, false otherwise
     */
    setCurrentRowKey: function(rowKey)
    {
      this._first = false;
      return this._items.setCurrentRowKey(rowKey);
    }
  };

  /**
   * Create an iterator that will support either a JavaScript array of objects or iterator over a
   * tree node iterator (collection model).
   * @param {(Array|TreeNodeIterator)} the items to iterate over
   * @return {Object} iterator object with "next", "hasNext", and "isTreeNodeIterator" functions
   *                           where "next" will return undefined when no more objects are available.
   */
  adf.mf.api.amx.createIterator = function(items)
  {
    if (items != null && items[".type"] === "TreeNodeIterator")
    {
      return new TreeNodeIteratorWrapper(items);
    }
    else
    {
      return new ArrayIterator(items);
    }
  };

  /**
   * Convenient method to sequentialy resolve each item of an array. If the itemResolver method
   * returns a promise, it will wait until resolved before processing the next element.
   * If the itemResolver returns the direct value, it will to the next item.
   *
   * @param {(Array|TreeNodeIterator)} items is the array or the TreeNodeIterator to iterate threw
   * @param {function} itemResolver(item) function that will resolve the item. Can return the value
   *        or a promise that will resolve with the value
   * @return {Promise} promise that will resolve with the array of values returned by the item
   *         resolver
   */
  amx.serialResolve = function(items,itemResolver)
  {
    var _type = null;

    try
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST, "amx", "serialResolve",
          "items is of type: " + items.constructor.name + " or " + items[".type"]);
      }
      _type = items.constructor.name || items[".type"];
    }
    catch (te)
    {
      /* ignore */
    }

    if (_type === "TreeNodeIterator")
    {
      return amx.iteratorResolve(items, itemResolver);
    }
    else
    {
      var promiseResolve = null;
      var promiseReject = null;
      var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
        {
          promiseResolve = resolve;
          promiseReject = reject;
        });
      var results = [];
      var i = 0;

      function resolveAndNext()
      {
        if (i < items.length)
        {
          var item = items[i];
          var itemResolverResult = itemResolver(item, i);

          // if it is a promise (but not a jquery object, which is also a promise), then, pipe it
          if (typeof itemResolverResult !== "undefined" && itemResolverResult !== null &&
            adf.mf.internal.amx.implementsFunction(itemResolverResult, "then") &&
            !itemResolverResult.jquery)
          {
            itemResolverResult.then(
              function(result)
            {
              results.push(result);
              i += 1;
              resolveAndNext();
              },
              function(result)
            {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                "resolveAndNext", "MSG_SERIAL_RESOLVE_DEFERRED_REJECTED", i);
                promiseReject();
            });
          }
          else
          {
            // if it is a normal object or a jqueryObject, then, just push the value and move to the next
            results.push(itemResolverResult);
            i += 1;
            resolveAndNext();
          }
        }
        else
        {
          // once we run out
          promiseResolve(results);
        }
      }
      resolveAndNext();
      return promise;
    }
  };

  /**
   * Determine if parameter is a finite number
   * @param {Object} n is the object to check
   */
  adf.mf.internal.amx.isFiniteNumber = function (n)
  {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  /**
   * Iterates over items provided by elNodeIterator and executes itemResolver for each item.  The number of iterations can be
   * limited by providing maxIterations.  If the itemResolver method returns a promise, it will wait until resolved before processing the next element.
   * If the itemResolver returns the direct value, it will do the next item.
   * @param {TreeNodeIterator} elNodeIterator is the iterator to iterate over
   * @param {function} itemResolver(item) function that will resolve the item. Can return the value or a promise that will resolve with the value
   * @param {Object} maxIterations specifies the maximum number of iterations to perform
   */
  amx.iteratorResolve = function(elNodeIterator,itemResolver,maxIterations)
  {
    var promiseResolve = null;
    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        promiseResolve = resolve;
      });
    var results = [];
    var methodNext = "first";
    var rowCount = 0;
    var _maxIterations = Infinity;
    if (maxIterations)
    {
      _maxIterations = maxIterations;
    }

    function resolveNext()
    {
      if (elNodeIterator.hasNext() && rowCount < _maxIterations)
      {
        elNodeIterator[methodNext](
          function(a,b)
        {
          methodNext = "next";
          var item = b[0].value;

          //FIXME: for now, turn this off for debugging
          var itemResolverResult = itemResolver(item,elNodeIterator.getCurrentIndex());

          // if it is a promise (but not a jquery object, which is also a promise), then, pipe it
          if (typeof itemResolverResult !== "undefined" && itemResolverResult !== null &&
            adf.mf.internal.amx.implementsFunction(itemResolverResult, "promise") &&
            !itemResolverResult.jquery)
          {
            itemResolverResult.then(function(result)
            {
              results.push(result);
              ++rowCount;
              resolveNext();
            });
          }
          else
          {
            // If it is a normal object or a jqueryObject, then, just push the value and move to
            // the next
            results.push(itemResolverResult);
            ++rowCount;
            resolveNext();
          }
          },
          function(a,b)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
              "resolveNext", "MSG_ITERATOR_FIRST_NEXT_ERROR");

            // Only log the exception at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx.iteratorResolve", "resolveNext", adf.mf.util.stringify(arguments));
            }
        });
      }
      else
      {
        promiseResolve(results);
      }
    }
    resolveNext();

    return promise;
  };

  /*TreeNodeIterator
k: id
k: treeNodeBindings
k: index
k: currentKey
k: createRow
k: first
k: getCurrentIndex
k: getCurrentKey
k: getCurrentRow
k: hasNext
k: hasPrevious
k: last
k: next
k: nextSet
k: previous
k: previousSet
k: refresh
k: setCurrentIndex
k: fetch
k: getKeys
k: removeCurrentRow
k: setCurrentRowWithKey
k: fetchSet
k: fetchProviderByKey
k: updateKeys
   */

  // ------ /Public API ------ //

  function initUI()
  {
    if (initPromise)
    {
      return initPromise;
    }
    else
    {
      initPromise = new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      // adf.mf.environment.profile.mockData=true for the DT as well as the RT test harness mode. The DT
      // requires that featureLevelIncludes.jso be in the feature root, NOT relative
      // to the directory of the AMX
      if (adf.mf.environment.profile.mockData)
      {
        adf.mf.api.resourceFile.loadJsonFile(
          adfc.Util.addFeatureRootPrefix("featureLevelIncludes.jso"),
          true,
          function(data)
          {
            loadIncludes(data);
                resolve();
          },
          function()
          {
            // do nothing, no config.
                resolve();
          });
      }
      else
      {
            container.internal.device.integration.getAmxIncludeList(
              function(includes)
        {
          loadIncludes(includes);
                resolve();
              },
              function(er)
        {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                  "initUI", "MSG_AMX_INCLUDE_FAILED");

                // Only log the exception at a fine level for security reasons
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "initUI", "container.internal.device.integration.getAmxIncludeList", er);
                resolve();
        });
      }
        });

      return initPromise;
    }
  }

  function loadIncludes(includes)
  {
    if (includes)
    {
      adf.mf.internal.amx._each(includes, function(idx, include)
      {
        var file = include.file;
        if (!amx.hasProtocol(file))
        {
          file = adfc.Util.addFeatureRootPrefix(include.file);
        }
        if (include.type == "StyleSheet")
        {
          amx.includeCss(file);
        }
        else if (include.type == "JavaScript")
        {
          amx.includeJs(file);
        }
      });
    }
  }

  function initData(amxPageName)
  {
    return mockInitData(amxPageName);
  }

  var initDataDone = false;

  function mockInitData(pagename)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    // if the data has not been initialized, and we are not in the Oracle Shell (ADFMobile undefined), then, we load the model.jso
    //TODO: need to add condition for :  typeof ADFMobile === "undefined" & and !forceInitDataMock
    if (!initDataDone && adf.mf.environment.profile.mockData)
    {
      // before we do anything, make sure all of the el gets set up by trying to retrieve the application scope
      // this will allow any data in model.jso that isn't bindings related to not get over-written
      adf.mf.el.getLocalValue("#{applicationScope}");
      pagename = pagename || "nopage";
      // adf.mf.environment.profile.mockData=true for the DT as well as the RT test harness mode. The DT
      // requires that model.jso be in the feature root, NOT relative
      // to the directory of the AMX
      adf.mf.api.resourceFile.loadJsonFile(
        adfc.Util.addFeatureRootPrefix("model.jso"),
        true,
        function(data)
        {
          if (data)
          {
            //model = data;
            //adf.mf.el.addVariable("bindings", data);
                adf.mf.internal.amx._each(data,
                  function(key,value)
            {
              adf.mf.el.addVariable(key, value);
            });

            adf.mf.el.addVariable("applicationScope", {});
            adf.mf.el.addVariable("pageFlowScope", {});
            initDataDone = true;
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "mockInitData-a",
                  "MSG_AMX_MODEL_JSO_LOADED");
                initContext(pagename, resolve);
          }
          else
          {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                  "mockInitData-b", "MSG_NO_MODEL_JSO_FOUND");
            adf.mf.environment.profile.mockData = false;
                initContext(pagename, resolve);
          }
        },
        function(error)
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                "mockInitData-c", "MSG_NO_MODEL_JSO_FOUND");

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "mockInitData", "adf.mf.api.resourceFile.loadJsonFile", error);

              adf.mf.environment.profile.mockData = false;
              initContext(pagename, resolve);
        });
    }
    else
    {
          initContext(pagename, resolve);
    }
    });
  }

  var amxTransitionModeELExpression = adf.mf.internal.el.parser.parse ("#{applicationScope.configuration.amxTransitionMode}");

  function initContext(amxPageName, callback)
  {
    var promise = new adf.mf.internal.BasePromise(function (resolve, reject)
    {
      if (!adf.mf.environment.profile.mockData)
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Initialize context for",
          adf.mf.log.level.FINER, "adf.mf.internal.amx:initContext", amxPageName);

        // Prime the EL values for the a variable that will be used in
        // adf.mf.internal.amx.isTransitionAfterRender:
        if (!adf.mf.environment.profile.mockData)
          amx.getElValue(amxTransitionModeELExpression, true);

        //
        //  Set the current context.
        //
        var newViewScope = adf.mf.internal.lastNavIsDifferentView;
        adf.mf.api.setCurrentContext(amxPageName, true, true, newViewScope, function ()
        {
          perf.stop();
          resolve();
        },
        function (ex)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "initContext",
            "MSG_SET_CONTEXT_FAILED", amxPageName);

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "initContext", "adf.mf.api.setCurrentContext", ex);

          perf.stop();
          resolve();
        });
      }
      else
      {
        resolve();
      }
    });
    promise.then(function ()
    {
      callback();
    });
  }

  // pageStructAndDef data by pageName
  var amxPages = {};

  /**
   * Load a new instance of the amxPage JSON structure.
   * Returns a promise that will resolve with the amxPage JSON Structure. <br />
   *
   * @param {Object} uri the URI to the AMX page
   */
  function loadAmxPage(uri)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        resourcesDataPromise.then(
          function()
          {
            adf.mf.internal.amx._loadXmlFile(
              uri,
              true,
              function(data)
              {
                resolve(data);
              },
              function(e)
              {
                reject("Unable to load the XML file: " + uri, e);
              });
          });
      });
  }

  /**
   * Reloads the current AMX page UI.
   * It should only be invoked in MobileApplicationAcceleratorMode.
   * This function does not reload the feature or page,
   * nor it affects any of the bindings, scopes, etc.
   *
   * This is an internal API and it is used by MAX.
   *
   * @return {Promise}
   */
  adf.mf.internal.amx.softReloadCurrentAmxPage = function ()
  {
    var that = this;
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        adf.mf.api.finishAnyLoading().then(
          function ()
          {
            adf.mf.api.amx.showLoadingIndicator();

            adf.mf.internal.amx._queueCriticalSectionFunction(
              softReloadCurrentAmxPageImpl,
              that,
              true,
              {
                "resolve": resolve,
                "reject": reject
              });
          });
      });
  };

  function softReloadCurrentAmxPageImpl(promiseCallbacks)
  {
    var amxPage = amx.getCurrentPageName();

    // if current page path is null
    // or the environmentMode is not set to MobileApplicationAccelerator
    // hide the loading indicator and do nothing
    if (amxPage == null || !adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
    {
      adf.mf.api.amx.hideLoadingIndicator();
      promiseCallbacks["reject"]();
    }
    else
    {
      // NOTE: amx-popup is lazily loaded, so we must check for the existence
      // of the function before calling it
      if (adf.mf.internal.amx.closePopups)
      {
        adf.mf.internal.amx.closePopups();
      }

      // Before we strip off the IDs, call the destroy methods on any AMX nodes
      var current = document.querySelector("#bodyPageViews > .current");
      adf.mf.internal.amx.processDestroy(current);

      // Strip off any ID attributes on the page's elements.
      if (current != null)
      {
        adf.mf.internal.amx.stripIds(current);
      }

      // Purge any elements that might be disconnected from the bodyPage:
      adf.mf.internal.amx._purgeOnNav();

      // invoke displayAmxPage to reload the amxPage
      adf.mf.api.amx.displayAmxPage(amxPage).then(
        function(newPage)
        {
          current.classList.remove("current");
          current.classList.add("old");
          newPage.classList.remove("new");
          newPage.classList.add("current");
          adf.mf.internal.amx.processDestroy(current);
          adf.mf.api.amx.removeDomNode(current);
          adf.mf.api.amx.hideLoadingIndicator();
          promiseCallbacks["resolve"]();
        });

      // if debug mode...
      // Check for window event leaks
      adf.mf.internal.amx._checkForWindowsEventLeaks("softReloadCurrentAmxPage");
    }
  };

  /**
   * Removes all element IDs from the given subtree (root included).
   * @param {Element} root the root element of the subtree whose IDs are to be removed
   */
  adf.mf.internal.amx.stripIds = function(root)
  {
    // Strip off any ID attributes on the old page's elements. This will prevent any issues
    // with getElementById finding elements on the old page instead of the new page.
    var treeWalker =
     document.createTreeWalker(
       root,
       NodeFilter.SHOW_ELEMENT,
       function(node)
       {
         return (node.hasAttribute("id")) ?
           NodeFilter.FILTER_ACCEPT :
           NodeFilter.FILTER_SKIP;
       },
       false);

    while (treeWalker.nextNode())
    {
      treeWalker.currentNode.removeAttribute("id");
    }

    root.removeAttribute("id"); // remove it from the root too
  };

  var amxTagForPagePromiseMap = {};

  /**
   * Return a promise object (or cached tag) that will get resolved with the amxPage root tag.
   * This will first try to get it from the cache, or load it if needed.
   *
   * @param {Object} uri The URI of the page to load
   * @param {Boolean} getCacheInsteadOfPromise whether to get the cached tag or a promise
   * @return {Object} either a promise object or a possibly undefined adf.mf.api.amx.AmxTag
   */
  function getAmxTagForPage(uri, getCacheInsteadOfPromise)
  {
    // Note that we are caching the tag hierarchy per page. If there is ever a problem with the
    // retained AMX tag hierarchies taking up too much RAM, then we should remove the cache and
    // regenerate the tags from the XML each time.

    // Get the base URI to resolve the relative path
    var prefix = adfc.Util.addFeatureRootPrefix("/");
    var relUri = uri;
    if (relUri.substring(0, prefix.length) == prefix)
    {
      relUri = relUri.substring(prefix.length);
    }

    var amxPageTag = amxPages[relUri];
    if (getCacheInsteadOfPromise)
    {
      return amxPageTag;
    }

    var promise;

    if (amxPageTag)
    {
      promise = new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      if (amxPageTag instanceof adf.mf.api.amx.AmxTag)
      {
            resolve(amxPageTag);
      }
      else
      {
        // The tag is not actually a tag, but the error arguments stored in the map
            reject(amxPageTag);
      }
        });
    }
    else
    {
      promise = amxTagForPagePromiseMap[relUri];
      if (promise == null)
      {
        promise = new adf.mf.internal.BasePromise(
          function(resolve, reject)
          {
            loadAmxPage(uri).then(
            function(amxPageTag)
            {
              // do not cache if in MAX Mode
              if(!adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
              {
                amxPages[relUri] = amxPageTag;
              }

                delete amxTagForPagePromiseMap[relUri];

                resolve(amxPageTag);
              },
              function(msgAndE)
            {
                var msg = msgAndE[0];
                var e = msgAndE[1];
              amxPages[relUri] = [ msg, e ];
                delete amxTagForPagePromiseMap[relUri];

                // forward the failure argument to the promise
              var args = Array.prototype.slice.call(arguments);
                reject.apply(null, args);
            });
          });
        amxTagForPagePromiseMap[relUri] = promise;
      }
    }

    return promise;
  }

  // Expose for use by the amx:fragment
  adf.mf.internal.amx.__getAmxTagForPage = getAmxTagForPage;

  /**
   * Get the AmxNode root node for the currently loaded page.
   *
   * @return {(adf.mf.api.amx.AmxNode|null)} the amx node or null if the
   *         page is not loaded.
   */
  adf.mf.api.amx.getPageRootNode = function()
  {
    return amxPageRootNode;
  };

  /**
   * Object used by the functions in markNodeForUpdate to pass the state
   * of the changes between the functions.
   * @constructor
   * @private
   */
  function AmxNodeChangesResults()
  {
    this._affectedNodeIds = {};
    this._affectedNodes = [];

    this._nodesToRecreate = [];

    this._descendentChanges = {};
    this._ancestorNodes = [];

    this._attributeChanges = {};

    this._changeResult = {};

    this._initialStates = {};

    this._hasChanges = false;
  }

  AmxNodeChangesResults.prototype =
  {
    /**
     * Get if there are changes to any nodes
     * @return {Boolean} true if any nodes were updated
     */
    hasChanges: function()
    {
      return this._hasChanges;
    },

    /**
     * Get the array of AMX nodes that have been changed and need to
     * be visited during the application of render changes.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes to visit
     */
    getAffectedNodes: function()
    {
      return this._affectedNodes;
    },

    /**
     * Get the result of the updateChildren function for an affected AMX node.
     * @param {number} amxNodeId the ID of the AMX node
     * @return {(number|null)} the result or null. One of the adf.mf.api.amx.AmxNodeChangeResult
     *         constants
     */
    getChangeResult: function(amxNodeId)
    {
      return this._changeResult[amxNodeId];
    },

    /**
     * Get the change result for a given AMX node ID
     * @param {number} amxNodeId the ID of the AMX node
     * @return {(adf.mf.api.amx.AmxAttributeChange|null)} the attribute change object or null
     *         if the node was not affected
     */
    getAttributeChanges: function(amxNodeId)
    {
      return this._attributeChanges[amxNodeId];
    },

    /**
     * Get the AMX nodes that need to be re-created
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes to re-create
     */
    getAmxNodesToRecreate: function()
    {
      return this._nodesToRecreate;
    },

    /**
     * Get the AMX nodes that have been queued to see if they can handle changes to descendents
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX ancestor nodes
     */
    getAmxNodesForDescendentChanges: function()
    {
      return this._ancestorNodes;
    },

    /**
     * Get the AMX descedent changes for a given ancestor AMX node ID
     * @param {number} amxNodeId the ID of the ancestor AMX node
     * @return {(adf.mf.api.amx.AmxDescendentChanges|null)} the changes object or null if the node
     *         has no descendent changes.
     */
    getDescendentChanges: function(amxNodeId)
    {
      return this._descendentChanges[amxNodeId];
    },

    /**
     * Notifies this object that a node has been recreated
     * @param {adf.mf.api.amx.AmxNode} oldAmxNode node that was re-created
     * @param {adf.mf.api.amx.AmxNode} newAmxNode re-created node
     */
    amxNodeRecreated: function(oldAmxNode, newAmxNode)
    {
      var index = this._affectedNodes.indexOf(oldAmxNode);
      if (index != -1)
      {
        this._affectedNodes[index] = newAmxNode;
      }

      var wasRendered = oldAmxNode.isRendered();

      if (wasRendered)
      {
        // If the node was rendered, and still is, we will just swap the root DOM
        // in place
        var id = newAmxNode.getId();
        if (newAmxNode.isReadyToRender())
        {
          this._changeResult[id] = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
        }
        else
        {
          // Otherwise we need to mark the parent to be re-rendered
          var initialState = this._initialStates[id];
          var attributeChanges = this._attributeChanges[id];
          var renderedAmxNode = newAmxNode.__getClosestRenderedNode(true);

          this._markNodeAffected(renderedAmxNode);
          this._queueCallToAncestor(newAmxNode, initialState, attributeChanges, renderedAmxNode);
        }
      }
    },

    /**
     * Called after calling the ancestor nodes getDescendentChangeAction function to see how
     * a change should be handled.
     * @param {adf.mf.api.amx.AmxNode} amxNode the ancestor AMX node.
     * @param {number} descendentChangeResult the value returned from getDescendentChangeAction
     */
    setDescendentChangesResult: function(
      amxNode,
      descendentChangeResult)
    {
      var amxNodeId = amxNode.getId();
      var currentResult = this._changeResult[amxNodeId];

      // If the node is not already marked for another change or if the
      // descendent changes require a more invasive change, then store the result
      // from asking about the descendent refresh changes
      if (currentResult == null || descendentChangeResult > currentResult)
      {
        this._changeResult[amxNodeId] = descendentChangeResult;

        if (descendentChangeResult != adf.mf.api.amx.AmxNodeChangeResult["NONE"])
        {
          this._markNodeAffected(amxNode);
        }
      }
    },

    /**
     * During the application of changes, adds a change result to this object.
     * @param {adf.mf.api.amx.AmxNode} amxNode the affected AMX node
     * @param {number} initialState one of the AMX node state constants representing the node
     *        state before the attributes and children were updated
     * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the attribute changes
     *        object for the AMX node
     * @param {number} changeResult the change result returned from updateChildren
     */
    addChangeResult: function(
      amxNode,
      initialState,
      attributeChanges,
      changeResult)
    {
      // Get the closest ancestor rendered AMX node
      var renderedAmxNode = amxNode.__getClosestRenderedNode(true);

      var id = amxNode.getId();

      this._initialStates[id] = initialState;
      this._attributeChanges[id] = attributeChanges;

      this._hasChanges = true;

      // See if this is a recreate result
      if (changeResult == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"])
      {
        this._nodesToRecreate.push(amxNode);
      }

      if (renderedAmxNode == null)
      {
        // The rendered AMX node will be null if the page has not rendered yet, in that case
        // the change result does not matter
        return;
      }

      // Mark the rendered AMX node as one to visit later if the change result is not NONE
      if (changeResult != adf.mf.api.amx.AmxNodeChangeResult["NONE"])
      {
        this._markNodeAffected(renderedAmxNode);
      }

      if (renderedAmxNode === amxNode)
      {
        // Honor the change result if the affected node is currently rendered
        this._changeResult[id] = changeResult;
      }
      else
      {
        // Allow the rendered ancestor to be notified of the change
        this._queueCallToAncestor(amxNode, initialState, attributeChanges, renderedAmxNode);
      }
    },

    _markNodeAffected: function(amxNode)
    {
      var id = amxNode.getId();
      if (this._affectedNodeIds[id] !== true)
      {
        this._affectedNodeIds[id] = true;
        this._affectedNodes.push(amxNode);
      }
    },

    _queueCallToAncestor: function(
      amxNode,
      initialState,
      attributeChanges,
      renderedAmxNode)
    {
      var renderedId = renderedAmxNode.getId();

      // If the rendered AMX node is not the changed AMX node, then we need
      // to ask the rendered node if it wishes to perform a refresh instead
      // of being rerendered
      var changes = this._descendentChanges[renderedId];

      // See if this parent has already been added as one to be called
      if (changes == null)
      {
        // Create a new changes object to be used later
        changes = new adf.mf.api.amx.AmxDescendentChanges();
        this._descendentChanges[renderedId] = changes;
        this._ancestorNodes.push(renderedAmxNode);
      }

      // Add the child's attribute changes and other state to the changes object
      // so that the parent can decide if it can refresh based on the results
      changes.__addAmxNode(
        amxNode,
        initialState,
        attributeChanges);

      // Note that we do not actually call the parent at this point, that is done
      // in a later pass
    }
  };

  /**
   * Called by markNodeForUpdate to update the attributes and initialize any new nodes created
   * as a result.
   * @param {adf.mf.api.amx.AmxNode} rootNode the root AMX node of the page
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} args the information passed to the
   *        mark node for update function
   * @private
   */
  function applyUpdatesToAmxNodeHierarchy(
    rootNode,
    args)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    var affectedAmxNodes = args.getAffectedNodes();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": affectedAmxNodes });
    var changes = new AmxNodeChangesResults();

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var nodeId = amxNode.getId();
        var affectedAttributes = args.getAffectedAttributes(nodeId);

        // Get the attributes that have changed for this node
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
            "Found node to apply updates. ID: " + nodeId);
        }

        var nodeWasRendered = amxNode.isRendered();

        var initialState = amxNode.getState();

        // Notify the node of the changed attributes
        var collectionChanges = args.getCollectionChanges(nodeId);
        var attributeChanges = amxNode.updateAttributes(affectedAttributes, collectionChanges);

        // Notify the tag instances
        amxNode.__updateTagInstanceAttributes(args);

        // See if the AMX node's converter was affected
        amxNode.__processConverterChanges(args, attributeChanges);

        var state = amxNode.getState();
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
            "Node attributes have been applied. New node state: " +
            adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
        }

        if (state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
        {
          // Allow the rendered ancestor node to be notified of the change
          changes.addChangeResult(amxNode, initialState, attributeChanges,
            adf.mf.api.amx.AmxNodeChangeResult[nodeWasRendered ? "RERENDER" : "NONE"]);

          // Do not attempt to apply changes to nodes if a parent is not rendered.
          // The node should have removed all the children at this point, so this
          // function does not need to perform that logic.
          return adf.mf.api.amx.VisitResult["REJECT"];
        }

        var skipBuild;
        var changeResult;

        // Do not create or update the children of nodes in the initial state
        if (state != adf.mf.api.amx.AmxNodeStates["INITIAL"])
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "Updating the children of the node");
          }

          // Update the children of the node only if the node is not in the
          // initial state. If it is, then the _buildVisitCallback below
          // will initialize the children
          changeResult = amxNode.updateChildren(attributeChanges);

          // Pick up any changes to the node's state as a result of the updateChildren
          // call.
          state = amxNode.getState();

          // Skip the initialization of the node and descendents if the updateChildren
          // call has caused the state of the node to go back to the initial state.
          // This means that the node's type handler changed the state back to initial
          // as a result of not being able to successfully create its children.
          skipBuild = (state == adf.mf.api.amx.AmxNodeStates["INITIAL"]);

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "New node state: " +
              adf.mf.api.amx.AmxNodeStates.getLabelForValue(state) +
              ". Should the build visit callback be skipped: " + skipBuild +
              ". Update children method returned: " +
              adf.mf.api.amx.AmxNodeChangeResult.getLabelForValue(changeResult));
          }
        }
        else
        {
          changeResult = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
          skipBuild = false;
        }

        // Record the change result
        changes.addChangeResult(amxNode, initialState, attributeChanges, changeResult);

        // See if the node has requested to be recreated
        var resultIsRecreate = changeResult == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"];
        if (resultIsRecreate)
        {
          skipBuild = true;
        }

        // Process the children tree under the node to initialize any newly
        // created nodes (does nothing if they are all already rendered or in the
        // unrendered state) as long as the node was able to create its children.
        if (skipBuild == false)
        {
          // Pass in the affected nodes into the visit context. This will allow
          // the _buildVisitCallback to skip any descendent nodes (they will be visited
          // later when they are updated). This improves performance by not visiting
          // the same nodes more than once.
          var contextData = {
            "affectedAmxNodes": affectedAmxNodes,
            "targetNode": amxNode
          };

          amxNode.visit(
            new adf.mf.api.amx.VisitContext({ "data": contextData }),
            adf.mf.internal.amx._buildVisitCallback);

          // Pick up any changes to the state as a result of initialization
          state = amxNode.getState();

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "Node state after invoking the build visit callback: " +
              adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
          }
        }

        // Do not progress down the hierarchies of nodes that are in the initial state,
        // or are not rendered or if the change result is to replace (recreate) the node
        if (resultIsRecreate ||
          state == adf.mf.api.amx.AmxNodeStates["INITIAL"] ||
          state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
        {
          return adf.mf.api.amx.VisitResult["REJECT"];
        }
        else
        {
          return adf.mf.api.amx.VisitResult["ACCEPT"];
        }
      });

    return changes;
  }

  /**
   * Called by markNodeForUpdate to recreate any AMX nodes and their descendants.
   * @private
   */
  function recreateRequestedAmxNodes(
    rootNode,
    changeResults)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    // For each node, we actually only want the parent node in context. Therefore, go through the
    // array and collect all of the parent nodes.
    var childNodesByParentId = {};
    var affectedNodeParents = [];
    var amxNode;
    var parentId;

    var amxNodes = changeResults.getAmxNodesToRecreate();

    for (var i = 0, size = amxNodes.length; i < size; ++i)
    {
      amxNode = amxNodes[i];
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "recreateRequestedAmxNodes",
          "Will attempt to recreate node with ID " + amxNode.getId());
      }

      var parent = amxNode.getParent();
      parentId = parent.getId();
      var children = childNodesByParentId[parentId];
      if (children == null)
      {
        children = [ amxNode ];
        childNodesByParentId[parentId] = children;
        affectedNodeParents.push(parent);
      }
      else
      {
        children.push(amxNode);
      }
    }

    // Now visit each parent
    rootNode.visit(
      new adf.mf.api.amx.VisitContext({ "amxNodes": affectedNodeParents }),
      function(
        visitContext,
        parentAmxNode)
      {
        var parentId = parentAmxNode.getId();
        var children = childNodesByParentId[parentId];
        var recreatedNodes = [];
        var i, size;

        // Loop through each child node that has changes
        for (i = 0, size = children.length; i < size; ++i)
        {
          var amxNode = children[i];
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "recreateRequestedAmxNodes",
              "Re-creating node " + amxNode.getId());
          }

          var tag = amxNode.getTag();
          var stampKey = amxNode.getStampKey();
          var newAmxNode = tag.buildAmxNode(parentAmxNode, stampKey);

          // Replace the child
          if (parentAmxNode.replaceChild(amxNode, newAmxNode))
          {
            // Push the nodes onto an array to process after initialization
            recreatedNodes.push([ amxNode, newAmxNode ]);
          }
          else
          {
            // TODO: log warning
          }
        }

        // Initialize the new nodes and create their children by visiting
        // the parent so that the parent is put into context
        parentAmxNode.visit(
          new adf.mf.api.amx.VisitContext(),
          adf.mf.internal.amx._buildVisitCallback);

        // Notify the change results of the new children (has to be done after node initialization)
        for (i = 0, size = recreatedNodes.length; i < size; ++i)
        {
          var arr = recreatedNodes[i];
          // Replace the node in the change results object
          changeResults.amxNodeRecreated(arr[0], arr[1]);
        }

        // Return accept since we are visiting the parent of the node to replace and not the node
        // itself.
        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  /**
   * Called by markNodeForUpdate to see if ancestor AMX nodes wish to handle changes to non-rendered
   * descendent AMX nodes.
   * @private
   */
  function processDescendentChanges(
    rootNode,
    changeResults)
  {
    var amxNodes = changeResults.getAmxNodesForDescendentChanges();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": amxNodes });

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var id = amxNode.getId();
        var descendentChanges = changeResults.getDescendentChanges(id);
        var descendentChangeAction = amxNode.__getDescendentChangeAction(descendentChanges);

        // We do not support a value of REPLACE for child refresh changes
        if (descendentChangeAction == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"])
        {
          // TODO: log error
          descendentChangeAction = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
        }

        changeResults.setDescendentChangesResult(amxNode, descendentChangeAction);

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  /**
   * Called by markNodeForUpdate to re-render any nodes and invoke and refresh methods
   * as appropriate.
   * @private
   */
  function applyRenderChanges(
    rootNode,
    changeResults)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    var affectedNodes = changeResults.getAffectedNodes();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": affectedNodes });

    var perf = adf.mf.internal.perf.startMonitorCall("Apply render changes", adf.mf.log.level.FINER, "adf.mf.internal.amx:applyRenderChanges");
    // set flag to prevent independent processing of the init and postDisplay queues
    // only wait if there is some rerender event which enqueues the rendered node into
    // the processing queue and process these queues after the whole refresh is complete
    amx.mustProcessQueues = false;

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var id = amxNode.getId();
        var changeResult = changeResults.getChangeResult(id);

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyRenderChanges",
            "Found node to apply render changes. ID: " + id +
            ". Change result: " +
            adf.mf.api.amx.AmxNodeChangeResult.getLabelForValue(changeResult));
        }

        switch (changeResult)
        {
          case adf.mf.api.amx.AmxNodeChangeResult["REFRESH"]:
            var attributeChanges = changeResults.getAttributeChanges(id);
            var descendentChanges = changeResults.getDescendentChanges(id);

            // Don't pass null as the attribute changes, but instead pass an empty object
            // so that it is easier to work with
            if (attributeChanges == null)
            {
              attributeChanges = new adf.mf.api.amx.AmxAttributeChange();
            }

            amxNode.refresh(attributeChanges, descendentChanges);
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "applyRenderChanges",
                "Completed the refresh of node " + id);
            }
            break;

          case adf.mf.api.amx.AmxNodeChangeResult["RERENDER"]:
            amxNode.rerender();
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "applyRenderChanges",
                "Completed the re-render of node " + id);
            }

            // Do not perform operations on the children
            return adf.mf.api.amx.VisitResult["REJECT"];
        }

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyRenderChanges",
            "Completed the processing of the changes for node " + id);
        }

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });

      // now process the queues at once to init and postDisplay
      // all newly rendered nodes
      amx.processAndCleanInitQueue();
      amx.processAndCleanPostDisplayQueue();
      // set flag that the single rerender function call on the amxNode should also invoke
      // processing of the init and postDisplay queues
      amx.mustProcessQueues = true;

    perf.stop();
  }

  /**
   * @deprecated
   */
  adf.mf.internal.amx.markNodeForUpdate = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "markNodeForUpdate", "MSG_DEPRECATED", "adf.mf.internal.amx.markNodeForUpdate",
      "adf.mf.api.amx.markNodeForUpdate");
    return adf.mf.api.amx.markNodeForUpdate.apply(this, arguments);
  };

  /**
   * Function for TypeHandlers to notify the framework of a state change to an AmxNode that requires the
   * AmxNode hierarchy to be updated at that node and below. If a custom createChildrenNodes method
   * exists on the TypeHandlers, it will be called again for these AmxNode. This will allow AmxNode that
   * stamp their children to add new stamps due to a user change.
   * The refresh method will be called on the AmxNode with the provided properties if the AmxNode is
   * ready to render. If the AmxNode is not ready to render, the framework will wait for any EL to be
   * resolved and the refresh method will be called once all the data is available.
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} args the change arguments
   */
  adf.mf.api.amx.markNodeForUpdate = function(args)
  {
    // See if the function was called with the deprecated API
    if (!(args instanceof adf.mf.internal.amx.AmxNodeUpdateArguments))
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.amx.markNodeForUpdate", "MSG_DEPRECATED",
        "Passing nodes and objects as arguments",
        "Pass one adf.mf.api.amx.AmxNodeUpdateArguments object");

      // Use a temporary variable until we are done reading from arguments
      var convertedArgs = new adf.mf.internal.amx.AmxNodeUpdateArguments();

      for (var arg = 0, argc = arguments.length; arg < argc; arg += 2)
      {
        amxNode = arguments[arg];
        affectedAttributes = arguments[arg + 1];

        for (var attrName in affectedAttributes)
        {
          convertedArgs.setAffectedAttribute(amxNode, attrName);
        }
      }

      // Now update the args variable
      args = convertedArgs;
    }

    adf.mf.internal.amx._queueCriticalSectionFunction(
      adf.mf.internal.amx._markNodeForUpdateImpl,
      this,
      true,
      args);
  };

  adf.mf.internal.amx._markNodeForUpdateImpl = function(
    args)
  {
    // Check if the update has been canceled since it was queued
    if (args.isCanceled())
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._markNodeForUpdateImpl", "Canceled",
          "The node update has been canceled");
      }

      return;
    }

    // Begin tracking EL cache misses in a batch (only if not in the mock data environment)
    if (!adf.mf.environment.profile.mockData)
    {
      adf.mf.el.startGetValueBatchRequest();
    }

    var perfOp = adf.mf.internal.perf.startMonitorOperation("Mark node for update", adf.mf.log.level.FINE,
      "adf.mf.api.amx.markNodeForUpdate");

    var rootNode = adf.mf.api.amx.getPageRootNode();
    try
    {
      // First, ensure the nodes are sorted
      var amxNodes = args.getAffectedNodes();
      if (amxNodes.length > 1)
      {
        adf.mf.api.amx.AmxNode.__sortNodesByDepth(amxNodes);
      }

      // Make a first pass at the nodes. In this pass we are only applying attribute
      // changes and initializing the AMX node hierarchy, no rendering should be done
      // at this point.
      var changeResults = applyUpdatesToAmxNodeHierarchy(rootNode, args);

      // See if any nodes are marked to be re-created
      if (changeResults.getAmxNodesToRecreate().length > 0)
      {
        // Make a second pass to recreate any AMX nodes marked for recreation by
        // the type handler
        recreateRequestedAmxNodes(rootNode, changeResults);

        amxNodes = changeResults.getAffectedNodes();
        // Ensure the nodes are still in the correct hierarchical order
        if (amxNodes.length > 1)
        {
          adf.mf.api.amx.AmxNode.__sortNodesByDepth(amxNodes);
        }
      }

      // Now process any ancestor nodes that are re-rendered to handle changes
      // to descendent AMX nodes
      processDescendentChanges(
        rootNode,
        changeResults);

      var pageBuildPromiseResolve = adf.mf.internal.amx._pageBuildPromiseResolve;

      if (pageBuildPromiseResolve == null)
      {
        // Only perform re-rendering if the page has been rendered
        applyRenderChanges(
          rootNode,
          changeResults);
      }
      // If the page has not yet been rendered and nodes were affected, then go ahead and resolve
      // the page build promise so the render may take place once the update has completed
      else if (changeResults.hasChanges())
      {
        adf.mf.internal.amx._pageBuildPromiseResolve = null;
        pageBuildPromiseResolve(rootNode);
      }
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }
    finally
    {
      try
      {
        // Flush the batch so that any missed EL are sent for loading
        if (!adf.mf.environment.profile.mockData)
        {
          adf.mf.el.flushGetValueBatchRequest();
        }
      }
      catch(e)
      {
        adf.mf.internal.amx.errorHandlerImpl(null, e);
      }

      perfOp.stop();

      adf.mf.internal.amx._pageBusyTracker.checkComplete();
    }
  };

  var amxPageRootNode = null;
  adf.mf.internal.amx._buildVisitCallback = function (
    visitContext,
    node)
  {
    var state = node.getState();
    var contextData = visitContext.data;
    if (contextData != null)
    {
      var targetAmxNode = contextData["targetNode"];
      if (targetAmxNode != node)
      {
        // Now see if the node being visited is actually a descendant that
        // will be visited later by another change.
        var affectedAmxNodes = contextData["affectedAmxNodes"];
        if (affectedAmxNodes.indexOf(node) >= 0)
        {
          // No need to visit this node now
          return adf.mf.api.amx.VisitResult["REJECT"];
        }
      }
    }

    if (state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
    {
      // If the node is unrendered, nothing more needs to be done
      return adf.mf.api.amx.VisitResult["REJECT"];
    }

    if (state != adf.mf.api.amx.AmxNodeStates["INITIAL"])
    {
      // Only initialize nodes in the initial state. All other states
      // are updated by the data change framework
      return adf.mf.api.amx.VisitResult["ACCEPT"];
    }

    // Initialize the node. This will populate the attributes,
    // both static and EL driven and also create the children
    node.init();

    // Check to see the new state of the node
    switch (node.getState())
    {
      case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
        // Store on the context that a cache miss occurred:
        visitContext._allNodesReadyToRender = false;

        // Do not process the children of a node in the initial state:
        return adf.mf.api.amx.VisitResult["REJECT"];

      case adf.mf.api.amx.AmxNodeStates["UNRENDERED"]:
        // Do not process the children of unrendered nodes:
        return adf.mf.api.amx.VisitResult["REJECT"];

      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
        // Store on the context that a cache miss occurred:
        visitContext._allNodesReadyToRender = false;

        // Process the children (type handlers must set the node's state
        // to initial to stop children creation and processing):
        return adf.mf.api.amx.VisitResult["ACCEPT"];

      default:
        return adf.mf.api.amx.VisitResult["ACCEPT"];
    }
  };

  adf.mf.internal.amx._pageBuildPromiseResolve = null;
  /**
   * Builds the AMX node hierarchy.
   *
   * @private
   * @param {string} amxPageName the name of the page that is being loaded.
   * @param {adf.mf.api.amx.AmxTag} rootTag the root AMX tag of the page
   * @return {Object} promise object resolved with the root AMX node once the page
   *         is ready to render.
   */
  function buildAmxNodeTree(
    amxPageName,
    rootTag)
  {
    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    var visitContext = null;

    var perf = adf.mf.internal.perf.startMonitorCall("Build AMX node tree", adf.mf.log.level.FINER, "adf.mf.internal.amx:buildAmxNodeTree");
    try
    {
          // Store off the promise object so that we can use it during the first data
      // change event
          adf.mf.internal.amx._pageBuildPromiseResolve = resolve;

      visitContext = new adf.mf.api.amx.VisitContext();
      visitContext._allNodesReadyToRender = true;

      if (amxPageName == null)
      {
        var viewHistory = adf.mf.internal.controller.ViewHistory.peek();
        amxPageName = viewHistory["amxPage"];
      }

      if (rootTag == null)
      {
        rootTag = amxPages[amxPageName];
      }

      amxPageRootNode = rootTag.buildAmxNode(null, null);

      if (!adf.mf.environment.profile.mockData)
      {
        adf.mf.el.startGetValueBatchRequest(); // prevent chatty getValue calls

        // we want to make sure we always are updated with the current values for
        // availableHeight and availableWidth, so we attempt to retrieve the values
        // here and then we can just call getLocalValue in any place afterwards
        adf.mf.internal.amx.evaluateExpression("#{deviceScope.hardware.screen.availableHeight}");
        adf.mf.internal.amx.evaluateExpression("#{deviceScope.hardware.screen.availableWidth}");
      }
      amxPageRootNode.visit(
        visitContext,
        adf.mf.internal.amx._buildVisitCallback);
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }
    finally
    {
      perf.stop();
    }

    try
    {
      if (!adf.mf.environment.profile.mockData)
      {
        adf.mf.el.flushGetValueBatchRequest(); // done preventing chatty getValue calls
      }
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }

    if (visitContext._allNodesReadyToRender)
    {
      // If there were no cache misses, then do not wait for a data change event
      // and render immediately
          adf.mf.internal.amx._pageBuildPromiseResolve = null;
          resolve(amxPageRootNode);
    }

        // Do not resolve the promise if the node tree has not yet been rendered.
    // We will wait for the first data change event that delivers the first batch
    // of EL values to the cache to render the page.
      },
      true /* needed for jQuery-like callbacks without timeouts */);

    return promise;
  }

  function debugPrintAmxTagTree(tag, prefix)
  {
    if (prefix == null)
    {
      prefix = "";
    }

    var str = prefix + "<" + tag._prefixedName;
    var attr = tag.getAttributes();
    for (var name in attr)
    {
      str += " " + name + "=\"" + attr[name] + "\"";
    }

    var children = tag.getChildren();
    if (children.length == 0)
    {
      str += "/>";
      console.log(str);
      return;
    }

    str += ">";
    console.log(str);
    for (var i = 0, size = children.length; i < size; ++i)
    {
      var childTag = children[i];
      debugPrintAmxTagTree(childTag, prefix + "  ");
    }

    console.log(prefix + "</" + tag._prefixedName + ">");
  }

  function debugPrintAmxNodeTree(rootNode)
  {
    rootNode.visit(
      new adf.mf.api.amx.VisitContext(),
      function(
        visitContext,
        node)
      {
        var prefix = "";
        for (var p = node.getParent(); p != null; p = p.getParent())
        {
          prefix += "  ";
        }
        var str = "AmxNode(" + node.getId() +"): ";
        var attrNames = node.getDefinedAttributeNames();
        for (var i in attrNames)
        {
          str += (attrNames[i] + ":" + node.getAttribute(attrNames[i])) + " ";
        }
        console.log(prefix + str);

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  // --------- Rendering Logic --------- //
  /**
   * Singleton object for maintaining a stack of prefixes for IDs on HTML elements inside of
   * iterating AMX nodes.
   */
  var iterationIdStack =
  {
    _prefix: "",
    _lengthStack: [],
    // Valid ID characters are everything that NMTOKEN allows from XML minus ":" since we are using
    // colons as separators. See http://www.w3.org/TR/2000/WD-xml-2e-20000814#NT-Nmtoken
    // For now just check a sub-set of NMTOKEN as the list is quite lengthy of allowed unicode
    // characters.
    _invalidCharsRe: /[^\w\.\-]/g,

    /**
     * Get the current prefix.
     * @return {String} a non-null string to use as a prefix for node IDs
     */
    getCurrentPrefix: function()
    {
      return this._prefix;
    },

    /**
     * Push an iterator prefix onto the stack.
     * @param {string} baseId the ID of the iterating AMX node to use as the base of the ID prefix
     *                 for the iterator's children nodes.
     * @param {Object} iterationKey the object to convert to a string to uniquely identify items
     *                 in the iterator.
     */
    pushIterator: function(baseId, iterationKey)
    {
      // Save off the old prefix length so that we know the length to truncate to during the
      // pop call.
      var oldLength = this._prefix.length;
      this._lengthStack.push(oldLength);

      // Create the new prefix
      var newPrefix = baseId + ":" + this._escapeIterationKey(iterationKey);

      this._prefix += newPrefix + ":";
    },

    /**
     * Pop the prefix back to the value before the current iteration.
     */
    popIterator: function()
    {
      var newLength = this._lengthStack.pop();
      if (newLength > 0)
      {
        this._prefix = this._prefix.substr(0, newLength);
      }
      else
      {
        this._prefix = "";
      }
    },

    /**
     * Escape an iteration key for usage in an HTML ID attribute.
     * @param {Object} iterationKey the key for the current iteration
     * @return {string} an ID-safe string that may be used to identify the current iteration
     * @private
     */
    _escapeIterationKey: function(iterationKey)
    {
      // Note that we may want to consider using an ID token cache to improve memory usage
      // so that smaller strings are used. The disadvantage is that the token generation would
      // have to be repeatable so that the node state would be correctly re-applied. For now,
      // we just wish to ensure there are no invalid characters
      if (iterationKey == null)
      {
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "_escapeIterationKey",
          "MSG_INVALID_ITERATION_KEY");

        // Only log the details at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "iterationIdStack", "_escapeIterationKey", iterationKey);

        return "null";
      }
      var strVal = iterationKey.toString();
      // Replace any non-ID friendly values with a sequence of characters unlikely to appear in the
      // value. This assumes that most characters
      // of the iterationKey will be valid and therefore produce a unique key. Using a token
      // cache would address this if this assumption becomes an issue.
      return strVal.replace(this._invalidCharsRe, "._.");
    },

    /**
     * Determine if there is an iteration container.  Searches the prefix for ":" and returns true
     * if the character is found.
     * @return {Boolean} true if an iteration container has been set; false otherwise.
     */
    hasTopIterationContainer: function()
    {
      if (this._prefix.indexOf(":") > -1)
      {
        return true;
      }
      return false;
    },

    /**
     * Returns ID of top-most iteration container.  Finds first occurence of ":" in prefix and returns
     * substring leading up to it.
     * @return {String} ID of top-most iteration container
     */
    getTopIterationContainer: function()
    {
      if (this._prefix.indexOf(":") > -1)
      {
        return this._prefix.substr(0,this._prefix.indexOf(":"));
      }
      return "";
    }
  };

  // ------ resource loading ------ //
  var resourcesData = null;
  // Load the resources.json file that contains the mapping of the resources
  // needed for AMX nodes:
  var resourcesDataPromise = new adf.mf.internal.BasePromise(function(resolve, reject)
    {
      adf.mf.api.resourceFile.loadJsonFile(
        adf.wwwPath + "js/amx-resources.json",
        true,
        function(data)
        {
          resourcesData = data;
          resolve();
        },
        function()
        {
          // TODO this needs to be promoted to a formal error; do not use amx.log
          amx.log.error("Unable to load the resources JSON file.");
          reject();
        });
    });

  /**
   * Internal function for loading the JS files from the profile in series.
   * @param {Array.<string>} listOfFiles the list of files to load
   * @return {adf.mf.internal.BasePromise} a promise that will resolve when all Files are loaded
   */
  var loadFilesSequentialPromise = function(listOfFiles)
  {
    var promise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        // Load the JS resources serially since the order is required due to dependencies:
        if (listOfFiles == null)
        {
          resolve(); // no JS files to load
        }
        else // load all of the files
        {
          _resourceLoadNextResource(resolve, listOfFiles, 0, listOfFiles.length);
        }
      });
    return promise;
  };

  var _resourceLoadNextResource = function(entrireListLoadedResolve, listOfFiles, listIndex, fileCount)
  {
    if (listIndex == fileCount)
    {
      // All jsResource files have been loaded
      entrireListLoadedResolve();
    }
    else // load the next file in the list
    {
      var theResource = listOfFiles[listIndex];
      var nextIndex = listIndex+1;
      var loadState = loadedJavaScriptResources[theResource];
      if (loadState == null) // possibilities are null, a promise, or true
      {
        // No attempt has been made yet to load this file:
        var loadedArrayResolve = null;
        var loadedArrayReject = null;
        loadedJavaScriptResources[theResource] =
          new adf.mf.internal.BasePromise(function(resolve, reject)
            {
              loadedArrayResolve = resolve;
              loadedArrayReject = reject;
            });
        adf.mf.api.resourceFile.loadJsFile(
          theResource,
          true,
          function()
          {
            loadedArrayResolve(theResource);
            loadedJavaScriptResources[theResource] = true;
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          },
          function(failure)
          {
            loadedArrayReject(failure);
            loadedJavaScriptResources[theResource] = true;
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          },
          null);
      }
      else if (loadState == true)
      {
        // This file was already loaded so move onto the next file
        _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
      }
      else
      {
        // Someone has already made a request for it so we need to wait on its promise
        // before we move onto the next file:
        loadState.then(
          function()
          {
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          });
      }
    }
  };

  /**
   * Called from findResourcesForTag to find all the resources for a given namespace object and tag name.
   * @param {Object} nsObj resources object for a namespace from the JSON object.
   * @param {string} tagName the local AMX node name or "*" for resources global to the namespace.
   * @param {Array.<string>} fileList Array where a list of files to load will be added
   */
  function findTagNsResources(nsObj, tagName, fileList)
  {
    var tagObj = nsObj[tagName];
    if (tagObj == null)
    {
      return;
    }
    var js = tagObj["js"];
    var index, size;
    if (js != null)
    {
      // Load any required javascript files:
      if (Array.isArray(js))
      {
        for (index = 0, size = js.length; index < size; ++index)
        {
          var theResource = js[index];
          if (loadedJavaScriptResources[theResource] !== true && // if undefined or a promise, then push
            fileList.indexOf(theResource) == -1) // prevent repeats
          {
            fileList.push(theResource);
          }
        }
      }
      else
      {
        if (loadedJavaScriptResources[js] !== true) // if undefined or a promise, then push
        {
          if (fileList.indexOf(js) == -1) // prevent repeats
            fileList.push(js);
        }
      }
    }
  }

  /**
   * Function to load any JavaScript or CSS file dependencies for an AMX tag.
   * @param {adf.mf.api.amx.AmxTag} tag the AMX tag.
   * @param {Array.<string>} fileList of resource to be loaded to allow the calling function to
   *                determine when all the resources have been loaded.
   */
  function findResourcesForTag(tag, fileList)
  {
    // The first level of objects are keyed by the namespace URI of the XML node:
    var ns = tag.getNamespace();
    var nsObj = resourcesData[ns];
    if (nsObj != null)
    {
      // Load any resources for all tags in this namespace:
      findTagNsResources(nsObj, "*", fileList);

      // Second level are keyed by the tag's local name:
      findTagNsResources(nsObj, tag.getName(), fileList);
    }

    // Process all the children tags
    var children = tag.getChildren();
    for (var index = 0, size = children.length; index < size; ++index)
    {
      var childTag = children[index];
      findResourcesForTag(childTag, fileList);
    }
  }
  // ------ /resource loading ------ //

  // ------ API for TypeHandlers ------ //

  /**
   * @deprecated
   */
  amx.registerRenderers = function(theNamespace, typeHandlerMap)
  {
    var typeHandlerDetail = "";
    adf.mf.internal.amx._each(typeHandlerMap, function(key, value)
    {
      if (typeHandlerDetail != "")
        typeHandlerDetail += ", ";
      typeHandlerDetail += key;
    });

    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "amx.registerRenderers", "MSG_AMX_REGISTER_DEPRECATED",
      typeHandlerDetail, theNamespace);

    if (theNamespace == "amx")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "amx.registerTypeHandlers", "MSG_NS_DEPRECATED",
        "amx", adf.mf.api.amx.AmxTag.NAMESPACE_AMX, typeHandlerMap);
      theNamespace = adf.mf.api.amx.AmxTag.NAMESPACE_AMX;
    }
    else if (theNamespace == "dvtm")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "registerTypeHandlers", "MSG_NS_DEPRECATED",
        "dvtm", adf.mf.api.amx.AmxTag.NAMESPACE_DVTM, typeHandlerMap);
      theNamespace = adf.mf.api.amx.AmxTag.NAMESPACE_DVTM;
    }

    adf.mf.internal.amx._each(typeHandlerMap, function(tagName, deprecatedTypeHandlerObject)
    {
      // If it is a function, then, it is actually the "render" of the NodeTypeHandler
        if (deprecatedTypeHandlerObject && (typeof deprecatedTypeHandlerObject === "function"))
      {
        deprecatedTypeHandlerObject =
        {
          render: deprecatedTypeHandlerObject
        };
      }

      // Convert the old style TypeHandler objects into classes needed for the new API:
      var typeHandlerClass = adf.mf.api.amx.TypeHandler.register(theNamespace, tagName);
        adf.mf.internal.amx._each(deprecatedTypeHandlerObject,
        function(functionName, functionImplementation)
      {
        typeHandlerClass.prototype[functionName] = functionImplementation;
      });
    });
  };

  /**
   * Notify the framework that an iteration node is being processed. Should be called by iterating
   * renderers for each stamp.
   * @param {string} amxNodeId the ID of the iterating AMX node to use as the base of the ID prefix
   *                 for the iterator's children nodes.
   * @param {Object} iterationKey the object to convert to a string to uniquely identify items
   *                 in the iterator.
   */
  amx.beginIterationContainer = function(amxNodeId, iterationKey)
  {
    iterationIdStack.pushIterator(amxNodeId, iterationKey);
  };

  /**
   * Notify the framework that an iteration node has finished being processed. Should be called by
   * iterating renderers after each stamp. Must correspond to a call to beginIterationContainer.
   */
  amx.endIterationContainer = function()
  {
    iterationIdStack.popIterator();
  };

  /**
   * @deprecated
   */
  amx.renderSubNodes = function(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderSubNodes", "MSG_DEPRECATED", "amx.renderSubNodes", "amxNode.renderDescendants");
    return adf.mf.api.amx.renderSubNodes.apply(this, arguments);
  };

  /**
   * @deprecated
   */
  adf.mf.api.amx.renderSubNodes = function(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderSubNodes", "MSG_DEPRECATED", "adf.mf.api.amx.renderSubNodes",
      "amxNode.renderDescendants");

    return amxNode.renderSubNodes();
  };

  /**
   * @deprecated
   */
  amx.isUITag = function(nsPrefixedTagName)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "isUITag", "MSG_DEPRECATED", "amx.isUITag", "AmxTag.isUITag");

    return adf.mf.internal.amx.AmxTagHandler.__hasHandler(nsPrefixedTagName) == false;
  };

  /**
   * @deprecated
   */
  amx.renderNode = function(node)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "renderNode",
      "MSG_DEPRECATED", "amx.renderNode", "amxNode.render");
    return adf.mf.api.amx.renderNode.apply(this, arguments);
  };

  /**
   * Render a amxNode or the xmlNode. If it is an xmlNode, then, it will be processed before rendering it.
   * @param {(xmlNode|adf.mf.api.amx.AmxNode)} node The node for a given element. Can be the process AMXNode or the XMLNode.
   * @return the rendered DOM node or null if nothing rendered
   */
  adf.mf.api.amx.renderNode = function(node)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "renderNode", "MSG_DEPRECATED", "adf.mf.api.amx.renderNode",
      "amxNode.render");
    return node.renderNode();
  };

  // --------- Critical section --------- //
  /**
   * Singleton class to handle the critical section of updating the AMX node hierarchy
   * @private
   */
  var criticalSection =
  {
    _queue: [],
    _blockedCount: 0,
    _timeout: null,
    _running: false,

    /**
     * Queues a method to be run in the critical section
     * @private
     */
    queue: function(method)
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.queue",
          "Queuing method");
      }

      this._queue.push(method);

      if (this._queue.length == 1 && this._blockedCount == 0 && this._running == false)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.queue",
            "Running method now. Queue length is " + this._queue.length);
        }

        // If this is the only method and we are not blocked, run it synchronously
        this.run();
      }
      else
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.queue",
            "Scheduling execution for later. Queue length is " + this._queue.length);
        }

        // Run the method later
        this._scheduleTimeout();
      }
    },

    /**
     * Prevent any more methods from running until the resume has been called. The resume must
     * be called one time for every call to pause.
     * @private
     */
    pause: function()
    {
      ++this._blockedCount;

      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.pause",
          "Blocked count: " + this._blockedCount);
      }
    },

    /**
     * Resume after having been paused
     * @private
     */
    resume: function()
    {
      this._blockedCount = Math.max(0, this._blockedCount - 1);

      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.resume",
          "Blocked count: " + this._blockedCount);
      }

      this._scheduleTimeout();
    },

    /**
     * Runs the next function in critical section
     * @private
     */
    run: function()
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.run",
          "Run invoked");
      }

      this._timeout = null;

      // Ensure that we are ready to run
      if (this._running || this._blockedCount > 0 || this._queue.length == 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.run",
            (this._running ? "Run called when a method is already running" :
              (this._blockedCount ?
                ("Block count preventing run. Count: " + this._blockedCount) :
                "The queue is empty"
              )
            ));
        }

        return;
      }

      this._running = true;

      var method = this._queue.shift();

      // Some of the methods that are queued are dependent on the current view. If the navigation ID has changed, then
      // do not run the method and check the next queued method.
      while (method != null)
      {
        var navigationId = method["navigationId"];

        if (navigationId >= 0 && navigationId != adf.mf.internal.amx._navigationId)
        {
          // Do not process any methods that were queued for an old page. Go to the next
          // item in the queue. Note that shift returns undefined if the array is empty
          method = this._queue.shift();
        }
        else
        {
          break;
        }
      }

      if (method == null)
      {
        // No more queued methods to run
        return;
      }

      var methodFinished = false;

      try
      {
        var fn = method["func"];
        var params = method["params"];
        var thisObj = method["thisObj"];

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.run",
            "Before critical method invocation. Queue length is now " + this._queue.length);
        }

        var result = fn.apply(thisObj, params);

        // The function is allowed to return a promise object if the task is asynchronous
        // and we need to block until it is fully finished
        if (result != null && typeof(result["then"]) == "function")
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "criticalSection.run",
              "Promise object was returned, will wait for resolution");
          }

          var callback = adf.mf.internal.getProxyFunction(this, this._promiseCallback);

          result.then(callback, callback);
        }
        else
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "criticalSection.run",
              "Method finished without a Promise object");
          }
          methodFinished = true;
        }
      }
      catch (e)
      {
        // If there was an exception, a promise object was not returned
        methodFinished = true;

        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "criticalSection.run",
          "MSG_CRITICAL_SECTION_FUNCTION_EXCEPTION");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "criticalSection", "run", e);
      }
      finally
      {
        if (methodFinished)
        {
          this._running = false;
          this._scheduleTimeout();
        }
      }
    },

    /**
     * Callback when a method has returned a promise object
     * @private
     */
    _promiseCallback: function()
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._promiseCallback",
          "_promiseCallback called");
      }

      this._running = false;
      this._scheduleTimeout();
    },

    /**
     * Schedules the run method to be called when not busy
     * @private
     */
    _scheduleTimeout: function()
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
          "_scheduleTimeout called");
      }

      // Ensure the critical section is ready before scheduling a callback and ensure that a
      // callback has not already been set
      if (this._running == false && this._timeout == null && this._blockedCount == 0 &&
        this._queue.length > 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
            "Scheduling a timeout");
        }

        this._timeout = window.setTimeout(adf.mf.internal.getProxyFunction(this, this.run), 1);
      }
      else if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
          (this._running ? "A method is already running" :
            (this._timeout != null ? "Timeout was already scheduled" :
              (this._blockedCount != 0 ?
                ("Critical section is blocked. Count: " + this._blockedCount) :
                "Queue is empty"
              )
            )
          ));
      }
    }
  };

  /**
   * Allows code that needs to use the critical section to queue a callback
   * when the critical section is free. This functionality is akin to the Java synchronized
   * block.
   * @param {function} func the function to invoke. It may return a promise object which
   *        will block the critical section until resolved (or fails)
   * @param {Object} thisObject the object to use as "this" when invoking the function.
   * @param {boolean} tiedToCurrentViewId if this is true, then the function will not be run
   *        if a navigation is currently executing that will result in a new view
   * @param {...Object} var_args parameters to pass to the function.
   * @private
   */
  adf.mf.internal.amx._queueCriticalSectionFunction = function(
    func,
    thisObject,
    tiedToCurrentViewId
    /* ... arguments */)
  {
    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx", "_queueCriticalSectionFunction",
        "Critical section function being queued");
    }

    var params = Array.prototype.slice.call(arguments, 3);

    var navigationId = tiedToCurrentViewId === true ? adf.mf.internal.amx._navigationId : -1;

    criticalSection.queue(
      {
        "func": func,
        "thisObj": (thisObject || window),
        "params": params,
        "navigationId": navigationId
      });
  };

  /**
   * Internal function for usage by type handlers to be able to pause changes to the UI.
   * Typical use case is to prevent updates to the AMX hierarchy and DOM nodes during
   * an animation. This prevents the DOM from being replaced while another task, like animation
   * is under way.
   */
  adf.mf.internal.amx.pauseUIChanges = function()
  {
    criticalSection.pause();
  };

  /**
   * Internal function for usage by type handlers to be able to resume changes to the UI.
   * See adf.mf.internal.amx.pauseUIChanges.
   */
  adf.mf.internal.amx.resumeUIChanges = function()
  {
    criticalSection.resume();
  };

  /**
   * Internal function for usage by the isLoading() API to be able to tell if
   * something is pausing UI changes.
   * See adf.mf.internal.amx.pauseUIChanges.
   */
  adf.mf.internal.amx.isUIChangePaused = function()
  {
    return criticalSection._running || criticalSection._blockedCount != 0;
  };
  // --------- /Critical section --------- //

  // --------- Data Change Logic --------- //
  var queuedBatchDataChanges = [];
  var queuedCollectionModelChanges = {};

  // Used to prevent bulk loads and queued critical section functions from being processed across navigation boundaries.
  adf.mf.internal.amx._navigationId = 0;
  adf.mf.internal.amx._navigationInProgress = false;

  /**
   * Process the data change queue once the critical section is available.
   * Method is only to be called from the critical section
   * @private
   */
  function processBatchDataChangeQueue()
  {
    // Ensure that there are queued changes
    if (queuedBatchDataChanges.length == 0)
    {
      return;
    }

    var q = queuedBatchDataChanges;
    var cmc = queuedCollectionModelChanges;

    queuedBatchDataChanges = [];
    queuedCollectionModelChanges = {};

    // Process the changes
    handleDataChangeImpl(q, cmc);
  }

  /**
   * Function called from the navigation listener to throw out any queued data changes when
   * a navigation has taken place.
   */
  function clearDataChangeQueue()
  {
    queuedBatchDataChanges = [];
    queuedCollectionModelChanges = {};
  }

  /**
   * Queue batch data changes and schedule the callback to the processBatchDataChangeQueue.
   * @param {Array.<string>} dependencyArray the array of EL to queue.
   * @param {Object} collectionModelChanges collection model changes
   */
  function queueBatchDataChange(dependencyArray, collectionModelChanges)
  {
    var initialLength = queuedBatchDataChanges.length;

    for (var i = 0, size = dependencyArray.length; i < size; ++i)
    {
      var el = dependencyArray[i];
      // Ensure the EL is only added once
      if (queuedBatchDataChanges.indexOf(el) < 0)
      {
        queuedBatchDataChanges.push(el);
      }

      if (collectionModelChanges != null)
      {
        var collectionChanges = collectionModelChanges[el];
        if (collectionChanges != null)
        {
          var currentCollectionModelChanges = queuedCollectionModelChanges[el];
          if (currentCollectionModelChanges != null)
          {
            // If a value is already present, we cannot merge the changes, so ensure that
            // itemized is false.
            queuedCollectionModelChanges[el] = { "itemized": false };
          }
          else
          {
            queuedCollectionModelChanges[el] = collectionChanges;
          }
        }
      }
    }

    // If the queue was empty, queue the callback to the process function
    // to handle the queued changes once the critical section is available
    if (initialLength == 0)
    {
      adf.mf.internal.amx._queueCriticalSectionFunction(
        processBatchDataChangeQueue,
        this,
        false);
    }
  }

  /**
   * Listener for the controller navigation events
   */
  function navigationListener(event)
  {
    if (event.isNavigationStart())
    {
      adf.mf.internal.amx._navigationInProgress = true;

      // Stop any critical section functions from running while a navigation is being processed
      adf.mf.internal.amx.pauseUIChanges();
    }
    else if (event.isNavigationEnd())
    {
      var navResult = event.getNavigationResult();

      if (navResult.isDifferentViewId())
      {
        var navigationId = adf.mf.internal.amx._navigationId;

        // Increment the navigationId
        adf.mf.internal.amx._navigationId = navigationId > 1000000 ? 0 : navigationId + 1;

        // Remove any queued data changes for the old view
        clearDataChangeQueue();
      }

      adf.mf.internal.amx._navigationInProgress = false;

      // Resume the critical section queue
      adf.mf.internal.amx.resumeUIChanges();
    }
  }

  // The 'adfc' window object is loaded after amx-core, so delay the addition if the listener until
  // after the page finishes loading
  document.addEventListener("showpagecomplete",
    function ()
    {
      adfc.NavigationHandler.addNavigationListener(navigationListener);
    }, false);

  // On Android 4.0.x releases, we have noticed that the UI will not always repaint after the DOM
  // has been changed in a data change listener. As a result, we need to check the user agent
  // to see if this is an Android 4.0 device.
  var requiresUiInValidation = false;
  if (adf.mf.internal.amx.agent["type"] == "Android")
  {
    // Example user agent string we want to match:
    // Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30
    var ua = navigator.userAgent;
    if (/Android 4\.0(\.\d+)?;/.test(ua))
    {
      requiresUiInValidation = true;
    }
  }

  /**
   * Callback used to handle batch data changes.
   * @param {Array} dependencyArray an Array of EL expression dependency strings that have changed
   *        (not full expressions)
   * @see adf.mf.api.addBatchDataChangeListener
   * @private
   */
  adf.mf.internal.amx._handleBatchDataChangeListener = function(
    dependencyArray,
    collectionModelChanges)
  {
    if (dependencyArray != null)
    {
      // If there is no root node, then we are getting a data change during navigation, or during
      // the building of the tree. Since we have not yet built the node hierarchy, we do not need
      // to process the change at this time.
      var rootAmxNode = adf.mf.api.amx.getPageRootNode();
      if (rootAmxNode == null)
      {
        return;
      }

      // Queue the work onto a critical section function
      queueBatchDataChange(dependencyArray, collectionModelChanges);
    }
  }

  /**
   * Process the work of _handleBatchDataChangeListener. This is called from
   * processBatchDataChangeQueue which is run from the critical section.
   * This method should never be called directly, but always from a critical section
   */
  function handleDataChangeImpl(dependencyArray, collectionModelChanges)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Process data change event", adf.mf.log.level.FINE,
      "adf.mf.internal.amx._handleBatchDataChangeListener");

    var affectedNodeCount = 0;
    try
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "_handleBatchDataChangeListener",
          adf.mf.util.stringify(dependencyArray));
      }

      var markNodeForUpdateArgs = new adf.mf.internal.amx.AmxNodeUpdateArguments();
      var hasCollectionModelChanges = collectionModelChanges != null;
      var collectionChangesElMap = null;

      if (hasCollectionModelChanges)
      {
        collectionChangesElMap = {};
        for (var el in collectionModelChanges)
        {
          var data = collectionModelChanges[el];
          collectionChangesElMap[el] = new adf.mf.api.amx.AmxCollectionChange(data);
        }
      }

      for (var i = 0, size = dependencyArray.length; i < size; ++i)
      {
        var el = dependencyArray[i];
        var valueExpr = adf.mf.internal.el.parser.parse("#{" + el + "}");

        var nodes = adf.mf.api.amx.AmxNode.__getNodesDependentOnElToken(valueExpr);
        for (var n = 0, nodeSize = nodes.length; n < nodeSize; ++n)
        {
          var node = nodes[n];
          var nodeId = node.getId();

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "_handleBatchDataChangeListener",
              "Node affected by change to EL #{" + el + "}: "+ nodeId);
          }

          var attrNames = node.__getAttributesForElDependency(valueExpr);
          for (var a = 0, asize = attrNames.length; a < asize; ++a)
          {
            var attrName = attrNames[a];
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "_handleBatchDataChangeListener",
                "Affected attribute: " + attrName);
            }

            markNodeForUpdateArgs.setAffectedAttribute(node, attrName);

            if (hasCollectionModelChanges)
            {
              var collectionChange = collectionChangesElMap[el];
              if (collectionChange != null)
              {
                markNodeForUpdateArgs.setCollectionChanges(nodeId, attrName, collectionChange);
              }
            }
          }

          node.__processTagInstancesForElDependency(markNodeForUpdateArgs, valueExpr);
        }
      }

      affectedNodeCount = markNodeForUpdateArgs.getAffectedNodes().length;
      if (affectedNodeCount > 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "_handleBatchDataChangeListener",
            affectedNodeCount + " nodes have been affected by the data changes");
        }

        // Call the internal mark node for update function which does not check for being in
        // the critical section since we are already in the critical section
        adf.mf.internal.amx._markNodeForUpdateImpl(markNodeForUpdateArgs);

        // On Android, there is a bug in the web view that changes from the data change events may
        // not be redrawn. So, invoke a callback to invalidate the WebView, forcing the repainting of
        // the WebView. Bug seen in at least the 4.0.3 Android version of the WebView
        if (requiresUiInValidation && window["AdfmfCallback"] != null)
        {
          window.AdfmfCallback.invalidateUi();
        }
      }
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "handleDataChangeImpl", "MSG_BATCH_DATA_CHANGE_FAILED");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "AMX", "handleDataChangeImpl", ex);
    }
    finally
    {
      perfOp.stop();
    }
  };

  amx.clearBindings = function()
  {
    adf.mf.api.amx.AmxNode.__clearBindings();
  };

  // Helper method
  // return boolean
  amx.containsELExpressions = function(elString)
  {
		if (!elString)
			return false;
		if (elString.getExpression)
			return true;
		return amx.getElsFromString(elString).length > 0;
  };

  // Helper method
  // return an array
  amx.getElsFromString = function(elString)
  {
    var result = [];

    if (elString != null)
    {
      var regEx = /[#,$]{.*?}/g;
      var m = regEx.exec(elString);
      while (m != null)
      {
        if (result.indexOf(m[0]) < 0)
        {
          result.push(m[0]);
        }
        m = regEx.exec(elString);
      }
    }

    return result;
  };
  // --------- /Data Change Logic --------- //

  /**
   * An event triggering an outcome-based navigation.
   * See also the Java API oracle.adfmf.amx.event.ActionEvent.
   * @constructor
   */
  adf.mf.api.amx.ActionEvent = function()
  {
    this[".type"] = "oracle.adfmf.amx.event.ActionEvent";
  };
  amx.ActionEvent = adf.mf.api.amx.ActionEvent; // deprecated syntax

  /**
   * A DOM event.
   * @param {string} amxNodeId the component ID
   * @param {Object} eventType the type of event
   * @param {Event} originalEvent the original DOM event object
   * @constructor
   */
  adf.mf.api.amx.DomEvent = function(amxNodeId, eventType, originalEvent)
  {
    this[".type"] = "oracle.adfmf.amx.event.DomEvent";
    this.amxNodeId = amxNodeId;
    this.eventType = eventType;
    this.source = originalEvent.target;
    this.currentTarget = originalEvent.currentTarget;
    this.originalEvent = originalEvent;
  };

  /**
   * An event for notifying that a specified row has been moved.
   * It contains the key for the row that was moved along with the key for the row it was inserted before.
   * See also the Java API oracle.adfmf.amx.event.MoveEvent.
   * @param {Object} rowKeyMoved the rowKey that was moved
   * @param {Object} rowKeyInsertedBefore the rowKey that the moved row was inserted before
   * @constructor
   */
  adf.mf.api.amx.MoveEvent = function(rowKeyMoved, rowKeyInsertedBefore)
  {
    this[".type"] = "oracle.adfmf.amx.event.MoveEvent";
    this.rowKeyMoved = rowKeyMoved;
    this.rowKeyInsertedBefore = rowKeyInsertedBefore;
  };
  adf.mf.internal.amx.MoveEvent = adf.mf.api.amx.MoveEvent; // deprecated syntax

  /**
   * An event for changes of selection for a component.
   * See also the Java API oracle.adfmf.amx.event.SelectionEvent.
   * @param {Object} oldRowKey the rowKey that has just been unselected
   * @param {Array<Object>} selectedRowKeys the array of rowKeys that have just been selected.
   * @constructor
   */
  adf.mf.api.amx.SelectionEvent = function(oldRowKey, selectedRowKeys)
  {
    this.oldRowKey = oldRowKey;
    this.selectedRowKeys = selectedRowKeys;
    this[".type"] = "oracle.adfmf.amx.event.SelectionEvent";
  };
  amx.SelectionEvent = adf.mf.api.amx.SelectionEvent; // deprecated syntax

  /**
   * An event for changes of value for a component.
   * See also the Java API oracle.adfmf.amx.event.ValueChangeEvent.
   * @param {Object} oldValue the previous value of the component.
   * @param {Object} newValue the new value of the component.
   * @constructor
   */
  adf.mf.api.amx.ValueChangeEvent = function(oldValue, newValue)
  {
    this.oldValue = oldValue;
    this.newValue = newValue;
    this[".type"] = "oracle.adfmf.amx.event.ValueChangeEvent";
  };
  amx.ValueChangeEvent = adf.mf.api.amx.ValueChangeEvent; // deprecated syntax

  /**
   * An event for range changes for a component (e.g. load more rows in listView).
   * See also the Java API oracle.adfmf.amx.event.RangeChangeEvent.
   * @param {string} eventSourceId the source ID of the event
   * @param {string} contextFreeValue the context-free value expression or null if not available
   * @param {Object} lastLoadedRowKey the row key of the last row loaded before the requested range or null if not available
   * @param {number} fetchSize the size to fetch or null if not available
   * @constructor
   */
  adf.mf.api.amx.RangeChangeEvent = function(
    eventSourceId,
    contextFreeValue,
    lastLoadedRowKey,
    fetchSize)
  {
    this.eventSourceId = eventSourceId;
    this.contextFreeValue = contextFreeValue;
    this.lastLoadedRowKey = lastLoadedRowKey;
    this.fetchSize = fetchSize;
    this[".type"] = "oracle.adfmf.amx.event.RangeChangeEvent";
    // Consider using: this[".type"] = "oracle.adfmf.framework.event.RangeChangeEvent";
  };

  /**
   * Process an AMX Event. Change the value if attributeValueName is defined, process the appropriate
   * setPropertyListener and actionListener sub tags and then process the [amxEventType]Listener attribute.
   * @param {adf.mf.api.amx.AmxNode} amxNode The node to process the event on.
   * @param {string} amxEventType String that represents the event type that triggered the call.
   * @param {string} attributeValueName The name of the attribute whose value will be changed (or undefined if not applicable).
   * @param {string} newValue The new value to be applied to the attribute sent in (or undefined if not applicable).
   * @param {Object} amxEvent The new AmxEvent being queued.
   * @param {Object} finishedCallback The optional function to invoke once the event has been processed.
   * @deprecated
   */
  amx.processAmxEvent = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    finishedCallback)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "processAmxEvent",
      "MSG_DEPRECATED", "amx.processAmxEvent", "amxNode.processAmxEvent");
    return adf.mf.api.amx.processAmxEvent(amxNode, amxEventType,
      attributeValueName, newValue, amxEvent, finishedCallback);
  };

  //adf.mf.internal.amx._useBatchProcessing = false;

  /**
   * Process an AMX Event. Change the value if attributeValueName is defined, process the
   * appropriate setPropertyListener and actionListener sub tags and then process the
   * [amxEventType]Listener attribute. For valueChange events, the attribute must have already
   * been registered on the node as the input value. Use getInputValueAttribute on the type handler
   * of the AMX node to return the attribute name that accepts the input value for which value
   * changes occur.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode The node to process the event on.
   * @param {string} amxEventType String that represents the event type that triggered the call.
   * @param {(string|undefined)} attributeValueName The name of the attribute whose value will be
   *        changed (or undefined if not applicable).
   * @param {(string|undefined)} newValue The new value to be applied to the attribute sent in
   *        (or undefined if not applicable).
   * @param {Object} amxEvent The new AmxEvent being queued.
   * @param {function=} successfulCallback An optional function to invoke once the event has been
   *        successfully processed.
   * @param {function=} failureCallback Optional callback function if the processing of the event
   *        fails
   */
  adf.mf.api.amx.processAmxEvent = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    successfulCallback,
    failureCallback)
  {
    // Show the loading indicator as this could take some time to process.
    adf.mf.api.amx.showLoadingIndicator();

    // Need a wrapper promise incase we are in design time and we will resolve this either in the else
    // or end of phase 4.
    var that = this;
    var promise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        var currPage = amx.getCurrentPageName();
        var nodeId = amxNode.getId();

        adf.mf.internal.amx._pageBusyTracker.startOperation(
          true,
          "Process AMX event",
          adf.mf.log.level.INFO,
          "Time to process event",
          "Page: " + currPage + " event of type " + amxEventType + " on node " + nodeId);

        // No adf.mf.internal.amx._pageBusyTracker.checkComplete will be called from this method. This
        // allows any subsequent data change events to be tracked and included in the current operation

        if (adf.mf.api.amx.getPageRootNode() == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being
          // delivered.
          reject();
        }
        else
        {
          var funcType = adf.mf.internal.amx.processAmxEventImplSerial;

          if (adf.mf.environment.profile.useBatchProcessing && !adf.mf.environment.profile.mockData)
          {
            funcType = adf.mf.internal.amx.processAmxEventImplBatch;
          }

          adf.mf.internal.amx._queueCriticalSectionFunction(
            funcType,
            that,
            true,
            amxNode,
            amxEventType,
            attributeValueName,
            newValue,
            amxEvent,
            {
              "resolve": resolve,
              "reject": reject
            });
        }
      });

    if (successfulCallback != null)
    {
      promise.then(successfulCallback);
    }

    if (failureCallback != null)
    {
      promise["catch"](failureCallback);
    }

    // Hide the loading indicator once the event is fully done and the callbacks have been fired
    promise.then(adf.mf.api.amx.hideLoadingIndicator, adf.mf.api.amx.hideLoadingIndicator);

    return promise;
  };

  // TODO: this method is gross. We need to refactor it to fit into one screen and break out the internals into
  // several functions so that it is readable
  adf.mf.internal.amx.processAmxEventImplBatch = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    promiseArgs)
  {
    // Return a promise object to the critical section
    return new adf.mf.internal.BasePromise(
      function(batchResolve, batchReject)
      {
        // Perform a visit to the node to put it back into context
        // TODO: find a way to get context free EL for listener tags so that we do not need to
        // re-establish context
        var rootNode = adf.mf.api.amx.getPageRootNode();
        if (rootNode == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being
          // delivered.
          promiseArgs["reject"]();
          batchReject();
          return;
        }

        var perf = adf.mf.internal.perf.startMonitorCall("Process AMX batch",
          adf.mf.log.level.FINER, "adf.mf.internal.amx.processAmxEventImplBatch");

        // Check if the deprecated API is in use (passing the AMX node as a jQuery object with the
        // root DOM element)
        if (amxNode != null && amxNode.jquery)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
                "processAmxEventImplBatch", "MSG_AMX_EVENT_JQUERY_DEPRECATED");
          amxNode = amxNode.data("amxNode");
        }

        // We need to use visit pattern to set up the context for this node the event is attached to
        var nodeFound = rootNode.visit(
          new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
          function (visitContext, amxNode)
          {
            // This function is only called when the node has been found and the context setup.
            var validationGroup = null;
            var popupActions = [];

            if (!adf.mf.environment.profile.dtMode)
            {
              // Start the batch request. This is to prevent us from doing all the set property and
              // action event one at a time and instead process all all the children at once we
              // queue up all the EL that needs to be proccessed in order. Once
              // completed the flush will process all the EL in one round trip.
              adf.mf.util.startBatchRequest();

              adf.mf.internal.pushNonBlockingCall();

              // detect if we might need to refresh the validation message area
              if (amxEventType === "valueChange" &&
                attributeValueName === amxNode.__getAttributeToValidate())
              {
                // First find the closest rendered node for validation group purposes
                var domNode = null;
                var renderedAmxNode = amxNode.__getClosestRenderedNode();

                if (renderedAmxNode != null)
                {
                  domNode = document.getElementById(renderedAmxNode.getId());
                }

                // We need to retrieve this here because calling setElValue will cause this domNode
                // to potentially be swapped out with a new one if the control doesn't support the
                // refresh method
                validationGroup = _getClosestWithClass(domNode, "amx-validationGroup");
              }

              // If this is a value change event then we need to convert the new value first before
              // we continue to process.
              var converter = amxNode.getConverter();
              if (converter && amxEventType === "valueChange" && attributeValueName === "value")
              {
                var rawValue = newValue;

                newValue = converter.getAsObject(newValue);

                if (newValue === "" && rawValue !== "")
                {
                  // There was a conversion error, do not process the event
                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                }
              }

              // Phase 1) Set the new value on the attribute. We need to first fetch the current
              //          value of the attribute (this has to be an EL Expression so we assume it is
              //          and let the setELValue figure out where it really needs to go. For our
              //          part we just get the value for this attribute that get returned and assume
              //          it is an EL expression for this attribute. This is  different from the
              //          rich client. First we know what the type (EL Expression or literal) and
              //          set the value immediatly if this is a literal. Once the "value" has been
              //          fetched for this attribute then the assumed EL expression and send off in
              //          another request for to be updated with the new value.

              // Make sure we have an attribute value name we are looking to update.
              if (attributeValueName)
              {
                // TODO: Need to change this into a non-promise call as we are in batch mode here.
                amxNode.setAttribute(attributeValueName, newValue);
              }

              // Phase 2) Process the setPropertyListeners and actionListeners of this node passed
              //          in. Since any component can have other types of components we are going to
              //          be looking for specific component types. We need to create a
              //          childrenPromise to make sure we can wait on this before we go to the next
              //          phase.
              // Get all the child tag instances from the AMX node.
              var tagInstances = amxNode.__getAllTagInstances();
              // Loop over all the children
              // Looking for one of five specific AMX tags here.
              //   1) setPropertyListener
              //   2) actionListener
              //   3) clientListener
              //   4) showPopupBehavior
              //   5) closePopupBehavior
              for (var i=0, length = tagInstances.length; i < length; i++)
              {
                var tagInstance = tagInstances[i];
                // Get the attribute type. If none is specified assume an action attribute.
                // TODO: Not sure thie assumption is correct as it assumes a type when none existis.
                //       I would expect a type would always be specified but because you are looking
                //       at AMX XML nodes we only see what is defined.
                var attrType;
                var type = tagInstance.getAttribute("type");
                if (type != null)
                {
                  attrType = adf.mf.internal._getEventTypeResolvedForBidi(type);
                }
                else
                {
                  // use default type
                  attrType = "action";
                }

                var subTag = tagInstance.getTag();

                if ((subTag.getNsPrefixedName() ===
                    adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":setPropertyListener") &&
                  attrType === amxEventType)
                {
                  // Get the from expression
                  var from = tagInstance.getAttributeExpression("from");
                  var isEl = false;
                  if (from)
                  {
                    from = from.toContextFreeExpression().getExpression();
                    isEl = true;
                  }
                  else
                  {
                    from = tagInstance.getAttribute("from", false);
                  }

                  if (from != null)
                  {
                    // Get a context free EL expression for the "to" so that we do not need to
                    // perform another visit to set the value
                    var toEl = tagInstance.getAttributeExpression("to").toContextFreeExpression();

                    // Set the value without trying to resolve the "from" value.
                    var setObject =
                    {
                      "name": toEl.getExpression(),
                      "expression": toEl,
                      "value": from
                    };

                    if (isEl)
                    {
                      // "from" is just a reference alias
                      setObject[adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]] = true;
                    }

                    amx.setElValue(setObject);
                  }
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":actionListener")
                {
                  // Process the action listener tag if there is an amxEventType passed matches the
                  // attribute type.
                  if (attrType == amxEventType)
                  {
                    // Create the arrays of paramaters and and paramater types.
                    var params     = [];
                    var paramTypes = [];
                    if (amxEvent)
                    {
                      params.push(amxEvent);
                      paramTypes.push(amxEvent[".type"]);
                    }

                        // Invoke the action event. This returns a promise.
                    var expr = tagInstance.getAttributeExpression("binding");
                    adf.mf.api.amx.invokeEl(expr, params, null, paramTypes);
                  }
                }
                else if ((subTag.getNsPrefixedName() ===
                    adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":clientListener") &&
                  attrType === amxEventType)
                {
                  // Execute it:
                  adf.mf.internal._processClientListener(attrType, amxEvent, amxNode, tagInstance);
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":showPopupBehavior")
                {
                  // Process the show popup behavior tag if there is an amxEventType passed in
                  // matches the attribute type.
                  if (attrType === amxEventType)
                  {
                    popupActions.push(
                      { "type": "show", "node": amxNode, "tagInstance": tagInstance });
                  }
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":closePopupBehavior")
                {
                  // Process the close popup behavior tag if there is an amxEventType passed in
                  // matches the attribute type.
                  if (attrType === amxEventType)
                  {
                    popupActions.push({ "type": "close", "node": amxNode, "tagInstance": tagInstance });
                  }
                }
              }
              // Start of Phase 3.
              // Process the listener if there is an amxEvent passed in and we have a listener
              // attribute on the compoenent.
              if (amxEvent)
              {
                var attParams     = [];
                var attParamTypes = [];
                attParams.push(amxEvent);
                attParamTypes.push(amxEvent[".type"]);

                var el = amxNode.getAttributeExpression(amxEventType + "Listener");
                adf.mf.api.amx.invokeEl(el, attParams, null, attParamTypes);
              }

              var scb = function(request, response)
              {
                // Check if an exception was returned (the success callback is still invoked in
                // these cases, so this callback must process the presence of an exception)
                if (Array.isArray(response) && response.length >= 1)
                {
                  var rl = response.length;
                  for (var r=0; r < rl; r++)
                  {
                    var obj = response[r];
                    if (obj != null &&
                      obj[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true)
                    {
                      // Call the failure callback instead
                      fcb(request, response);
                      return;
                    }
                  }
                }

                // Have a call back from all the events being proccessed. Now need to go over the
                // popup stack and process them
                for (var j = 0, len = popupActions.length; j < len; j++)
                {
                  amxNode = popupActions[j]["node"];
                  var tagInstance = popupActions[j]["tagInstance"];
                  var type = popupActions[j]["type"];

                  // we want to show the popup
                  rootNode.visit(
                    new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                    function (visitContext, amxNode)
                    {
                      // Invoke the show popup behavior. This returns a promise to the calling function.
                      if (type == "show")
                      {
                        amx.processShowPopupBehavior(amxNode, tagInstance);
                      }
                      else
                      {
                        amx.processClosePopupBehavior(amxNode, tagInstance);
                      }

                      return adf.mf.api.amx.VisitResult["COMPLETE"];
                    });
                }

                // Phase 4) Required Validations process the required validators. First we will wait
                //          for the previous phase to complete.
                // detect if we need to refresh the validation message area
                if (validationGroup !== undefined &&
                  adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
                {
                  // Due to the fact that we have been called back both by the setAttribute promise
                  // object as well as the serialResolve being used to iterate the children, we have
                  // lost the context of the amxNode. Use a visit to re-obtain the context so that
                  // iterating EL expressions may be correctly evaluated.
                  rootNode.visit(
                    new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                    function (visitContext, amxNode)
                    {
                      // this is a required value, so refresh the messages for this group
                      // let the validation context know that this group has been modified
                      // this method is defined in amx-validation.js
                      amx.requiredControlValueChanged(validationGroup);

                      return adf.mf.api.amx.VisitResult["COMPLETE"];
                    });
                }

                // resolve the root promise
                promiseArgs["resolve"]();
                batchResolve();
                adf.mf.internal.popNonBlockingCall();
              };

              var fcb = function()
              {
                // resolve the root promise
                promiseArgs["reject"].apply(null, arguments);
                batchReject.apply(null, arguments);
                adf.mf.internal.popNonBlockingCall();
                // TODO: Need to do something here. Not sure what
              };

              // Done processing all the events in batch mode. Time to send them over to the java
              // side to be processed
              perf.stop();
              adf.mf.util.flushBatchRequest(false, [scb], [fcb]);
            }
            else
            {
              perf.stop();

              // if adf.mf.environment.profile.dtMode, just resolve the promise
              promiseArgs["resolve"]();
              batchResolve();
            }

            return adf.mf.api.amx.VisitResult["COMPLETE"];
          });

        if (nodeFound == false)
        {
          perf.stop();

          // This may happen if an AMX event is processed after a navigation takes place. If so,
          // then just resolve the promise and hide the loading indicator
          promiseArgs["reject"]();
          batchReject();
        }
      });
  };

  // TODO: this method is gross. We need to refactor it to fit into one screen and break out the internals into
  // several functions so that it is readable
  adf.mf.internal.amx.processAmxEventImplSerial = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    promiseArgs)
  {
    return new adf.mf.internal.BasePromise(
      function(serialPromiseResolve, serialPromiseReject)
      {
        // Perform a visit to the node to put it back into context
        // TODO: find a way to get context free EL for listener tags so that we do not need to re-establish context
        var rootNode = adf.mf.api.amx.getPageRootNode();
        if (rootNode == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being delivered.
          promiseArgs["reject"]();
          serialPromiseReject();
          return;
        }

        // Prevent any data change events from processing while the event is being processed.
        // This is necessary to stop the AMX node hierarchy from being modified as we are
        // processing the child tags and nodes of the target node. If we remove the target,
        // we are no longer able to setup context of the node using visiting.
        var perf = adf.mf.internal.perf.startMonitorCall("Process AMX event", adf.mf.log.level.FINER,
          "adf.mf.internal.amx.processAmxEventImplSerial");

        // Check if the deprecated API is in use (passing the AMX node as a jQuery object with the
        // root DOM element)
        if (amxNode != null && amxNode.jquery)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
            "processAmxEventImplSerial", "MSG_AMX_EVENT_JQUERY_DEPRECATED");
          amxNode = amxNode.data("amxNode");
        }

        // We need to use visit pattern to set up the context for this node the event is attached to.
        var nodeFound = rootNode.visit(
          new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
          function (visitContext, amxNode)
          {
            var validationGroup = null;
            if (!adf.mf.environment.profile.dtMode)
            {
              adf.mf.internal.pushNonBlockingCall();
              // detect if we might need to refresh the validation message area
              if (amxEventType === "valueChange" &&
                attributeValueName === amxNode.__getAttributeToValidate())
              {
                // First find the closest rendered node for validation group purposes
                var domNode = null;
                var renderedAmxNode = amxNode.__getClosestRenderedNode();
                if (renderedAmxNode != null)
                {
                  domNode = document.getElementById(renderedAmxNode.getId());
                }

                // we need to retrieve this here because calling setElValue will cause this domNode
                // to potentially be swapped out with a new one if the control doesn't support the
                // refresh method
                validationGroup = _getClosestWithClass(domNode, "amx-validationGroup");
              }

              // If this is a value change event then we need to convert the new value first before
              // we continue to process.
              if (amxNode.getConverter() && amxEventType === "valueChange" &&
                attributeValueName === "value")
              {
                newValue = amxNode.getConverter().getAsObject(newValue);
              }

              // Phase 1) Set the new value on the attribute. We need to first fetch the current
              //          value of the attribute (this has to be an EL Expression so we assume it is
              //          and let the setELValue figure out where it really needs to go. For our
              //          part we just get the value for this attribute that get returned and assume
              //          it is an EL expression for this attribute. This is  different from the
              //          rich client. First we know what the type (EL Expression or literal) and
              //          set the value immediatly if this is a literal. Once the "value" has been
              //          fetched for this attribute then the assumed EL expression and send off in
              //          another request for to be updated with the new value.
              // TODO: I do not know what this means for input values as they are most likly never
              //       EL bound. Another question is what does this mean for disclosure state? In
              //       the rich client EL driven disclosure state is only driven the first time it
              //       is evaluated and from then on it is controlled by the component (or the
              //       developer) who set the value in JS.

              // Need a new promise to represent when the set has completed. Since this can go to
              // Java that means this operation may happen asynchronously and we need to wait for it
              // to finish. This will be initialized later but we need this defined here for scoping
              // purposes as this is used below in the promise.all.
              var setValuePromise = [];

              // Make sure we have an attribute value name we are looking to update.
              if (attributeValueName)
              {
                setValuePromise.push(amxNode.setAttribute(attributeValueName, newValue));
              }

              // Wait for Phase 1 to complete.
              // Note: when setValuePromise is undefined, then, the promise.all will resolve
              // immediately (which is what we want).
              // Other wise we will continue to wait until the set value has completed.
              var childrenPromise = null;
              adf.mf.internal.BasePromise.all(setValuePromise)["catch"](
                function()
                {
                  // bug 16371894: setValuePromise failed so we abort further processing and reject
                  // childrenPromise
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_SET_VALUE_REJECTED");

                  // For security purposes, only log at FINE level
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                  {
                    adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                      "adf.mf.internal.amx", "processAmxEventImplSerial",
                      "Value rejected: " + newValue);
                  }

                  childrenPromise = new adf.mf.internal.BasePromise(
                    function(resolve, reject)
                    {
                      reject();
                    });
                })
                .then(
                  function()
                  {
                    // Phase 2) Process the setPropertyListeners and actionListeners of this node
                    // passed in. Since any component can have other types of components we are
                    // going to be looking for specific component types. We need to create a
                    // childrenPromise to make sure we can wait on this before we go to the next
                    // phase.
                    // Get all the child tag instances from the AMX node.
                    var tagInstances = amxNode.__getAllTagInstances();

                    // Need a new promise variable as proccessing the child components action, set
                    // property, show popup, close popup behaviors may require calls into the Java
                    // engine and this will always be done Asynchronously.
                    if (tagInstances.length > 0)
                    {
                      // Restore the child variables if this is an iterator or stamped component.
                      // This is required in order to process the specific children in the same and
                      // have thier attribute EL or values. Call serialResolve on the chidlren and
                      // pass it the anonyos function to be applied to all the children.
                      // The returned promise will be used to make sure to wait on it before
                      // performing the next phase.
                      // TODO: Break this our into its own function. This should be a simple case
                      //       statement that calls the specific function for the type of component.
                      childrenPromise = amx.serialResolve(tagInstances,
                        function(tagInstance, i)
                        {
                          // Get the attribute type. If none is specified assume an action attribute
                          // TODO: Not sure thie assumption is correct as it assumes a type when
                          //       none exists. I would expect a type would always be specified but
                          //       because you are looking at AMX XML nodes we only see what is
                          //       defined.
                          var attrType;
                          if (tagInstance.getAttribute("type") != null)
                          {
                            attrType = adf.mf.internal._getEventTypeResolvedForBidi(
                              tagInstance.getAttribute("type"));
                          }
                          else
                          {
                            // use default type
                            attrType = "action";
                          }

                          var subTag = tagInstance.getTag();

                          // Looking for one of five specific AMX tags here.
                          //   1) setPropertyListener
                          //   2) actionListener
                          //   3) clientListener
                          //   4) showPopupBehavior
                          //   5) closePopupBehavior
                          // TODO: this code could explode as more behaviors are added. This needs
                          // to be broken out into a core behavior class that is subclassed by the
                          // specific behaviors. and then just call the function on the behavior.
                          // Maybe this should be an interface that we look for and then execute the
                          // function if it is defined.
                          if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":setPropertyListener" &&
                            attrType === amxEventType)
                          {
                            // Need a new promise as set property listener has two phases. One to
                            // retrieve the data "from" and one to set the "to".
                            var propPromiseResolve = null;
                            var propPromise = new adf.mf.internal.BasePromise(
                              function(resolve, reject)
                              {
                                propPromiseResolve =
                                  function()
                                  {
                                    resolve();
                                  };
                              });

                            // Due to the fact that we have been called back both by the
                            // setAttribute promise object as well as the serialResolve being used
                            // to iterate the children, we have lost the context of the amxNode. Use
                            // a visit to re-obtain the context so that iterating EL expressions may
                            // be correctly evaluated.
                            var nestedVisitNodeFound = rootNode.visit(
                              new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                              function (visitContext, amxNode)
                              {
                                // Get the from expression
                                var fromEL = tagInstance.getAttributeExpression("from");

                                if (fromEL)
                                {
                                  // Get a context free EL expression for the "to" so that we do not
                                  // need to perform another visit to set the value.
                                  var toEl = tagInstance.getAttributeExpression("to")
                                    .toContextFreeExpression();

                                  // Get the value and when it has been retieved the always function
                                  // will be invoked and this is where we will set the value we just
                                  // retrieved.
                                  var getAlways =
                                    function(requestAndResponse)
                                    {
                                      var response = requestAndResponse[1];

                                      // Have the new value now set it based on the EL binding for
                                      // the element
                                      amx.setElValue(
                                        {
                                          "name": toEl.getExpression(),
                                          "expression": toEl,
                                          "value": response[0].value
                                        }).then(propPromiseResolve, propPromiseResolve);
                                    };

                                  amx.getElValue(fromEL).then(getAlways, getAlways);
                                }
                                else
                                {
                                  var from = tagInstance.getAttribute("from", false);
                                  // Get a context free EL expression for the "to" so that we do not
                                  // need to perform another visit to set the value.
                                  var toEl = tagInstance.getAttributeExpression("to")
                                    .toContextFreeExpression();
                                  amx.setElValue(
                                    {
                                      "name": toEl.getExpression(),
                                      "expression": toEl,
                                      "value": from
                                    })
                                    .then(propPromiseResolve, propPromiseResolve);
                                }

                                return adf.mf.api.amx.VisitResult["COMPLETE"];
                              });

                            if (nestedVisitNodeFound == false)
                            {
                              // Resolve the promise if the node could no longer be found
                              propPromiseResolve();
                            }

                            // Return the promise to the calling function (This is within the
                            // amx.serialResolve). It needs this as it will wait for this to finish
                            // before going to the next child in the hiearchy.
                            return propPromise;
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":actionListener")
                          {
                            // Process the action listener tag if there is an amxEventType passed
                            // matches the attribute type
                            if (attrType == amxEventType)
                            {
                              // Create the arrays of paramaters and and paramater types
                              var params     = [];
                              var paramTypes = [];

                              if (amxEvent)
                              {
                                params.push(amxEvent);
                                paramTypes.push(amxEvent[".type"]);
                              }

                              var actionListenerPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the action event. This returns a promise.
                                  var expr = tagInstance.getAttribute("binding");
                                  actionListenerPromise = adf.mf.api.amx.invokeEl(
                                    expr,
                                    params,
                                    null,
                                    paramTypes);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return actionListenerPromise;
                            }
                            else
                            {
                              // Returning null allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":clientListener")
                          {
                            // Process the clientListener tag if there is an amxEventType passed in
                            // matches the attribute type
                            if (attrType === amxEventType)
                            {
                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the clientListener.
                                            adf.mf.internal._processClientListener(attrType, amxEvent,
                                              amxNode, tagInstance);
                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return null;
                            }
                            else
                            {
                              // Returning allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":showPopupBehavior")
                          {
                            // Process the show popup behavior tag if there is an amxEventType
                            // passed in matches the attribute type.
                            if (attrType === amxEventType)
                            {
                              var showPopupPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the show popup behavior. This returns a promise to the calling function.
                                  showPopupPromise = amx.processShowPopupBehavior(amxNode, tagInstance);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return showPopupPromise;
                            }
                            else
                            {
                              // Returning null allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":closePopupBehavior")
                          {
                            // Process the close popup behavior tag if there is an amxEventType
                            // passed in matches the attribute type.
                            if (attrType === amxEventType)
                            {
                              var closePopupPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the close popup behavior. This returns a promise to the
                                  // calling function.
                                  closePopupPromise = amx.processClosePopupBehavior(amxNode, tagInstance);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return closePopupPromise;
                          }
                          else
                          {
                            // Returning null allows any calling function to resolve immediately
                            return null;
                          }
                        }
                        else
                        {
                          // Returning null if there are no match to any tag (this is the catch
                          // all). This allows any calling function to resolve immediately.
                          return null;
                        }
                      });
                    }
                    else
                    {
                      // There are no children so we need to create an empty promise and resolve it.
                      // This is because we will be waiting on this before going to the next phase.
                      childrenPromise = new adf.mf.internal.BasePromise(
                        function(resolve, reject)
                        {
                          resolve();
                        });
                    }
                  });

              // Phase 3) process the listeners. First we will wait for the previous phase to finish
              // before we continue on. Need to create another promise for the listeners. This is
              // required to be able to wait for the this phase to complete.
              var listenerPromiseResolve = null;
              var listenerPromiseReject = null;
              var listenerPromise = new adf.mf.internal.BasePromise(
                function(resolve, reject)
                {
                  listenerPromiseResolve = resolve;
                  listenerPromiseReject = reject;
                });

              // Wait for phase 2 to complete.
              adf.mf.internal.BasePromise.all([childrenPromise])["catch"](
                function()
                {
                  // Bug 16371894: childrenPromise was rejected so we abort further processing and
                  // reject listenerPromise
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_CHILDREN_REJECTED");
                  listenerPromiseReject();
                })
                .then(
                  function()
                  {
                    // Start of Phase 3.
                    // Process the listener if there is an amxEvent passed in.
                    if (amxEvent)
                    {
                      var params     = [];
                      var paramTypes = [];

                      params.push(amxEvent);
                      paramTypes.push(amxEvent[".type"]);

                      // Due to the fact that we have been called back both by the setAttribute
                      // promise object as well as the serialResolve being used to iterate the
                      // children, we have lost the context of the amxNode. Use a visit to re-obtain
                      // the context so that iterating EL expressions may be correctly evaluated.
                      var nestedVisitNodeFound = rootNode.visit(
                        new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                        function (visitContext, amxNode)
                        {
                          var el = amxNode.getAttributeExpression(amxEventType + "Listener");

                          adf.mf.api.amx.invokeEl(
                            el,
                            params,
                            null,
                            paramTypes,
                            function()
                            {
                              listenerPromiseResolve();
                            },
                            function()
                            {
                              listenerPromiseResolve();
                            });

                          return adf.mf.api.amx.VisitResult["COMPLETE"];
                        });

                      if (nestedVisitNodeFound == false)
                      {
                        // Resolve the promise if the node could no longer be found
                        listenerPromiseResolve();
                      }
                    }
                    else
                    {
                      listenerPromiseResolve();
                    }
                  });

              // Phase 4) Required Validations process the required validators. First we will wait
              // for the previous phase to complete.
              adf.mf.internal.BasePromise.all([listenerPromise])["catch"](
                function()
                {
                  // bug 16371894: listenerPromise failed so skip validation.  We are done at this
                  // point so reject promise and clean up
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_LISTENERS_REJECTED");
                  perf.stop();
                  adf.mf.internal.popNonBlockingCall();

                  // reject the root promise
                  promiseArgs["reject"]();
                  serialPromiseReject();
              })
              .then(
                function()
                {
                  // detect if we need to refresh the validation message area
                  if (validationGroup !== undefined &&
                      adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
                  {
                    // Due to the fact that we have been called back both by the setAttribute
                    // promise object as well as the serialResolve being used to iterate the
                    // children, we have lost the context of the amxNode. Use a visit to re-obtain
                    // the context so that iterating EL expressions may be correctly evaluated.
                    rootNode.visit(
                      new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                      function (visitContext, amxNode)
                      {
                        // this is a required value, so refresh the messages for this group
                        // let the validation context know that this group has been modified
                        // this method is defined in amx-validation.js
                        amx.requiredControlValueChanged(validationGroup);

                        return adf.mf.api.amx.VisitResult["COMPLETE"];
                      });
                  }

                  perf.stop();

                  // resolve the root promise
                  promiseArgs["resolve"]();
                  serialPromiseResolve();
                  adf.mf.internal.popNonBlockingCall();
                });
            }
            else
            {
              perf.stop();

              // If adf.mf.environment.profile.dtMode, just resolve the promise
              promiseArgs["resolve"]();
              serialPromiseResolve();
            }

            return adf.mf.api.amx.VisitResult["COMPLETE"];
          });

        if (nodeFound == false)
        {
          perf.stop();

          // This may happen if an AMX event is processed after a navigation takes place. If so,
          // then just resolve the promise and hide the loading indicator
          promiseArgs["reject"]();
          serialPromiseReject();
        }
      });
  };

  function _getClosestWithClass(domNode, classNameToMatch)
  {
    // Find the closest ancestor (including self that uses the given class name)
    if (domNode == null || (domNode.classList && domNode.classList.contains(classNameToMatch)))
    {
      return domNode;
    }
    else
    {
      return _getClosestWithClass(domNode.parentNode, classNameToMatch);
    }
  }

  /**
   * Internal function to invoke a clientListener.
   * @param {string} type the event type that occurred
   * @param {Object} amxEvent the AMX event that occurred
   * @param {adf.mf.api.amx.AmxNode} amxNode the AMX node of the component that triggered the event
   * @param {adf.mf.internal.amx.AmxTagInstance} clientListenerTagInstance the AMX tag instance of
   *  the clientListener
   */
  adf.mf.internal._processClientListener = function(
    type,
    amxEvent,
    amxNode,
    clientListenerTagInstance)
  {
    var method = clientListenerTagInstance.getAttribute("method");

    if (method != null && method.length > 0)
    {
      try
      {
        // Produce the client event object by copying over the AMX event properties to it.
        var timeStamp = (new Date()).getTime();
        var clientEvent =
        {
          "toString": function()
          {
            var result = "oracle.adfmf.amx.event.ClientEvent{ ";

            // Always start with these properties (in this order):

            // The ID of the AMX Node
            var value = clientEvent["amxNodeId"];
            if (value != null)
              result += "amxNodeId:\"" + value + "\"";
            else
            {
              value = clientEvent["amxNode"];
              if (value != null && value.getId)
                result += "amxNode.getId():\"" + value.getId() + "\"";
              else
                result += "(no amxNode.getId)";
            }

            // The type
            value = clientEvent["type"];
            if (value != null)
              result += ", type:\"" + clientEvent["type"] + "\"";

            // The timeStamp
            value = clientEvent["timeStamp"];
            if (value != null)
              result += ", timeStamp:\"" + clientEvent["timeStamp"] + "\"";

            // Print the rest of the properties (order not guaranteed):
            for (var key in clientEvent)
            {
              if (key != "amxNodeId" && key != "type" && key != "timeStamp")
              {
                value = clientEvent[key];
                var valueType = typeof value;
                if (valueType != "function")
                {
                  result += ", " + key + ":";
                  if (valueType == "string")
                    result += "\"";
                  result += value;
                  if (valueType == "string")
                    result += "\"";
                }
              }
            }

            result += " }";
            return result;
          }
        };

        for (var key in amxEvent)
        {
          clientEvent[key] = amxEvent[key];
        }

        // Add some additional properties if they don't overwrite ones of the same name from the
        // AMX event.
        if (clientEvent["type"] === undefined)
          clientEvent["type"] = type;

        if (clientEvent["amxNode"] === undefined)
          clientEvent["amxNode"] = amxNode;

        if (clientEvent["timeStamp"] === undefined)
          clientEvent["timeStamp"] = timeStamp;

        // Invoke the clientListener's method as a function.
        // If it is not already a function (e.g. a use case for MAX) then we
        // need to sandbox-convert it to a function via new Function:
        if (typeof method != "function")
          method = (new Function("return " + method))();

        method(clientEvent);
      }
      catch (problem)
      {
        var message = "Problem with clientListener type=\"" + type + "\" method=\"" + method + "\":\n\n";
        alert(message + problem);
      }
    }
  };

  /**
   * Internal function to convert bidi types so both bidi and non-bidi equivalents are handled
   * with the same event.
   * @param {string} rawEventType the application developer-specified event type
   * @return {string} the resolved direction-explicit event type
   * @private
   */
  adf.mf.internal._getEventTypeResolvedForBidi = function(rawEventType)
  {
    var resolvedEventType = rawEventType;
    if (resolvedEventType == "swipeStart")
    {
      if (document.documentElement.dir == "rtl")
        resolvedEventType = "swipeRight";
      else
        resolvedEventType = "swipeLeft";
    }
    else if (resolvedEventType == "swipeEnd")
    {
      if (document.documentElement.dir == "rtl")
        resolvedEventType = "swipeLeft";
      else
        resolvedEventType = "swipeRight";
    }
    return resolvedEventType;
  };

  /**
   * Internal function. Calls adf.mf.el.getLocalValue and processes the resulting value, performing
   * any conversions if necessary. Currently converts JS objects with a ".null" property to a null
   * value.
   *
   * @param {string} expr The EL expression
   * @return {Object} the result
   */
  adf.mf.internal.amx.evaluateExpression = function(expr)
  {
    var value = adf.mf.el.getLocalValue(expr);

    return (value != null && value[".null"] === true) ? null : value;
  };

  /**
   * adf.mf.el.getValue wrapper using the promise for asynchronous
   * .then(requestAndResponse)  - response is an array of the values in the
   *                            same order as the el values passed in
   * .catch(requestAndException) - never invoked
   * @param {boolean=} ignoreErrors if true, causes EL errors to be ignored.
   *                   use sparingly for pre-loading data into the client side
   *                   EL cache. Primary goal is to ignore loop based variables
   *                   during pre-fetching of data while not stamping.
   */
  amx.getElValue = function (singleOrArrayOfEls, ignoreErrors)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    if (!adf.mf.environment.profile.dtMode)
    {
          var arrayOfEls = (adf.mf.internal.util.is_array(singleOrArrayOfEls)) ?
            singleOrArrayOfEls : [singleOrArrayOfEls];

      arrayOfEls = arrayToEL (arrayOfEls);

          var perf = adf.mf.internal.perf.startMonitorCall("AMX get EL value",
            adf.mf.log.level.FINER, "amx:getElValue");

      // this function will help convert the response from a call to adf.mf.el.getValue
      // to an array of objects that is exactly the length of the request el.
      // This handles full failure, full success, and partial success situations
      var makeResponseArray = function(partialResponses)
      {
        // in a full failure case, the partialResponses will be undefined
        if (partialResponses === undefined)
        {
          partialResponses = [];
        }

        var partialResponseIndex = 0;

        var resultArray = [];

        for (var i = 0; i < arrayOfEls.length; ++i)
        {
          var currentEl = arrayOfEls[i];
          var val = null;
          // we are guaranteed that any successes will be in the order of the request/ However,
              // we are not guaranteed that the length of the response array is the length of the
              // request array, so we keep state to know which partial response index we are on and
              // we will use that value instead of making the slightly more costly call of
              // getLocalValue
          var isException = true;
              if (partialResponseIndex < partialResponses.length &&
                partialResponses[partialResponseIndex].name == currentEl.getExpression())
          {
            var nvp = partialResponses[partialResponseIndex];
                if (nvp !== null &&
                  nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === undefined)
            {
              isException = false;
              val = nvp.value;
                  // we found a match, so increment the partial response index for when we loop
                  // back around
              ++partialResponseIndex;
            }
          }

          if (isException)
          {
            try
            {
                  // we don't have any data for what this EL is, so call getLocalValue and use what
                  // is cached
              val = adf.mf.el.getLocalValue(currentEl);
            }
            catch(innerEx)
            {
              // if this throws an exception, then do nothing, since val will be undefined
              // and we will set it to null in the check below
              ;
            }
          }

              // make sure we never return an "undefined" value - make sure it is just a json null
              // struct
          if (val === undefined)
          {
            val = {".null" : true};
          }
              resultArray.push(
                { name: currentEl.getExpression(), expression: currentEl, value: val });
        }

        return resultArray;
      };

      var successFunc = function(request,response)
      {
        var resultArray;
        try
        {
          resultArray = makeResponseArray(response);
        }
        finally
        {
          perf.stop();
        }

            resolve([request,resultArray]);
      };

      var failureFunc = function(request,exception)
      {
        var resultArray;
        try
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "getElValue",
                "MSG_GETVALUE_FAILED");

              // For security purposes, only log at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "amx", "getElValue",
                  "Request that failed: " + request + " exception: " + exception);
              }

          resultArray = makeResponseArray();
        }
        finally
        {
          perf.stop();
        }
            resolve([request,resultArray]);
      };

      try
      {
        adf.mf.el.getValue(arrayOfEls, successFunc, failureFunc, ignoreErrors);
      }
      catch (ex)
      {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "getElValue",
              "MSG_GETVALUE_EXCEPTION");

            // For security purposes, only log at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx", "getElValue",
                "EL strings: " + adf.mf.util.stringify(arrayOfEls) + " error: " + ex);
            }

            // call the failure function to handle resolving the promise object
        failureFunc(arrayOfEls, ex);
      }
    }
    else
    {
      // if adf.mf.environment.profile.dtMode then, return the result
      var response = [{value:singleOrArrayOfEls}];
          resolve([singleOrArrayOfEls,response]);
    }
      });
  };

  /**
   * Converts array of strings to array of ELExpressions.
   *
   * @param {type} expressions
   * @returns {Array}
   */
  function arrayToEL (expressions)
  {
    if (expressions[0].tokens)
      return expressions;
    var elExpressions = [];
    for (var i = 0; i < expressions.length; i++)
    {
      elExpressions.push (adf.mf.internal.el.parser.parse (expressions[i]));
    }
    return elExpressions;
  }

  /**
   * adf.mf.el.setValue wrapper using the promise for asynchronous
   */
  amx.setElValue = function(nameValues)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    if (!adf.mf.environment.profile.dtMode)
    {
          var perf = adf.mf.internal.perf.startMonitorCall("AMX set EL value",
            adf.mf.log.level.FINER, "amx:setElValue");

      try
      {
        adf.mf.el.setValue(nameValues,
          function(request, response)
          {
            perf.stop();
                resolve([request,response]);
          },
          function(request, exception)
          {
            perf.stop();
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "setElValue",
                  "MSG_SETVALUE_FAILED");

                // For security purposes, only log at FINE level
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                    "amx", "setElValue",
                    "Request arguments: " + adf.mf.util.stringify(nameValues) +
                    " exception: " + exception);
                }

                reject([request,exception]);
          });
      }
      catch (ex)
      {
        perf.stop();

        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "setElValue",
              "MSG_SETVALUE_EXCEPTION");

            // For security purposes, only log at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx", "setElValue",
                "Name: " + nameValues.name + " error: " + ex);
            }

        // TODO: why is this resolve and not reject?
            resolve();
      }
    }
    else
    {
      // if adf.mf.environment.profile.dtMode, just resolve
          resolve();
    }
      });
  };

  amx.loadBundle = function(basename, variable)
  {
    if (!adf.mf.environment.profile.mockData)
    {
      return new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      try
      {
            // Kilgore: add a placeholder for the resources to be loaded into:
            adf.mf.el.addVariable(variable, {});
            adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "loadBundle", basename,
              variable,
              function()
        {
              resolve();
            },
            function(req,ex)
        {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "loadBundle",
                  "MSG_LOADBUNDLE_FAILED");

                // Only log the details at a fine level for security reasons
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                    "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
                      " variable: " + variable + " exception: " + ex);
                }

              resolve();
        });
      }
      catch (ex)
      {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "loadBundle",
              "MSG_LOADBUNDLE_EXCEPTION");

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
                  " variable: " + variable + " exception: " + ex);
            }
      }
        });
    }
    else
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "loadBundle",
        "MSG_LOADBUNDLE_SKIPPED");

      // Only log the details at a fine level for security reasons
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
            " variable: " + variable);
      }
      return;
    }
  };

  /**
   * @deprecated
   */
  amx.invokeEl = function(expression, params, returnType, types)
  {
    if (expression && expression.getExpression)
      expression = expression.getExpression ();

    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amx.invokeEl", "MSG_DEPRECATED", "amx.invokeEl", "adf.mf.api.amx.invokeEl");

    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    try
    {
      if (expression && !adf.mf.environment.profile.dtMode)
      {
        if (!adf.mf.environment.profile.mockData)
        {
          //TODO: needs to inject correct params, and handle return type
              adf.mf.el.invoke(expression, params, "void", types,
                function(req,res)
          {
                resolve(res);
                },
                function(req,exp)
          {
                reject(exp);
          });
        }
        else
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "invokeEl",
                "MSG_AMX_DO_NOT_CALL_ADFMF_EL_INVOKE");

              // For security purposes, only log at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "amx", "invokeEl",
                  "Deprecated call with expression: " + expression);
              }

              resolve();
        }
      }
      else
      {
            resolve();
      }
    }
    catch (ex)
    {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "invokeEl",
            "MSG_INVOKEEL_EXCEPTION");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "amx", "invokeEl",
              "Call failed. Expression: " + expression  + " error: " + ex);
          }

          resolve();
    }
      });
  };

  /**
   * Utility similar to adf.mf.el.invoke() for invoking an EL method but will refrain execution in
   * environments such as design time previews.
   *
   * @param {string} expression the EL method to invoke
   * @param {Array.<string>} params an array of parameters to send to the method
   * @param {string} returnType null or the return type for the method
   * @param {Array.<string>} paramTypes an array of types for each parameter in the params array
   * @param {function} successCallback optional function to call when the method is invoked
   * @param {function} failureCallback optional function to call if something failed while
   *   attempting to invoke the method
   */
  adf.mf.api.amx.invokeEl = function(expression, params, returnType, paramTypes, successCallback,
    failureCallback)
  {
    try
    {
      if (expression && expression.getExpression)
        expression = expression.getExpression ();

      if (expression && !adf.mf.environment.profile.dtMode)
      {
        if (!adf.mf.environment.profile.mockData)
        {
          //TODO: needs to inject correct params, and handle return type
          if (returnType == null)
            returnType = "void";
          adf.mf.el.invoke(expression, params, returnType, paramTypes, successCallback,
            failureCallback);
        }
        else
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "invokeEl",
            "MSG_AMX_DO_NOT_CALL_ADFMF_EL_INVOKE");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.api.amx", "invokeEl",
              "invokeEl called in mock mode with expression: " + expression);
          }

          if (successCallback)
            successCallback();
        }
      }
      else
      {
        if (successCallback)
          successCallback();
      }
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "invokeEl",
        "MSG_INVOKEEL_EXCEPTION");

      // For security purposes, only log at FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx", "invokeEl",
          "Call failed. Expression: " + expression + " error: " + ex);
      }
      if (failureCallback)
        failureCallback();
    }
  };

  /**
   * Take the varName and varValue and store it for this domNode.
   */
  amx.storeVariable = function(domNode, varName, varValue) // TODO is this still used?
  {
    var amxVar = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxVar");
    domNode.classList.add("amxVar");
    if (!amxVar)
    {
      amxVar = {};
      adf.mf.internal.amx._setNonPrimitiveElementData(domNode, "amxVar", amxVar);
    }
    amxVar.name = varName;
    amxVar.value = varValue;
  };

  //FIXME: remove this (for backward compability with the dvt team)
  amx.storeVarNameValue = amx.storeVariable; // TODO is this still used?

  /**
   * Restore iterator stamp variables for use during listener invocation.
   * May be used by component authors to reset the EL context during a callback.
   * @return a non-null (but possibly empty) array of amxVar data objects that were restored
   * @see cleanVariables
   * @deprecated use adf.mf.internal.amx.restoreContext instead
   */
  amx.restoreVariables = function(domNodes) // TODO is this still used?
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "restoreVariables", "MSG_DEPRECATED", "amx.restoreVariables",
      "adf.mf.internal.amx.restoreContext");

    if (domNodes.length == 1)
    {
      return adf.mf.internal.amx.restoreContext(domNodes);
    }
    else
    {
      var results = [];
      for (var i = 0, size = domNodes.length; i < size; ++i)
      {
        results = results.concat(adf.mf.internal.amx.restoreContext(domNodes[i]));
      }
      return results;
    }
  };

  /**
   * Use to restore rendering context of a node post-rendering.
   * May be used by component authors to reset the EL context during a callback.
   * @param {DOMNode} domNode the HTML DOM node to restore the context of.
   * @return a non-null (but possibly empty) array of amxVar data objects that were restored
   * @see cleanVariables
   */
  adf.mf.internal.amx.restoreContext = function(domNode) // TODO is this still used?
  {
    // TODO: consider allowing the type handlers for the DOM nodes
    // to have hooks for restoring the context instead of hard-coding
    // this to only support AMX variables that were introduced during
    // rendering.
    var amxVars = getAmxVars(domNode);
    for (var i = 0, size = amxVars.length; i < size; ++i)
    {
      var amxVar = amxVars[i];
      adf.mf.el.addVariable(amxVar.name, amxVar.value);
    }
    return amxVars;
  };

  /**
   * @deprecated use adf.mf.internal.amx.tearDownContext instead
   */
  amx.cleanVariables = function(varsToClean) // TODO is this still used?
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "cleanVariables", "MSG_DEPRECATED", "amx.cleanVariables",
      "adf.mf.internal.amx.tearDownContext");

    adf.mf.internal.amx.tearDownContext(varsToClean);
  };

  /**
   * Tear down the context setup by adf.mf.internal.amx.restoreContext.
   * @param {Object} contextResult the value returned from adf.mf.internal.amx.restoreContext
   * @see adf.mf.internal.amx.restoreContext
   */
  adf.mf.internal.amx.tearDownContext = function(contextResult) // TODO is this still used?
  {
    for (var i = 0, size = contextResult.length; i < size; ++i)
    {
      adf.mf.el.removeVariable(contextResult[i].name);
    }
  };


  /**
   * @deprecated
   */
  amx.isValueFalse = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "isValueFalse",
      "MSG_DEPRECATED", "amx.isValueFalse", "adf.mf.api.amx.isValueFalse");
    return adf.mf.api.amx.isValueFalse.apply(this, arguments);
  };

  /**
   * Returns true if the value is boolean false or string "false".
   * If undefined, returns false.
   */
  adf.mf.api.amx.isValueFalse = function(value)
  {
    if (typeof value !== "undefined")
    {
      if (value === false || value === "false" || value === 0 || value === "0")
      {
        return true;
      }
      else
      {
        return false;
      }
    }
    else
    {
      return false;
    }
  };

  /**
   * @deprecated
   */
  amx.isValueTrue = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "isValueTrue",
      "MSG_DEPRECATED", "amx.isValueTrue", "adf.mf.api.amx.isValueTrue");
    return adf.mf.api.amx.isValueTrue.apply(this, arguments);
  };

  /**
   * Returns true if the value is boolean true or string "true".
   * If undefined, returns false.
   */
  adf.mf.api.amx.isValueTrue = function(value)
  {
    if (typeof value !== "undefined")
    {
      if (value === true || value === "true" || value === 1 || value === "1")
      {
        return true;
      }
      else
      {
        return false;
      }
    }
    else
    {
      return false;
    }
  };

  /**
   * Return the list of var object {name:..,value:..} starting from this domNode up to the root document.
   */
  function getAmxVars(domNode) // TODO is this still used?
  {
    var amxVars = [];
    _getAmxVars(amxVars, domNode);
    return amxVars;
    }

  function _getAmxVars(amxVars, node)
    {
    if (node != null)
    {
      if (node.classList.contains("amxVar"))
      {
        amxVars.push(adf.mf.internal.amx._getNonPrimitiveElementData(node, "amxVar"));
  }
      _getAmxVars(amxVars, node.parentNode);
    }
  }

  // ------ API for TypeHandlers ------ //
  /**
   * Function called for each time a page has been loaded. Walks the entire tag tree and
   * performs any necessary initialization.
   * @param {adf.mf.api.amx.AmxTag} rootTag the root AMX tag of the page
   * @return {Object} Promise object that is resolved once the processing has been
   *         completed.
   * @private
   */
  adf.mf.internal.amx._preProcessTagTree = function(rootTag)
  {
    var fileArray = [];

    var perf = adf.mf.internal.perf.startMonitorCall("Process tag tree", adf.mf.log.level.FINER, "adf.mf.internal.amx._preProcessTagTree");
    findResourcesForTag(rootTag, fileArray);

    // Create a promise to load all the resources serially.
    var loadResourcePromise = loadFilesSequentialPromise(fileArray);

    // Hook to load additional files for the page when in automation mode. This function
    // will only exist if amx-automation.js has been loaded
    if (adf.mf.internal.amx.getAutomationResourcesForHierarchy != null)
    {
      // Save off the base promise
      var basePromise = loadResourcePromise;

      // Setup a new promise to return
      loadResourcePromise = new adf.mf.internal.BasePromise(
        function (resolve, reject)
        {
          // Wait for the base files to load
          basePromise.then(
            function()
            {
              // Now that the type handlers have loaded, load any needed automation files
              var automationFiles = adf.mf.internal.amx.getAutomationResourcesForHierarchy(rootTag);
              loadFilesSequentialPromise(automationFiles).then(
                function()
                {
                  // Resolve the promise for performance and the code waiting on the processing
                  resolve();
                });
            });

        });
    }

    return loadResourcePromise.then(
      function()
      {
        perf.stop();
      });
  };

  function processCssLinks(amxNode)
  {
    cssNodes = [];

    // We build the list of cssNodes
    adf.mf.internal.amx._each(amxNode.nodes, function(idx, node)
    {
      if (node.tagName === "amx:CSSInclude") // TODO is this still valid?
      {
        cssNodes.push(node);
      }
    });

    // We add them to the <head /> document
    // TODO: needs to check if the css was already added
    // TODO: probably needs to try to return a promise that will resolve when the css is loaded.
    adf.mf.internal.amx._each(cssNodes, function(idx, cssNode)
    {
      amx.includeCss(cssNode.file);
    });
  }

  function getNodeTypeHandler(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "getNodeTypeHandler", "MSG_AMX_GET_NODE_TYPE_HANDLER_DEPRECATED");

    return amxNode.getTypeHandler();
  }
  amx.getNodeTypeHandler = getNodeTypeHandler;

  // ------ TypeHandler ------ //

  /**
   * Abstraction for TypeHandler implementations.
   * To extend TypeHandler, use:
   * <pre><code>(function()
   *   {
   *     // TypeHandler for custom "x" tags:
   *     var x = adf.mf.api.amx.TypeHandler.register("http://xmlns.example.com/custom", "x");
   *
   *     x.prototype.render = function(amxNode)
   *     {
   *       var rootElement = document.createElement("div");
   *       rootElement.appendChild(document.createTextNode("Hello World"));
   *       return rootElement;
   *     };
   *
   *     // TypeHandler for custom "y" tags:
   *     var y = adf.mf.api.amx.TypeHandler.register("http://xmlns.example.com/custom", "y");
   *
   *     y.prototype.render = function(amxNode)
   *     {
   *       var rootElement = document.createElement("div");
   *       rootElement.appendChild(document.createTextNode("Goodbye World"));
   *       return rootElement;
   *     };
   *
   *   })();</code></pre>
   * @constructor adf.mf.api.amx.TypeHandler
   * @augments adf.mf.api.AdfObject
   */
  function TypeHandler()
  {
    this.Init();
  }

  // make adf.mf.api.amx.TypeHandler a subclass of adf.mf.api.AdfObject
  adf.mf.api.amx.TypeHandler = TypeHandler;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.TypeHandler, adf.mf.api.AdfObject, "adf.mf.api.amx.TypeHandler");

  /**
   * Initializes the TypeHandler class
   * @protected
   */
  adf.mf.api.amx.TypeHandler.InitClass = function()
  {
    TypeHandler._classDictionary = {};
    TypeHandler._instanceDictionary = {};
  };

  /**
   * Register a TypeHandler class with a tag namespace and name.
   * @param {string} theNamespace the xmlns for the tag
   * @param {string} tagName the name of the tag (no namespace)
   * @param {adf.mf.api.amx.TypeHandler=} precreatedClass optional pre-created class to register
   * @return {function} the registered adf.mf.api.amx.TypeHandler subclass so that prototype functions can be added
   */
  adf.mf.api.amx.TypeHandler.register = function(theNamespace, tagName, precreatedClass)
  {
    // make sure that our class is initialized, since we are using a Factory Method
    adf.mf.api.AdfObject.ensureClassInitialization(TypeHandler);
    var registeredClass = precreatedClass;

    if (theNamespace != null && theNamespace.indexOf(":") != -1 && tagName != null)
    {
      if (registeredClass == null)
      {
        // Create the new class and make it inherit from adf.mf.api.amx.TypeHandler:
        registeredClass = function RegisteredTypeHandler()
        {
          this.Init();
        };
        adf.mf.api.AdfObject.createSubclass(registeredClass, adf.mf.api.amx.TypeHandler,
          "TypeHandler[" + theNamespace + ":" + tagName + "]");
      }

      // Make the association so we can find the class:
      var id = theNamespace + ":" + tagName;
      this._classDictionary[id] = registeredClass;
    }
    else // invalid registration, do not register the TypeHandler class
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.amx.TypeHandler.register", "MSG_INVALID_TYPE_HANDLER_REGISTRATION",
        theNamespace, tagName);
    }

    return registeredClass;
  };

  /**
   * Renders the initial set of DOM for this component.
   * @param {adf.mf.api.amx.AmxNode} amxNode an object that describes the instance of the component to be rendered
   * @param {string} id the id of this component
   */
  adf.mf.api.amx.TypeHandler.prototype.render = function(amxNode, id)
  {
    if (this.create)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "render", "MSG_DEPRECATED", "typeHandler.render",
        "Use typeHandler.prototype.render instead for " + amxNode.getTag().getNsPrefixedName());
      return this.create(amxNode, id);
    }
    else
    {
      var tag = amxNode.getTag();
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "render",
        "MSG_NO_RENDERER", tag.getNsPrefixedName());

      var rootElement = document.createElement("div");
      rootElement.appendChild(document.createTextNode(
        "Missing prototype.render function in the TypeHandler for the " + tag.getName() +
        " tag in the " + tag.getNamespace() + " namespace; id = " + id));

      return rootElement;
    }
  };

  /**
   * Function that checks to see if the attributes that have changed may be handled
   * by the refresh function. May be overridden to make custom changes to the children
   * due to an attribute change. If the sub-class only needs to react to individual
   * attribute changes, it may override only the attributeChangeResult function
   * instead.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  adf.mf.api.amx.TypeHandler.prototype.updateChildren = function(
    amxNode,
    attributeChanges)
  {
    var changedAttributes = attributeChanges.getChangedAttributeNames();
    var result = adf.mf.api.amx.AmxNodeChangeResult["NONE"];

    for (var i = 0, num = changedAttributes.length; i < num; ++i)
    {
      // The AmxNodeChangeResult is order by the least amount of changes as the lowest
      // number, so using the maximum return value will provide the desired behavior
      result = Math.max(result,
        this.attributeChangeResult(amxNode, changedAttributes[i], attributeChanges));
    }

    return result;
  };

  /**
   * Checks if the type handler can handle updating the DOM in response to a changed
   * attribute. Called from updateChildren. Currently the base implementation supports
   * styleClass and inlineStyle changes to be handled by the refresh function.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {string} attributeName the name of the attribute to check
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  adf.mf.api.amx.TypeHandler.prototype.attributeChangeResult = function(
    amxNode,
    attributeName,
    attributeChanges)
  {
    return attributeName == "styleClass" || attributeName == "inlineStyle" ?
      adf.mf.api.amx.AmxNodeChangeResult["REFRESH"] :
      adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
  };

  /**
   * Called to refresh the HTML of a node. This method is called after the updateChildren
   * method and should be implemented by type handlers that wish to update their DOM in
   * response to a change.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {(adf.mf.api.amx.AmxDescendentChanges|null)} descendentChanges the changes for any
   *        descendent nodes that need to be refreshed.
   */
  adf.mf.api.amx.TypeHandler.prototype.refresh = function(
    amxNode,
    attributeChanges,
    descendentChanges)
  {
    var styleClassChanged = attributeChanges.hasChanged("styleClass");
    var inlineStyleChanged = attributeChanges.hasChanged("inlineStyle");

    if (styleClassChanged || inlineStyleChanged)
    {
      var element = document.getElementById(amxNode.getId());
      if (element != null)
      {
        if (styleClassChanged)
        {
          this._refreshStyleClass(amxNode, attributeChanges, element);
        }

        if (inlineStyleChanged)
        {
          this._refreshInlineStyle(amxNode, attributeChanges, element);
        }
      }
    }
  };

  /**
   * Allows a DOM element to be associated to the AMX node. Necessary for
   * AmxNode.getAmxNodeForElement to function. Calling this method is only necessary
   * if the element is located outside of its parent element or under a different node's
   * element (element is not a direct descendent of a node rendered for the amxNode's
   * root element or its own children elements).
   * @param {adf.mf.api.amx.AmxNode} amxNode the AMX node
   * @param {object} elem the DOM element
   */
  adf.mf.api.amx.TypeHandler.prototype.associateElementWithAmxNode = function(amxNode, elem)
  {
    adf.mf.internal.amx._setNonPrimitiveElementData(elem, "amxNode", amxNode);
    elem.classList.add("amx-node");
  };

  /**
   * Updates the style class of the root DOM element. This function will use the difference from
   * the old value and the new value to determine what style classes to add and which to remove,
   * so all style classes that were added by other code (like the render function of AmxNode) will
   * not be affected.
   *
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {Element} element the DOM element to which to apply the changes
   * @return {boolean} true if the changes were made
   */
  adf.mf.api.amx.TypeHandler.prototype._refreshStyleClass = function(
    amxNode,
    attributeChanges,
    element)
  {
    var oldValue = attributeChanges.getOldValue("styleClass");
    var newValue = amxNode.getAttribute("styleClass");

    oldValue = oldValue == null || oldValue == "" ? [] : oldValue.split(" ");
    newValue = newValue == null || newValue == "" ? [] : newValue.split(" ");

    var i, num, sc;
    var classList = element.classList;

    for (i = 0, num = oldValue.length; i < num; ++i)
    {
      sc = oldValue[i];
      if (newValue.indexOf(sc) == -1 && sc != "")
      {
        classList.remove(sc);
      }
    }

    for (i = 0, num = newValue.length; i < num; ++i)
    {
      sc = newValue[i];
      if (oldValue.indexOf(sc) == -1 && sc != "")
      {
        classList.add(sc);
      }
    }
  };

  /**
   * Called from the refresh function to update the
   * inline style of the root DOM element. This function will use the difference from the old value
   * and the new value to determine what changes to apply. So all style
   * that was added by other code (like the render function of AmxNode) will not be
   * affected.
   *
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {Element} element the DOM element to which to apply the changes
   * @return {boolean} true if the changes were made
   */
  adf.mf.api.amx.TypeHandler.prototype._refreshInlineStyle = function(
    amxNode,
    attributeChanges,
    element)
  {
    var oldValue = attributeChanges.getOldValue("inlineStyle");
    var newValue = amxNode.getAttribute("inlineStyle");
    var style;

    if (adf.mf.environment.profile.dtMode)
    {
      // if adf.mf.environment.profile.dtMode, remove el
      newValue = newValue.replace(/#\{(.*?)\}/ig, ' ');
    }

    var newStyle = null;
    if (oldValue != null && oldValue != "")
    {
      if (style == oldValue)
      {
        newStyle = newValue;
      }
      else
      {
        style = element.getAttribute("style") || "";
        index = style.indexOf(oldValue);
        if (index >= 0)
        {
          var prefix;
          if (index == 0)
          {
            prefix = ""
          }
          else
          {
            prefix = style.substr(0, index);
          }

          var suffix;
          if (index == oldValue.length - 1)
          {
            suffix = "";
          }
          else
          {
            suffix = style.substr(index + oldValue.length);
          }

          newStyle = prefix + newValue + suffix;
        }
      }
    }
    else if (newValue != null && newValue != "")
    {
      style = element.getAttribute("style") || "";
      if (style.length > 0)
      {
        if (style.charAt(style.length - 1) === ";")
        {
          newStyle = style + newValue;
        }
        else
        {
          newStyle = style + ";" + newValue;
        }
      }
      else
      {
        newStyle = newValue;
      }
    }

    if (newStyle != null)
    {
      // Use setAttribute and not style.cssText as Safari will change the style attribute
      // and 'sanitize' the value. While not a bad thing, causes the ability to compare
      // the new value and the old value to be broken. If the style is set via the attribute,
      // the formatting is kept and the value can be used for comparisson
      element.setAttribute("style", newStyle);
    }
  };

  /**
   * DO NOT USE; this method is experimental and will be removed without notice.
   * @param {adf.mf.api.amx.AmxNode} amxNode an object that describes the instance of the component
   * @param {string} amxNodeId the id of this component
   * @param {string} eventType the event type
   * @param {HTMLElement} rootElement the root element of the component
   * @param {boolean} useDocument in some cases, the event node is the document
   */
  adf.mf.api.amx.TypeHandler.prototype.__experimentalCLAssociation = function(
    amxNode,
    amxNodeId,
    eventType,
    rootElement,
    useDocument)
  {
    // DO NOT USE; this method is experimental and will be removed without notice.
    // This is a temporary experiment for TypeHandler-speicfic clientListener implementation.
    // The idea is this can be overridden to connect a listener to a DOM element other than the
    // root (the default element bound to the event).
    adf.mf.api.amx.addBubbleEventListener(
      useDocument ? document : rootElement,
      eventType,
      adf.mf.api.amx.TypeHandler._experimentalCLHandler,
      {
        "amxNode": amxNode,
        "amxNodeId": amxNodeId,
        "eventType": eventType
      });

    if (useDocument)
    {
      // If rootElement is document then the listener could leak so we have to
      // define an __amxRemoveFunctions entry so that it will be cleaned up when
      // the real element is removed:
      if (rootElement.__amxRemoveFunctions == null)
        rootElement.__amxRemoveFunctions = [];
      rootElement.__amxRemoveFunctions.push(
        function()
        {
          adf.mf.api.amx.removeBubbleEventListener(
            document,
            eventType,
            adf.mf.api.amx.TypeHandler._experimentalCLHandler);
        });
    }
  };

  /**
   * DO NOT USE; this method is experimental and will be removed without notice.
   * @param {Object} domEvent the browser's DOM event object
   */
  adf.mf.api.amx.TypeHandler._experimentalCLHandler = function(domEvent)
  {
    var data = domEvent.data;
    var amxNode = data["amxNode"];
    var amxNodeId = data["amxNodeId"];
    var eventType = data["eventType"];
    var event = new adf.mf.api.amx.DomEvent(amxNodeId, eventType, domEvent);
    adf.mf.api.amx.processAmxEvent(amxNode, eventType, undefined, undefined, event, function() {});
  };

  /**
   * Gets the attribute to be used for validation. If a non-null value is returned, the
   * AmxNode's storeModifyableEl method will be called for this attribute, so it is not necessary
   * for the type handler to manually call this method.
   *
   * @return {string|null} the name of the attribute to use for validation. By default null is
   *         returned.
   */
  adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute = function()
  {
    return null;
  };

  // ------ /TypeHandler ------ //

  // ------ AmxNode enums ------ //
  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeStates =
  {
    /** Initial state. The node has been created but not populated */
    "INITIAL": 0,
    /** EL based attributes needed for rendering have not been fully loaded yet */
    "WAITING_ON_EL_EVALUATION": 1,
    /** EL attributes have been loaded, the node has not yet been rendered */
    "ABLE_TO_RENDER": 2,
    /**
     * The EL is not fully loaded but the node has partially rendered itself (reserved for future
     * use)
     */
    "PARTIALLY_RENDERED": 3,
    /** The node has been fully rendered */
    "RENDERED": 4,
    /** The node is not to be rendered */
    "UNRENDERED": 5,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the state label for a state value
     *
     * @param {int} state one of the node state values
     * @return {string|null} the label or null if not a valid state
     */
    getLabelForValue: function(state)
    {
      for (var label in adf.mf.api.amx.AmxNodeStates)
      {
        if (adf.mf.api.amx.AmxNodeStates[label] == state)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeChangeResult =
  {
    /**
     * Allows a type handler that is rendered to take no action in response to an attribute change
     * on a non-rendered descendent AMX node.
     */
    "NONE": 0,

    /**
     * The type handler is able to handle the change to AMX node and its children AMX nodes and
     * will be able to update DOM in response to a change after a call to the refresh method.
     */
    "REFRESH": 1,

    /**
     * The type handler is able to handle the change to the AMX node and its children AMX nodes,
     * but the HTML should only be recreated, there is no need to modify the node hierarchy. The
     * refresh method will not be called on the type handler.
     */
    "RERENDER": 2,

    /**
     * The type handler cannot handle the change. The HTML as well as the
     * node hierarchy should be recreated. This value may only be returned from the updateChildren
     * method on a type handler and cannot be returned from the getDescendentChangeAction method.
     */
    "REPLACE": 3,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the label for a constant value
     *
     * @param {int} result one of the change result values
     * @return {string|null} the label or null if not a valid change result
     */
    getLabelForValue: function(result)
    {
      for (var label in adf.mf.api.amx.AmxNodeChangeResult)
      {
        if (adf.mf.api.amx.AmxNodeChangeResult[label] == result)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeCreateChildrenNodesResult =
  {
    /**
     * The type handler could not create the children yet.
     */
    "NONE": 0,

    /**
     * The type handler created the children.
     */
    "HANDLED": 1,

    /**
     * The type handler generated a placeholder to be shown until the real children can be created.
     */
    "DEFERRED": 2,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the label for a constant value
     *
     * @param {int} result one of the children node result values
     * @return {string|null} the label or null if not a valid result
     */
    getLabelForValue: function(result)
    {
      for (var label in adf.mf.api.amx.AmxNodeCreateChildrenNodesResult)
      {
        if (adf.mf.api.amx.AmxNodeCreateChildrenNodesResult[label] == result)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeNotifications =
  {
    /**
     * Notification type broadcast to a type handler when an AMX node is about to be removed from
     * the node hierarchy.
     */
    "PRE_REMOVAL": 0,
    /**
     * Notification type broadcast to a type handler when an AMX node is going from a rendered to an
     * unrendered state.
     */
    "UNRENDERED": 1
  };
  // ------ /Node enums ------ //

  // ------ Visit ------ //
  /**
   * Constant values for visit results.
   * @namespace
   */
  adf.mf.api.amx.VisitResult =
  {
    /** Continue visiting the children of the current node. */
    "ACCEPT": 0,
    /** Skip the children of the current node but continue visiting. */
    "REJECT": 1,
    /** Stop visiting */
    "COMPLETE": 2
  };

  /**
   * A visit context object to direct tree visitation.
   * <p>
   * Parameter properties:
   * <dl>
   *   <dt>amxNodes</dt>
   *   <dd>An array of AMX nodes to visit</dd>
   * </dl>
   * @param {{amxNodes: Array.<adf.mf.api.amx.AmxNode>, data: Object}} params An object
   *        containing key/value pairs to populate the visit context. If the "data" object
   *        is passed, it may be retrieved in the callback via the "data" field value.
   * @constructor adf.mf.api.amx.VisitContext
   */
  function VisitContext(params)
  {
    this._walk = null;
    this._visit = null;

    if (params != null)
    {
      // Allow custom data to be stored on the context
      this.data = params["data"];

      var nodes = params["amxNodes"];
      if (nodes != null)
      {
        this._visit = nodes;
        this._walk = [];
        for (var i = 0, size = nodes.length; i < size; ++i)
        {
          for (var n = nodes[i]; n != null; n = n.getParent())
          {
            if (this._walk.indexOf(n) >= 0)
            {
              break;
            }

            this._walk.push(n);
          }
        }
      }
    }
    else
    {
      this.data = null;
    }
  }

  adf.mf.api.amx.VisitContext = VisitContext;

  adf.mf.api.amx.VisitContext.prototype =
  {
    /**
     * Get if all nodes should be visited.
     * @return {boolean} true if all nodes should be visited
     */
    isVisitAll: function()
    {
      return this._visit == null;
    },

    /**
     * Get the nodes that should be walked during visitation. This list does not necessarily
     * include the nodes that should be visited (callback invoked).
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that should be walked.
     */
    getNodesToWalk: function()
    {
      return this._walk;
    },

    /**
     * Get the list of nodes to visit.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that should be visited.
     */
    getNodesToVisit: function()
    {
      return this._visit;
    },

    /**
     * Convenience function to determine what child AMX nodes, including facets, if any,
     * should be walked of the given parent AMX node. Allows for type handlers to optimize how to
     * walk the children if not all are being walked.
     *
     * @param {adf.mf.api.amx.AmxNode} parentNode the parent node
     * @return {(Array.<adf.mf.api.amx.AmxNode>|null)} array of the children to walk, may be empty.
     *         returns null if all the children should be visited (isVisitAll is true)
     */
    getChildrenToWalk: function(parentNode)
    {
      if (this._walk == null)
      {
        return null;
      }

      return this._walk.filter(
        function(node, index, array)
        {
          return node.getParent() == parentNode;
        });
    }
  };
  // ------ /Visit ------ //

  // ------ AMX Collection change ------ //
  function AmxCollectionChange(data)
  {
    this._itemized = data["itemized"];
    this._hasMoreKeysChanged = data["hasMoreKeysChanged"] == true;

    if (this._itemized)
    {
      this._created = [];
      this._deleted = [];
      this._updated = [];
      this._dirtied = [];

      var i;
      var size;

      var created = data["created"];
      if (created != null)
      {
        for (i = 0, size = created.length; i < size; ++i)
        {
          var obj = created[i];
          this._created.push(obj["key"]);
          // Note: In a future version we may need to pull more information off of the "obj"
        }
      }

      var updated = data["updated"];
      if (updated != null)
      {
        for (i = 0, size = updated.length; i < size; ++i)
        {
          this._updated.push(updated[i]);
        }
      }

      var deleted = data["deleted"];
      if (deleted != null)
      {
        for (i = 0, size = deleted.length; i < size; ++i)
        {
          this._deleted.push(deleted[i]);
        }
      }

      var dirtied = data["dirtied"];
      if (dirtied != null)
      {
        for (i = 0, size = dirtied.length; i < size; ++i)
        {
          this._dirtied.push(dirtied[i]);

          // It is possible for the embedded side to send both dirtied and updated
          // at the same time. Check for this, and remove the key from the updated
          // if present
          var index = this._updated.indexOf(dirtied[i]);
          if (index >= 0)
          {
            this._updated.splice(index, 1);
          }
        }
      }
    }
  }

  adf.mf.api.amx.AmxCollectionChange = AmxCollectionChange;

  AmxCollectionChange.prototype =
  {
    /**
     * Return true if the flag has changed marking if more rows are available or not
     * has changed state.
     */
    hasMoreKeysChanged: function()
    {
      return this._hasMoreKeysChanged;
    },

    /**
     * Return if the change to the collection may be itemized
     * @return {boolean} true if the change may be itemized
     */
    isItemized: function()
    {
      return this._itemized;
    },

    /**
     * Get an array of the keys that were created.
     * @return {Array.<string>|null} created keys or null if the change cannot be itemized
     */
    getCreatedKeys: function()
    {
      return this._itemized ? this._created : null;
    },

    /**
     * Get an array of the keys that were removed.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getDeletedKeys: function()
    {
      return this._itemized ? this._deleted : null;
    },

    /**
     * Get an array of the keys that were updated.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getUpdatedKeys: function()
    {
      return this._itemized ? this._updated : null;
    },

    /**
     * Get an array of the keys that were dirtied.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getDirtiedKeys: function()
    {
      return this._itemized ? this._dirtied : null;
    }
  };
  // ------ /AMX Collection change ------ //


  // ------ AMX Attribute change ------ //
  /**
   * Object to allow type handlers to determine the changes that have been made during a data change
   * event.
   */
  function AmxAttributeChange()
  {
    this._changedAttributes = {};
    this._oldValues = {};
    this._length = 0;
    this._collectionChanges = {};
    this._custom = {};
  }
  adf.mf.api.amx.AmxAttributeChange = AmxAttributeChange;

  AmxAttributeChange.prototype =
  {
    /**
     * Get a custom value stored by setCustomValue
     * @param {string} key the key
     * @return {(Object|null)} the object or null if not set
     */
    getCustomValue: function(key)
    {
      return this._custom[key];
    },

    /**
     * Set a custom value. This is useful for a type handler to "pass" information between the
     * updateChildren method and the refresh method.
     * @param {string} key the key
     * @param {Object} value the value to store
     */
    setCustomValue: function(key, value)
    {
      return this._custom[key] = value;
    },

    /**
     * Get the names of the attributes that have been affected during the current change.
     * @return {Array.<string>} array of the attribute names
     */
    getChangedAttributeNames: function()
    {
      return Object.keys(this._changedAttributes);
    },

    /**
     * Check if the attribute change is a collection change
     * @param {string} name the attribute name
     * @return {boolean} true if the change is a collection change
     */
    isCollectionChange: function(name)
    {
      return this._collectionChanges[name] != null;
    },

    /**
     * Get the collection model change information for an attribute
     * @param {string} name the attribute name
     * @return {(adf.mf.api.amx.AmxCollectionChange|null)} the change object if available
     */
    getCollectionChange: function(name)
    {
      var change = this._collectionChanges[name];
      return change == null ? null : change;
    },

    /**
     * Get the value of the attribute before the change was made
     * @param {string} name the attribute name
     */
    getOldValue: function(name)
    {
      return this._oldValues[name];
    },

    /**
     * Check if the attribute with the given name has changed.
     * @param {string} name the attribute name
     */
    hasChanged: function(name)
    {
      return this._changedAttributes[name] == true;
    },

    /**
     * Get the number of attribute changes
     */
    getSize: function()
    {
      return this._length;
    },

    /**
     * Mark an attribute as having been changed
     * @param {string} name the attribute name
     * @param {Object} oldValue the attribute's old value
     * @param {(adf.mf.api.amx.AmxCollectionChange|null)} collectionChanges the collection model
     *        change information if applicable
     * @ignore
     */
    __addChangedAttribute: function(name, oldValue, collectionChanges)
    {
      if (this.hasChanged(name) == false)
      {
        ++this._length;
        this._changedAttributes[name] = true;
      }
      this._oldValues[name] = oldValue;

      if (collectionChanges != null)
      {
        this._collectionChanges[name] = collectionChanges;
      }
    }
  };
  // ------ /AMX Attribute change ------ //

  // ------ AMX children changes ------ //
  function AmxDescendentChanges()
  {
    this._amxNodes = [];
    this._amxNodeChanges = {};
    this._previousStates = {};
  }

  adf.mf.api.amx.AmxDescendentChanges = AmxDescendentChanges;

  AmxDescendentChanges.prototype =
  {
    /**
     * Get the un-rendered changed descendent AMX nodes.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes that have changed
     */
    getAffectedNodes: function()
    {
      return this._amxNodes;
    },

    /**
     * Get the changes for a given AMX node.
     * @param {adf.mf.api.amx.AmxNode} amxNode the descendent AMX node that was changed
     * @return {adf.mf.api.amx.AmxAttributeChange} the changes that were made to the descendent node
     */
    getChanges: function(amxNode)
    {
      var id = amxNode.getId();
      return this._amxNodeChanges[id];
    },

    /**
     * Get the state of the descendent node before the changes were applied.
     * @param {adf.mf.api.amx.AmxNode} amxNode the descendent AMX node that was changed
     * @return {number} one of the adf.mf.api.amx.AmxNodeStates constant values
     */
    getPreviousNodeState: function(amxNode)
    {
      var id = amxNode.getId();
      return this._previousStates[id];
    },

    __addAmxNode: function(
      amxNode,
      previousState,
      attributeChanges)
    {
      var id = amxNode.getId();
      this._amxNodes.push(amxNode);
      this._previousStates[id] = previousState;
      this._amxNodeChanges[id] = attributeChanges;
    }
  };
  // ------ /AMX children changes ------ //

})();
// ------ /amx UI ------ //

// --------- amx UA --------- //
(function()
{
  var _hasTouch = null;

  amx.hasTouch = function()
  {
    if (_hasTouch === null)
    {
      _hasTouch = isEventSupported("touchstart");

      if (_hasTouch &&
        adf.mf.environment.profile.mockData &&
        navigator.userAgent.indexOf("Windows") != -1)
      {
        // Mock mode for browsers (e.g. Chrome) on UWP is better when using mouse events:
        _hasTouch = false;
      }
    }
    return _hasTouch;
  };

  var isEventSupported = (function()
  {
    var TAGNAMES =
    {
      'select' : 'input',
      'change' : 'input',
      'submit' : 'form',
      'reset' : 'form',
      'error' : 'img',
      'load' : 'img',
      'abort' : 'img'
    };

    function isEventSupported(eventName)
    {
      var el = document.createElement(TAGNAMES[eventName] || 'div');
      eventName = 'on' + eventName;
      var isSupported = (eventName in el);
      if (!isSupported)
      {
        el.setAttribute(eventName, 'return;');
        isSupported = typeof el[eventName] == 'function';
      }
      el = null;
      return isSupported;
    }
    return isEventSupported;
  })();
})();
// --------- /amx UA --------- //

// --------- Utilities --------- //
(function()
{
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

  amx.uuid = function(len)
  {
    len = len || 10;
    var chars = CHARS, uuid = [];
    var radix = chars.length;

    for (var i = 0; i < len; i++)
      uuid[i] = chars[0 | Math.random()*radix];

    return uuid.join('');
  };

  amx.arrayRemove = function(a, from, to)
  {
    var rest = a.slice((to || from) + 1 || a.length);
    a.length = from < 0 ? a.length + from : from;
    return a.push.apply(a, rest);
  };

  /**
   * @deprecated use adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute instead
   */
  amx.registerInputValue = function(amxNode, attrName)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "registerInputValue",
      "MSG_DEPRECATED", "amx.registerInputValue",
      "adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute");

    // Mirror the code in AmxNode's _setupInputValueValidation without calling the type handler
    if (amxNode._attributeToValidate === undefined)
    {
      amxNode._attributeToValidate = attrName;
      amxNode.storeModifyableEl(attrName);
    }
  };

  /**
   * Rendrer would call this function to change the style of showRequired attribute
   * @param {Object} amxNode This is the amxNode object
   * @param {Object} field This object is returned from createField method and must have a
   *   "fieldRoot" property
   * @see See also the definition of amx.createField method inside amx-commonTags.js
   */
  adf.mf.api.amx.applyRequiredMarker = function(amxNode, field)
  {
    if (adf.mf.api.amx.isValueTrue(amxNode.getAttribute("showRequired")) ||
      adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
    {
      field.fieldRoot.classList.add("required");
    }
  };

  // safely return the value, handling json null objects,
  // undefined objects, and null objects by returning null
  amx.getObjectValue = function(value)
  {
    if (value == null)
    {
      return null;
    }

    if (typeof value === "undefined")
    {
      return null;
    }

    if (typeof value[".null"] !== "undefined")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "getObjectValue",
        "MSG_UNHANDLED_NULL");

      if (value[".null"] == true)
      {
        return null;
      }
    }

    return value;
  };

  /**
   * Get the value as a string. Null or undefined objects will
   * be returned as an empty string.
   * @param {Object} value the value
   * @return {string} the value as a string.
   */
  amx.getTextValue = function(value)
  {
    value = amx.getObjectValue(value);
    if (value == null)
    {
      return "";
    }

    // Ensure the value is a string
    return "" + value;
  };

  // Gets the amx_dtfolderpath if it is on the URL
  amx.getDtFolderPath = function()
  {
    var queryString = adf.mf.api.getQueryString();
    var amx_dtfolderpath = adf.mf.api.getQueryStringParamValue(queryString, "amx_dtfolderpath", null);
    return amx_dtfolderpath;
  };

  // Builds a string that is the relative path to
  // the folder containing the amx page we are currently
  // viewing.
  amx.currentPageContainingFolder = function()
  {
    try
    {
      // Check for DT folder path
      var amx_dtfolderpath = amx.getDtFolderPath();
      if(amx_dtfolderpath !== null)
      {
        return amx_dtfolderpath;
      }
      // Get current amx filename
      var amxPage = adf.mf.internal.controller.ViewHistory.peek().amxPage;
      // Break up the filename so we can get the length
      // of just the filename.
      var parts = amxPage.split("/");
      // Add the feature root prefix to the filename
      var amxPageFullPath = adfc.Util.addFeatureRootPrefix(amxPage);
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "amx.currentPageContainingFolder", "MSG_CURRENT_PAGE_FOLDER_FAILED");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "amx", "currentPageContainingFolder", ex);

      return "";
    }
    // Strip off the filename
    return amxPageFullPath.substr(0,
      amxPageFullPath.length - parts[parts.length - 1].length);
  };

  // Determines if the tartget string has a protocol
  amx.hasProtocol = function(url)
  {
    return /^(:?ms-app*|\w+:)/.test(url);
  };

  // Builds the relative path based to the specified
  // resource assuming it is relative to the current
  // amx page.  If there is a protocol on the resource
  // then it is assumed to be an absolute path and
  // left unmodified
  amx.buildRelativePath = function(url)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "buildRelativePath",
      "MSG_DEPRECATED", "amx.buildRelativePath", "adf.mf.api.amx.buildRelativePath");

    return adf.mf.api.amx.buildRelativePath.apply(this, arguments);
  };

  /**
   * Builds the relative path based to the specified resource assuming it is relative to the current
   * AMX page. If there is a protocol on the resource then it is assumed to be an absolute path and
   * left unmodified.
   * @param {string} url the location of the specified resource
   * @return {string} the resolved path
   */
  adf.mf.api.amx.buildRelativePath = function(url)
  {
    if(amx.hasProtocol(url))
    {
      return url;
    }

    url = url.replace("\\", "/");
    if(url.charAt(0) == "/")
    {
        // Check for DT folder path
        var amx_dtfolderpath = amx.getDtFolderPath();
        if (amx_dtfolderpath !== null)
        {
            var publicHtmlString = 'public_html/';
            var publicHtmlIndex    = amx_dtfolderpath.indexOf(publicHtmlString);

            return (amx_dtfolderpath.substring(0, publicHtmlIndex + publicHtmlString.length)) + url.substring(1);
        }
        else
        {
            return adfc.Util.addFeatureRootPrefix(url.substring(1));
        }
    }

    return amx.currentPageContainingFolder() + url;
  };

  /**
   * Adds a CSS className to the dom node if it doesn't already exist in the classNames list and
   * returns <code>true</code> if the class name was added.
   * @param {HTMLElement} domElement DOM Element to add style class name to
   * @param {string} className Name of style class to add
   * @return {boolean} <code>true</code> if the style class was added
   * @deprecated Use domElement.classList.add instead.
   */
  adf.mf.internal.amx.addCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.addCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.addCSSClassName",
      "domElement.classList.add");

    // TODO AdfAssert.assertDomElement(domElement);
    var added = false;

    if (className != null)
    {
      var classNames = className.split(" ");
      for (var i = 0, num = classNames.length; i < num; ++i)
      {
        var className = classNames[i];
        if (!domElement.classList.contains(className))
        {
          domElement.classList.add(className);
          added = true;
        }
      }
    }

    return added;
  };

  /**
   * Removes a CSS className to the dom node if it existd in the classNames list and
   * returns <code>true</code> if the class name was removed.
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className Name of style class to remove
   * @return {boolean} <code>true</code> if the style class was removed
   * @deprecated Use domElement.classList.remove instead.
   */
  adf.mf.internal.amx.removeCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.removeCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.removeCSSClassName",
      "domElement.classList.remove");
    // TODO AdfAssert.assertDomElement(domElement);

    var removed = false;

    if (className != null)
    {
      var classNames = className.split(" ");
      for (var i = 0, num = classNames.length; i < num; ++i)
      {
        var className = classNames[i];
        if (domElement.classList.contains(className))
        {
          domElement.classList.remove(className);
          removed = true;
        }
      }
    }

    return removed;
  };

  /**
   * Convenient function to add or removes a CSS className from the dom node. Will be deprecated
   * once all supported browsers support the classList.toggle function fully (IE 10 and 11
   * do not support the second argument of toggle).
   *
   * @param {boolean} add boolean value if we should do an add of a CSS className
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className the CSS className which should be added or removed
   * @return {boolean} <code>true</code> if the element's style class list changed
   */
  adf.mf.internal.amx.addOrRemoveCSSClassName = function(
    add,
    domElement,
    className) // TODO move into some "domutils" class
  {
    // For backward compatibility usage, check for spaces in the name
    var classNames = className.split(" ");

    var contains = false;
    var num = classNames.length;
    var classList = domElement.classList;

    for (var i = 0; i < num; ++i)
    {
      if (classList.contains(classNames[i]))
      {
        contains = true;
        break;
      }
    }


    if (add && !contains)
    {
      classList.add.apply(classList, classNames);
      return true;
    }
    else if (!add && contains)
    {
      classList.remove.apply(classList, classNames);
      return true;
    }

    return false;
  };

  /**
   * Check if the dom node contains the className
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className Name of style class to remove
   * @return {boolean} <code>true</code> if the style class is on the domElement
   * @deprecated Use domElement.classList.contains instead.
   */
  adf.mf.internal.amx.containsCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.containsCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.containsCSSClassName",
      "domElement.classList.contains");
    var classNames = className.split(" ");
    var containsAll = true;

    for (var i = 0, num = classNames.length; i < num; ++i)
    {
      var className = classNames[i];
      if (!domElement.classList.contains(className))
      {
        containsAll = false;
        break;
      }
    }

    return containsAll;
  };

  /**
   * Returns the index at which <code>className</code> appears within <code>currentClassName</code>
   * with either a space or the beginning or end of <code>currentClassName</code> on either side.
   * This function optimizes the runtime speed by not creating objects in most cases and assuming
   * 1) It is OK to only check for spaces as whitespace characters
   * 2) It is rare for the searched className to be a substring of another className, therefore
   *    if we get a hit on indexOf, we have almost certainly found our className
   * 3) It is even rarer for the searched className to be a substring of more than one className,
   *    therefore, repeating the search from the end of the string should almost always either return
   *    our className or the original search hit from indexOf
   * @param {string} currentClassName Space-separated class name string to search
   * @param {string} className String to search for within currentClassName
   * @return {number} index of className in currentClassName, or -1 if it doesn't exist
   * @deprecated Use domElement.classList instead.
   */
  adf.mf.internal.amx.getCSSClassNameIndex = function(currentClassName, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.getCSSClassNameIndex", "MSG_DEPRECATED",
      "adf.mf.internal.amx.getCSSClassNameIndex",
      "domElement.classList");
    // if no current class
    if (!currentClassName)
      return -1;
    else
    {
      // if the strings are equivalent, then the start index is the beginning of the string
      if (className === currentClassName)
        return 0;
      else
      {
        var classNameLength = className.length;
        var currentClassNameLength = currentClassName.length;

        // check if our substring exists in the string at all
        var nameIndex = currentClassName.indexOf(className);

        // if our substring exists then our class exists if either:
        // 1) It is at the beginning of the classNames String and has a following space
        // 2) It is at the end of the classNames String and has a leading space
        // 3) It has a space on either side
        if (nameIndex >= 0)
        {
          var hasStart = (nameIndex == 0) || (currentClassName.charAt(nameIndex - 1) == " ");
          var endIndex = nameIndex + classNameLength;
          var hasEnd = (endIndex == currentClassNameLength) || (currentClassName.charAt(endIndex) == " ");

          //one of the three condition above has been met so our string is in the parent string
          if (hasStart && hasEnd)
            return nameIndex;
          else
          {
            // our substring exists in the parent string but didn't meet the above conditions,  Were
            // going to be lazy and retest, searchig for our substring from the back of the classNames
            // string
            var lastNameIndex = currentClassName.lastIndexOf(className);

            // if we got the same index as the search from the beginning then we aren't in here
            if (lastNameIndex != nameIndex)
            {
              // recheck the three match cases
              hasStart = currentClassName.charAt(lastNameIndex - 1);
              endIndex = lastNameIndex + classNameLength;
              hasEnd =  (endIndex == currentClassNameLength) || (currentClassName.charAt(endIndex) == " ");

              if (hasStart && hasEnd)
                return lastNameIndex;
              else
              {
                // this should only happen if the searched for className is a substring of more
                // than one className in the classNames list, so it is OK for this to be slow.  We
                // also know at this point that we definitely didn't get a match at either the very
                // beginning or very end of the classNames string, so we can safely append spaces
                // at either end
                return currentClassName.indexOf(" " + className + " ");
              }
            }
          }
        }

        // no match
        return -1;
      }
    }
  };

  /**
   * Returns the element's right side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's right side position in Window coordinates
   */
  adf.mf.internal.amx.getElementRight = function(domElement) // TODO move into some "agent" class
  {
    var documentElementOffsetWidth = document.documentElement.offsetWidth;
    var domElementOffsetWidth = domElement.offsetWidth;
    var domElementLeft = adf.mf.internal.amx.getElementLeft(domElement);
    var domElementRight = documentElementOffsetWidth - domElementLeft - domElementOffsetWidth;
    return domElementRight;
  };

  /**
   * Returns the element's left side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's left side position in Window coordinates
   */
  adf.mf.internal.amx.getElementLeft = function(domElement) // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return adf.mf.internal.amx._webkitGetElementLeft(domElement);
    return adf.mf.internal.amx._baseGetElementLeft(domElement);
  };

  adf.mf.internal.amx._baseGetElementLeft = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomNode(element);

    var bodyElement = element.ownerDocument.body;
    var currParent  = element.offsetParent;
    var currLeft    = element.offsetLeft;

    while (currParent)
    {
      element = currParent;
      currLeft += element.offsetLeft;

      if (element != bodyElement)
        currLeft -= element.scrollLeft;

      currParent = currParent.offsetParent;
    }

    return currLeft;
  };

  adf.mf.internal.amx._webkitGetElementLeft = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomElement(element);

    // getBoundingClientRect was added in safari 4, webkit version 533
    // just look for the API versus the version
    if (!element.getBoundingClientRect)
      return this._baseGetElementLeft(element);

    var boundingRect = element.getBoundingClientRect();
    var elemLeft = boundingRect.left;
    var docElement = element.ownerDocument.documentElement;

    // adjust for the document scroll positions and window borders
    elemLeft -= (docElement.clientLeft - adf.mf.internal.amx.getBrowserViewportScrollLeft());
    return elemLeft;
  };

  /**
   * Returns the element's top side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's top side position in Window coordinates
   */
  adf.mf.internal.amx.getElementTop = function(domElement) // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return adf.mf.internal.amx._webkitGetElementTop(domElement);
    return adf.mf.internal.amx._baseGetElementTop(domElement);
  };

  adf.mf.internal.amx._baseGetElementTop = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomNode(element);

    var bodyElement = element.ownerDocument.body;
    var currParent  = element.offsetParent;
    var currTop     = element.offsetTop;

    //In safari/opera position absolute incorrectly account for body offsetTop
    if (adf.mf.internal.amx.getComputedStyle(element).position == "absolute")
    {
      currTop -= bodyElement.offsetTop;
    }

    while (currParent)
    {
      element = currParent;
      currTop += element.offsetTop;

      if (element != bodyElement)
        currTop -= element.scrollTop;

      currParent = currParent.offsetParent;
    }

    return currTop;
  };

  adf.mf.internal.amx._webkitGetElementTop = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomElement(element);

    // getBoundingClientRect was added in safari 4, webkit version 533
    // just look for the API versus the version
    if (!element.getBoundingClientRect)
      return adf.mf.internal.amx._baseGetElementTop(element);

    var boundingRect = element.getBoundingClientRect();
    var elemTop = boundingRect.top;
    var docElement = element.ownerDocument.documentElement;

    // adjust for the document scroll positions and window borders
    elemTop -= (docElement.clientTop - adf.mf.internal.amx.getBrowserViewportScrollTop());
    return elemTop;
  };

  /**
   * @return {Number} returns the starting position on the canvas of the viewport
   */
  adf.mf.internal.amx.getBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return this._webkitGetBrowserViewportScrollLeft();
    return this._baseGetBrowserViewportScrollLeft();
  };

  adf.mf.internal.amx._baseGetBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    return document.documentElement.scrollLeft;
  };

  adf.mf.internal.amx._webkitGetBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    return document.body.scrollLeft;
  };

  /**
   * @return {Number} returns the top position on the canvas the viewport begins
   */
  adf.mf.internal.amx.getBrowserViewportScrollTop = function() // TODO use adf.mf.internal.amx.getBrowserViewportScrollTop
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return this._webkitGetBrowserViewportScrollTop();
    return this._baseGetBrowserViewportScrollTop();
  };

  adf.mf.internal.amx._baseGetBrowserViewportScrollTop = function() // TODO move into some "agent" class
  {
    return document.documentElement.scrollTop;
  };

  adf.mf.internal.amx._webkitGetBrowserViewportScrollTop = function() // TODO move into some "agent" class
  {
    return document.body.scrollTop;
  };

  /**
   * Tries to return the current style, taking into account the inline styles and style sheets.
   * @param {HTMLElement} element the element in question
   * @param {string} pseudoElement the name of the pseudo-element e.g. ":after" or null if not applicable
   * @return {Object} the style computed style object
   */
  adf.mf.internal.amx.getComputedStyle = function(element, pseudoElement) // TODO move into some "agent" class
  {
    return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElement);
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
   * Called from our test code
   * @export
   * @param {DOMNode} ancestorNode the potential ancestor or possibly same node as the descendant
   * @param {DOMNode} node the potential descendant or same node as the ancestor
   * @return whether the ancestorNode is an ancestor of the node or they are the same nodes
   */
  adf.mf.internal.amx.isAncestorOrSelf = function(ancestorNode, node)
  {
    return (node == ancestorNode) ? true : adf.mf.internal.amx.isAncestor(ancestorNode, node);
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node".
   * @param {DOMNode} ancestorNode the potential ancestor
   * @param {DOMNode} node the potential descendant
   * @return whether the ancestorNode is an ancestor of the node
   */
  adf.mf.internal.amx.isAncestor = function(ancestorNode, node)
  {
    if (node == null)
      return false;
    var parentNode = node.parentNode;
    while (parentNode)
    {
      if (parentNode == ancestorNode)
        return true;
      parentNode = parentNode.parentNode;
    }
    return false;
  };

  /**
   * Temporary solution for getting non-primitive element data.
   * @param {HTMLElement} domElement the DOM element the data is associated with
   * @param {string} key the data key
   * @return {Object} the non-primitive data
   * @private
   */
  adf.mf.internal.amx._getNonPrimitiveElementData = function(domElement, key)
  {
    if (domElement == null) return undefined;
    if (domElement._amxNonPrimitiveData == null)
      return undefined;
    return domElement._amxNonPrimitiveData[key];
  };

  /**
   * Temporary solution for setting non-primitive element data.
   * @param {HTMLElement} domElement the DOM element the data is associated with
   * @param {string} key the data key
   * @param {Object} nonPrimitiveData the non-primitive data
   * @private
   */
  adf.mf.internal.amx._setNonPrimitiveElementData = function(domElement, key, nonPrimitiveData)
  {
    if (domElement == null) return;
    if (domElement._amxNonPrimitiveData == null)
      domElement._amxNonPrimitiveData = {};
    domElement._amxNonPrimitiveData[key] = nonPrimitiveData;
  };

  /**
   * Adds padding to a number string.  Does nothing if number is longer than paddingLength.
   * @param {number} number to be padded
   * @param {number} paddingLength specifies length to which to pad
   * @return {string} padded number at least paddingLength long
   */
  adf.mf.internal.amx.addPadding = function(number, paddingLength)
  {
    var padded = "" + number;
    for (var i = padded.length; i < paddingLength; ++i)
    {
      padded = "0" + padded;
    }
    return padded;
  };

  /**
   * Extracts time portion from date object and returns it as "HH:mm:ss"
   * @param {Date} dateObject
   * @return {string} returns time as "HH:mm:ss"
   */
  adf.mf.internal.amx.extractTimeFromDateObject = function(dateObject)
  {
    var time = adf.mf.internal.amx.addPadding(dateObject.getHours(), 2) + ":" +
      adf.mf.internal.amx.addPadding(dateObject.getMinutes(), 2) + ":" +
      adf.mf.internal.amx.addPadding(dateObject.getSeconds(), 2) + "." +
      adf.mf.internal.amx.addPadding(dateObject.getMilliseconds(), 3);
    return time;
  };

  /**
   * Extracts date portion from date object and returns it as "yyyy-MM-dd"
   * @param {Date} dateObject
   * @return {string} returns date as "yyyy-MM-dd"
   */
  adf.mf.internal.amx.extractDateFromDateObject = function(dateObject)
  {
    var time = adf.mf.internal.amx.addPadding(dateObject.getFullYear(), 4) + "-" +
      adf.mf.internal.amx.addPadding(dateObject.getMonth() + 1, 2) + "-" +
      adf.mf.internal.amx.addPadding(dateObject.getDate(), 2);
    return time;
  };

  /**
   * Updates time portion of date object with given time.
   * @param {Date} dateObject is the Date to be updated
   * @param {string} time is a string with this format: "hh:mm"
   */
  adf.mf.internal.amx.updateTime = function(dateObject, time)
  {
    if (time != null && typeof time !== "undefined" && time.length > 4)
    {
      var h = time.substring(0,2);
      var m = time.substring(3,5);
      dateObject.setHours(h);
      dateObject.setMinutes(m);
    }
  };

  /**
   * Updates date portion of date object with given date.
   * @param {Date} dateObject is the Date to be updated
   * @param {string} date is a string with this format: "yyyy-MM-dd".  The year must be full length (e.g. 1999, not 99)
   */
  adf.mf.internal.amx.updateDate = function(dateObject, date)
  {
    if (date != null && typeof date !== "undefined" && date.length > 9)
    {
      var i = date.indexOf("-");
      if (i > 3)
      {
        var year = date.substring(0, i);
        var j = date.indexOf("-", i+1);
        if (j > -1)
        {
          var month = date.substring(i+1, j) - 1;
          var day = date.substring(j+1, date.length);
          dateObject.setFullYear(year);
          dateObject.setMonth(month);
          dateObject.setDate(day);
        }
      }
    }
  };

  /**
   * Check if an object implements a function
   *
   * @param {(Object|null)} obj the object to check.
   * @param {string} name the name of the function to look for
   * @return {boolean} true if the object is non-null and implements a function by the given name
   */
  adf.mf.internal.amx.implementsFunction = function(
    obj,
    name)
  {
    return obj != null && typeof obj[name] === "function";
  };

  adf.mf.internal.NONBLOCKING_CALL_COUNTER = 0;
  adf.mf.internal.pushNonBlockingCall = function()
  {
    ++adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };

  adf.mf.internal.popNonBlockingCall = function()
  {
    --adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };

  adf.mf.internal.getUnresolvedCallDepth = function()
  {
    return adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };
}) ();
/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* --------------------- amx-event.js ------------------- */
/* ------------------------------------------------------ */

(function()
{
  var _currentFocusDomNode = null;
  var _focusBlurEventData = {}; // allows these focus/blur events to be unique from other focus/blur events

  /**
   * Internal method to bind to the focus method and be notified when another control gains focus
   */
  adf.mf.internal.amx.registerFocus = function(domNode, callback)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "focus",
      function(event)
      {
        // register this node in order to receive events when another control is tapped
        _currentFocusDomNode = domNode;
        if (callback)
        {
          callback(event);
        }
      },
      _focusBlurEventData);
  };

  /**
   * Internal method to bind to the blur method and be notified when another control gains focus
   */
  adf.mf.internal.amx.registerBlur = function(domNode, callback)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "blur",
      function(event)
      {
        // unregister this node - no more need to receive events when another control is tapped
        if (_currentFocusDomNode == domNode)
        {
          _currentFocusDomNode = null;
        }
        if (callback)
        {
          callback(event);
        }
      },
      _focusBlurEventData);
  };

  // this method calls blur on the currentFocus node
  // in order to give it a chance to saved its internal changes
  // first we will blur the node in order to trigger value change events etc
  // then we restore focus back so that we don't accidently cause the user to get the
  // wrong focus - due to keyboard hiding/showing in other words, so that the touchstart &
  // touchend events occur on the same element
  function blurCurrentNode()
  {
    var oldCurrentNode = _currentFocusDomNode;
    var oldActiveElement = document.activeElement;

    if (_currentFocusDomNode != null)
      adf.mf.api.amx.triggerBubbleEventListener(_currentFocusDomNode, "blur");

    if (document.activeElement != null && document.activeElement.blur != null)
      document.activeElement.blur();

    if (oldCurrentNode != null)
    {
      if (oldCurrentNode.tagName == "SELECT" || oldCurrentNode.tagName == "INPUT")
        adf.mf.api.amx.triggerBubbleEventListener(oldCurrentNode, "focus");
    }

    if (oldActiveElement != null && oldActiveElement.focus != null)
    {
      if (oldActiveElement.tagName == "SELECT" || oldActiveElement.tagName == "INPUT")
        oldActiveElement.focus();
    }

  }

  function triggerEvent(eventTarget, eventName, triggerExtra)
  {
    if (eventName == "tap")
    {
      // "tap" is not a real event so we need to trigger the real events for it
      var tapEvents = _getTapEvents();
      triggerEvent(eventTarget, tapEvents.start, triggerExtra);
      triggerEvent(eventTarget, tapEvents.end, triggerExtra);
    }
    else if (eventName == "taphold")
    {
      // "taphold" is not a real event so we need to trigger the real events for
      // it (the 2nd event needs to take place after the underlying 1st event's
      // timeout occurs hence the addition of 1 to the threshold).
      var tapHoldEvents = _getTapEvents();
      triggerEvent(eventTarget, tapHoldEvents.start, triggerExtra);
      setTimeout(
        function()
        {
          triggerEvent(eventTarget, tapHoldEvents.end, triggerExtra);
        },
        1+holdThreshold);
    }
    else
    {
      adf.mf.internal.triggerEvent(
        eventTarget,
        "HTMLEvents",
        eventName,
        true,
        true,
        triggerExtra);
    }
  }

  function _isSimpleObject(o)
  {
    return Object.prototype.toString.call(o) == "[object Object]";
  }

  /**
   * Utility to merge an arbitrary list of simple objects onto the given base object.
   * If any of the given objects is determined to not be a simple object, the merging
   * will cease and false is returned.
   * @param {Object} baseObject the simple object that the remaining objects will be added to (in order)
   * @return {Boolean} whether the full set of objects was merged
   */
  function _mergeSimpleObjects(baseObject)
  {
    if (!_isSimpleObject(baseObject))
      return false;

    // Loop through the rest of the arguments to merge their properties into the base object
    var args = Array.prototype.slice.call(arguments);
    for (var i=1, count=args.length; i<count; ++i)
    {
      var objectToMerge = args[i];

      if (!_isSimpleObject(objectToMerge))
        return false;

      for (var key in objectToMerge)
        baseObject[key] = objectToMerge[key];
    }

    return true;
  }

  var tapPendingIds = {};

  function cancelPendingTap()
  {
    tapPendingIds = {};
  }

  var _tapEvents = null;
  var _getTapEvents = function()
  {
    if (_tapEvents == null)
      _tapEvents = amx.hasTouch() ? { start: "touchstart", end: "touchend", cancel: "touchcancel" } : { start: "mousedown", end: "mouseup", cancel: "" };
    return _tapEvents;
  };

  var _addSpecialTapBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    var tapEvents = _getTapEvents();
    var tapId = null;
    var originalPosition = null;
    var startListener = function(event)
    {
      // if there is a node that registered its focus, then
      // the first thing to do is blur that focus here
      var newFocusedTagName = domNode.tagName;
      if (newFocusedTagName != "INPUT" && newFocusedTagName != "SELECT") // virtual keyboard elements
        blurCurrentNode();
      tapId = amx.uuid(); // TODO don't use amx.foo!
      tapPendingIds[tapId] = true;
      originalPosition = _getEventPagePosition(event);
    };
    var endListener = function(event)
    {
      if (tapPendingIds[tapId])
      {
        // Ignore taps if the finger moves too much between start and end.
        // The points might be null in automated testing mode so allow the tap
        // if points cannot be determined.
        var newPosition = _getEventPagePosition(event);
        var pointsCloseEnough =
          Math.abs(originalPosition["pageX"] - newPosition["pageX"]) < 25 &&
          Math.abs(originalPosition["pageY"] - newPosition["pageY"]) < 25;
        if (pointsCloseEnough ||
           originalPosition["pageX"] == null ||
           originalPosition["pageY"] == null ||
           newPosition["pageX"] == null ||
           newPosition["pageY"] == null)
        {
          adf.mf.api.amx.showLoadingIndicator();
          listener.call(this, event);
          adf.mf.api.amx.hideLoadingIndicator();
        }
        originalPosition = null;
        delete tapPendingIds[tapId];
        cancelPendingDrag(true, false);
      }
    };
    var cancelListener = function(event)
    {
      // Starting in Android 4.4, sometimes the browser will trigger a cancel
      // event before you lift your finger. In such cases, we can't reliably
      // honor the gesture as a tap because the 2 points are inaccurate.
      if (tapPendingIds[tapId])
      {
        originalPosition = null;
        delete tapPendingIds[tapId];
        cancelPendingDrag(true, false);
      }
    };
    // We used to ignore tap cancel but this is no longer valid with the new Chrome WebView in 4.4. Like native Chrome,
    // this will generate the cancel event if the preventDefault is not registered within 250ms. Since we get a touchStart
    // we need to figure out what the intent of the touch is (tap and hold or just tap or drag and drop). The issue
    // is the 250ms is a system time (outside the WebView) and when the WebView is busy (over long runs in Selenium), or
    // lots of open features then we start to slow down where some of the clicks are not addressed in time and we get a
    // touch cancel. What we do instead is treat the cancel like a touch end.
    if (tapEvents.cancel != "")
    {
      _addSpecialBubbleEventListener(
        domNode,
        eventType,
        listener,
        eventData,
        [
          [ tapEvents.start,  startListener ],
          [ tapEvents.end,    endListener ],
          [ tapEvents.cancel, cancelListener ]
        ]);
    }
    else
    {
      _addSpecialBubbleEventListener(
        domNode,
        eventType,
        listener,
        eventData,
        [
          [ tapEvents.start, startListener ],
          [ tapEvents.end,   endListener ]
        ]);
    }
  };
  // --------- /Tap Event --------- //

  // --------- Tap Hold --------- //
  var tapHoldPendingIds = {};

  function cancelPendingTapHold()
  {
    tapHoldPendingIds = {};
  }

  var holdThreshold = 800;

  var _addSpecialTapHoldBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    var tapEvents = _getTapEvents();
    var tapId = null;
    var startListener = function(event)
    {
      tapId = amx.uuid(); // TODO don't use amx.foo!
      tapHoldPendingIds[tapId] = new Date().getTime();

      // Since we are using a timer, we need to fetch our eventData now for reapplication in the timer
      var eventData = event.data;

      setTimeout(function()
      {
        // Note: here we double check if the time is greater than the threshold. This is useful since sometime timeout
        //       is not really reliable.
        if (tapHoldPendingIds[tapId] > 0)
        {
          var timeOffset = new Date().getTime() - tapHoldPendingIds[tapId];
          if (timeOffset >= holdThreshold)
          {
            // Call the listener but make sure our eventData is used:
            var eventDataToRestore = event.data;
            event.data = eventData;
            var result = listener.call(domNode, event);
            event.data = eventDataToRestore;

            // if the handler consumes the tapHold, remove it from the tapPendingIds so that it does not count like a tap
            if (result === "consumeTapHold")
            {
              // Android requires that we preventDefault, otherwise native select/edit text mode can be triggered
              // This code does also fixes softKeyboard show/hide bug and let's user select/edit text for inputText component
              var agent = adf.mf.internal.amx.agent;
              if (agent["type"] == "Android")
              {
                event.preventDefault();
              }
              cancelPendingTap();
              cancelPendingTapHold();
              cancelPendingDrag(false, false);
            }
          }
          delete tapHoldPendingIds[tapId];
        }

      }, holdThreshold);
    };
    var endListener = function(event)
    {
      if (tapHoldPendingIds[tapId])
      {
        delete tapHoldPendingIds[tapId];
      }
    };
    _addSpecialBubbleEventListener(
      domNode,
      eventType,
      listener,
      eventData,
      [
        [ tapEvents.start, startListener ],
        [ tapEvents.end, endListener ]
      ]);
  };
  // --------- /Tap Hold --------- //

  // --------- Drag Event --------- //
  var dragPendingIds = {};
  var dragEvents = null;

  function cancelPendingDrag(releaseLocks, triggerCancelOrEndBeforeRemove)
  {
    if (!triggerCancelOrEndBeforeRemove)
      dragPendingIds = {};

    if (releaseLocks)
    {
      if (!dragEvents)
        dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

      if (triggerCancelOrEndBeforeRemove)
      {
        // If a container is listening to drag events but a descendant gets removed, we need to
        // trigger the cancel/end listeners or else that container could get in a corrupt state:
        if (dragEvents.cancel != "")
          adf.mf.api.amx.triggerBubbleEventListener(document.documentElement, dragEvents.cancel);
        else
          adf.mf.api.amx.triggerBubbleEventListener(document.documentElement, dragEvents.end);
      }

      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag);
      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd);
      if (dragEvents.cancel != "")
        adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel);
      releaseDragLock();

      // delete the dragContext since it no longer applies
      adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", null);
    }
  }

  var DRAGSTART = "amxdragstart";
  var DRAGDRAG = "amxdragdrag";
  var DRAGEND = "amxdragend";

  /**
   * Options optional method implementation:
   */
  var mouseDragEvents =
  {
    start: "mousedown",
    drag: "mousemove",
    end: "mouseup",
    cancel: ""
  };

  var touchDragEvents =
  {
    start: "touchstart",
    drag: "touchmove",
    end: "touchend",
    cancel: "touchcancel"
  };

  // Handler for the event DRAGSTART event.
  function handleDragEvent(e, options)
  {
    var domNode = this;
    var id = "_" + amx.uuid(); // TODO don't use amx.foo!

    dragPendingIds[id] = true;

    var startEvent = e;
    var startPagePos = _getEventPagePosition(startEvent);

    // so far, we prevent the default, otherwise, we see some text select which can be of a distracting
    // since we create "meta events" we consume this one
    // e.preventDefault();
    // e.stopPropagation();

    var documentDragData = {
      "options": options,
      "domNode": domNode,
      "id": id,
      "startEvent": startEvent,
      "startPagePos": startPagePos,
      "dragStarted": false
    };

    if (!dragEvents)
      dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

    // We use the documentElement for the following 2 events so that the dragging doesn't stop when leaving the domNode.
    // In order to uniquely identify these listeners for removal the documentDragData will be passed in so that other
    // events of the same names on the document don't get lost.

    // drag
    adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag, documentDragData);

    // drag end
    adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd, documentDragData);

    // drag cancel
    if (dragEvents.cancel != "")
      adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel, documentDragData);
  }

  function documentDragDrag(e)
  {
    var documentDragData = e.data;
    var options = documentDragData["options"];
    var domNode = documentDragData["domNode"];
    var id = documentDragData["id"];
    var startEvent = documentDragData["startEvent"];
    var startPagePos = documentDragData["startPagePos"];

    // if the drag has not started, check if we need to start it
    if (!documentDragData["dragStarted"] && dragPendingIds[id])
    {
      var currentPagePos = _getEventPagePosition(e);
      var offsetX = (startPagePos.pageX - currentPagePos.pageX);
      var offsetY = (startPagePos.pageY - currentPagePos.pageY);

      // if the diff > threshold, then, we start the drag
      if (Math.abs(offsetX) > options.threshold || Math.abs(offsetY) > options.threshold)
      {
        var dragCtx = adf.mf.internal.amx._getNonPrimitiveElementData(document.documentElement, "dragCtx");
        if (dragCtx == null) // if no drag is already in progress on the element...
        {
          documentDragData["dragStarted"] = true;

          // we cancel any pending tap event
          cancelPendingTap();
          cancelPendingTapHold();

          // create the dragCtx
          adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", {});

          var dragStartExtra = buildDragExtra(startEvent, domNode, DRAGSTART, startPagePos, currentPagePos);
          triggerEvent(domNode, DRAGSTART, dragStartExtra);
        }
      }
    }

    if (documentDragData["dragStarted"] && dragPendingIds[id])
    {
      // making sure they they are canceled
      cancelPendingTap();
      cancelPendingTapHold();

      var dragExtra = buildDragExtra(e, domNode, DRAGDRAG);
      triggerEvent(domNode, DRAGDRAG, dragExtra);

      // since we create "meta events" we consume this event if the meta event was consumed
      if (dragExtra.preventDefault)
        e.preventDefault();
      if (dragExtra.stopPropagation)
        e.stopPropagation();
    }
  }

  function documentDragEnd(e)
  {
    _documentDragFinish(e);
  }

  function documentDragCancel(e)
  {
    _documentDragFinish(e);
  }

  function _documentDragFinish(e)
  {
    var documentDragData = e.data;
    var domNode = documentDragData["domNode"];
    var id = documentDragData["id"];

    if (documentDragData["dragStarted"] && dragPendingIds[id])
    {
      var extra = buildDragExtra(e, domNode, DRAGEND);
      triggerEvent(domNode, DRAGEND, extra);

      // since we create "meta events" we consume this event if the meta event was consumed
      if (extra.preventDefault)
        e.preventDefault();
      if (extra.stopPropagation)
        e.stopPropagation();

      // Let other elements have a chance at handling drag events:
      extra.releaseDragLock();
    }

    // unbind the document event that is specifically tied to this documentDragData instance
    adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag, documentDragData);
    adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd, documentDragData);
    if (dragEvents.cancel != "")
      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel, documentDragData);
    delete dragPendingIds[id];

    // delete the dragContext
    adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", null);
  }

  var currentDragElementH = null;
  var currentDragElementV = null;

  /**
   * Mechanism to release a reservation for horizontal and/or vertical drag behavior for the given element.
   * @param {HTMLElement} element the element that no longer wants to consume the specified drag events
   * @param {Boolean} horizontal whether you want to reserve drag events for the horizontal axis
   * @param {Boolean} vertical whether you want to reserve drag events for the horizontal axis
   * @return {Boolean} whether your release request was successful for the specified axes
   */
  function releaseDragLock(element, horizontal, vertical)
  {
    var releasedTheLock = false;

    if (element)
    {
      releasedTheLock = true;

      if (horizontal)
      {
        if (currentDragElementH == null || currentDragElementH == element)
          currentDragElementH = null;
        else
          releasedTheLock = false;
        }

      if (vertical)
      {
        if (currentDragElementV == null || currentDragElementV == element)
          currentDragElementV = null;
        else
          releasedTheLock = false;
        }
      }
    else // purge all
    {
      releasedTheLock = true;
      currentDragElementH = null;
      currentDragElementV = null;
    }

    return releasedTheLock;
  }

  /**
   * Mechanism to establish a reservation for horizontal and/or vertical drag behavior for the given element.
   * @param {HTMLElement} element the element that wants to consume the specified drag events
   * @param {Boolean} horizontal whether you want to reserve drag events for the horizontal axis
   * @param {Boolean} vertical whether you want to reserve drag events for the horizontal axis
   * @return {Boolean} whether your reservation request was granted for the specified axes
   */
  function requestDragLock(element, horizontal, vertical)
  {
    var gotTheLock = false;

    if (element)
    {
      gotTheLock = true;

      if (horizontal)
      {
        if (currentDragElementH == null || currentDragElementH == element)
          currentDragElementH = element;
        else
          gotTheLock = false;
      }

      if (vertical)
      {
        if (currentDragElementV == null || currentDragElementV == element)
          currentDragElementV = element;
        else
          gotTheLock = false;
      }
    }

    return gotTheLock;
  }

  /**
   * Build the extra event info for the drag event.
   * @param {Object} event TODO
   * @param {HTMLElement} domNode the dragged element
   * @param {String} dragType the custom drag event name
   * @param {Object} startPagePos optional argument with pageX and pageY properties
   * @param {Object} currentPagePos optional argument with pageX and pageY properties
   */
  function buildDragExtra(event, domNode, dragType, startPagePos, currentPagePos)
  {
    var hasTouch = amx.hasTouch(); // TODO don't use amx.foo!
    var extra = _getEventPagePosition(event); // fetch the pageX and pageY as appropriate
    extra["eventSource"] = event;
    extra["preventDefault"] = false;
    extra["stopPropagation"] = false;
    extra["releaseDragLock"] = releaseDragLock;
    extra["requestDragLock"] = requestDragLock;

    if (hasTouch)
    {
      extra.touches = event.touches;
    }

    var dragCtx = adf.mf.internal.amx._getNonPrimitiveElementData(document.documentElement, "dragCtx");
    if (dragCtx)
    {
      if (dragType === DRAGSTART)
      {
        dragCtx.startPageX = extra.startPageX = extra.pageX;
        dragCtx.startPageY = extra.startPageY = extra.pageY;

        dragCtx.lastPageX = dragCtx.startPageX = extra.startPageX;
        dragCtx.lastPageY = dragCtx.startPageY = extra.startPageY;
      }
      else if (dragType === DRAGEND)
      {
        // because, on iOS, the touchEnd event does not have the .touches[0].pageX
        extra.pageX = dragCtx.lastPageX;
        extra.pageY = dragCtx.lastPageY;
      }

      if (startPagePos != null && dragCtx.originalAngle == null)
      {
        // Calculate, using the start page event location, the angle that the user moved their
        // finger. Allows callers to determine the directionality that the user intends to scroll.
        diffX = currentPagePos.pageX - startPagePos.pageX;
        diffY = startPagePos.pageY - currentPagePos.pageY; // Y direction is reversed;

        // Determine the angle
        // angle = arctan(opposite/adjacent) (converted from radians to degrees)
        // Note that this computation uses 0 degrees as east, 90 is north.
        // Angles to the south and west are negative (-90 is south)
        dragCtx.originalAngle = Math.round(Math.atan2(diffY, diffX) * 180 / Math.PI);
      }

      extra.originalAngle = dragCtx.originalAngle;
      extra.startPageX = dragCtx.startPageX;
      extra.startPageY = dragCtx.startPageY;
      extra.deltaPageX = extra.pageX - dragCtx.lastPageX;
      extra.deltaPageY = extra.pageY - dragCtx.lastPageY;

      dragCtx.lastPageX = extra.pageX;
      dragCtx.lastPageY = extra.pageY;
    }
    else
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "buildDragExtra",
        "MSG_DRAG_CTX_NULL");
    }

    return extra;
  }

  function _getEventPagePosition(e)
  {
    var pageX, pageY;
    if (e.changedTouches && e.changedTouches.length > 0)
    {
      pageX = e.changedTouches[0].pageX;
      pageY = e.changedTouches[0].pageY;
    }
    else if (e.touches && e.touches.length > 0)
    {
      pageX = e.touches[0].pageX;
      pageY = e.touches[0].pageY;
    }
    else
    {
      pageX = e.pageX;
      pageY = e.pageY;
    }

    return {
      "pageX": pageX,
      "pageY": pageY
    };
  }

  // --------- /Drag Event --------- //

  // -------- Swipe Event --------- //

  var swipeThreshold = 5;

  /**
   * Determine if it is a swipe event, and if yes, build the swipeExtra
   */
  function buildSwipeExtra(domNode, event, dragExtra)
  {
    var swipeExtra = null;
    var swipeDone = domNode.getAttribute("data-swipeDone");

    if (swipeDone != "true" && dragExtra)
    {
      var offsetX = (dragExtra.pageX - dragExtra.startPageX);
      var offsetY = (dragExtra.pageY - dragExtra.startPageY);
      var absOffsetX = Math.abs(offsetX);
      var absOffsetY = Math.abs(offsetY);
      if (absOffsetX >= absOffsetY && absOffsetX > swipeThreshold)
      {
        // Only consider it a drag if the angle of the drag is within 30 degrees of due horizontal
        var angle = Math.abs(dragExtra.originalAngle);
        if (angle <= 30 || angle >= 150)
        {
          swipeExtra = {};
          swipeExtra.swipeType = (offsetX > -1)?"swipeRight":"swipeLeft";
          domNode.setAttribute("data-swipeDone", "true");
        }
      }
      else if (absOffsetY >= absOffsetX && absOffsetY > swipeThreshold)
      {
        // Only consider it a drag if the angle of the drag is within 30 degrees of due vertical
        var ang = Math.abs(dragExtra.originalAngle);
        if (ang >= 60 && ang <= 120)
        {
          swipeExtra = {};
          swipeExtra.swipeType = (offsetY > -1)?"swipeDown":"swipeUp";
          domNode.setAttribute("data-swipeDone", "true");
        }
      }
    }

    return swipeExtra;
  }
  // -------- /Swipe Event --------- //

// --------- /events --------- //

// --------- Event Enabler --------- //

  /**
   * Triggers an HTML bubble event listener (e.g. tap, taphold, keydown,
   * touchstart, touchmove, touchend, focus, blur, resize, etc.).
   * It is important to note that web browsers do not support all event types on
   * all DOM nodes. Refer to browser documentation for specifics.
   * @param {DOMNode} eventTarget the target DOM node for this event
   * @param {String} eventName the name of the HTML event to listen for
   */
  adf.mf.api.amx.triggerBubbleEventListener = function(eventTarget, eventName)
  {
    triggerEvent(eventTarget, eventName);
  };

  /**
   * Register a bubble event listener (e.g. tap, taphold, keydown, touchstart, touchmove, touchend, focus,
   * blur, resize, etc.). It is important to note that web browsers do not support all event types on all
   * DOM nodes. Refer to browser documentation for specifics. The eventData is optional and
   * serves as extra data to be made available to your listener function.
   * @param {DOMNode} domNode the target element for this event
   * @param {String} eventType the name of the event to listen for
   * @param {Function} listener the function that will be invoked when the specified element encounters this event (with a parameter that is the DOM event object)
   * @param {Object} eventData extra event data that will be made available on the "data" member of the event object
   */
  adf.mf.api.amx.addBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    // For special events (ones we made up that delegate to other real events), we have more
    // work to do in order to add the listeners:
    if ("tap" == eventType)
    {
      _addSpecialTapBubbleEventListener(domNode, eventType, listener, eventData);
    }
    else if ("taphold" == eventType)
    {
      _addSpecialTapHoldBubbleEventListener(domNode, eventType, listener, eventData);
    }
    else
    {
      // Adding a real event listener:
      _addBubbleEventListener(domNode, eventType, listener, eventData);
    }
  };

  var _addBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    // Internal note: we will support eventData using a technique similar to this:
    // domNode.addEventListener("click", function() { var tempData = eventData; yourListener(tempData); }, false)
    // but we need to follow the removeEventListener "handleEvent" guidance noted here and we will need a
    // mechanism to remove all listeners at once (for the removeDomNode function) so that means we need to
    // track the listeners using some ID mechanism).

    if (domNode != null && listener != null)
    {
      var actualListener = function(event)
      {
// TODO integrate .registerFocus and .registerBlur here
        var oldData = event.data;
        if (eventData != null)
        {
          if (oldData == null)
          {
            // No merging necessary (only new data)
            event.data = eventData;
          }
          else // Try merging the 2 pieces of data
          {
            var merged = {};
            if (_mergeSimpleObjects(merged, oldData, eventData))
              event.data = merged; // Use the merged result
            else
              event.data = eventData; // Both are not objects so we can't merge; use only new data
          }
        }
        var result = listener.call(this, event, event.triggerExtra);
        event.data = oldData;
        if (result !== undefined)
        {
          if ((event.result = result) === false)
          {
            // Stop the event from continuing (e.g. max length hit in an inputText)
            event.preventDefault();
            event.stopPropagation();
          }
        }
      };
      var newListener = {
        "actualListener": actualListener,
        "eventType": eventType,
        "listener": listener,
        "eventData": eventData
      };
      if (domNode._amxListeners == null)
        domNode._amxListeners = [];
      domNode._amxListeners.push(newListener);
      domNode.addEventListener(eventType, actualListener, false);
    }
  };

  var _addSpecialBubbleEventListener = function(domNode, eventType, eventKey, eventData, backingListeners)
  {
    // specialEventsMap is a map with keys like "tap", "taphold", "amxdrag":
    var specialEventsMap = domNode._amxSpecialEvents;
    if (specialEventsMap == null)
    {
      specialEventsMap = {};
      domNode._amxSpecialEvents = specialEventsMap;
    }

    // Since there can be multiple instances of each special event type, each type points to an instance map.
    // The eventKeysMap is keyed by something that allows unique removal.
    // This key could be the developer's passed-in listener function (in the case of "tap" and "taphold") or
    // the developer's payload object (in the case of "amxdrag").
    var eventKeysMap = specialEventsMap[eventType];
    if (eventKeysMap == null)
    {
      eventKeysMap = {};
      specialEventsMap[eventType] = eventKeysMap;
    }

    // Each entry in eventKeysMap is a map keyed by the event data (possibly null):
    var eventDataMap = eventKeysMap[eventKey];
    if (eventDataMap == null)
    {
      eventDataMap = {};
      eventKeysMap[eventKey] = eventDataMap;
    }

    // Each entry in eventDataMap is an array of instance listeners.
    var instanceListenersArray = eventDataMap[eventData];
    if (instanceListenersArray == null)
    {
      instanceListenersArray = [];
      eventDataMap[eventData] = instanceListenersArray;
    }

    // Each member of instanceListeners is a backing listener array where index 0 is an
    // DOM event type and index 1 is a DOM event handler function.
    for (var i=0, count=backingListeners.length; i<count; ++i)
    {
      var backingListener = backingListeners[i];
      _addBubbleEventListener(domNode, backingListener[0], backingListener[1], eventData);
      instanceListenersArray.push(backingListener);
    }
  };

  /**
   * Unregister a bubble event listener that was added via adf.mf.api.amx.addBubbleEventListener.
   * If eventType is not specified, all listeners registered by the add function will be removed.
   * If listener is not specified, all listeners registered by the add function of the given type will be removed.
   * @param {DOMNode} domNode the target element for which an event listener was previously added
   * @param {String} eventType the name of the event
   * @param {Function} listener the event listener function
   * @param {Object} eventData the extra event data
   */
  adf.mf.api.amx.removeBubbleEventListener = function(
    domNode,
    eventType,
    listener,
    eventData)
  {
    if (domNode != null)
    {
      if (eventType == null)
      {
        // Remove all special event listeners:
        _removeSpecialBubbleEventListener(domNode);
        delete domNode._amxSpecialEvents;

        // Remove all real event listeners:
        _removeBubbleEventListener(domNode);
      }
      else if ("tap" == eventType || "taphold" == eventType || "amxdrag" == eventType)
      {
        // For special events (ones we made up that delegate to other real events), we have more
        // work to do in order to remove the listeners:
        var eventKey = listener; // for "tap" and "taphold", the listener is the eventKey
        _removeSpecialBubbleEventListener(domNode, eventType, eventKey, eventData);
      }
      else
      {
        // Removing a real event listener:
        _removeBubbleEventListener(domNode, eventType, listener, eventData);
      }
    }
  };

  /**
   * Remove a bubble event listener.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {String} eventType the DOM event type (if not specified, all events will be removed)
   * @param {Function} listener the DOM event listener (if not specified, all events of the given type will be removed)
   * @param {Object} eventData the optional event data that is bundled with the event listener
   */
  var _removeBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    if (domNode != null && listener != null)
    {
      // Account for listeners not added via adf.mf.api.amx.addBubbleEventListener:
      domNode.removeEventListener(eventType, listener, false);
    }

    if (domNode != null && domNode._amxListeners != null)
    {
      // Account for listeners added via adf.mf.api.amx.addBubbleEventListener:
      var savedListeners = domNode._amxListeners;
      var savedListenerCount = savedListeners.length;
      for (var i=savedListenerCount-1; i>=0; --i)
      {
        var savedListener = savedListeners[i];
        var removeThisListener = false;
        if (eventType === undefined) // remove all saved listeners
        {
          eventType = savedListener["eventType"];
          removeThisListener = true;
        }
        else if (listener === undefined) // remove all saved listeners of this event type
          removeThisListener = savedListener["eventType"] == eventType;
        else if (eventData === undefined) // remove all saved listeners of this event type and listener function
          removeThisListener = savedListener["eventType"] == eventType && savedListener["listener"] == listener;
        else // remove only listeners that match this type, listener function, and event data
          removeThisListener = savedListener["eventType"] == eventType && savedListener["listener"] == listener && savedListener["eventData"] == eventData;

        if (removeThisListener)
        {
          domNode.removeEventListener(eventType, savedListener["actualListener"], false);
          savedListeners.splice(i, 1); // remove that listener from the array
        }
      }

      if (domNode._amxListeners.length == 0)
        delete domNode._amxListeners;
    }
  };

  /**
   * Remove any special event listeners associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {String} eventType optional eventType to limit what gets removed
   * @param {Object} eventKey optional eventKey to limit what gets removed
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialBubbleEventListener = function(domNode, eventType, eventKey, eventData)
  {
    var specialEventsMap = domNode._amxSpecialEvents;
    if (specialEventsMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventType == null)
    {
      // Remove for all possible special eventType values
      for (var foundEventType in specialEventsMap)
      {
        _removeSpecialEventForKeyAndData(domNode, specialEventsMap[foundEventType]);
        delete specialEventsMap[foundEventType];
      }
    }
    else
    {
      // Restrict removal to just this special eventType
      var eventKeysMap = specialEventsMap[eventType];
      _removeSpecialEventForKeyAndData(domNode, eventKeysMap, eventKey, eventData);
      if (Object.keys(eventKeysMap).length == 0)
        delete specialEventsMap[eventType]; // no more keys for this event type
    }

    if (Object.keys(specialEventsMap).length == 0)
      delete domNode._amxSpecialEvents; // no more special events of any type
  };

  /**
   * Remove special event listeners of a specific type associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} eventKeysMap map of all special event keys for a particular eventType
   * @param {Object} eventKey optional eventKey to limit what gets removed
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialEventForKeyAndData = function(domNode, eventKeysMap, eventKey, eventData)
  {
    if (eventKeysMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventKey == null)
    {
      // Remove all instances of this special eventType
      for (var foundEventKey in eventKeysMap)
      {
        _removeSpecialEventForData(domNode, eventKeysMap[foundEventKey]);
        delete eventKeysMap[foundEventKey];
      }
    }
    else
    {
      // Restrict removal to just this eventKey
      var eventDataMap = eventKeysMap[eventKey];
      _removeSpecialEventForData(domNode, eventDataMap, eventData);
      if (Object.keys(eventDataMap).length == 0)
        delete eventKeysMap[eventKey]; // no more keys for this event type and key combo
    }
  };

  /**
   * Remove special event listeners of a specific eventData associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} eventDataMap map of all special eventData for a particular eventType and eventKey
   * @param {Object} eventData optional eventData to limit what gets removed
   * @return {Boolean} whether the specified listeners were removed
   */
  var _removeSpecialEventForData = function(domNode, eventDataMap, eventData)
  {
    if (eventDataMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventData == null)
    {
      // Remove all instances of this special eventData
      for (var foundEventData in eventDataMap)
      {
        _removeSpecialEventInstanceListeners(domNode, eventDataMap[foundEventData], foundEventData);
        delete eventDataMap[foundEventData];
      }
    }
    else
    {
      // Restrict removal to just this eventData
      var instanceListeners = eventDataMap[eventData];
      _removeSpecialEventInstanceListeners(domNode, instanceListeners, eventData);
      delete eventDataMap[eventData]; // no more keys for this event type and key combo
    }
  };

  /**
   * Remove special event listeners of associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} instanceListeners the backing listener array
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialEventInstanceListeners = function(domNode, instanceListeners, eventData)
  {
    if (instanceListeners == null)
    {
      return; // nothing was registered so nothing to remove
    }

    // Remove the real underlying events for this custom event listener
    for (var i=instanceListeners.length-1; i>=0; --i)
    {
      var backingListener = instanceListeners[i];
      // Note, for now we are not passing along eventData so that callers can delete references to
      // instanceListeners.
      _removeBubbleEventListener(domNode, backingListener[0], backingListener[1], eventData);
    }
  };

  /**
   * Allow a DOM node to trigger custom AMX events for amx:showPopupBehavior, amx:setPropertyListener, etc.
   * like "tapHold" and the "swipe".
   * @param {adf.mf.api.amx.AmxNode} amxNode the AmxNode that owns the DOM for the event
   * @param {DOMNode} domNode the DOM node that can trigger the event
   * @param {String} eventType the type of event being associated; either "tapHold" or "swipe"
   */
  adf.mf.api.amx.enableAmxEvent = function(amxNode, domNode, eventType)
  {
    if (eventType == "swipe")
      _enableSwipe(amxNode, domNode);
    else if (eventType == "tapHold")
      _enableTapHold(amxNode, domNode);
  };

  var _enableSwipe = function(amxNode, domNode)
  {
    var handler = function(event, swipeExtra)
    {
      var tag = amxNode.getTag();
      var swipeType = swipeExtra.swipeType;

      // check that we have at least one action with this type
      var childrenTags = tag.getChildren();
      for (var i=0, size=childrenTags.length; i<size; ++i)
      {
        var childTag = childrenTags[i];
        var childType = childTag.getAttribute("type");

        // The event processing doesn't know about start/end so use left/right if applicable:
        if (childType == "swipeStart")
        {
          if (document.documentElement.dir == "rtl")
            childType = "swipeRight";
          else
            childType = "swipeLeft";
        }
        else if (childType == "swipeEnd")
        {
          if (document.documentElement.dir == "rtl")
            childType = "swipeLeft";
          else
            childType = "swipeRight";
        }

        if (childType == swipeType)
        {
          var event = new amx.ActionEvent(); // TODO don't use amx.foo!
          adf.mf.api.amx.processAmxEvent(amxNode, swipeType, undefined, undefined, event);
          return "consumeSwipe";
        }
      }
    };

    var swipeConsumed = false;
    adf.mf.api.amx.addDragListener(
      domNode,
      {
        start: function(event, dragExtra) {},

        drag: function(event, dragExtra)
        {
          if (!swipeConsumed)
          {
            var swipeExtra = buildSwipeExtra(domNode, event, dragExtra);
            if (swipeExtra)
            {
              var result = handler.call(this, event, swipeExtra);
              if (result === "consumeSwipe")
              {
                swipeConsumed = true;
                domNode.removeAttribute("data-swipeDone");
              }
            }
           }
        },

        end: function(event, dragExtra)
        {
          swipeConsumed = false;
          domNode.removeAttribute("data-swipeDone");
        },

        threshold: 5
      });
  };

  var _enableTapHold = function(amxNode, domNode)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "taphold",
      function(event)
      {
        var tag = amxNode.getTag();

        // check that we have at least one action with this type
        var childrenTags = tag.getChildren();
        for (var i=0, size=childrenTags.length; i<size; ++i)
        {
          var childTag = childrenTags[i];
          if (childTag.getAttribute("type") == "tapHold")
          {
            var event = new amx.ActionEvent(); // TODO don't use amx.foo!
            adf.mf.api.amx.processAmxEvent(amxNode, "tapHold", undefined, undefined, event);
            return "consumeTapHold";
          }
        }
      });
  };

  /**
   * Allow a DOM node to trigger AMX drag events.
   * The payload object defines 3 member functions: "start", "drag", "end" where each one's first parameter
   * is the DOM event, the second parameter is a "dragExtra" object with members: "eventSource" (the DOM event
   * source), "pageX" (the x coordinate of the event, "pageY" the y coordinate of the event, "startPageX" (the
   * original pageX), "startPageY" (the original pageY), "deltaPageX" (the change in pageX), "deltaPageY" (the
   * change in pageY), "originalAngle" (if available, it will be the original angle of the drag in degrees
   * where 0 degrees as east, 90 is north, -90 is south, 180 is west), and modifiable member flags:
   * "preventDefault", and "stopPropagation".
   * @param {DOMNode} domNode the DOM node that can trigger the drag event
   * @param {Object} playload the specifics about the drag event
   * @param {Object} eventData the extra event data
   */
  adf.mf.api.amx.addDragListener = function(domNode, payload, eventData)
  {
    var options =
    {
      threshold: 5
    };
    _mergeSimpleObjects(options, payload);

    var backingListeners = [];
    if (options.start)
      backingListeners.push([ DRAGSTART, options.start ]);
    if (options.drag)
      backingListeners.push([ DRAGDRAG, options.drag ]);
    if (options.end)
      backingListeners.push([ DRAGEND, options.end ]);

    var dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

    backingListeners.push([ dragEvents.start, function(e)
      {
        domNode.setAttribute("data-amxDragInProgress", "yes");
        handleDragEvent.call(domNode, e, options);
      }]);
    backingListeners.push([ dragEvents.end, function(e)
      {
        cleanElementsWithDragInProgress();
      }]);
    if (dragEvents.cancel != "")
    {
      backingListeners.push([ dragEvents.cancel, function(e)
        {
          cleanElementsWithDragInProgress();
        }]);
    }

    _addSpecialBubbleEventListener(
      domNode,
      "amxdrag",
      payload,
      eventData,
      backingListeners);
  };

  function cleanElementsWithDragInProgress()
  {
    // Since we are not guaranteed to get an "end" for a "start" (e.g. the drag ended
    // on a different element than the start element) then we need to find all drag
    // elements and remove their "in-progress" markers:
    var elementsWithDragInProgress = document.querySelectorAll("*[data-amxDragInProgress]");
    for (var i = 0, count = elementsWithDragInProgress.length; i < count; ++i)
      elementsWithDragInProgress[i].removeAttribute("data-amxDragInProgress");

    // Ensure the drag is concluded:
    cancelPendingDrag(true, true);
  }

  /**
   * Apply innerHTML upon on element (this will call adf.mf.api.amx.emptyHtmlElement for
   * you).
   * @param {HTMLElement} parentElement the parent HTML element whose innerHTML is to be applied
   * @param {string} innerHtml the HTML to apply in the parentElement
   * @param {boolean} scriptEval whether script tags should be evaluated
   */
  adf.mf.api.amx.applyInnerHtml = function(parentElement, innerHtml, scriptEval)
  {
    adf.mf.api.amx.emptyHtmlElement(parentElement);
    parentElement.innerHTML = innerHtml;
    if (scriptEval)
    {
      // Loop through all script nodes in the parent (might be more than just innerHTML's):
      var scriptNodes = parentElement.querySelectorAll("script");
      for (var i = 0; i < scriptNodes.length; i++)
      {
        // Clone the node (if not previously-cloned)
        var scriptNode = scriptNodes[i];
        var scriptClone = cloneScriptNode(scriptNode);
        if (scriptClone)
          scriptNode.parentNode.replaceChild(scriptClone, scriptNode);
      }
    }
  };

  function cloneScriptNode(oldNode)
  {
    if (oldNode == null)
      return oldNode;
    var newNode = document.createElement("script");
    var cloneIdentifier = "data-amx-script-clone";
    newNode.setAttribute(cloneIdentifier, "yes"); // marker to prevent re-cloning
    newNode.text = oldNode.innerHTML;
    var attrs = oldNode.attributes;
    for (var i = attrs.length-1; i >= 0; i--)
    {
      var attr = oldNode.attributes[i];
      var attrName = attr.name;
      if (attrName == cloneIdentifier)
        return null; // found a script node that was previously-cloned
      newNode.setAttribute(attrName, attr.value);
    }
    return newNode;
  }

  /**
   * Remove a DOM node (and its children) but first removes event listeners
   * that were added via adf.mf.api.amx.addBubbleEventListener and ensures any
   * components inside it get cleaned up properly.
   * @param {DOMNode} domNode the DOM node to remove
   */
  adf.mf.api.amx.removeDomNode = function(domNode)
  {
    var i;

    // We need to proceed depth-first:
    if (domNode != null)
    {
      // Cancel pending drags if applicable
      // We need to cancel pending drags because they may have been abandoned
      // due to element removal during their "dragdrag" handlers.
      // This is needed for bug 18775524 but means we can't have a navigationDragBehavior.
      if (domNode.getAttribute && "yes" == domNode.getAttribute("data-amxDragInProgress"))
      {
        cancelPendingDrag(true, true);
      }

      // First we need to clean up any associated AMXNodes before the DOM is
      // removed or else the destroy handlers might lose important context.
      adf.mf.internal.amx.removeAmxDomNode(domNode);

      // Going depth-first, clean up the children:
      var children = domNode.childNodes;
      if (children != null)
      {
        for (i = children.length - 1; i >= 0; --i)
        {
          adf.mf.api.amx.removeDomNode(children[i]);
        }
      }

      // Unregister the event listeners:
      adf.mf.api.amx.removeBubbleEventListener(domNode);

      // In some cases an element delegates event listeners to the document like
      // amx:view for some document events. We need to make sure those get
      // unregistered too or else there would be a leak:
      if (domNode.__amxRemoveFunctions != null)
      {
        var removeFunctionCount = domNode.__amxRemoveFunctions.length;
        for (i = removeFunctionCount - 1; i >= 0; --i)
        {
          var removeFunc = domNode.__amxRemoveFunctions[i];
          try
          {
            removeFunc();
          }
          catch (problem)
          {
            adf.mf.log.logInfoResource(
              "AMXInfoBundle",
              adf.mf.log.level.SEVERE,
              "adf.mf.api.amx.removeDomNode",
              "MSG_ERROR_REMOVE_DOM_NODE_SCRIPT");

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx", "removeDomNode",
                "Error in function: " + removeFunc + " error: " + problem);
            }
          }
        }
        domNode.__amxRemoveFunctions = null;
      }

      // Remove the node:
      if (domNode.parentNode != null)
        domNode.parentNode.removeChild(domNode);
    }
  };

  /**
   * Empty an HTML element by removing children DOM nodes and calling adf.mf.api.amx.removeDomNode on each
   * of the children nodes.
   * @param {HTMLElement} element the HTML element to empty
   */
  adf.mf.api.amx.emptyHtmlElement = function(element)
  {
    // HTMLElement element
    if (element != null)
    {
      var children = element.childNodes;
      if (children != null)
      {
        for (var i=children.length-1; i>=0; --i)
          adf.mf.api.amx.removeDomNode(children[i]);
      }
    }
  };

  /**
   * Enable scrolling for the given element.
   * This operation may append a style class to the element so ensure that you
   * do not overwrite the element class name after calling this API.
   */
  adf.mf.api.amx.enableScrolling = function(element)
  {
    var scrollPolicyClassName = "amx-scrollable";

    // In legacy skins, scrolling is much more aggressive so we have a different class name:
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 2)
    {
      if (args[1] === true) // 2nd magic argument is whether you need legacy scrolling support
        scrollPolicyClassName = "amx-scrollPolicy-auto";
    }

    // Apply the class name:
    element.classList.add(scrollPolicyClassName);

    // Enable programmatic scrolling for Android if applicable:
    if (adf.mf.internal.amx.bindManualScrollers)
      adf.mf.internal.amx.bindManualScrollers(element);
  };

  function _shorten(object, limit)
  {
    if (object == null)
      result = object;
    else
    {
      var string = "" + object;
      if (string.length > limit)
        result = string.substring(0, limit-3).trim() + "...";
      else
        result = string;
      result = result.replace(/\n/g, " ").trim();
      result = result.replace(/[\s]+/g, " "); // collapse all spaces
    }
    return result;
  }

  /**
   * Generate a debugging string for events associated with a given HTML element.
   * @param {HTMLElement} element the HTML element whose event detail will be generated
   * @param {Number} shortenLimit optional number that can change the limit to the length of debug listener or data text
   * @return {String} a debugging string representing details about events associated with the given HTML element
   */
  adf.mf.api.amx.getEventDebugString = function(element, shortenLimit)
  {
    if (element == null)
      return element;

    if (shortenLimit === undefined)
      shortenLimit = 25;

    var domEventsMessage = "\n  n/a";
    var domListeners = element._amxListeners;
    if (domListeners != null)
    {
      var domListeners = element._amxListeners;
      var domListenerCount = domListeners.length;
      domEventsMessage = "";
      for (var i=0; i<domListenerCount; ++i)
      {
        var domListener = domListeners[i];
        var firstPrefix = "  " + (1+i) + " - ";
        var otherPrefix = Array(1+firstPrefix.length).join(" "); // empty spaces of equal length
        domEventsMessage += "\n" + firstPrefix + "type: " + domListener["eventType"];
        domEventsMessage += "\n" + otherPrefix + "listener: " + _shorten(domListener["listener"], shortenLimit);
        domEventsMessage += "\n" + otherPrefix + "data: " + _shorten(domListener["eventData"], shortenLimit);
      }
    }

    var specialEventsMessage = "\n  n/a";
    var specialEventsMap = element._amxSpecialEvents;
    if (specialEventsMap != null)
    {
      specialEventsMessage = "";
      var eventTypeCounter = 0;
      for (var eventType in specialEventsMap)
      {
        // Since there can be multiple instances of each special event type, each type points to an event key map.
        // The eventKeysMap is keyed by something that allows unique removal.
        // This key could be the developer's passed-in listener function (in the case of "tap" and "taphold") or
        // the developer's payload object (in the case of "amxdrag").
        var eventKeysMap = specialEventsMap[eventType];
        specialEventsMessage += "\n  " + ++eventTypeCounter + " - type: " + eventType;
        var eventKeyCounter = 0;
        for (var eventKey in eventKeysMap)
        {
          // Each entry in eventKeysMap is a eventDataMap.
          var eventDataMap = eventKeysMap[eventKey];
          specialEventsMessage += "\n    " + eventTypeCounter + "." + ++eventKeyCounter + " - key: " + _shorten(eventKey, shortenLimit);
          var eventDataCounter = 0;
          for (var eventData in eventDataMap)
          {
            // Each entry in eventDataMap is an array of instance listeners.
            var instanceListenersArray = eventDataMap[eventData];
            var instanceListenerCount = instanceListenersArray.length;
            specialEventsMessage += "\n      " + eventTypeCounter + "." + eventKeyCounter + "." + ++eventDataCounter + " - data: " + _shorten(eventData, shortenLimit);
            for (var i=0; i<instanceListenerCount; ++i)
            {
              // Each member of instanceListenersArray is a backing listener array where index 0 is an
              // DOM event type and index 1 is a DOM event handler function.
              specialEventsMessage += "\n        " + eventTypeCounter + "." + eventKeyCounter + "." + eventDataCounter + "." + (1+i) + " - DOM type: " + instanceListenersArray[i][0];
            }
          }
        }
      }
    }

    var message =
      "DOM events: " + domEventsMessage +
      "\nSpecial events:" + specialEventsMessage;
    return message;
  };

  //NOTE: The body of this function was removed to allow use of native scrolling in iOS 5.0 by
  // the use of the CSS "-webkit-overflow-scrolling: touch" on the amx-scrollable class, but the
  // binding itself remains because removing it causes AMX-processed touch events to fail
  // altogether.
  //TODO : Do we still need this (was in a jQuery load of amx-core)?
  adf.mf.api.amx.addBubbleEventListener(document.body, "touchmove", function(event) {});

  adf.mf.api.finishAnyLoading().then(
    function()
    {
      // Android workaround for form elements not appearing within visible part of the display
      // when a keyboard is shown (they would otherwise be covered up by the keyboard).
      if (adf.mf.internal.amx.agent["type"] == "Android")
      {
        var lastShowKeyboardTime = 0;
        var lastResizeTime = 0;
        var timeOutRunning = false;

        var scrollActiveElementIntoView = function()
        {
          timeOutRunning = false;

          var ae = document.activeElement;

          // Ignore the document body (when the active element has not been set).
          if (ae != document.body)
          {
            // Not every browser implements scrollIntoViewIfNeeded. The mobile browsers mostly
            // implement it, but check first before falling back on scrollIntoView.
            ae["scrollIntoViewIfNeeded"] ? ae.scrollIntoViewIfNeeded() : ae.scrollIntoView();
          }
        };

        var scrollActiveElementIntoViewIfAppropriate = function(newerTime, olderTime)
        {
          // Determine how long between the most recent showkeyboard and resize events.
          var timeDiff = newerTime - olderTime;

          // Is this resize due to the keyboard (close in time to the event)?
          if (timeDiff <= 750 && !timeOutRunning)
          {
            timeOutRunning = true;

            // Use a timeout to allow the browser time to redraw before trying to bring the
            // element into view.
            window.setTimeout(scrollActiveElementIntoView, 150);
          }
        };

        // Note: showkeyboard is only called on Android and it is called several times per one
        // showing of the keyboard for some unknown reason.
        document.addEventListener("showkeyboard",
          function(event)
          {
            // Record when the event was generated
            lastShowKeyboardTime = (new Date()).getTime();

            scrollActiveElementIntoViewIfAppropriate(lastShowKeyboardTime, lastResizeTime);
          });

        // The android:windowSoftInputMode is set to adjustResize, so the window will resize
        // to fit to the space left without the keyboard. Listen for this event so that we can
        // catch the resize event that happens after the showkeyboard event.
        window.addEventListener("resize",
          function(event)
          {
            // Record when the event was generated
            lastResizeTime = (new Date()).getTime();

            scrollActiveElementIntoViewIfAppropriate(lastResizeTime, lastShowKeyboardTime);
          });
      }
    });

})();
/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-validation.js ---------------------- */
/* ------------------------------------------------------ */

// ------ amx validations ------ //
(function()
{
  var ERROR_UPPER_STR = "ERROR";
  var WARNING_UPPER_STR = "WARNING";

  var INFO_STR = "info";
  var CONFIRMATION_STR = "confirmation";
  var WARNING_STR = "warning";
  var ERROR_STR = "error";
  var FATAL_STR = "fatal";

  // initialize display strings with fallback values - too early to load from resource bundle
  var INFO_DISPLAY_STR = "Info";
  var CONFIRMATION_DISPLAY_STR = "Confirmation";
  var WARNING_DISPLAY_STR = "Warning";
  var ERROR_DISPLAY_STR = "Error";
  var FATAL_DISPLAY_STR = "Fatal";

  var INFO_VAL = 4;
  var CONFIRMATION_VAL = 3;
  var WARNING_VAL = 2;
  var ERROR_VAL = 1;
  var FATAL_VAL = 0;

  // these maps are used to convert to and from severity string/int values
  var __severityStringToInt = {};
  __severityStringToInt[INFO_STR] = INFO_VAL;
  __severityStringToInt[CONFIRMATION_STR] = CONFIRMATION_VAL;
  __severityStringToInt[WARNING_STR] = WARNING_VAL;
  __severityStringToInt[ERROR_STR] = ERROR_VAL;
  __severityStringToInt[FATAL_STR] = FATAL_VAL;

  var __severityIntToDisplayString = {};
  __severityIntToDisplayString[INFO_VAL] = INFO_DISPLAY_STR;
  __severityIntToDisplayString[CONFIRMATION_VAL] = CONFIRMATION_DISPLAY_STR;
  __severityIntToDisplayString[WARNING_VAL] = WARNING_DISPLAY_STR;
  __severityIntToDisplayString[ERROR_VAL] = ERROR_DISPLAY_STR;
  __severityIntToDisplayString[FATAL_VAL] = FATAL_DISPLAY_STR;

  // This map is used to provide the associated resource bundle key. These ADFInfoBundle keys
  // are special cased in getResourceStringImpl(), and will always return a displayable value.
  var __severityDisplayStringBundleKey = {};
  __severityDisplayStringBundleKey[INFO_DISPLAY_STR] = "LBL_INFO_DISPLAY_STR";
  __severityDisplayStringBundleKey[CONFIRMATION_DISPLAY_STR] = "LBL_CONFIRMATION_DISPLAY_STR";
  __severityDisplayStringBundleKey[WARNING_DISPLAY_STR] = "LBL_WARNING_DISPLAY_STR";
  __severityDisplayStringBundleKey[ERROR_DISPLAY_STR] = "LBL_ERROR_DISPLAY_STR";
  __severityDisplayStringBundleKey[FATAL_DISPLAY_STR] = "LBL_FATAL_DISPLAY_STR";

  amx.validationsUnsetListEl = adf.mf.internal.el.parser.parse("#{validationScope.unsetList}");
  amx.validationsInvalidListEl = adf.mf.internal.el.parser.parse("#{validationScope.invalidList}");

  // this keeps track of the groups that have been validated
  // so that we know if we should be showing the required failures
  // or not
  var __validatedGroups = {};

  // this keeps track of whether or not we are currently validating group[s]
  var __isValidating = false;

  var validationExName = "oracle.adfmf.framework.exception.ValidationException";
  var batchValidationExName = "oracle.adfmf.framework.exception.BatchValidationException";

  adf.mf.api.amx.TypeHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationGroup").prototype.render = function(amxNode)
  {
    var rootElement = document.createElement("div");
    var descendants = amxNode.renderDescendants();
    for (var i=0, size=descendants.length; i<size; ++i)
    {
      rootElement.appendChild(descendants[i]);
    }
    return rootElement;
  };

  // data change handler for when the validationList changes
  function validationsDataChangeHandler(el)
  {
    updateValidationMessages();
  }

  /**
   * This method will go through all of the items in validationData and extract
   * the current validation exceptions for the group id and add them to the
   * error message box.
   * @param validationData the data that contains all of the validation info
   * @param groupId the current group id
  */
  function updateValidationMessagesByGroupId(validationData, groupId)
  {
      var groupValidationData = validationData[groupId];
      if (groupValidationData === undefined)
      {
        return;
      }

      var groupInvalid = groupValidationData.invalid;
      for (item in groupInvalid)
      {
        var arrayList = groupInvalid[item];
        for(var index in arrayList)
        {
          var nvp = arrayList[index];
          adf.mf.api.amx.addMessage(nvp.name.toLowerCase(), nvp.value, null, null);
        }
      }

      // check for required failures
      var groupRequired = groupValidationData.required;
      for (item in groupRequired)
      {
        var text = groupRequired[item];
        adf.mf.api.amx.addMessage(ERROR_STR, text, null, null);
      }
  }

  /**
   * This method builds up the validation data given an array
   * of group ids to check. If any validation errors are present,
   * then they will be added to the error message box
   * @param groupsToCheck  the array of groups to check for validation errors
  */
  function updateValidationMessages(groupsToCheck)
  {
    if (amx.isValidating())
    {
      return;
    }

    // get all of the groups and all of the messages
    var validationGroupElements = document.getElementsByClassName("amx-validationGroup");

    if (validationGroupElements.length == 0)
    {
      // do nothing
      return;
    }

    var always =
      function(validationData)
      {
        // now show the message box
        if (groupsToCheck !== undefined && groupsToCheck != null && groupsToCheck.length > 0)
        {
          for (var i = 0; i < groupsToCheck.length; ++i)
          {
            var groupId = groupsToCheck[i];

            var groupValidationData = validationData[groupId];
            if (groupValidationData === undefined)
            {
              // no validation data present
              continue;
            }

            updateValidationMessagesByGroupId(validationData, groupId);
          }
        }
      };
    amx.buildValidationData(validationGroupElements).then(always, always);
  }

  function getCurrentPageGroup(id)
  {
    var thisPage = adf.mf.internal.controller.ViewHistory.peek().viewId;
    if (__validatedGroups[thisPage] === undefined)
    {
      __validatedGroups[thisPage] = {};
    }

    return __validatedGroups[thisPage];
  }

  function setGroupValidated(id)
  {
    var pageGroups = getCurrentPageGroup(id);
    pageGroups[id] = true;
  }

  function isGroupValidated(id)
  {
    var pageGroups = getCurrentPageGroup(id);
    return pageGroups[id] === true;
  }


  // detect if the xmlNode is rendered, visible, and shown on the screen
  amx.isNodeRendered = function(amxNode)
  {
    if (!amxNode.isReadyToRender())
    {
      return false;
    }

    // TODO: this has no place in a global function:
    if (amxNode.getTag().getNsPrefixedName() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":popup")
    {
      if (amxNode.getAttribute("_renderPopup"))
      {
        return true;
      }

      return false;
    }

    var attr = amxNode.getAttribute("visible");
    if(typeof attr !== "undefined")
    {
      if(adf.mf.api.amx.isValueFalse(attr))
      {
        return false;
      }
    }

    return true;
  };

  function setValidationWatchData(groupId, amxNode, watchData, addRequired)
  {
    var attributeValue = amxNode.__getAttributeToValidate();
    if (attributeValue == null)
    {
      return;
    }

    var attributeValueEl = amxNode.getAttributeExpression(attributeValue, true);

    if (amx.containsELExpressions(attributeValueEl))
    {
      if (watchData.el[attributeValueEl] === undefined)
      {
        watchData.el[attributeValueEl] = [];
      }

      if(watchData.el[attributeValueEl].indexOf(groupId) < 0)
      {
        watchData.el[attributeValueEl].push(groupId);
      }
    }

    // now check to see if this is required
    if (adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")) == false)
    {
      return;
    }

    var nodeValue = amxNode.getAttribute(attributeValue);
    // if the returned value is an array, then we will validate the length
    if (Array.isArray(nodeValue))
    {
      if (nodeValue.length > 0)
      {
        return;
      }
    }
    else if (amx.getTextValue(nodeValue) !== "")
    {
      return;
    }

    if (addRequired == false)
    {
      // this group has not been validated yet, so disregard
      return;
    }

    var tag = amxNode.getTag();
    var key;
    var nsPrefixedName = tag.getNsPrefixedName();
    if (nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":selectOneChoice" ||
        nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":selectManyChoice")
    {
      key = "MSG_MAKE_A_SELECTION";
    }
    else
    {
      key = "MSG_ENTER_A_VALUE";
    }

    var msg = adf.mf.resource.getInfoString("AMXInfoBundle", key);
    var label = amxNode.getAttribute("label");
    if (label == null)
    {
      label = "";
    }
    var text = label + ": " + msg;

    if (watchData.required[groupId] === undefined)
    {
      watchData.required[groupId] = [];
    }

    watchData.required[groupId].push(text);
  }

  // add to the passed in list an el expressions that this node
  // and this node's descendants are watching
  function buildValidationWatchData(groupId, domElement, watchData, addRequired)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var childNodes = domElement.childNodes;

        if (childNodes && childNodes.length > 0)
        {
          var childPromiseArray = [];
          // for each node
          for (var i = 0; i < childNodes.length; ++i)
          {
            var childNode = childNodes[i];

            // only check for node info if this is an amx-node
            // if not, just assume this is a container for actual amx-nodes
            if (childNode.nodeType == 1/*ELEMENT_NODE*/ && childNode.classList.contains("amx-node"))
            {
              var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(childNode, "amxNode");
              if (amxNode === undefined)
              {
                continue;
              }

              if (amx.isNodeRendered(amxNode) == false)
              {
                continue;
              }

              setValidationWatchData(groupId, amxNode, watchData, addRequired);
            }

            var childPromise = buildValidationWatchData(groupId, childNode, watchData, addRequired);
            childPromiseArray.push(childPromise);
          }
          adf.mf.internal.BasePromise.all(childPromiseArray).then(
            function()
            {
              resolve();
            });
        }
        else
        {
          resolve();
        }
      });
  }

  // build a list of all the el expressions that this group/array of groups are watching
  function buildValidationGroupWatchData(groupElements, isValidating)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var arrayOfPromises = [];
        var watchData = {
          el: {},
          required: {}
        };

        for (var i = 0; i < groupElements.length; ++i)
        {
          var groupElement = groupElements[i];
          if (groupElement.length != null)
          {
            groupElement = groupElement[0];
          }
          var addRequired;
          var id = adf.mf.internal.amx._getNonPrimitiveElementData(groupElement, "amxNode").getId();
          if (isValidating == true)
          {
            // add this to the list so that buildElWatchArray will return any required
            // failures for this group
            setGroupValidated(id);
            addRequired = true;
          }
          else
          {
            addRequired = isGroupValidated(id);
          }

          arrayOfPromises.push(buildValidationWatchData(id, groupElement, watchData, addRequired));
        }

        adf.mf.internal.BasePromise.all(arrayOfPromises).then(
          function()
          {
            resolve(watchData);
          });
      });
  }

  function getValidationDataForGroup(validationData, groupId, watchData)
  {
    if (validationData[groupId] === undefined)
    {
      validationData[groupId] = {
        invalid: [],
        required: []
      };
    }

    return validationData[groupId];
  }

  function buildValidationDataInternal(groupElements, isValidating, validationWatchData)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        if (groupElements.length == 0)
        {
          // nothing to do here, so just resolve it
          resolve();
          return;
        }
        amx.getElValue(amx.validationsInvalidListEl).then(
          function(requestAndResponse)
          {
            var response = requestAndResponse[1];
            var invalidList = response[0].value;
            var elWatchPromise =
              new adf.mf.internal.BasePromise(
                function(elWatchPromiseResolve, elWatchPromiseReject)
                {
                  if (validationWatchData == null)
                  {
                    var always = function(watchData)
                      {
                        validationWatchData = watchData;
                        elWatchPromiseResolve();
                      };
                    buildValidationGroupWatchData(groupElements, isValidating).then(always, always);
                  }
                  else
                  {
                    elWatchPromiseResolve();
                  }
                });

            var elWatchPromiseAlways = function()
            {
              var hasError = false;
              var hasWarning = false;
              var validationData = {};

              for(var item in validationWatchData.required)
              {
                if(validationWatchData.required.hasOwnProperty(item))
                {
                  hasError = true;

                  var groupValidationData = getValidationDataForGroup(validationData, item, validationWatchData);
                  // add all of these to the required list
                  groupValidationData.required = validationWatchData.required[item];
                }
              }

              // iterate through the invalid el expressions and determine if
              // the expression is in the list of el expressions that are
              // defined in descendants of the validationGroup tag
              for(var item in invalidList)
              {
                if(invalidList.hasOwnProperty(item))
                {
                  var elInfo = validationWatchData.el[item];
                  if(elInfo === undefined)
                  {
                    // not in the list
                    continue;
                  }

                  var arrayList = invalidList[item];
                  if (hasError == false)
                  {
                    for(var index in arrayList)
                    {
                      var nvp = arrayList[index];
                      if (nvp.name == ERROR_UPPER_STR)
                      {
                        hasError = true;
                        break;
                      }

                      if (nvp.name == WARNING_UPPER_STR)
                      {
                        hasWarning = true;
                      }
                    }
                  }

                  for (var group in elInfo)
                  {
                    var groupId = elInfo[group];
                    var groupValidationData = getValidationDataForGroup(validationData, groupId, validationWatchData);
                    groupValidationData.invalid.push(arrayList);
                  }
                }
              }

              if (hasError)
              {
                // let the caller know that navigation should fail
                reject(validationData);
                return;
              }

              // succeeded, but with possible warnings, so send in the data array
              resolve(validationData);
            };

            elWatchPromise.then(elWatchPromiseAlways, elWatchPromiseAlways);
          },
          function(requestAndResponse)
          {
            // failed to retrieve the invalid list - allow navigation to proceed
            resolve();
          });
      });
  }

  amx.buildValidationData = function(elementArray)
  {
    return buildValidationDataInternal(elementArray, false, null);
  };

  function getGroupsById(domElement)
  {
    var popupElement = _getClosestAncestorByClassName(domElement, "amx-popup");
    var validationGroupElements;
    if (popupElement != null)
    {
      // we are inside a popup, so we need to get a list of all of the groups in this popup
      validationGroupElements = popupElement.getElementsByClassName("amx-validationGroup");
    }
    else
    {
      validationGroupElements = document.getElementsByClassName("amx-validationGroup");
    }

    var groupsById = {};
    for (var i = 0; i < validationGroupElements.length; ++i)
    {
      var groupElement = validationGroupElements[i];
      var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(groupElement, "amxNode");
      var id = amxNode.getId();
      groupsById[id] = groupElement;
    }

    return groupsById;
  }

  // get the list of all of the groups that this control validates against
  function getValidationGroupList(domElement)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domElement, "amxNode");
        if (amxNode == null && adf.mf.environment.profile.mockData)
        {
          // Hosted CompGallery will experience this when changing row selection (e.g. listItemStyles.amx)
          resolve([]);
          return;
        }
        var tag = amxNode.getTag();
        var children = tag.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationBehavior");
        var len = children.length;
        var groups = [];

        if (len > 0)
        {
          var groupIdArray = [];
          var propPromises = [];

          for (var i = 0; i < len; ++i)
          {
            var subTag = children[i];

            var disabledEl = subTag.getAttribute("disabled");
            if (disabledEl != null)
            {
              var propPromise = new adf.mf.internal.BasePromise(
                function(propPromiseResolve, propPromiseReject)
                {
                  amx.getElValue(disabledEl)
                    .then(
                      function(requestAndResponse)
                      {
                        var response = requestAndResponse[1];
                        var resp = response[0];
                        if (adf.mf.api.amx.isValueTrue(resp.value))
                        {
                          propPromiseResolve();
                          return;
                        }
                        var groupId = subTag.getAttribute("group");
                        if (groupIdArray.indexOf(groupId) < 0)
                        {
                          groupIdArray.push(groupId);
                        }
                        propPromiseResolve();
                      },
                      propPromiseResolve);
                  });

              propPromises.push(propPromise);
            }
            else
            {
              var groupId = subTag.getAttribute("group");
              if (groupIdArray.indexOf(groupId) < 0)
              {
                groupIdArray.push(groupId);
              }
            }
          }

          adf.mf.internal.BasePromise.all(propPromises).then(
            function()
            {
              var groupsById = getGroupsById(domElement);
              for (var i = 0; i < groupIdArray.length; ++i)
              {
                var group = groupsById[groupIdArray[i]];
                if (typeof group !== "undefined")
                {
                  groups.push(group);
                }
              }

              resolve(groups);
            });
        }
        else
        {
          resolve(groups);
        }
      }, true /* needed for jQuery-like callbacks without timeouts */);
  }

  amx.requiredControlValueChanged = function(validationGroup)
  {
    if (amx.isValidating())
    {
      return;
    }

    // mark this group as validated
    var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(validationGroup, "amxNode");
    if (amxNode)
    {
      setGroupValidated(amxNode.getId());
      updateValidationMessages();
    }
  };

  function validateBegin()
  {
    __isValidating = true;
  }

  function validateEnd(groupElements, validationData)
  {
    __isValidating = false;

    if (groupElements === undefined || groupElements.length == 0)
    {
      // no groups were validated, exit early
      return;
    }

    var groupsToCheck = [];

    if (validationData !== undefined)
    {
      // if the validationData is not undefined, then there was a failure
      // go through and create a list of the groups that may need a message box
      for (groupId in validationData)
      {
        if(validationData.hasOwnProperty(groupId) == false)
        {
          continue;
        }

        groupsToCheck.push(groupId);
      }
    }

    updateValidationMessages(groupsToCheck);
  }

  amx.isValidating = function()
  {
    return __isValidating;
  };

  function validateInternal(domElement)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var always =
          function(groupElements)
          {
            // we now have the list of groups that we need to validate, so go
            // through them all and verify every el expressions is in the valid state
            if (groupElements.length == 0)
            {
              // everything is valid since there are no groups
              resolve(groupElements);
              return;
            }

            // make sure all of the unset values are validated
            amx.getElValue(amx.validationsUnsetListEl).then(
              function(requestAndResponse)
              {
                var response = requestAndResponse[1];
                var unsetList = response[0].value;
                // set this to null so that we only build up the node list when we want to
                // figure out if an item is valid or not
                var validationWatchData = null;
                var elToResolve = [];
                var unsetPromise =
                  new adf.mf.internal.BasePromise(
                    function(unsetPromiseResolve, unsetPromiseReject)
                    {
                      if (unsetList.length > 0)
                      {
                        buildValidationGroupWatchData(groupElements, true).then(function(watchData)
                        {
                          validationWatchData = watchData;
                          for (var i = 0; i < unsetList.length; ++i)
                          {
                            var item = unsetList[i];
                            if(validationWatchData.el[item] === undefined)
                            {
                              // not in the list
                              continue;
                            }

                            elToResolve.push(item);
                          }

                          if (elToResolve.length > 0)
                          {
                            amx.getElValue(elToResolve).then(
                              function(requestAndResponse)
                              {
                                var response = requestAndResponse[1];
                                // all the el expressions are resolved, so create an
                                // array of values to set
                                var setList = [];
                                // we might have more responses than just our requests, so make sure we handle that here
                                for (var i = 0; i < response.length; ++i)
                                {
                                  var item = response[i];
                                  if (elToResolve.indexOf(item.name) < 0)
                                  {
                                    // not part of what we requested
                                    continue;
                                  }

                                  setList.push({name:item.name, value:amx.getObjectValue(item.value)});
                                }
                                amx.setElValue(setList).then(
                                  function(requestAndResponse)
                                  {
                                    // success (but with possible failures), just continue
                                    // and check the invalid list later
                                    unsetPromiseResolve();
                                  },
                                  function(requestAndResponse)
                                  {
                                    // failure, just continue and check the invalid list later
                                    unsetPromiseResolve();
                                  });
                              },
                              function(requestAndResponse)
                              {
                                // failure, just continue and check the invalid list later
                                unsetPromiseResolve();
                              });
                          }
                          else
                          {
                            unsetPromiseResolve();
                          }
                        },
                        function()
                        {
                          unsetPromiseResolve();
                        });
                      }
                      else
                      {
                        unsetPromiseResolve();
                      }
                    });

                unsetPromise.then(
                  function()
                  {
                    buildValidationDataInternal(groupElements, true, validationWatchData).then(
                      function(validationData)
                      {
                        // we can navigate (may have warnings)
                        resolve([groupElements, validationData]);
                      },
                      function(validationData)
                      {
                        // we can NOT navigate
                        reject([groupElements, validationData]);
                      });
                  });
              },
              function(requestAndResponse)
              {
                // failed to retrieve the unset list - allow navigation to proceed
                resolve(groupElements);
              });
          };
        getValidationGroupList(domElement).then(always, always);
      }, true /* needed for jQuery-like callbacks without timeouts */);
  }

  /**
   * Use this when performing an operation like a navigation where you would want to prevent navigating
   * when there are unsatisfied validators (required or AMX validationBehavior).
   * The successCallback will be invoked if allowed to proceed.
   * @param {DOMNode} domNode the element whose associated validation is to be tested
   * @param {function} successCallback the function to invoke if the event should be accepted
   */
  adf.mf.api.amx.validate = function(domNode, successCallback)
  {
    amx.validate(domNode).then(function()
    {
      if (successCallback && adf.mf.api.amx.acceptEvent())
      {
        successCallback();
      }
    });
  };

  /**
   * Private, internal function.
   */
  amx.validate = function(domElement)
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Validate node", adf.mf.log.level.FINER, "amx.validate");

    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        validateBegin();
        validateInternal(domElement)
          .then(
            function(groupElementsAndValidationData)
            {
              var groupElements = groupElementsAndValidationData[0];
              validateEnd(groupElements);
              perf.stop();
              resolve();
            },
            function(groupElementsAndValidationData)
            {
              var groupElements = groupElementsAndValidationData[0];
              var validationData = groupElementsAndValidationData[1];
              validateEnd(groupElements, validationData);
              perf.stop();
              reject();
            });
      }, true /* needed for jQuery-like callbacks without timeouts */);
  };

  // register the data change handler
  adf.mf.api.addDataChangeListeners(amx.validationsInvalidListEl, validationsDataChangeHandler);

  //--------- ErrorHandler ---------//
  // taken from Trinidad.Core.js
  /**
   * Return true if the object or any of its prototypes'
   * are an instance of the specified object type.
   * @param {Object} obj the object instance
   * @param {Object} type the constructor function
   */
  function _instanceof(obj, type)
  {
    if (type == (void 0))
      return false;

    if (obj == (void 0))
      return false;

    while (typeof(obj) == "object")
    {
      if (obj.constructor == type)
        return true;

      // walk up the prototype hierarchy
      obj = obj.prototype;
    }

    return false;
  }

  /**
   * The is the home for all error handling. This gets registered as an error handler
   * in adf.mf.api.amx.loadTrinidadResources (amx-resource.js) and will extract the
   * relevant error information and call adf.mf.api.amx.addMessage
   *
   * @param request the channel request, can be null if this is called manually
   * @param response a JS Error instance, a TrConverterException or TrValidatorException instance,
   *                 or an exception in JSON form
  */
  adf.mf.internal.amx.errorHandlerImpl = function(request, response)
  {
    // detect if this is a known Trinidad error class
    if (_instanceof(response, window["TrConverterException"]) || _instanceof(response, window["TrValidatorException"]))
    {
      var facesMsg = response.getFacesMessage();
      var severity = facesMsg.getSeverity();
      var severityStr = ERROR_STR;
      if (severity == TrFacesMessage.SEVERITY_INFO)
      {
        severityStr = "info";
      }
      else if (severity == TrFacesMessage.SEVERITY_WARN)
      {
        severityStr = "warning";
      }
      else if (severity == TrFacesMessage.SEVERITY_ERROR)
      {
        severityStr = ERROR_STR;
      }
      else // if (severity == TrFacesMessage.SEVERITY_FATAL)
      {
        severityStr = "fatal";
      }
      adf.mf.api.amx.addMessage(severityStr, facesMsg.getDetail(), null, null);
      return;
    }

    // detect if this is a known js error class
    if (_instanceof(response, Error))
    {
      adf.mf.api.amx.addMessage(ERROR_STR, response.message, null, null);
      return;
    }

    // assume this is an exception from the channel
    var exceptionClassName = response[adf.mf.internal.api.constants.TYPE_PROPERTY];
    var isBatchValidation = (exceptionClassName == batchValidationExName);
    // check to see if we are in the process of validating all of the
    // el expressions contained in this group. We will go back and add
    // of the validation messages from the validationContext, so don't
    // add any that fire right now
    if (amx.isValidating())
    {
      if (isBatchValidation || exceptionClassName == validationExName)
      {
        return;
      }
    }

    if (isBatchValidation)
    {
      // loop through the the batch exceptions and add them one by one
      var batch = response.batch;
      if (batch !== undefined && batch != null)
      {
        for (var i = 0; i < batch.length; ++i)
        {
          addMessageFromException(batch[i]);
        }
      }
      return;
    }

    addMessageFromException(response);
  };

  function addMessageFromException(ex)
  {
    if (ex.exception)
      ex = ex.exception;
    var msg = ex.message;
    var severity = ex.severity;
    if (severity === undefined)
      severity = "fatal";
    adf.mf.api.amx.addMessage(severity == null ? "severe" : severity.toLowerCase(), msg, null, null);
  }

  /**
   * Adds a message to the message box (and shows it if it isn't already showing.
   * @param {string} severity the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   * @param {string} summary the short title of the message (e.g. exception message)
   * @param {string} detail null or the optional long detail of the message (e.g. stack trace)
   * @param {string} clientId null or the optional client ID that uniquely identify which component instance the message should be associated with
   */
  adf.mf.api.amx.addMessage = function(severity, summary, detail, componentClientId)
  {
    messageBoxCreate().addItem(severity, summary, detail);
  };

  function severityStringToInt(severity)
  {
    var val = __severityStringToInt[severity];
    if (val == null)
    {
      val = ERROR_VAL;
    }

    return val;
  }

  function severityIntToDisplayString(severity)
  {
    var val = __severityIntToDisplayString[severity];
    if (val == null)
    {
      val = ERROR_DISPLAY_STR;
    }

    return val;
  }

  //--------- ErrorHandler ---------//

  /**
   * Get the child elements that have the specified class names.
   * @param {HTMLElement} parentElement the element whose children will be traversed
   * @param {Array.<String>} classNames the class names to search for
   * @param {boolean} searchInChildOrder whether to start looking at the first child then second, etc.
   * @return {Array} an array of found elements whose entries match the specified classNames order
   */
  function _getChildrenByClassNames(parentElement, classNames, searchInChildOrder)
  {
    var childNodes = parentElement.childNodes;
    var childNodeCount = childNodes.length;
    var classNameCount = classNames.length;
    var foundChildren = [];
    var foundCount = 0;
    if (searchInChildOrder === false) // start with the last index
    {
      for (var i = childNodeCount - 1; i >= 0 && foundCount < classNameCount; --i)
      {
        var child = childNodes[i];
        for (var j = 0; j < classNameCount; ++j)
        {
          if (child.nodeType == 1/*ELEMENT_NODE*/ && child.classList.contains(classNames[j]))
          {
            foundChildren[j] = child;
            ++foundCount;
            break; // done with this specific child
          }
        }
      }
    }
    else // start with the first index:
    {
      for (var i = 0; i < childNodeCount && foundCount < classNameCount; ++i)
      {
        var child = childNodes[i];
        for (var j = 0; j < classNameCount; ++j)
        {
          if (child.nodeType == 1/*ELEMENT_NODE*/ && child.classList.contains(classNames[j]))
          {
            foundChildren[j] = child;
            ++foundCount;
            break; // done with this specific child
          }
        }
      }
    }
    return foundChildren;
  }

  /**
   * Get the nearest ancestor element that has the specified class name (could be the specified element too).
   * @param {HTMLElement} startingElement the element (inclusive) to find the closest ancestor with the given className
   * @param {string} className the class name to search for
   * @return {HTMLElement} the found ancestor element whose or null if not found
   */
  function _getClosestAncestorByClassName(startingElement, className)
  {
    if (startingElement == null)
      return null;
    else if (startingElement.className == className)
      return startingElement;
    else
      return _getClosestAncestorByClassName(startingElement.parentNode, className);
  }

  //--------- MessageBox ---------//
  function MessageBox()
  {
  }

 /**
   * Creates or returns the header object as the first entry in the content.
  */
  MessageBox.prototype.getHeader = function()
  {
    var headerClassName = "amx-messages-header";
    // ake sure that the first item in the content is not a header
    var firstNode = this.contentElement.firstChild;
    var headerNode;
    if (firstNode == null ||
      firstNode.nodeType != 1 /*ELEMENT_NODE*/ ||
      !firstNode.classList.contains(headerClassName))
    {
      headerNode = document.createElement("div");
      headerNode.className = headerClassName;
      this.contentElement.parentNode.insertBefore(headerNode, this.contentElement);
    }
    else
    {
      headerNode = firstNode;
    }
    return headerNode;
  };

  /**
   * This updates the messagebox label if the type of message
   * is more severe than the current label severity
   * ("error" takes precedence over "warning")
   * @param type the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   */
  MessageBox.prototype.setHeaderLabel = function(type)
  {
    var typeValue = severityStringToInt(type);

    if (this.headerValue == null || typeValue < this.headerValue)
    {
      this.headerValue = typeValue;
    }
    else
    {
      return;
    }

    // Ensure that we only have the most-severe header:
    var parentNode = this.contentElement.parentNode;
    var headers = parentNode.querySelectorAll(".amx-messages-header");
    for (var i=headers.length-1; i>=0; --i)
    {
      var oldHeader = headers[i];
      var oldValue = parseInt(oldHeader.getAttribute("data-value"), 10);
      if (oldValue >= this.headerValue)
      {
        adf.mf.api.amx.removeDomNode(oldHeader);
      }
    }

    var newHeader = severityIntToDisplayString(this.headerValue);
    var headerNode = this.getHeader();
    headerNode.setAttribute("data-value", this.headerValue);
    // remove the current message, if it exists
    headerNode.innerHTML = "";
    // now add the message label
    var labelNode = document.createElement("div");
    labelNode.className = "amx-messages-header-text";
    labelNode.textContent = adf.mf.resource.getInfoString(adf.mf.resource.ADFInfoBundleName, __severityDisplayStringBundleKey[newHeader]);
    labelNode.setAttribute("role", "heading");
    headerNode.appendChild(labelNode);
  };

  /**
   * This adds the passed in data to the current message box
   * Note: if the type of message is more severe than the current
   * label severity, it will be replace
   * ("error" takes precedence over "warning")
   * @param type the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   * @param summary the error summary message
   * @param detail any extra detail to be shown to the user, or null
  */
  MessageBox.prototype.addItem = function(type, summary, detail)
  {
    this.setHeaderLabel(type);
    // for now, type can only be warning or error since we don't have graphics
    // for the other ones. So error will be "error" and "fatal" and all else
    // will be warnings
    var typeValue = severityStringToInt(type);
    var errorClass;
    switch (typeValue)
    {
      case INFO_VAL:
        errorClass = INFO_STR;
        break;
      case CONFIRMATION_VAL:
        errorClass = CONFIRMATION_STR;
        break;
      case WARNING_VAL:
        errorClass = WARNING_STR;
        break;
      default: // error and fatal
        errorClass = ERROR_STR;
    }
    var itemNode = document.createElement("div");
    itemNode.className = "amx-messages-item";
    itemNode.setAttribute("role", "listitem");
    var textItem1 = document.createElement("div");
    textItem1.className = "amx-messages-text amx-messages-text-" + errorClass + " amx-messages-" + errorClass;
    textItem1.textContent = summary;
    if (detail !== undefined && detail != null && detail != "")
    {
      textItem1.appendChild(document.createElement("br"));
      textItem1.appendChild(document.createTextNode(detail));
    }
    var prevMessagesItem = _getChildrenByClassNames(this.contentElement, ["amx-messages-item"], false)[0];
    var prevTextItem = null;
    if (prevMessagesItem != null)
      prevTextItem = _getChildrenByClassNames(prevMessagesItem, ["amx-messages-text"], false)[0];
    if (prevTextItem == null)
    {
      textItem1.classList.add("amx-messages-first");
    }
    else
    {
      prevTextItem.classList.remove("amx-messages-last");
    }
    // this is the last item
    textItem1.classList.add("amx-messages-last");
    itemNode.appendChild(textItem1);
    var icon = document.createElement("div");
    icon.className = "amx-messages-icon amx-messages-icon-" + errorClass;
    itemNode.appendChild(icon);
    this.contentElement.appendChild(itemNode);

    // now center the whole msg box vertically
    var messageBoxElement = this.messageBoxElement;
    var messageBoxComputedStyle = adf.mf.internal.amx.getComputedStyle(messageBoxElement);
    var messageBoxMarginTop = messageBoxComputedStyle.marginTop;
    var messageBoxMarginBottom = messageBoxComputedStyle.marginBottom;
    var messageBoxOuterHeight =
      messageBoxElement.offsetHeight +
      parseInt(messageBoxMarginTop, 10) +
      parseInt(messageBoxMarginBottom, 10);

    // In order to center the message box on the view, we need its height.
    // It is possible to display an error prior to displaying the first view so
    // in that case we should use the body height as a fallback.
    var bodyPageViews = document.getElementById("bodyPageViews");
    var firstViewContainer = _getChildrenByClassNames(bodyPageViews, ["amx-view-container"])[0];
    var viewElement = document.body;
    if (firstViewContainer != null)
      viewElement = _getChildrenByClassNames(firstViewContainer, ["amx-view"])[0];
    var viewHeight = viewElement.offsetHeight;

    var newTop;
    if (messageBoxOuterHeight < viewHeight)
    {
      newTop = (viewHeight - messageBoxOuterHeight)/2;
    }
    else
    {
      newTop = 0;
    }

    messageBoxElement.style.top = newTop + "px";
  };

  /**
   * Adds the footer than contains the OK button
  */
  MessageBox.prototype.addFooter = function(messageBoxContainer)
  {
    var footerNode = document.createElement("div");
    footerNode.className = "amx-messages-footer";
    var btnNode = document.createElement("div");
    btnNode.className = "amx-messages-btn amx-commandButton";
    // Adding WAI-ARIA Attribute for the message box commandButton role attribute
    btnNode.setAttribute("role", "button");
    var buttonLabel = document.createElement("div");
    buttonLabel.className = "amx-messages-btn-label amx-commandButton-label";

    // ADFInfoBundle[LBL_OK_DISPLAY_STR] is special cased in getResourceStringImpl(), and will always return a displayable value
    buttonLabel.textContent = adf.mf.resource.getInfoString(adf.mf.resource.ADFInfoBundleName, "LBL_OK_DISPLAY_STR");

    btnNode.appendChild(buttonLabel);
    footerNode.appendChild(btnNode);
    var mousedown = "mousedown";
    var mouseup = "mouseup";
    if (amx.hasTouch())
    {
      mousedown = "touchstart";
      mouseup = "touchend";
    }
    adf.mf.api.amx.addBubbleEventListener(btnNode, mousedown, function()
    {
      btnNode.classList.add("amx-selected");
    });
    adf.mf.api.amx.addBubbleEventListener(btnNode, mouseup, function()
    {
      btnNode.classList.remove("amx-selected");
    });
    adf.mf.api.amx.addBubbleEventListener(btnNode, "mouseout", function()
    {
      btnNode.classList.remove("amx-selected");
    });

    var extendedTarget = document.createElement("div");
    extendedTarget.className = "amx-extendedTarget";
    btnNode.appendChild(extendedTarget);

    messageBoxContainer.appendChild(footerNode);
    return btnNode;
  };

  /**
   * Creates the basic structure of this message box class
  */
  MessageBox.prototype.create = function()
  {
    var bodyPageViews = document.getElementById("bodyPageViews");
    var messageBoxElement = document.createElement("div");
    messageBoxElement.id = "amxMessageBox";
    // make sure this responds to dragging for scrolling purposes
    adf.mf.api.amx.enableScrolling(messageBoxElement);
    messageBoxElement.classList.add("messageBox");
    var messageBoxScreen = document.createElement("div");
    messageBoxScreen.className = "transparentScreen messageBoxScreen";
    bodyPageViews.appendChild(messageBoxScreen);
    bodyPageViews.appendChild(messageBoxElement);
    adf.mf.internal.amx._setNonPrimitiveElementData(messageBoxElement, "messageBox", this);
    var messageBoxObject = this;
    this.e = messageBoxElement;
    this.screen = messageBoxScreen;
    messageBoxElement.style.display = "none";
    var messageBoxContainer = document.createElement("div");
    messageBoxContainer.className = "messageBoxContainer";
    // Adding WAI-ARIA Attribute for role the message container div
    messageBoxContainer.setAttribute("role", "alertdialog");
    messageBoxElement.appendChild(messageBoxContainer);
    var messageBoxContent = document.createElement("div");
    messageBoxContent.className = "messageBoxContent";
    messageBoxContent.setAttribute("role", "list");
    messageBoxContainer.appendChild(messageBoxContent);
    this.contentElement = messageBoxContent;
    this.messageBoxElement = messageBoxElement;
    var okButton = this.addFooter(messageBoxContainer);

    /*adf.mf.api.amx.addBubbleEventListener(messageBoxScreen, "tap", function()
    {
      // this is always modal for now
      // messageBox.hide();
    });*/

    adf.mf.api.amx.addBubbleEventListener(okButton, "tap", function(event)
      {
        // Eat the event since this button is handling it:
        event.preventDefault();
        event.stopPropagation();

        // Delay the DOM removal so that the event eating doesn't fail to trigger a focus
        // on some input component behind this popup (we don't want the input's keyboard to appear):
        setTimeout(function()
        {
          messageBoxObject.hide();
        },
        0);
      });

    return messageBoxElement;
  };

  /**
   * Shows the message box to the user
  */
  MessageBox.prototype.show = function()
  {
    var messageBoxElement = this.e;
    var messageBoxScreen = this.screen;

    messageBoxScreen.style.display = "";
    messageBoxElement.style.display = "";

    // All view containers are now hidden from screen readers (we can't just
    // look for the first one because an error could occur while transitioning):
    var foundViewContainers = document.getElementsByClassName("amx-view-container");
    for (var i=0, elementCount=foundViewContainers.length; i<elementCount; i++)
    {
      foundViewContainers[i].setAttribute("aria-hidden", "true"); // Note: toggling this doesn't work on iOS 5 but does in iOS 6
    }
  };

  /**
   * Hides the message box from the user
  */
  MessageBox.prototype.hide = function()
  {
    var messageBoxElement = this.e;
    var messageBoxScreen = this.screen;

    var messageBoxContent = this.contentElement;
    messageBoxContent.innerHTML = "";

    adf.mf.api.amx.removeDomNode(messageBoxElement);
    adf.mf.api.amx.removeDomNode(messageBoxScreen);

    // All view containers are no longer hidden from screen readers (we can't just
    // look for the first one because an error could occur while transitioning):
    var foundViewContainers = document.getElementsByClassName("amx-view-container");
    for (var i=0, elementCount=foundViewContainers.length; i<elementCount; i++)
    {
      foundViewContainers[i].setAttribute("aria-hidden", "false"); // Note: toggling this doesn't work on iOS 5 but does in iOS 6
    }
  };

  function messageBoxCreate()
  {
    var messageBoxElement = null;
    var messageBoxObject = null;
    var foundMessageBoxElements = document.getElementsByClassName("messageBox");
    if (foundMessageBoxElements.length > 0)
    {
      messageBoxElement = foundMessageBoxElements[0];
      messageBoxObject = adf.mf.internal.amx._getNonPrimitiveElementData(messageBoxElement, "messageBox");
    }
    else
    {
      messageBoxObject = new MessageBox();
      messageBoxElement = messageBoxObject.create();
    }
    messageBoxObject.show();
    return messageBoxObject;
  };
  //--------- /MessageBox ---------//
})();
// @compiled on Sat Aug 13 01:07:17 MDT 2016
// Note: this is a generated file all changes will be lost. 


/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/ControlFlowEngine.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.ControlFlowEngine = ControlFlowEngine;
  function ControlFlowEngine()
  {}

  ControlFlowEngine.BACK_NAV_OUTCOME = "__back";
  // For backward compatability, remove after tests transition to the new value above.
  ControlFlowEngine.BACK_NAV_OUTCOME_OLD = "_BACK_BUTTON:";

  ControlFlowEngine.doRouting = function(routingState)
  {
    //
    //  See if routing is complete.
    //
    if (!routingState.isRoutingComplete())
    {
      //
      //  Routing is not yet complete so we need to get the ID of the next
      //  activity to be executed.
      //
      var getActivityIdComplete = function(nextActivityId, routingState1)
      {
         if (nextActivityId != null)
         {
           //
           //  Get the activity.
           //
           ControlFlowEngine.getActivity(
             function(activity)
             {
               if (activity)
               {
                 //
                 //  Get the implementation logic for the activity.
                 //
                 var activityLogic = ControlFlowEngine.getActivityLogic(activity);
                 if (activityLogic)
                 {
                   //
                   //  Update the routing state.
                   //
                   routingState1.setCurrentActivityId(nextActivityId);
                   routingState1.setNextActivityId(null);

                   //
                   //  Execute the activity.
                   //
                   ControlFlowEngine.executeActivity(activity, activityLogic, routingState,
                                          ControlFlowEngine.doRouting,
                                          routingState1.getRoutingFailedCallback());
                   return;
                 }
                 else
                 {
                   var errMsg = "ADFc: failed to find activity logic implementation: " + activity.getActivityType();
                   routingState.getRoutingFailedCallback()(errMsg);
                 }
               }
               else
               {
                  var errMsg2 = "ADFc: failed to find activity: " + nextActivityId;
                  routingState.getRoutingFailedCallback()(errMsg2);
               }
             },
             nextActivityId);
         }
         else
         {
           //
           //  We're not able to tell what activity to execute next.
           //
           routingState1.setRoutingComplete(true);
           ControlFlowEngine.doRouting(routingState1);
           return;
         }
      };
      ControlFlowEngine.getNextActivityId(routingState, getActivityIdComplete);
      return;
    }

    if (routingState.isRoutingComplete() && (routingState.getNavigationResult() == null))
    {
       if (routingState.getNavigationResult() == null)
       {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: constructing navigation result.");
        }

        var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();

        //
        //  Do we have back navigation?
        //
        var backNav = routingState.getBackNavigation();
        if (backNav)
        {
          var startingActivityId = routingState.getStartingActivityId();
          var currentActivityId = routingState.getCurrentActivityId();

          //
          // Determine if the current routing state has an incorrect back called on a page that is not bound to any task flows.
          // This should only happen if there is user error (they make an app without a task flow and invoke __back) or on devices that
          // can override the back system action. In both situations, we need to handle it as an invalid back action.
          //
          // Note: This won't be true on a task flow pop. The logic makes sure that the current activity is also the starting activity, which
          // might be the case on a valid task flow pop. However, any valid task flow scenario will also have a non-null taskFlowId.
          //
          var isLastTaskFlowBack = (startingActivityId != null && startingActivityId === currentActivityId && startingActivityId.getTaskFlowId() == null);
          if (isLastTaskFlowBack)
          {
           //
           // This might be an unbounded task flow. If so, we need to perform a check to see if the back action will result in the task flow being
           // exited, so that we can continue on with the unhandled back logic. If the current task flow won't be exited, then it is a valid
           // unbounded task flow action and we allow it.
           //
           isLastTaskFlowBack = ((currentTaskFlowEntry == null) || ((currentTaskFlowEntry.getViewHistoryLength() == 1) && !routingState.isBackNavTfPopped()));
          }
          
          //
          //  Is back navigation valid from the view we're currently on?
          //
          if (isLastTaskFlowBack ||
             (!routingState.isBackNavTfPopped() && !currentTaskFlowEntry.peekViewHistory().isBackNavigationValid()))
          {
            //
            // Always hide the loading indicator before further processing
            //
            adfc.internal.SystemUtil.hideLoadingIndicator();

            //
            // Since the navigation listeners already received a Navigation Start event, make sure to also send an End event.
            //
            ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), null);
            
            //
            // Let the native side optionally handle the back
            //
            if (adfc.internal.SystemUtil.onBackUnhandled())
            {
              //
              // Back was handled, so exit early
              //
              return;
            }

           if (adfc.internal.LogUtil.isFine())
           {
             adfc.internal.LogUtil.fine("ADFc: invalid back navigation detected, throwing an error.");
           }
           throw new Error("back navigation is not valid from the current view");
          }

          //
          //  Will the back navigation result in the current task flow being exited?
          //
          else if ((currentTaskFlowEntry.getViewHistoryLength() == 1) && !routingState.isBackNavTfPopped())
          {
            //
            //  Back navigation out of the TF.  We need to pop the flow that was exited.
            //
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("ADFc: back navigation out of a task flow, popping flow.");
            }
            var currentViewItem = currentTaskFlowEntry.peekViewHistory();
            routingState.setBackNavTfLeftViewItem(currentViewItem);

            var popSuccessCallback = function()
            {
              if (adfc.internal.LogUtil.isFine())
              {
                adfc.internal.LogUtil.fine("ADFc: task flow pop completed.");
              }
              var routingState1 = ControlFlowEngine.getCurrentRoutingState();
              ControlFlowEngine.clearCurrentRoutingState();
              routingState1.setBackNavTfPopped(true);
              ControlFlowEngine.doRouting(routingState1);
              return;
            }

            ControlFlowEngine.setCurrentRoutingState(routingState);
            var controllerState = adfc.internal.AdfcContext.getControllerState();
            controllerState.popTaskFlow(popSuccessCallback, routingState.getRoutingFailedCallback());
            return;
          }

          //
          //  See if we have already popped a back navigation exited flow.
          //
          else if (routingState.isBackNavTfPopped())
          {
             //
             //  We already popped the exited flow so create a result based on the
             //  view we're returning to.
             //
             if (adfc.internal.LogUtil.isFine())
             {
               adfc.internal.LogUtil.fine("ADFc: back navigation out of a task flow, flow already popped.");
             }
             var leftViewItem = routingState.getBackNavTfLeftViewItem();
             var returnedToViewItem = currentTaskFlowEntry.peekViewHistory();
             var navResult = ControlFlowEngine.constructBackNavResult(leftViewItem, returnedToViewItem);
             routingState.setNavigationResult(navResult);
             ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), navResult);
             (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
          }
          else
          {
            //
            //  Back navigation occurred within the same flow.
            //
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("ADFc: back navigation within a task flow.");
            }
            var leftViewItem1 = currentTaskFlowEntry.popViewHistory();
            var returnedToViewItem1 = currentTaskFlowEntry.peekViewHistory();
            var navResult1 = ControlFlowEngine.constructBackNavResult(leftViewItem1, returnedToViewItem1);
            routingState.setNavigationResult(navResult1);
            ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), navResult1);
            (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
          }
        }
        else
        {
          //
          //  We either had forward navigation or no navigation at all.
          //
          if (adfc.internal.LogUtil.isFine())
          {
            adfc.internal.LogUtil.fine("ADFc: forward navigation.");
          }
          ControlFlowEngine.constructForwardNavResult(
            function(navResult2)
            {
              routingState.setNavigationResult(navResult2);

              //
              //  See if back navigation is valid from the view we reached (if we reached a view).
              //  If we navigated to a view and we exited a task flow then back navigation is not
              //  valid.
              //
              if (routingState.isViewReached() && routingState.isTaskFlowReturnExecuted())
              {
                //
                //  Back navigation is not valid in this case.
                //
                var currentViewItem2 = currentTaskFlowEntry.peekViewHistory();
                currentViewItem2.setBackNavigationValid(false);
              }

              //
              //  Pass the navigation result back to the success function.
              //
              ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), routingState.getNavigationResult());
              (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
            },
            routingState);
        }
      }
    }
  };

  /**
   * Construct a NavigationResult object based on back navigation.
   */
  ControlFlowEngine.constructBackNavResult = function(backFromViewItem, retunredToViewItem)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: constructing back navigation result.");
    }
    newViewId = retunredToViewItem.viewId;
    vdlDocPath = retunredToViewItem.amxPage;
    transition = backFromViewItem.transitionType;
    var result = new adfc.NavigationResult(false, true, newViewId, vdlDocPath, transition, false, true);
    adfc.internal.ElUtil.setMfContextInstance(retunredToViewItem, false);
    ControlFlowEngine.logNavResult(result);
    return result;
  }

  /**
   * Construct a NavigationResult object based on forward (or no) navigation.
   */
  ControlFlowEngine.constructForwardNavResult = function(callback, routingState)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: constructing forward navigation result.");
    }

    var finalViewId = null;
    var newViewId = null;
    var transition = null;
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();

    //
    //  See if we navigated to a new view.  If the starting and ending task flow instance ID
    //  and viewId are the same then we didn't reach a new view, otherwise we did.
    //
    var newView = routingState.isViewReached();
    var differentView = newView;
    if (newView)
    {
       finalViewId = routingState.getCurrentActivityId();

       var startingTfInstance = routingState.getStartingTaskFlowInstanceId();
       var currentTfInstance = currentTaskFlowEntry.getInstanceId();
       if (startingTfInstance == currentTfInstance)
       {
         //
         //  We're still in the same task flow.
         //
         var startingViewId = routingState.getStartingActivityId();
         if ((finalViewId != null) && (startingViewId != null) && (startingViewId.equals(finalViewId)))
         {
           newView = false;
         }
         else if ((finalViewId == null) && (startingViewId == null))
         {
           newView = false;
         }
       }
       differentView = newView;

       //
       //  Figure out what type of transition to use for the new view.
       //
       transition = routingState.getTransition();
    }
    else
    {
      //
      //  See if we returned from a bounded task flow.
      //
      var tfEntry = routingState.getLastReturnedFromTfEntry();
      if (tfEntry != null)
      {
        //
        //  Navigation didn't reach a new view but we did return from a task flow.
        //  In this case return to the calling view activity in the flow we've
        //  returned to.
        //
        finalViewId = tfEntry.getCallingViewActivityId();
        differentView = true;
      }
    }

    var vdlDocPath = null;
    if (finalViewId != null)
    {
      newViewId = finalViewId.getLogicalViewId();
      var localId = finalViewId.getLocalActivityId();
      currentTaskFlowEntry.getTaskFlowDefinition(
        function(currentTaskFlowDef)
        {
          var finalActivity = currentTaskFlowDef.getActivities()[localId];
          vdlDocPath = finalActivity.getVldDocumentPath();
          ControlFlowEngine._constructForwardNavResultPhase2(
            transition,
            currentTaskFlowEntry,
            differentView,
            newView,
            newViewId,
            vdlDocPath,
            finalViewId,
            callback);
        });
    }
    else
    {
      ControlFlowEngine._constructForwardNavResultPhase2(
        transition,
        currentTaskFlowEntry,
        differentView,
        newView,
        newViewId,
        vdlDocPath,
        finalViewId,
        callback);
    }
  };

  ControlFlowEngine._constructForwardNavResultPhase2 = function(
    transition,
    currentTaskFlowEntry,
    differentView,
    newView,
    newViewId,
    vdlDocPath,
    finalViewId,
    callback)
  {
    if (transition == null)
    {
      transition = adfc.internal.ControlFlowCase.DEFAULT_TRANSITION;
    }

    if (newView)
    {
      //
      //  Push a new view history entry.
      //
      currentTaskFlowEntry.pushViewHistory(newViewId, vdlDocPath, transition);
    }
    else if (finalViewId != null)
    {
      //
      //  Reset the MfContextInstance.
      //
      adfc.internal.ElUtil.setMfContextInstance(currentTaskFlowEntry.peekViewHistory(), false);
    }

    var result = new adfc.NavigationResult(newView, false, newViewId, vdlDocPath, transition, false, differentView);
    ControlFlowEngine.logNavResult(result);
    callback(result);
  };

  ControlFlowEngine.logNavResult = function(navResult)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      var msg = "ADFc: navigationResult:" +
        " isDifferentViewId=" + navResult.mDifferentViewId +
        " isNewViewId=" + navResult.mNewViewId +
        " isBackNav=" + navResult.mBackNavigation +
        " viewId=" + navResult.mViewId +
        " vdlDocPath=" + navResult.mVdlDocumentPath +
        " transitionType=" + navResult.mTransitionType +
        " featureExited=" + navResult.mFeatureExited;
      adfc.internal.LogUtil.fine(msg);
    }
  }

  ControlFlowEngine.getNextActivityId = function(routingState, complete)
  {
    //
    //  If the routing state already has a next activity defined then that's
    //  what we want to use.
    //
    var result = routingState.getNextActivityId();
    if (result)
    {
      complete(result, routingState);
    }
    else
    {
      //
      //  Check for a special outcome.
      //
      var currentOutcome = routingState.getCurrentOutcome();
      if ((currentOutcome == ControlFlowEngine.BACK_NAV_OUTCOME) ||
         (currentOutcome == ControlFlowEngine.BACK_NAV_OUTCOME_OLD))
      {
        routingState.setBackNavigation(true);
        routingState.setRoutingComplete(true);
        complete(result, routingState);
      }
      else
      {
        //
        //  Evaluate the control flow rules to determine the next activity.
        //
        var findCfCaseComplete = function(routingState1)
        {
          var cfCase = routingState1.getControlFlowCase();
          if (cfCase)
          {
            result = cfCase.getTargetActivityId();
            routingState1.setTransition(cfCase.getTransition());
          }
          complete(result, routingState1);
        };
        routingState.setFindCfCaseCallback(findCfCaseComplete);
        routingState.resetCfRuleEvaluation();
        ControlFlowEngine.findControlFlowCase(routingState);
      }
    }
  };

  ControlFlowEngine.findControlFlowCase = function(routingState)
  {
    //
    //  We need to evaluate the control flow rules.  Get the current set
    //  of control flow rules from the current page flow.
    //
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(currentTaskFlow)
      {
        //
        //  Get the best matching control flow rule.
        //
        var alreadyTried = routingState.getTriedCfRules();

        //
        //  Get the best matching rule that has not already been tried.
        //
        var currentActivityId = routingState.getCurrentActivityId();
        var cfRule = ControlFlowEngine.getBestControlFlowRule(currentTaskFlow, currentActivityId, alreadyTried);
        if (cfRule != null)
        {
          //
          //  A rule was found.  Check to see if it has a matching control
          //  flow case.
          //
          var cfCase = cfRule.getControlFlowCase(routingState.getCurrentOutcome());
          if (cfCase != null)
          {
            //
            // Check the guard condition
            //
            var guardConditionCallback = function(executeCase, routingState1)
            {
              if (executeCase)
              {
                //
                //  A matching control flow case was found. Use it to identify
                //  the next activity to be executed.
                //
                var result = cfCase;
                routingState.setControlFlowCase(result);
                routingState.getFindCfCaseCallback()(routingState);
              }
              else
              {
                //
                //  A matching control flow case was not found.  Add this rule's
                //  from activity ID to the set of one's already tried and try again.
                //
                alreadyTried[cfRule.getFromActivityId().getLocalActivityId()] = true;
                ControlFlowEngine.findControlFlowCase(routingState);
              }
            };
            var guardCondition = cfCase.getGuardCondition();
            ControlFlowEngine.evaluateGuardCondition(guardCondition, routingState, guardConditionCallback);
          }
          else
          {
            //
            //  A matching control flow case was not found.  Add this rule's
            //  from activity ID to the set of one's already tried and try again.
            //
            alreadyTried[cfRule.getFromActivityId().getLocalActivityId()] = true;
            ControlFlowEngine.findControlFlowCase(routingState);
          }
        }
        else
        {
          //
          //  No control flow rule was found.
          //
          routingState.getFindCfCaseCallback()(routingState);
        }
      });
  };

  ControlFlowEngine.getBestControlFlowRule = function(pageFlow, fromId, excludeSet)
  {
    var WILDCARD_ID = "*";
    var result = null;

    //
    // The best matching rule is an exact match on the fromId.  Next, the best
    // matching rule is the one that has a fromId that ends with an asterisk,
    // matches the fromId up until the asterisk, and is the longest.
    //
    var cfRules = pageFlow.getControlFlowRules();
    if (fromId != null)
    {
      var localId = fromId.getLocalActivityId();
      if (!excludeSet[localId])
      {
        result = cfRules[localId];
      }
    }
    if (result == null)
    {
      //
      //  We didn't find an exact match so now we need to look for a best match.
      //  Get a hash map of control flow rules keyed by the local activity ID.
      //

      //
      //  Check for a null from activity ID.
      //
      if (fromId == null)
      {
        //
        //  See if there is a wild card rule that can be used.
        //
        if (!excludeSet[WILDCARD_ID])
        {
          result = cfRules[WILDCARD_ID];
        }
      }
      else
      {
        //
        //  Look for the longest match that ends with an asterisk.
        //
        var localActivityId = fromId.getLocalActivityId();
        for (var i = localActivityId.length - 1; i >= 0; i--)
        {
          var key = localActivityId.substring(0, i) + WILDCARD_ID;
          if (!(excludeSet[key]))
          {
            result = cfRules[key];
            if (result != null)
            {
              break;
            }
          }
        }
      }
    }

    return result;
  }

  ControlFlowEngine.evaluateGuardCondition = function(guardCondition, routingState, callback)
  {
    if (guardCondition != null)
    {
      var evalSuccessCallback = function(request, response)
      {
        var value = response[0].value;
        value = adfc.internal.ElUtil.resultToBoolean(value);
        callback(value, routingState);
      }
      var evalFailedCallback = function(request, response)
      {
        var errMsg = "ADFc: evaluation of control flow guard condition failed: " + request[0];
        routingState.getRoutingFailedCallback()(errMsg);
      }
      adfc.internal.LogUtil.fine("evaluateing control flow guard condition: " + guardCondition);
      adfc.internal.ElUtil.getValue(guardCondition, evalSuccessCallback, evalFailedCallback);
    }
    else
    {
      callback(true, routingState);
    }
  }

  ControlFlowEngine.getActivity = function(callback, activityId)
  {
    var result = null;
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        if (taskFlowDef)
        {
          var activities = taskFlowDef.getActivities();
          if (activities)
          {
            var localId = activityId.getLocalActivityId();
            result = activities[localId];
          }
          else
          {
            throw new Error("ADFc: task flow " + taskFlowDef.getTaskFlowId() + " does not have any activities");
          }
        }
        else
        {
          throw new Error("ADFc: failed to find task flow definition");
        }
        callback(result);
      });
  }

  ControlFlowEngine.getActivityLogic = function(activity)
  {
    var type = activity.getActivityType();
    var result = adfc.internal.ActivityLogic.getImplementation(type);
    return result;
  }

  ControlFlowEngine.executeActivity = function(activity, activityLogic, routingState, successCallback, failCallback)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: executing ControlFlowEngine.executeActivity(), activityId=" +
                         activity.getActivityId());
    }

    //
    //  Sanity check.
    //
    if (routingState.isRoutingComplete())
    {
      adfc.internal.LogUtil.severe("ADFc: attempting to execute activity when routing is already complete");
    }

    var bcChanged = false;
    var originalBindingPath = null;
    var activityBindingPath = null;

    var setBCPathSuccess = function()
    {
      //
      //  Execute the activity.
      //
      var exeSuccess = function(rState)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: execution of " + activity.getActivityId() + " succeeded.");
        }

        //
        //  Restore the original binding container if necessary.
        //
        var restoreBCPathSuccess = function()
        {
          successCallback(rState);
        }
        var restoreBCPathFailed = function()
        {
          failCallback("failed to restore binding container following activity execute");
        }
        if (bcChanged)
        {
          //
          //  Release the activity's binding container.
          //
          adfc.internal.ElUtil.resetBindingContainerPath(activityBindingPath, restoreBCPathSuccess, restoreBCPathFailed);
         }
        else
        {
          restoreBCPathSuccess();
        }
      }
      var exeFailed = function(message)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: execution of " + activity.getActivityId() + " failed.");
        }
        var callback = function()
        {
          failCallback(message);
        }
        if (bcChanged)
        {
          //
          //  Restore the original binding container.
          //
          adfc.internal.ElUtil.setBindingContainerPath(originalBindingPath, false, callback, callback);
        }
      }
      activityLogic.execute(routingState, activity, exeSuccess, exeFailed);
    }

    var setBCPathFailed = function()
    {
      failCallback("failed to set the binding container path to: " + activityBindingPath);
    }

    var getBCPathSuccess = function(req, path)
    {
      originalBindingPath = path;
      activityBindingPath = ControlFlowEngine.getActivityBindingPath(activity);

      //
      //  See if we need to switch the binding containers.
      //
      if ((originalBindingPath != null) || (activityBindingPath != null))
      {
        //
        //  We need to switch.
        //
        bcChanged = true;
        adfc.internal.ElUtil.setBindingContainerPath(activityBindingPath, false, setBCPathSuccess, setBCPathFailed);
      }
      else
      {
        //
        //  No need to switch.
        //
        setBCPathSuccess();
      }
    }

    var getBCPathFailed = function()
    {
      failCallback("Failed to get the current binding container path");
    }

    //
    //  If the activity we're about to execute is NOT a view activity then get the current
    //  binding context path so we can swith and later switch back.
    //
    if (activity.getActivityType() != adfc.internal.ActivityType.VIEW)
    {
      //
      //  This is a non-view activity so switch the binding context.
      //
      adfc.internal.ElUtil.getCurrentBindingContainerPath(getBCPathSuccess, getBCPathFailed);
    }
    else
    {
      //
      //  This is a view activity so we don't need to switch the binding context.
      //
      setBCPathSuccess();
    }
  }

  ControlFlowEngine.getActivityBindingPath = function(activity)
  {
    //
    //  This method only returns a binding container path for method-call activities.
    //  The binding container for a view activity will be set by the AMX layer when
    //  if set the new page.
    //
    var bindingPath = null;
    var activityType = activity.getActivityType();
    if (activityType == adfc.internal.ActivityType.METHOD_CALL ||
       activityType == adfc.internal.ActivityType.ROUTER ||
       activityType == adfc.internal.ActivityType.TASK_FLOW_CALL ||
       activityType == adfc.internal.ActivityType.TASK_FLOW_RETURN )
    {
      bindingPath = activity.getActivityId().toString();
    }
    return bindingPath;
  }

  /**
   * Store the current routing state on a global so we can find it later.
   * Poor man's version of a Java thread local.
   */
  ControlFlowEngine.setCurrentRoutingState = function(instance)
  {
    adfc.internal.ControlFlowEngine.currentRoutingState = instance;
  }
  ControlFlowEngine.getCurrentRoutingState = function()
  {
    var result = null;
    if (typeof adfc.internal.ControlFlowEngine.currentRoutingState !== "undefined")
    {
      result = adfc.internal.ControlFlowEngine.currentRoutingState;
    }
    return result;
  }
  ControlFlowEngine.clearCurrentRoutingState = function()
  {
    if (typeof adfc.internal.ControlFlowEngine.currentRoutingState !== "undefined")
    {
      adfc.internal.ControlFlowEngine.currentRoutingState = null;
    }
  }
  
  ControlFlowEngine.notifyEndNavigationListeners = function(currentViewId, navigationResult)
  {
    var deliverNotifications = function()
    {
      //
      // Deliver navigation end event
      //
      var endNavEvent = new adfc.NavigationEvent(currentViewId, navigationResult, adfc.NavigationEventType.END);
      adfc.internal.NavigationHandlerImpl.notifyNavigationListeners(endNavEvent);
    }

    //
    //  Before sending end navigaiton events we may need to check if we're returning to the same view.
    //  If we are we need to restore that view activity's context in case any non-view activities
    //  have set a different context.
    //
    if ((navigationResult != null) && !navigationResult.isDifferentViewId())
    {
      //
      //  Navigation did not reach a different view activity, set that view's context.
      //
      var contextPath = navigationResult.getVdlDocumentPath();
      adfc.internal.ElUtil.setBindingContainerPath(contextPath, false, deliverNotifications, deliverNotifications);
    }
    else
    {
      //
      //  Navigaiton reached a different view activity so no need to restore the
      //  previous view's context.
      //
      deliverNotifications();
    }
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/ControlFlowEngine.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/adf/mf/internal/controller/ViewHistory.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adf) window.adf = {};
adf.mf                      = adf.mf                      || {};
adf.mf.internal             = adf.mf.internal             || {};
adf.mf.internal.controller  = adf.mf.internal.controller  || {};

(function(){

   adf.mf.internal.controller.ViewHistory = ViewHistory;
   function ViewHistory()
   {}
   
   /**
    * Peeks the current entry in the view history.
    * @export
    */
   ViewHistory.peek = function()
   {
      var controllerState = adfc.internal.AdfcContext.getControllerState();
      var tfEntry = controllerState.peekTaskFlowStack();
      var result = tfEntry.peekViewHistory();
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/adf/mf/internal/controller/ViewHistory.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationEvent.js///////////////////////////////////////

/*
* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationEvent = NavigationEvent;
  adfc.NavigationEventType = NavigationEventType;

  function NavigationEventType()
  {
  }
  NavigationEventType.START = "start";
  NavigationEventType.END = "end";

  /**
   * NavigationEvent represents information about view id changes during navigation.
   */
  function NavigationEvent(startingViewId, navigationResult, navigationEventType)
  {
      this.mStartingViewId = startingViewId;
      this.mNavigationResult = navigationResult;
      this.mNavigationEventType = navigationEventType;
  }
  
  /**
   * The initial view id (before navigation started). This should be available for both start and end
   * navigation events.
   * @return {string} the view id of the page where navigation started. For example, 
   * "/some-task-flow/some-page".
   * @export
   */
  NavigationEvent.prototype.getStartingViewId = function()
  {
      return this.mStartingViewId;
  }
  /**
   * The NavigationResult if navigation happened, or null, if navigation is not yet finished.
   * @return {NavigationResult} navigation result, including view id of the page that was navigated to, for example:
   * <code>
   *   var navResult = event.getNavigationResult();
   *   var endViewId = navResult.getViewId();
   * </code>
   * @export
   */
  NavigationEvent.prototype.getNavigationResult = function() 
  {
      return this.mNavigationResult;
  }
  
  /**
   * Has navigation started and not ended?
   * @return {Boolean}
   * @export
   */
  NavigationEvent.prototype.isNavigationStart = function()
  {
      return (this.mNavigationEventType == NavigationEventType.START);
  }

  /**
   * Has navigation ended and NavigationResult is available?
   * @return {Boolean}
   * @export
   */
  NavigationEvent.prototype.isNavigationEnd = function()
  {
      return (this.mNavigationEventType == NavigationEventType.END);
  }
  
  /**
   * String representation of the event.
   * @return {string}
   * @export
   */
  NavigationEvent.prototype.toString = function()
  {
    if (this.isNavigationStart())
    {
      return "Navigating from " + this.mStartingViewId;
    }
    else
    {
      return "Navigated from  " + this.mStartingViewId + " to " + this.mNavigationResult.getViewId();
    }
    return "Unknown";
  }
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationEvent.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/MetadataService.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };
if (!adfc.internal)
  adfc.internal = 
  {
  };(function ()
{

  /**
   *  Service for fetching various metadata resources.
   */
  adfc.internal.MetadataService = MetadataService;

  function MetadataService()
  {
  }

  /*
   * Setting up an LRU cache for the metadata. This will prevent from re-reading files in and parsing the controller
   * metadata.
   */
  var taskFlowDefCache = new adf.mf.internal.BaseLRUCache(5);

  /**
   * @param {Function} callback a callback function whose parameter is the
   *                            requested task flow definition or null if the
   *                            task flow could not be found.
   * @param {Object} taskFlowId the id of the task flow to be fetched.
   * @param {boolean} [useCache=true] determines whether task flow cache should be used to fetch task flow definition. If false,
   *        the cache won't be used to fetch the definition, but will be updated with the fetched definition,
   *        if one is found. If not specified, the default value is true.
   */
  MetadataService.getTaskFlowDefinition = function(callback, taskFlowId, useCache)
  {
    var docPath = taskFlowId.getDocumentUri();
    if (docPath == null)
    {
      callback(null);
    }
    else
    {
      //
      // useCache is an optional argument that defaults to true
      //
      if (useCache === undefined)
      {
        useCache = true;
      }
      //
      // cacheKey needs to be defined here because even though cache is not used
      // when useCache == false; it is used to store a newly parsed task flow definition
      //
      var cacheKey = MetadataService.constructCacheKey(docPath, taskFlowId);
      if (useCache)
      {
        // See if the data is already in the cache.
        var cacheDef = taskFlowDefCache.get(cacheKey);
        if (cacheDef && cacheDef != null)
        {
          callback(cacheDef);
          return;
        }
      }
      var filePath = adfc.Util.addFeatureRootPrefix(docPath);
      if (adfc.internal.LogUtil.isFine())
      {
        adfc.internal.LogUtil.fine("attempting to load task flow file: " + filePath);
      }
      adfc.internal.XmlUtil.loadXmlFile(filePath, function(document)
        {
          if (document != null)
          {
            var tfNodes = document.getElementsByTagName("task-flow-definition");
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("number of task-flow-definition elements in the file = " + tfNodes.length);
            }
            var result = null;
            for (var i = 0;i < tfNodes.length;i++)
            {
              var tfNode = tfNodes.item(i);
              var taskFlowDef = adfc.internal.TaskFlowDefinitionXmlParser.parse(docPath, document, tfNode);
              if (taskFlowDef)
              {
                if (taskFlowDef.getTaskFlowId().equals(taskFlowId))
                {
                  result = taskFlowDef;
                  // Since spent all the time reading and parsing this Task Definition we need to stash it off
                  // in an LRU cache.
                  taskFlowDefCache.put(cacheKey, result);
                  break;
                }
              }
            }
            callback(result);
          }
          else 
          {
            adfc.internal.LogUtil.severe("failed to load task flow file " + filePath);
            callback(null);
          }
        });
    }
  };

  MetadataService.loadBootstrapMetadata = function (successCallback, failCallback, useCache)
  {
    adfc.internal.LogUtil.fine("loading bootstrap metadata ...");
    
    var unboundedFlowDocPath = adfc.Util.addFeatureRootPrefix("adfc-mobile-config.xml");
    var cacheKey = MetadataService.constructCacheKey(unboundedFlowDocPath);

    //
    // useCache is an optional argument that defaults to true
    //
    if (useCache === undefined)
    {
      useCache = true;
    }

    if (useCache)
    {
      // See if the data is already in the cache.
      var cacheDef = taskFlowDefCache.get(cacheKey);
      if (cacheDef && cacheDef != null)
      {
        // We found the data so we can now just call the success call back with the cached data.
        successCallback(cacheDef);
        return;
      }
    }

    adfc.internal.XmlUtil.loadXmlFile(unboundedFlowDocPath, function(document)
      {
        //
        //  Get the "adfc-mobile-config" element from the file.
        //
        if (document != null)
        {
          var nodes = document.getElementsByTagName("adfc-mobile-config");
          if ((nodes != null) && (nodes.length == 1))
          {
            var unboundedFlowNode = nodes[0];
            var unboundedFlowDef = adfc.internal.TaskFlowDefinitionXmlParser.parse(null, document, unboundedFlowNode);
            if (unboundedFlowDef != null)
            {
              var loadBootstrapSuccess = function ()
              {
                adfc.internal.LogUtil.fine("bootstrap metadata load complete.");
                successCallback(unboundedFlowDef);
                return;
              }
              taskFlowDefCache.put(cacheKey, unboundedFlowDef);
              //
              // Do not update controller state if this is a call to reload unbounded flow
              //
              if (useCache)
              {
                var controllerState = adfc.internal.AdfcContext.getControllerState();
                controllerState.pushTaskFlow(unboundedFlowDef, null, null, loadBootstrapSuccess, failCallback);
              }
              else
              {
                loadBootstrapSuccess();
              }
            }
            else 
            {
              var msg = "failed to parse the adfc-mobile-config element in bootstrap metadata document";
              adfc.internal.LogUtil.severe(msg);
              throw new Error(msg);
            }
          }
          else 
          {
            var msg2 = "failed to find adfc-mobile-config element in bootstrap metadata document";
            adfc.internal.LogUtil.severe(msg2);
            throw new Error(msg2);
          }
        }
        else 
        {
          var msg3 = "bootstrap metadata document adfc-mobile-config.xml is null";
          adfc.internal.LogUtil.severe(msg3);
          throw new Error(msg3);
        }
      });
  }

  MetadataService.constructCacheKey = function (docPath, taskFlowId)
  {
    var cacheKey = docPath;
    if (taskFlowId !== undefined)
    {
      cacheKey = taskFlowId.toString();
    }
    return cacheKey;
  }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/MetadataService.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/UrlUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adf) window.adf = {};
adf.FEATURE_ROOT = null;
adf.AMX_DTMODE = false;

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.UrlUtil = UrlUtil;
   function UrlUtil()
   {}
   
   UrlUtil.getEntryPointDocumentPath = function(queryString)
   {
      var path = null;
      if ((queryString != null) && (queryString.length > 0))
      {
         path = adfc.internal.UrlUtil.getUrlParamValue(queryString, "file");
         if (path != null)
         {
            path = unescape(path);
         }
      }   
      return path;
   }
   
   UrlUtil.getAmxDtMode = function(queryString)
   {
      var result = false;
      if ((queryString != null) && (queryString.length > 0))
      {
         var root = adfc.internal.UrlUtil.getUrlParamValue(queryString, "amx_dtmode");
         if (root != null)
         {
            root = unescape(root);
            result = adfc.internal.ElUtil.resultToBoolean(root);
         }
      }
      return result;
   }
   
   UrlUtil.getFeatureRoot = function(queryString)
   {
      var root = null;
      if ((queryString != null) && (queryString.length > 0))
      {
         root = adfc.internal.UrlUtil.getUrlParamValue(queryString, "featureRoot");
         if (root != null)
         {
            root = unescape(root);
         }
      }
      return root;
   }
   
   UrlUtil.getParamStartIndex = function(url, name)
   {
      var sb = "?" + name;
      var index = url.indexOf(sb);
      if (index < 0)
      {
         sb = "&" + name;
         index = url.indexOf(sb.toString());
      }
      return index;
   }

   UrlUtil.getParamEndIndex = function(url, startIndex)
   {
      var endIndex = url.indexOf('&', startIndex);
      if (endIndex < 0)
      {
         endIndex = url.length;
      }
      return endIndex;
   }

   UrlUtil.getUrlParamValue = function(url, paramName)
   {
      var result = null;
      if ((url != null) && (paramName != null))
      {
         //
         //  Find out where the parameter value begins within the URL.
         //
         var startIndex = adfc.internal.UrlUtil.getParamStartIndex(url, paramName);
         if (startIndex >= 0)
         {
            //
            //  Find out where the parameter and value end within the URL.
            //
            var endIndex = adfc.internal.UrlUtil.getParamEndIndex(url, startIndex + 1);

            //
            //  Get the substring.
            //
            var value = url.substring(startIndex, endIndex);

            //
            //  Find the equals sign.
            //
            var start2 = value.indexOf('=');
            if ((start2 >= 0) && (start2 < value.length))
            {
               result = value.substring(start2 + 1);
               if (result.length == 0)
               {
                  result = null;
               }
            }
         }
      }
      return result;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/UrlUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/metadata/MetadataService.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };(function ()
{
  adfc.MetadataService = MetadataService;

  /**
   * MetadataService is the public facing interface to the ADFc MetadataService.
   * @export
   */
  function MetadataService()
  {
  }

  /**
   * @param {string} [taskFlowIdString=null] taskFlowIdString the task flow id of the task flow to be reloaded.
   *        For example: "/feature1/task-flow.xml#task-flow-id". This is an optional argument. If not specified,
   *        or if null or empty, the unbounded task flow definition will be reloaded ("adfc-mobile-config.xml").
   * @param {Function} successCallback invoked upon successful reloading of the task flow definition
   * @param {Function} failCallback invoked if reloading failed.
   */
  MetadataService.reloadTaskFlowDefinition = function(taskFlowIdString, successCallback, failCallback)
  {
    if (arguments.length == 3)
    {
      //
      // null or empty taskFlowIdString is a request for reloading bootstrap metadata
      //
      if (taskFlowIdString && taskFlowIdString.trim().length)
      {
        var taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
        if (taskFlowId != null)
        {
          adfc.internal.MetadataService.getTaskFlowDefinition(
            function(taskFlowDefinition)
            {
              if (taskFlowDefinition && taskFlowDefinition != null)
                successCallback();
              else
                failCallback();
            },
            taskFlowId,
            false);
        }
        else
        {
          failCallback();
        }
      }
      else
      {
        adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback, false);
      }
    }
    else 
    {
      //
      // Since the first argument is optional, reassign callbacks
      //
      successCallback = arguments[0];
      failCallback = arguments[1];
      adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback, false);
    }
  }
})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/metadata/MetadataService.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/MethodCallActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.MethodCallActivityLogic = MethodCallActivityLogic;
   function MethodCallActivityLogic()
   {
   }
      
   MethodCallActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("MethodCallActivityLogic.prototype.execute() entered");
      adfc.internal.LogUtil.perfLog("BEGIN: MethodCallActivityLogic.execute");
      routingState.setCurrentOutcome(null);
      
      var getParamsSuccess = function(request, response)
      {
         var invokeSuccess = function(request2, response2)
         {
            adfc.internal.LogUtil.fine("method call invokation successful");
            
            //
            //  Store the return value.
            //
            var storeResultSuccess = function()
            {
               //
               //  Determine the outcome to generate.
               //
               var outcome = null;
               if (activity.getDefaultOutcome())
               {
                  outcome = activity.getDefaultOutcome();
               }
               else if (activity.isConvertToString())
               {
                  if (response2)
                  {
                     outcome = new String(response2);
                  }
               }
               routingState.setCurrentOutcome(outcome);
               adfc.internal.LogUtil.perfLog("END: MethodCallActivityLogic.execute");
               adfc.internal.LogUtil.fine("method call complete, outcome=" + outcome);
               successCallback(routingState);
            }
            
            var resultExpression = activity.getReturnValue();
            if ((resultExpression != null) && (resultExpression.length > 0))
            {
               //
               //  Store the result value.
               //
               adfc.internal.LogUtil.fine("storing method call result to: " + resultExpression);
               var setRequest = new Array();
               setRequest[0] = {name: resultExpression, value: response2};
               adfc.internal.ElUtil.setValue(setRequest, storeResultSuccess, failCallback);
            }
            else 
            {
               //
               //  There's no EL expression for storing the result.
               //
               adfc.internal.LogUtil.fine("no method call result to store");
               storeResultSuccess();
            }
         }
         
         //
         //  Build an array of the parameter values.
         //
         var paramValues = new Array(paramTypes.length);
         for (var i = 0; i < paramTypes.length; i++)
         {
            if (response[i] != undefined)
            {
              paramValues[i] = response[i].value;
            }
            else 
            {
              paramValues[i] = null;
              adfc.internal.LogUtil.fine("no parameter value for " + paramExpressions[i]);
            }     
         }
   
         //
         //  Execute the method.
         //
         var elExpression = activity.getMethodElExpression();
         adfc.internal.LogUtil.fine("executing method call expression: " + elExpression);
         adfc.internal.ElUtil.invokeMethod(elExpression, paramTypes, paramValues, invokeSuccess, failCallback);
      }
      
      //
      //  Collect the method's input parameter values.
      //
      var params = activity.getParameters();
      var paramExpressions = new Array();
      var paramTypes = new Array();
      if (params.length > 0)
      {
         for (var i = 0; i < params.length; i++)
         {
            paramExpressions.push(params[i].getValueExpression());
            paramTypes.push(params[i].getType());
         }
         adfc.internal.LogUtil.fine("getting method call activity parameter values");
         adfc.internal.ElUtil.getValues(paramExpressions, getParamsSuccess, failCallback);
      }
      else 
      {
         //
         //  There aren't any input params.
         //
         adfc.internal.LogUtil.fine("no method call activity parameters specified");
         getParamsSuccess(paramExpressions, paramExpressions);
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/MethodCallActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowReturnActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-return activity.
    */
   adfc.internal.TaskFlowReturnActivity = TaskFlowReturnActivity;
   function TaskFlowReturnActivity(activityId, outcomeName)
   {
      this.mActivityId = activityId;
      this.mOutcomeName = outcomeName;
   }

   TaskFlowReturnActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.TASK_FLOW_RETURN;
   }
  
   TaskFlowReturnActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   TaskFlowReturnActivity.prototype.getOutcomeName = function() 
   {
      return this.mOutcomeName;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowReturnActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedBeanDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ManagedBeanDefinition = ManagedBeanDefinition;
   function ManagedBeanDefinition(name, type, scope, props)
   {
      this.mBeanName = name;
      this.mBeanClass = type;
      this.mBeanScope = scope;
      this.mManagedProperties = props;
   }
   
   ManagedBeanDefinition.prototype.getBeanName = function() 
   {
      return this.mBeanName;
   }
   
   ManagedBeanDefinition.prototype.getBeanClass = function() 
   {
      return this.mBeanClass;
   }
   
   ManagedBeanDefinition.prototype.getBeanScope = function() 
   {
      return this.mBeanScope;
   }
   
   ManagedBeanDefinition.prototype.getManagedProperties = function() 
   {
      return this.mManagedProperties;
   }
   
   //
   //  Constents used to specify a bean's scope.
   //
   ManagedBeanDefinition.APPLICATION = "application";
   ManagedBeanDefinition.PAGE_FLOW = "pageFlow";
   ManagedBeanDefinition.VIEW = "view";

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedBeanDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowInputParameter.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow input parameter.
    */
   adfc.internal.TaskFlowInputParameter = TaskFlowInputParameter;
   function TaskFlowInputParameter(name, valueExpression, type, isRequired)
   {
      this.mName = name;
      this.mValueExpression = valueExpression;
      this.mType = type;
      this.mRequired = isRequired;
   }
   
   TaskFlowInputParameter.prototype.getName = function()
   {
      return this.mName;
   }
   
   TaskFlowInputParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }
   
   TaskFlowInputParameter.prototype.getType = function()
   {
      return this.mType;
   }
   
   TaskFlowInputParameter.prototype.isRequired = function()
   {
      return this.mRequired;
   }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowInputParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ViewIdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewIdUtil = ViewIdUtil;
   function ViewIdUtil()
   {
   }
   
   ViewIdUtil.logicalViewIdToActivityId = function(taskFlowId, logicalViewId)
   {
      var result = null;
      if ((logicalViewId != null) && (logicalViewId.length > 1))
      {
         //
         //  Figure out the local activityId from the logical viewId.
         //
         var localActivityId = null;
         if (taskFlowId == null)
         {
            //
            //  Unbounded ADF page flow case.
            //
            localActivityId = logicalViewId;
            if (localActivityId.charAt(0) == '/')
            {
               localActivityId = localActivityId.substring(1);
            }
         }
         else
         {
            //
            //  Make sure the logical viewId begins with "/" + localTaskFlowName.
            //
            var localTaskFlowName = taskFlowId.getLocalTaskFlowId();
            if (logicalViewId.indexOf(localTaskFlowName) == 1)
            {
               localActivityId = logicalViewId.substring(localTaskFlowName.length + 2);
            }
         }

         //
         //  Build the activityId.
         //
         if (localActivityId != null)
         {
            result = new adfc.internal.ActivityId(taskFlowId, localActivityId);
         }
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ViewIdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ManagedBeanDefinitionXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ManagedBeanDefinitionXmlParser = {};
adfc.internal.ManagedBeanDefinitionXmlParser.parse = function(docPath, taskFlowId, node)
{
   var beanName = null;
   var beanClass = null;
   var beanScope = null;
   var managedProps = new Array();
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "managed-bean-name")
         {
            beanName = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-bean-class")
         {
            beanClass = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-bean-scope")
         {
            beanScope = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-property")
         {
            var prop = adfc.internal.ManagedPropertyDefinitionXmlParser.parse(child);
            if (prop != null)
            {
               managedProps.push(prop);
            }
         }
      }
   }
   var result = new adfc.internal.ManagedBeanDefinition(beanName, beanClass, beanScope, managedProps);
   return result;
}

adfc.internal.ManagedPropertyDefinitionXmlParser = {};
adfc.internal.ManagedPropertyDefinitionXmlParser.parse = function(node)
{
   var name = null;
   var type = null;
   var value = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "property-name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "property-class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            value = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.ManagedPropertyDefinition(name, type, value);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ManagedBeanDefinitionXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowCallActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.TaskFlowCallActivityLogic = TaskFlowCallActivityLogic;
  function TaskFlowCallActivityLogic()
  {
  }

  TaskFlowCallActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
  {
    adfc.internal.LogUtil.fine("TaskFlowCallActivityLogic.prototype.execute() entered");
    adfc.internal.LogUtil.perfLog("BEGIN: TaskFlowCallActivityLogic.execute");

    var getTaskFlowIdSuccess = function(taskFlowId)
    {
      var invokeBeforeListenerSuccess = function()
      {
        adfc.internal.MetadataService.getTaskFlowDefinition(
          function(taskFlowDef)
          {
            var gatherInputParamsSuccess = function(params)
            {
              var invokeTfSuccess = function()
              {
                routingState.setCurrentOutcome(null);
                routingState.setNextActivityId(taskFlowDef.getDefaultActivityId());

                adfc.internal.LogUtil.perfLog("END: TaskFlowCallActivityLogic.execute");
                successCallback(routingState);
              }

              //
              //  Enter the task flow.
              //
              adfc.internal.LogUtil.fine("TaskFlowCallActivityLogic.prototype.execute() invoking taskFlow: " + taskFlowId + " from activity : " + activity.getActivityId());
              adfc.internal.TaskFlowCallActivityLogic.invokeTaskFlow(taskFlowId, params, activity, routingState, invokeTfSuccess, failCallback);
            }

            if (taskFlowDef == null)
            {
              failCallback(/* What is message? message + ": " + */taskFlowId);
            }
            TaskFlowCallActivityLogic.gatherInputParamerValues(activity, gatherInputParamsSuccess, failCallback)
          },
          taskFlowId);
      }
      TaskFlowCallActivityLogic.invokeBeforeListener(activity, invokeBeforeListenerSuccess, failCallback);
    }
    TaskFlowCallActivityLogic.getTaskFlowId(activity, getTaskFlowIdSuccess, failCallback);
  }

  /**
   * Invoke a bounded task flow and set the flow's default activity as the next
   * activity to be executed.
   */
  TaskFlowCallActivityLogic.invokeTaskFlow = function(taskFlowId, inParams, taskFlowCallActivity, routingState, successCallback, failCallback)
  {
    //
    //  Look up the task flow definition.
    //
    adfc.internal.MetadataService.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        var pushTfSuccess = function()
        {
          var inParamSuccess = function()
          {
            var initializerSuccess = function()
            {
              //
              //  Perform control flow routing beginning with the default activity.
              //
              var defaultActivityId = taskFlowDef.getDefaultActivityId();
              routingState.setNextActivityId(defaultActivityId);
              routingState.setCurrentOutcome(null);
              successCallback(routingState);
            }

            //
            //  Execute the task flow's initializer, if it has one.
            //
            var initializer = taskFlowDef.getInitializer();
            if (initializer && (initializer != null))
            {
              adfc.internal.ElUtil.invokeMethod(initializer, new Array(), new Array(), initializerSuccess, failCallback);
            }
            else
            {
              initializerSuccess();
            }
          }

          //
          //  Store any input parameter values passed to the task flow.
          //
          var request = new Array();
          var inParamDefs = taskFlowDef.getInputParameters();
          if ((inParamDefs != null) && (inParamDefs.length > 0))
          {
            for (var i = 0; i < inParamDefs.length; i++)
            {
              var paramDef = inParamDefs[i];
              var paramName = paramDef.getName();
              if (inParams[paramName] !== undefined)
              {
                var value = inParams[paramName];
                var elExpression = paramDef.getValueExpression();
                if ((elExpression == null) || (elExpression == ""))
                {
                  elExpression = "#{pageFlowScope." + paramName + "}";
                }
                request.push({name: elExpression, value: value});
              }
              else
              {
                //
                //  See if the parameter is required.
                //
                if (paramDef.isRequired())
                {
                  //
                  //  The parameter is required but a value was not supplied.
                  //
                  throw new Error("ADFc: required task flow input parameter [" + paramName + "] not provided.");
                }
              }
            }
            adfc.internal.ElUtil.setValues(request, inParamSuccess, failCallback);
          }
          else
          {
            inParamSuccess();
          }
        }

        var pushTfFailed = function()
        {
          var msg = "ADFc: Push of task flow failed for [" + taskFlowId + "]";
          // What is message? msg += message;
          failCallback(msg);
        }

        if (taskFlowDef == null)
        {
          var msg = "ADFc: Failed to find task flow definition for [" + taskFlowId + "]";
          // What is message? msg += message;
          failCallback(msg);
        }

        //
        //  Determine the calling view activity.  This is defined as the view ativity in
        //  the _current_ flow that was last displayed.  If no view has been displayed in
        //  the current flow then the calling view is null.
        //
        var callingView = null;
        var controllerState = adfc.internal.AdfcContext.getControllerState();
        var currentTfInstance = controllerState.peekTaskFlowStack();
        if (currentTfInstance.getInstanceId() == routingState.getStartingTaskFlowInstanceId())
        {
          //
          //  We're still in the same flow as the last displayed view activity.
          //
          callingView = routingState.getStartingActivityId();
        }

        //
        //  Record this task flow as the 'current' task flow.
        //
        controllerState.pushTaskFlow(taskFlowDef, taskFlowCallActivity, callingView, pushTfSuccess, pushTfFailed);
      },
      taskFlowId);
  }

  /**
   * gets the TaskFlowId of the task flow to be called
   */
  TaskFlowCallActivityLogic.getTaskFlowId = function(activity, successCallback, failCallback)
  {
    var taskFlowId = null;
    if (activity.isDynamic())
    {
      var getTaskFlowIdSuccess = function(request, response)
      {
        var taskFlowIdString = response[0].value;
        taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
      }
      var elExpression = activity.getDynamicTaskFlowIdElExpression();
      adfc.internal.LogUtil.fine("evaluating dynamic task flow call expression: " + elExpression);
      adfc.internal.ElUtil.getValue(elExpression, getTaskFlowIdSuccess, failCallback)
    }
    else
    {
      var taskFlowIdString = activity.getTaskFlowReference();
      taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
    }
    if (taskFlowId != null)
    {
      successCallback(taskFlowId);
    }
    else
    {
      failCallback();
    }
  }

  /**
   * invokes the before-listener of a the given task flow call activity if it is specified
   */
  TaskFlowCallActivityLogic.invokeBeforeListener = function(activity, successCallback, failCallback)
  {
    //
    // invoke the before listener if specified
    //
    var listener = activity.getBeforeListener();
    if (listener && (listener != null))
    {
      adfc.internal.LogUtil.fine("calling before-listener: " + listener);
      adfc.internal.ElUtil.invokeMethod(listener, new Array(), new Array(), successCallback, failCallback);
    }
    else
    {
      successCallback()
    }
  }

  /**
   * collects input parameters from the task flow call activity
   */
  TaskFlowCallActivityLogic.gatherInputParamerValues = function(activity, successCallback, failCallback)
  {
    var paramExpressions = new Array();
    var paramNames = new Array();

    var getParamsSuccess = function(request, response)
    {
      //
      //  Build a map of the parameter name/value pairs
      //
      var inputParams = {};
      for (var i = 0; i < response.length; i++)
      {
        var paramName = paramNames[i];
        inputParams[paramName] = response[i].value;
      }




      var inputParamMapEL = activity.getInputParameterMapElExpression();
      // Add any parameters specified in a map
      if (inputParamMapEL != null)
      {
        var getMapSuccess = function(request1, response1)
        {
          var inputParamMap = response1[0].value;

          for (var key in inputParamMap)
          {
            adfc.internal.LogUtil.fine("adding input parameter from map: " + key + ":" + inputParamMap[key]);
            inputParams[key] = inputParamMap[key];
          }

          successCallback(inputParams);
        }
        adfc.internal.LogUtil.fine("Evaluating input parameter map expression: " + inputParamMapEL);
        adfc.internal.ElUtil.getValue(inputParamMapEL, getMapSuccess, failCallback);
      }
      else
      {
        successCallback(inputParams);
      }
    }

    //
    //  Collect the task flow call's input parameter values.
    //
    var params = activity.getInputParameters();

    if (params.length > 0)
    {
      for (var i = 0; i < params.length; i++)
      {
        paramExpressions.push(params[i].getValueExpression());
        paramNames.push(params[i].getName());
      }
      adfc.internal.LogUtil.fine("getting method call activity parameter values");
      adfc.internal.ElUtil.getValues(paramExpressions, getParamsSuccess, failCallback);
    }
    else
    {
      //
      //  There aren't any input params.
      //
      adfc.internal.LogUtil.fine("no method call activity parameters specified");
      getParamsSuccess(paramExpressions, paramExpressions);
    }
  }

   /**
   * Determines data control context type. If the EL does not evaluate to "isolated",
   * the data control context is assumed to be shared.
   */
   TaskFlowCallActivityLogic.isDataControlContextIsolated = function(activity, failCallback)
   {
    var isolated = false;
    var elSuccessCallback = function(request, response)
    {
      var result = response[0].value;
      if (adfc.internal.LogUtil.isFine())
      {
        adfc.internal.LogUtil.fine("ADFc: data control context expression '" + elExpression + "' evaluated to '" + result + "'.");
      }
      if (result != null && result.toLowerCase() == "isolated")
      {
        isolated = true;
      }
    }

    var elExpression = activity.getDataControlContextType();
    //
    // Evaluating null el sometimes fails
    //
    if (elExpression != null)
    {
      adfc.internal.LogUtil.fine("evaluating data control context expression: " + elExpression);
      adfc.internal.ElUtil.getValue(elExpression, elSuccessCallback, failCallback);
    }
    return isolated;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowCallActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowId.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Unique identifier of a task flow.
    */
   adfc.internal.TaskFlowId = TaskFlowId;
   function TaskFlowId(documentUri, localId)
   {
      this.mDocumentUri = documentUri;
      this.mLocalTaskFlowId = localId;
   }
   
   TaskFlowId.prototype.getDocumentUri = function()
   {
      return this.mDocumentUri;
   }
   
   TaskFlowId.prototype.getLocalTaskFlowId = function()
   {
      return this.mLocalTaskFlowId;
   }
   
   TaskFlowId.prototype.toString = function()
   {
      return this.mDocumentUri + "#" + this.mLocalTaskFlowId;
   }
   
   TaskFlowId.prototype.equals = function(other)
   {
      var result = false;
      if (other)
      {
         var otherDoc = other.getDocumentUri();
         var otherLocalId = other.getLocalTaskFlowId();
         result = (this.mDocumentUri == otherDoc) && (this.mLocalTaskFlowId == otherLocalId);
      }
      return result;
   }
   
   /**
    * Parses a string representation of a task flow ID and returns a
    * TaskFlowId object.
    */
   TaskFlowId.parse = function(stringId)
   {
      var result = null;
      
      //
      // Document path should not start with a "/"
      //
      if (stringId.indexOf("/") == 0)
      {
        stringId = stringId.substring(1);    
      }
      //
      //  Task flow ID strings are formatted as: <document-uri>#<local-id>
      //
      var index = stringId.indexOf("#");
      if (index > 0)
      {
         var docUri = stringId.substring(0, index);
         var localId = stringId.substring(index+1);
         result = new TaskFlowId(docUri, localId);
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowId.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/TaskFlowStackEntry.js///////////////////////////////////////

/*
* Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };
if (!adfc.internal)
  adfc.internal = 
  {
  };(function ()
{
  adfc.internal.TaskFlowStackEntry = TaskFlowStackEntry;
  adfc.internal.TaskFlowStackEntry.SequenceCounter = 0;

  function TaskFlowStackEntry(taskFlowId, taskFlowCallActivity, callingViewActivityId, newPageFlowScopeCreated, newDataControlContextCreated)
  {
    this.mInstanceId = adfc.internal.TaskFlowStackEntry.SequenceCounter++;
    
    this.mTaskFlowId = taskFlowId;
    this.mTaskFlowCallActivity = taskFlowCallActivity;
    this.mViewReached = false;
    this.mCallingViewActivityId = callingViewActivityId;
    this.mNewPageFlowScopeCreated = newPageFlowScopeCreated;
    this.mNewDataControlContextCreated = newDataControlContextCreated;
    this.mViewHistoryStack = new Array();
  }

  TaskFlowStackEntry.prototype.getInstanceId = function ()
  {
    return this.mInstanceId;
  }

  TaskFlowStackEntry.prototype.getTaskFlowDefinition = function(callback)
  {
    var getTaskFlowDefinitionFail = function()
    {
      callback(null);
    };

    var getTaskFlowDefinition = function(taskFlowDefinition)
    {
      callback(taskFlowDefinition);
    }

    //
    // null task flow id indicates unbounded flow
    //
    if (this.mTaskFlowId && (this.mTaskFlowId != null))
    {
      adfc.internal.MetadataService.getTaskFlowDefinition(getTaskFlowDefinition, this.mTaskFlowId);
    }
    else
    {
      adfc.internal.MetadataService.loadBootstrapMetadata(getTaskFlowDefinition, getTaskFlowDefinitionFail);
    }
  }

  TaskFlowStackEntry.prototype.getTaskFlowCallActivity = function ()
  {
    return this.mTaskFlowCallActivity;
  }

  TaskFlowStackEntry.prototype.shouldPopPageFlowScope = function ()
  {
    return this.mNewPageFlowScopeCreated;
  }

  TaskFlowStackEntry.prototype.shouldPopDataControlContext = function ()
  {
    return this.mNewDataControlContextCreated;
  }

  TaskFlowStackEntry.prototype.pushViewHistory = function (viewId, amxPage, transType)
  {
    var item = new adfc.internal.ViewHistoryItem(viewId, amxPage, transType);
    this.mViewHistoryStack.push(item);
    adfc.internal.ElUtil.setMfContextInstance(item, true);
  }

  TaskFlowStackEntry.prototype.popViewHistory = function ()
  {
    var result = this.mViewHistoryStack.pop();
    adfc.internal.ElUtil.removeMfContextInstance(result);
    return result;
  }

  TaskFlowStackEntry.prototype.peekViewHistory = function ()
  {
    var result = this.mViewHistoryStack[this.mViewHistoryStack.length - 1];
    return result;
  }

  TaskFlowStackEntry.prototype.clearViewHistory = function ()
  {
    while (this.mViewHistoryStack.length > 0)
    {
      this.popViewHistory();
    }
  }

  TaskFlowStackEntry.prototype.getViewHistoryLength = function ()
  {
    var result = this.mViewHistoryStack.length;
    return result;
  }

  TaskFlowStackEntry.prototype.isViewReached = function ()
  {
    return this.mViewReached;
  }

  TaskFlowStackEntry.prototype.setViewReached = function (value)
  {
    this.mViewReached = value;
  }

  TaskFlowStackEntry.prototype.getCallingViewActivityId = function ()
  {
    return this.mCallingViewActivityId;
  }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/TaskFlowStackEntry.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowRuleXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ControlFlowRuleXmlParser = {};
adfc.internal.ControlFlowRuleXmlParser.parse = function(docPath, taskFlowId, node)
{
   // big ADF handles control flow cases slightly differently:  It has collections for the different combinations
   // of values for from-action and from-outcome.  Since ADFmf currently only supports from-outcome, we store everything
   // in the same Array.  the default (null from-outcome) is just stored along with the normal cases.  
   // ControlFlowRule.getControlFlowCaseIndex(outcome) contains the logic to determine if the default should be used
   
   var fromActivityId = null;
   var cfCases = new Array();
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "from-activity-id")
         {
            var localId = adfc.internal.XmlUtil.getNodeText(child);
            fromActivityId = new adfc.internal.ActivityId(taskFlowId, localId);
         }
         else if (childName == "control-flow-case")
         {
            var cfCase = adfc.internal.ControlFlowCaseXmlParser.parse(docPath, taskFlowId, child);
            if (cfCase)
            {
               cfCases.push(cfCase);
            }
         }
      }
   }
   var result = new adfc.internal.ControlFlowRule(fromActivityId, cfCases);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowRuleXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityType.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ActivityType = ActivityType;
   function ActivityType()
   {}
   
   ActivityType.VIEW = "view";
   ActivityType.ROUTER = "router";
   ActivityType.METHOD_CALL = "method-call";
   ActivityType.TASK_FLOW_RETURN = "task-flow-return";
   ActivityType.TASK_FLOW_CALL = "task-flow-call";

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityType.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedPropertyDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ManagedPropertyDefinition = ManagedPropertyDefinition;
   function ManagedPropertyDefinition(name, type, value)
   {
      this.mName = name;
      this.mType = type;
      this.mValue = value;
   }
   
   ManagedPropertyDefinition.prototype.getName = function() 
   {
      return this.mName;
   }
   
   ManagedPropertyDefinition.prototype.getType = function() 
   {
      return this.mType;
   }
   
   ManagedPropertyDefinition.prototype.getValue = function() 
   {
      return this.mValue;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedPropertyDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallParameter.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */
 
if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-call activity input parameter or return value.
    */
   adfc.internal.TaskFlowCallParameter = TaskFlowCallParameter;
   function TaskFlowCallParameter(name, valueExpression, passByValue)
   {
      this.mName = name;
      this.mValueExpression = valueExpression;
      this.mPassByValue = passByValue;
   }
   
   TaskFlowCallParameter.prototype.getName = function()
   {
      return this.mName;
   }
   
   TaskFlowCallParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }
   
   TaskFlowCallParameter.prototype.getPassByValue = function()
   {
      return this.mPassByValue;
   }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ActivityXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ActivityXmlParser = {};
adfc.internal.ActivityXmlParser.parse = function(docPath, taskFlowId, node)
{
   var result = null;
   if (node && (node != null))
   {
      //
      //  Get the activityId.
      //
      var idStr = node.attributes.getNamedItem("id").nodeValue;
      var activityId = new adfc.internal.ActivityId(taskFlowId, idStr);
      
      var nodeName = node.localName;
      if (nodeName == "view")
      {
         result = adfc.internal.ActivityXmlParser.parseViewActivity(activityId, node);
      }
      else if (nodeName == "router")
      {
         result = adfc.internal.ActivityXmlParser.parseRouterActivity(activityId, node);
      }
      else if (nodeName == "method-call")
      {
         result = adfc.internal.ActivityXmlParser.parseMethodCallActivity(activityId, node);
      }
      else if (nodeName == "task-flow-return")
      {
         result = adfc.internal.ActivityXmlParser.parseTaskFlowReturnActivity(activityId, node);
      }
      else if (nodeName == "task-flow-call")
      {
         result = adfc.internal.ActivityXmlParser.parseTaskFlowCallActivity(activityId, node);
      }
   }
   return result;
}

adfc.internal.ActivityXmlParser.parseViewActivity = function(activityId, node)
{
   var vdlDocPath = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "page")
         {
            vdlDocPath = adfc.internal.XmlUtil.getNodeText(child);
            
            //
            //  The VDL document path should begin with a leading slash '/' but it's
            //  possible it might not be that way in the metadata.  Add a leading slash
            //  if needed.
            //
            if ((vdlDocPath != null) && (vdlDocPath.length > 0))
            {
               var firstChar = vdlDocPath.charAt(0);
               if ((firstChar != null) && (firstChar != "/"))
               {
                  vdlDocPath = "/" + vdlDocPath;
               }
            }
         }
      }
   }
   var result = new adfc.internal.ViewActivity(activityId, vdlDocPath);
   return result;
}

adfc.internal.ActivityXmlParser.parseRouterActivity = function(activityId, node)
{
   var cases = new Array();
   var defaultOutcome = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "default-outcome")
         {
            defaultOutcome = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "case")
         {
            var routerCase = adfc.internal.ActivityXmlParser.parseRouterCase(child);
            cases.push(routerCase);
         }
      }
   }
   if (defaultOutcome == null)
   {
      var msg = "task flow router activity " + activityId.toString() + " does not have a default outcome";
      adfc.internal.LogUtil.severe(msg);
   }
   var result = new adfc.internal.RouterActivity(activityId, cases, defaultOutcome);
   return result;
}

adfc.internal.ActivityXmlParser.parseRouterCase = function(node)
{
   var expression = null;
   var outcome = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "expression")
         {
            expression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "outcome")
         {
            outcome = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.RouterCase(expression, outcome);
   return result;
}

adfc.internal.ActivityXmlParser.parseMethodCallActivity = function(activityId, node)
{
   var elExpression = null;
   var defaultOutcome = null;
   var convertToString = false;
   var params = new Array();
   var returnValue = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "method")
         {
            elExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "outcome")
         {
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "fixed-outcome")
                  {
                     defaultOutcome = adfc.internal.XmlUtil.getNodeText(child2);
                     break;
                  }
                  else if (child2Name == "to-string")
                  {
                     convertToString = true;
                     break;
                  }
               }
            }
         }
         else if (childName == "parameter")
         {
            var param = adfc.internal.ActivityXmlParser.parseMethodCallParam(child);
            params.push(param);
         }
         else if (childName == "return-value")
         {
            returnValue = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = 
      new adfc.internal.MethodCallActivity(activityId, elExpression, defaultOutcome, convertToString, params, returnValue);
   return result;
}

adfc.internal.ActivityXmlParser.parseMethodCallParam = function(node)
{
   var type = null;
   var valueExpression = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.MethodCallParameter(type, valueExpression);
   return result;
}

adfc.internal.ActivityXmlParser.parseTaskFlowReturnActivity = function(activityId, node)
{
   var outcomeName = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "outcome")
         {
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "name")
                  {
                     outcomeName = adfc.internal.XmlUtil.getNodeText(child2);
                     break;
                  }
               }
            }
         }
      }
   }
   return new adfc.internal.TaskFlowReturnActivity(activityId, outcomeName);
}


adfc.internal.ActivityXmlParser.parseTaskFlowCallActivity = function(activityId, node)
{
   var taskFlowReference = null;
   var dynamicTaskFlowReferenceEl = null;
   var params = new Array();
   var paramMap = null;
   var returnValues = new Array();
   var beforeListener = null;
   var afterListener = null;
   var dcContext = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "task-flow-reference")
         {
            var taskFlowDocument = null;
            var taskFlowId = null;
            
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "document")
                  {
                     taskFlowDocument = adfc.internal.XmlUtil.getNodeText(child2);
                  }
                  else if (child2Name == "id")
                  {
                     taskFlowId = adfc.internal.XmlUtil.getNodeText(child2);;
                  }
               }
            }
            
            if (document && taskFlowId)
            {
               taskFlowReference = taskFlowDocument + "#" + taskFlowId;
            }
            else if (document)
            {
               taskFlowReference = taskFlowDocument;
            }
            else if (taskFlowId)
            {
               taskFlowReference = taskFlowId;
            }
            
         }
         else if (childName == "dynamic-task-flow-reference")
         {
            dynamicTaskFlowReferenceEl = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "input-parameter")
         {
            var param = adfc.internal.ActivityXmlParser.parseTaskFlowCallParam(child);
            params.push(param);
         }
         else if (childName == "input-parameter-map")
         {
            paramMap = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "return-value")
         {
            var returnValue = adfc.internal.ActivityXmlParser.parseTaskFlowCallParam(child);
            returnValues.push(returnValue);
         }
         else if (childName == "before-listener")
         {
            beforeListener = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "after-listener")
         {
            afterListener = adfc.internal.XmlUtil.getNodeText(child);
         }
          else if (childName == "data-control-context")
         {
            dcContext = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = 
      new adfc.internal.TaskFlowCallActivity(activityId, taskFlowReference, dynamicTaskFlowReferenceEl, params, paramMap,
                                             returnValues, beforeListener, afterListener, dcContext);
   return result;
}


// Note that this function is used for both input parameters and return values because they have the same elements.  This 
// is similar to the way the big ADF parsing code works
adfc.internal.ActivityXmlParser.parseTaskFlowCallParam = function(node)
{
   var name = null;
   var valueExpression = null;
   var passByValue = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "pass-by-value")
         {
            passByValue = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.TaskFlowCallParameter(name, valueExpression, passByValue);
   return result;
}

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ActivityXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowInputParameterXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.TaskFlowInputParameterXmlParser = {};
adfc.internal.TaskFlowInputParameterXmlParser.parse = function(docPath, taskFlowId, node)
{
   var name = null;
   var valueExpression = null;
   var type = null;
   var isRequired = false;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "required")
         {
            isRequired = true;
         }
      }
   }
   var result = new adfc.internal.TaskFlowInputParameter(name, valueExpression, type, isRequired);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowInputParameterXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ViewActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a view activity.
    */
   adfc.internal.ViewActivity = ViewActivity;
   function ViewActivity(id, vdlDocumentPath)
   {
      this.mActivityId = id;
      this.mVdlDocumentPath = vdlDocumentPath;
   }
  
   ViewActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.VIEW;
   }
  
   ViewActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
  
   ViewActivity.prototype.getVldDocumentPath = function() 
   {
      return this.mVdlDocumentPath;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ViewActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowCaseXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ControlFlowCaseXmlParser = {};
adfc.internal.ControlFlowCaseXmlParser.parse = function(docPath, taskFlowId, node)
{
   var outcome = null;
   var guardCondition = null;
   var targetActivityId = null;
   var transition = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "from-outcome")
         {
            outcome = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "if")
         {
            guardCondition = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "to-activity-id")
         {
            var localId = adfc.internal.XmlUtil.getNodeText(child);
            targetActivityId = new adfc.internal.ActivityId(taskFlowId, localId);
         }
         else if (childName == "transition")
         {
            transition = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.ControlFlowCase(outcome, guardCondition, targetActivityId, transition);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowCaseXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationHandler.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationHandler = NavigationHandler;

  /**
   * NavigationHandler is the public facing interface to the ADFc NavigationHandler.
   * @export
   */
  function NavigationHandler()
  {
  }

  /**
   * Get the initial viewId of a feature.
   * @param {Object} request an initial navigation request.  It must have an
   *                 attribute named:
   *                    entryPoint: the entry point file path.
   *
   * @param {function} success(request, response)  invoked upon successful completion of the navigation.
   * @param {function} failed(request, response)  invoked if navigation failed.
   * @export
   */
  NavigationHandler.getInitialViewId = function(request, successCallback, failCallback)
  {
      adfc.internal.LogUtil.perfLog("BEGIN: NavigationHandler.getInitialViewId");
      if (adfc.internal.LogUtil.isFine())
      {
         adfc.internal.LogUtil.fine("executing NavigationHandler.getInitialViewId() called.");
      }

      var entryPoint = request["entryPoint"];
      var inputParams = request["inputParams"];
      if (typeof inputParams === "undefined")
      {
        inputParams = {};
      }
      
      var success = function(result)
      {
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.getInitialViewId");
         successCallback(request, result);
      }
      
      var failed = function(message)
      {
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.getInitialViewId");
         failCallback(request, message);
      }

      adfc.internal.NavigationHandlerImpl.getInitialViewId(entryPoint, inputParams, success, failed);
  }

  /**
   * Perform navigation handling based on the current viewId and outcome.
   * @param {Object} request an initial navigation request.  It must have
   *                 attributes named:
   *                    currentViewId:  the viewId of the currently displayed view.
   *                    outcome:  the outcome produced by an action.
   * @param {function} success(request, response)  invoked upon successful completion of the navigation.
   * @param {function} failed(request, response)  invoked if navigation failed.
   * @export
   */
  NavigationHandler.handleNavigation = function(request, successCallback, failedCallback)
  {
      adfc.internal.LogUtil.perfLog("BEGIN: NavigationHandler.handleNavigation");

      var currentViewId = request["currentViewId"];
      var outcome = request["outcome"];
      
      if (adfc.internal.LogUtil.isFine())
      {
         adfc.internal.LogUtil.fine("executing NavigationHandler.handleNavigation(), currentViewId=" + 
                                    currentViewId + ", outcome=" + outcome);
      }
      
      var success = function(navResult)
      {
         if (adfc.internal.LogUtil.isFine())
         {
            var isNewView = navResult.isNewViewId();
            var msg = "ADFc: executing NavigationHandler.handleNavigation() completed, isNewView=" + isNewView;
            if (isNewView) 
            {
               var page = navResult.getVdlDocumentPath();
               msg += ", page=" + page;
            }
            adfc.internal.LogUtil.fine(msg);
         }
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.handleNavigation");
         successCallback(request, navResult);
      }
      var failed = function(message) 
      {
         if (adfc.internal.LogUtil.isFine())
         {
            adfc.internal.LogUtil.fine("executing NavigationHandler.handleNavigation() failed");
         }
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.handleNavigation");
         failedCallback(request, message);
      }
      adfc.internal.NavigationHandlerImpl.handleNavigation(currentViewId, outcome, success, failed);
      
  }
  
  /**
   * Registers a navigation listener function. 
   * @param {function} callback(event)  invoked upon start or successful completion of the navigation.
   * @export
   */
  NavigationHandler.addNavigationListener = function(callback)
  {
    for(var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      if(adfc.internal.navigationListeners[i] == callback)
      {
        return;
      }
    }
    adfc.internal.LogUtil.fine("ADFc: addNavigationListener");
    adfc.internal.navigationListeners.push(callback);
  }

  /**
   * Removes a registered navigation listener.
   * @param {function} callback(event)  invoked upon start or successful completion of the navigation.
   * @export
   */
  NavigationHandler.removeNavigationListener = function(callback)
  {
    var temp = [];

    for(var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      if(adfc.internal.navigationListeners[i] != callback)
      {
        adfc.internal.LogUtil.fine("ADFc: removeNavigationListener");
        temp.push(adfc.internal.navigationListeners[i]);
      }
    }
    adfc.internal.navigationListeners = temp;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationHandler.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowReturnActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.TaskFlowReturnActivityLogic = TaskFlowReturnActivityLogic;
   function TaskFlowReturnActivityLogic()
   {
   }

  TaskFlowReturnActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
  {
    var controllerState = adfc.internal.AdfcContext.getControllerState();
    var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(currentTaskFlow)
      {
        var currentTaskFlowCallActivity = currentTaskFlowEntry.getTaskFlowCallActivity()
        if (currentTaskFlowCallActivity && (currentTaskFlowCallActivity != null))
        {
          var finalizerSuccess = function()
          {
            var gatherReturnValuesSuccess = function(returnValueDefs)
            {
              var popTfSuccess = function(poppedTfStackEntry)
              {
                routingState.setLastReturnedFromTfEntry(poppedTfStackEntry);
                var returnValuesSuccess = function()
                {
                  var invokeAfterListenerSuccess = function()
                  {
                    var outcome = activity.getOutcomeName();
                    routingState.setCurrentOutcome(outcome);
                    routingState.setCurrentActivityId(currentTaskFlowCallActivity.getActivityId());
                    routingState.setNextActivityId(null);
                    routingState.setTaskFlowReturnExecuted(true);
                    routingState.setRoutingComplete(false);
                    successCallback(routingState);
                  }
                  // invoke the after-listener
                  TaskFlowReturnActivityLogic.invokeAfterListener(currentTaskFlowCallActivity, invokeAfterListenerSuccess, failCallback);
                }
                // store the return values in the caller
                TaskFlowReturnActivityLogic.storeReturnValues(currentTaskFlowCallActivity, returnValueDefs, returnValuesSuccess, failCallback)
              }
              // pop the task flow from the stack
              adfc.internal.AdfcContext.getControllerState().popTaskFlow(popTfSuccess, failCallback);
            }
            // gather the retun values from the callee
            TaskFlowReturnActivityLogic.gatherReturnValues(currentTaskFlow, gatherReturnValuesSuccess, failCallback);
          }
          // invoke the finalizer
          TaskFlowReturnActivityLogic.invokeFinalizer(currentTaskFlow, finalizerSuccess, failCallback);
        }
        else
        {
          routingState.setTaskFlowReturnExecuted(true);
          routingState.setRoutingComplete(true);
          successCallback(routingState);
        }
      });
  };

   /**
    * invokes the after-listener of a the given task flow call activity if it is specified
    */
   TaskFlowReturnActivityLogic.invokeAfterListener = function(activity, successCallback, failCallback)
   {
      //
      // invoke the after listener if specified
      //
      var listener = activity.getAfterListener();
      if (listener && (listener != null))
      {
         adfc.internal.LogUtil.fine("calling after-listener: " + listener);
         adfc.internal.ElUtil.invokeMethod(listener, new Array(), new Array(), successCallback, failCallback);
      }
      else
      {
         successCallback()
      }
   }
   

   /**
    * invokes the finalizer of a the given task flow activity if it is specified
    */
   TaskFlowReturnActivityLogic.invokeFinalizer = function(taskFlowDef, successCallback, failCallback)
   {
      //
      //  Execute the task flow's finalizer, if it has one.
      //
      var finalizer = taskFlowDef.getFinalizer();
      if (finalizer && (finalizer != null))
      {
         adfc.internal.LogUtil.fine("calling finalzer: " + finalizer);
         adfc.internal.ElUtil.invokeMethod(finalizer, new Array(), new Array(), successCallback, failCallback);
      }
      else
      {
         successCallback();
      }
   }
   
   
   
   /**
    * collects return values from the called taskflow prior to returning
    */
   TaskFlowReturnActivityLogic.gatherReturnValues = function(taskFlowDef, successCallback, failCallback)
   {
      var returnValueExpressions = new Array();
      var returnValueNames = new Array();
      
      var getReturnValuesSuccess = function(request, response)
      {
         //
         //  Build a map of the return value name/value pairs
         //
         var returnValues = {};
         for (var i = 0; i < response.length; i++)
         {
            var returnValueName = returnValueNames[i];
            returnValues[returnValueName] = response[i].value;
         }
         
         successCallback(returnValues);
      }
      
      //
      //  Collect the task flow's return values.
      //
      var values = taskFlowDef.getReturnValues();

      if (values.length > 0)
      {
         for (var i = 0; i < values.length; i++)
         {
            returnValueExpressions.push(values[i].getValueExpression());
            returnValueNames.push(values[i].getName());
         }
         adfc.internal.LogUtil.fine("getting task flow return values");
         adfc.internal.ElUtil.getValues(returnValueExpressions, getReturnValuesSuccess, failCallback);
      }
      else 
      {
         //
         //  There aren't any return values.
         //
         adfc.internal.LogUtil.fine("no task flow return values defined");
         getReturnValuesSuccess(returnValueExpressions, returnValueExpressions);
      }
   }
   
   
   /**
    * stores return values from the called taskflow into the expressions defined in the task flow call
    */
   TaskFlowReturnActivityLogic.storeReturnValues = function(currentTaskFlowCallActivity, returnValueDefs, successCallback, failCallback)
   {
      var request = new Array();
      var returnValues = currentTaskFlowCallActivity.getReturnValues();
      if ((returnValues != null) && (returnValues.length > 0))
      {
         for (var i = 0; i < returnValues.length; i++)
         {
            var returnValue = returnValues[i];
            var returnValueName = returnValue.getName();
            if (returnValueDefs[returnValueName])
            {
               var value = returnValueDefs[returnValueName];
               var elExpression = returnValue.getValueExpression();
               if ((elExpression == null) || (elExpression == ""))
               {
                  elExpression = "#{pageFlowScope." + returnValueName + "}";
               }
               request[i] = {name: elExpression, value: value};
            }
         }
         adfc.internal.ElUtil.setValues(request, successCallback, failCallback);
      }
      else
      {
         successCallback();
      }
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowReturnActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/IdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.IdUtil = IdUtil;
   adfc.internal.IdUtil.seqNum = 0;
   
   function IdUtil()
   {}
   
   IdUtil.uuid = function()
   {
      var result = true;
      if (typeof amx !== "undefined")
      {
         if (typeof amx.uuid !== "undefined")
         {
            result = amx.uuid();
         }
         else
         {
            result = adfc.internal.IdUtil.seqNum++;
         }
      }
      else
      {
         result = adfc.internal.IdUtil.seqNum++;
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/IdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/RouterActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.RouterActivityLogic = RouterActivityLogic;
   function RouterActivityLogic()
   {
   }
      
   RouterActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.perfLog("BEGIN: RouterActivityLogic.execute");
      var currentCase = 0;
      var expression = null;
      var elSuccessCallback = function(request, response)
      {
         //
         //  Convert the result into a boolean value.
         //
         var result = response[0].value;
         if (adfc.internal.LogUtil.isFine())
         {
            adfc.internal.LogUtil.fine("ADFc: router expression '" + expression + "' evaluated to '" + result + "'.");
         }
         result = adfc.internal.ElUtil.resultToBoolean(result);
         
         var cases = activity.getCases();
         if (result == true)
         {
            //
            //  The expression evaluated to true so we want this router case's outcome.
            //
            var outcome = cases[currentCase].getOutcome();
            routingState.setCurrentOutcome(outcome);
            adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
            successCallback(routingState);
         }
         else
         {
            //
            //  The expression evaluated to false so see if there's another
            //  expression case to evaluate.
            //
            if (cases.length > currentCase+1)
            {
               ++currentCase;
               var routerCase = cases[currentCase];
               expression = routerCase.getExpression();
               adfc.internal.ElUtil.getValue(expression, elSuccessCallback, failCallback);
            }
            else
            {
               //
               //  There are no more cases so use the default outcome.
               //
               outcome = activity.getDefaultOutcome();
               routingState.setCurrentOutcome(outcome);
               adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
               successCallback(routingState);
            }
         }
      }
      
      var cases = activity.getCases();
      if ((cases != null) && (cases.length > 0))
      {
         //
         //  Evaluate the first case's expression.
         //
         var routerCase = cases[currentCase];
         var expression = routerCase.getExpression();
         adfc.internal.ElUtil.getValue(expression, elSuccessCallback, failCallback);
      }
      else
      {
         //
         //  There are no cases so use the default outcome.
         //
         var outcome = this.mRouter.getDefaultOutcome();
         routingState.setCurrentOutcome(outcome);
         adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
         successCallback(routingState);
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/RouterActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a router activity.
    */
   adfc.internal.RouterActivity = RouterActivity;
   function RouterActivity(activityId, cases, defaultOutcome)
   {
      this.mActivityId = activityId;
      this.mCases = cases;
      this.mDefaultOutcome = defaultOutcome;
   }

   RouterActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.ROUTER;
   }
  
   RouterActivity.prototype.getActivityId = function()
   {
      return this.mActivityId;
   }
   
   RouterActivity.prototype.getCases = function()
   {
      return this.mCases;
   }
   
   RouterActivity.prototype.getDefaultOutcome = function()
   {
      return this.mDefaultOutcome;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/application/NavigationHandlerImpl.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.NavigationHandlerImpl = NavigationHandlerImpl;

  adfc.internal.navigationListeners   = [];

  function NavigationHandlerImpl()
  {
  }

  NavigationHandlerImpl.getInitialViewId = function(entryPoint, inputParams, successCallback, failCallback)
  {
    //
    //  See if we're starting with a bounded task flow.
    //
    var isTaskFlow = adfc.internal.XmlUtil.isTaskFlowDocument(
      function(isTaskFlow)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("isTaskFlow=" + isTaskFlow);
        }
        if (isTaskFlow)
        {
          //
          //  We're starting with a task flow document. Parse the task flow ID.
          //
          var taskFlowId = adfc.internal.TaskFlowId.parse(entryPoint);

          //
          //  Create a RoutingState.
          //
          var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
          var currentTfInstanceId = currentTaskFlowEntry.getInstanceId();
          var routingState = new adfc.internal.RoutingState(currentTfInstanceId, null, null, null);
          routingState.setRoutingSuccessCallback(successCallback);
          routingState.setRoutingFailedCallback(failCallback);

          var invokeSuccessCallback =
            function(routingState2)
            {
              var routingSuccess = function(navResult)
              {
                if (adfc.internal.LogUtil.isFine())
                {
                  adfc.internal.LogUtil.fine("ADFc: routing completed in getInitialViewId.");
                }

                //
                //  Mark back navigation invalid from the initial view.
                //
                var currentTfEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
                if (currentTfEntry.getViewHistoryLength() > 0)
                {
                  var viewItem = currentTfEntry.peekViewHistory();
                  viewItem.setBackNavigationValid(false);
                }

                if (adfc.internal.LogUtil.isFine())
                {
                  adfc.internal.LogUtil.fine("ADFc: getInitialViewId calling successCallback.");
                  if (typeof successCallback === "undefined")
                  {
                    adfc.internal.LogUtil.fine("ADFc: successCallback is undefined!!!");
                  }
                }
                successCallback(navResult);
              }

              //
              //  Perform routing once we're inside the starting flow.
              //
              routingState.setRoutingSuccessCallback(routingSuccess);
              adfc.internal.ControlFlowEngine.doRouting(routingState2);
            };

          //
          //  Invoke the starting task flow.
          //
          adfc.internal.TaskFlowCallActivityLogic.invokeTaskFlow(taskFlowId, inputParams, null, routingState, invokeSuccessCallback, failCallback);
        }
        else
        {
          //
          //  We're not starting with a bounded task flow so see if the entry point is
          //  a view activity in the unbounded flow.
          //
          var tfEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
          NavigationHandlerImpl.getUnboundedFlowViewActivity(
            function(viewActivity)
            {
              if (viewActivity != null)
              {
                //
                //  We're starting with a view activity in the unbounded flow.
                //
                var pagePath = viewActivity.getVldDocumentPath();
                var viewId = viewActivity.getActivityId().getLogicalViewId();
                adfc.internal.LogUtil.info("displaying initial unbounded view activity, page=" + pagePath);
                var navResult = new adfc.NavigationResult(true, false, viewId, pagePath, "", false, true);

                //
                //  Push the initial view history item.
                //
                tfEntry.pushViewHistory(viewId, pagePath, adfc.internal.ControlFlowCase.DEFAULT_TRANSITION);

                successCallback(navResult);
              }
              else
              {
                //
                //  Assume the entry point is an AMX page.
                //
                adfc.internal.LogUtil.info("displaying initial AMX page, page=" + entryPoint);
                var navResult2 = new adfc.NavigationResult(true, false, entryPoint, entryPoint, "", false, true);

                //
                //  Push the initial view history item.
                //
                tfEntry.pushViewHistory(entryPoint, entryPoint, adfc.internal.ControlFlowCase.DEFAULT_TRANSITION);

                successCallback(navResult2);
              }
            },
            entryPoint);
        }
      },
      adfc.Util.addFeatureRootPrefix(entryPoint));
  };

  NavigationHandlerImpl.getUnboundedFlowViewActivity = function(callback, entryPoint)
  {
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(unboundedTf)
      {
        if ((unboundedTf == null) || (unboundedTf.getTaskFlowId() != null))
        {
          var msg = "unbounded task flow is not current";
          adfc.internal.LogUtil.showAlert(msg);
          throw new Error(msg);
        }

        //
        //  Look for a view activity that uses the entry point as its VDL document.
        //
        var viewActivity = null;
        var testEntryPoint = entryPoint;
        if ((testEntryPoint != null) && (testEntryPoint.length > 0) &&
          (testEntryPoint.charAt(0) != "/"))
        {
          testEntryPoint = "/" + testEntryPoint;
        }
        var activities = unboundedTf.getActivities();
        for (var name in activities)
        {
          var activity = activities[name];
          if (activity.getActivityType() == adfc.internal.ActivityType.VIEW)
          {
            var vdlDoc = activity.getVldDocumentPath();
            if (vdlDoc == testEntryPoint)
            {
              viewActivity = activity;
              break;
            }
          }
        }
        callback(viewActivity);
      });
  };

  NavigationHandlerImpl.handleNavigation = function(currentViewId, outcome, successCallback,
    failCallback)
  {
    //
    // Deliver navigation start event
    //
    var startNavEvent = new adfc.NavigationEvent(currentViewId, null,
      adfc.NavigationEventType.START);
    NavigationHandlerImpl.notifyNavigationListeners(startNavEvent);

    var controllerState = adfc.internal.AdfcContext.getControllerState();
    var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
    var tfInstanceId = currentTaskFlowEntry.getInstanceId();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        var currentTaskFlowId = taskFlowDef.getTaskFlowId();
        var currentActivityId = adfc.internal.ViewIdUtil.logicalViewIdToActivityId(
          currentTaskFlowId, currentViewId);
        var routingState = new adfc.internal.RoutingState(tfInstanceId, currentViewId,
          currentActivityId, outcome);

        routingState.setRoutingSuccessCallback(successCallback);
        routingState.setRoutingFailedCallback(failCallback);
        adfc.internal.ControlFlowEngine.doRouting(routingState);
      });
  };

  NavigationHandlerImpl.notifyNavigationListeners = function(event)
  {
    for (var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      try
      {
        adfc.internal.LogUtil.fine("ADFc: notifyNavigationListeners");
        adfc.internal.navigationListeners[i](event);
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "NavigationHandlerImpl.notifyNavigationListeners",
          "ERROR_IN_BULK_NOTIFICATION_CALLBACK");

        // Only log the details at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "NavigationHandlerImpl", "notifyNavigationListeners", e);
      }
    }
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/application/NavigationHandlerImpl.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityId.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Unique identifier of an activity.
    */
   adfc.internal.ActivityId = ActivityId;
   function ActivityId(taskFlowId, localId)
   {
      this.mTaskFlowId = taskFlowId;
      this.mLocalActivityId = localId;
   }
   
   /**
    * Parses a string representation of a task flow ID and returns an
    * ActivityId object.
    */
   ActivityId.parse = function(stringId)
   {
      var result = null;
      
      //
      //  The expected format is <task-flow-id>@<local-id>.
      //
      var index = stringId.indexOf("@");
      if (index > 0)
      {
         var tfIdString = stringId.substring(0, index);
         var tfId = adfc.internal.TaskFlowId.parse(tfIdString);
         var localId = stringId.substring(index+1);
         result = new ActivityId(tfId, localId);
      }
      return result;
   }
   
   ActivityId.prototype.getTaskFlowId = function()
   {
      return this.mTaskFlowId;
   }
   
   ActivityId.prototype.getLocalActivityId = function()
   {
      return this.mLocalActivityId;
   }
   
   /**
    * Constructs the logical viewId which is a cancatination of the
    * task flow's localId and the activity's localId.
    */
   ActivityId.prototype.getLogicalViewId = function()
   {
      var tfLocalId = "";
      if (this.mTaskFlowId != null)
      {
         tfLocalId = "/" + this.mTaskFlowId.getLocalTaskFlowId();
      }
      var result = tfLocalId + "/" + this.mLocalActivityId;
      return result;
   }
   
   ActivityId.prototype.toString = function()
   {
      var tfn = (this.mTaskFlowId != null)? this.mTaskFlowId.toString() : "";
      var result = tfn + "@" + this.mLocalActivityId;
      return result;
   }
   
   ActivityId.prototype.equals = function(other)
   {
      var result = false;
      if (other != null)
      {
         if ((typeof other.mTaskFlowId !== "undefined") && (typeof other.mLocalActivityId !== "undefined"))
         {
            if (this.mTaskFlowId != null)
            {
               //
               //  See if the taskFlowIds match.
               //
               if (this.mTaskFlowId.equals(other.mTaskFlowId))
               {
                  //
                  //  See if the local activityIds match.
                  //
                  result = (this.mLocalActivityId == other.mLocalActivityId);
               }
            }
            else if (other.mTaskFlowId == null)
            {
               //
               //  Both taskFlowIds are null.
               //
               result = (this.mLocalActivityId == other.mLocalActivityId);
            }
         }
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityId.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ElUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ElUtil = ElUtil;
   
   function ElUtil()
   {}
   
   ElUtil.TASK_FLOW_UTILITIES = "oracle.adfmf.framework.TaskFlowUtilities";
   
   /**
    * Get a single value.
    */
   ElUtil.getValue = function(expression, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.getValue(expression, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.getValue(expression, successCallback, failCallback);
      }
   }
   
   /**
    * Get an array of values.
    */
   ElUtil.getValues = function(expressions, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.getValues(expressions, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.getValue(expressions, successCallback, failCallback);
      }
   }
   
   /**
    * Set a single value.
    */
   ElUtil.setValue = function(request, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.setValue(request, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.setValue(request, successCallback, failCallback);
      }
   }
   
   /**
    * Set an array of values.
    */
    ElUtil.setValues = function(request, successCallback, failCallback)
    {
       ElUtil.setValue(request, successCallback, failCallback);
    }
   
   /**
    * Invoke a method binding.
    */
   ElUtil.invokeMethod = function(expression, argTypes, argValues, successCallback, failCallback)
   {
      if (argTypes == null)
      {
         adfc.internal.LogUtil.warning("ElUtil.invokeMethod() passed null argTypes.  This is likely to fail.");
      }
      
      if (argValues == null)
      {
         adfc.internal.LogUtil.warning("ElUtil.invokeMethod() passed null argValues.  This is likely to fail.");
      }
         
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.invokeMethod(expression, argTypes, argValues, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.invoke(expression, argValues, null, argTypes, successCallback, failCallback);
      }
   }
   
   /**
    * Set the current binding container.
    */
   ElUtil.setBindingContainerPath = function(path, resetViewScope, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("Setting binding container for: " + path);
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock setBindingContainerPath");
         successCallback();
      }
      else
      {
        // We really should be resetting the context if it exists. We really need a function that resets the 
        // Context if it exits, or else creates if for the first time.
        adf.mf.api.setCurrentContext(path, true, true, resetViewScope, successCallback, failCallback);
      }
   }
   
   /**
    * Reset/release a binding container.
    */
   ElUtil.resetBindingContainerPath = function(path, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("Removing binding container for: " + path);
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock resetBindingContainerPath");
         successCallback();
      }
      else
      {  
        // This should be resetting the context instance but for now we are removing it. The issue is I have
        // no way to know it existed to reuse. So I remove it, and recreate it in the setBindingContainerPath
        adf.mf.api.removeContextInstance(path, path, successCallback, failCallback);
      }
   }
      
   ElUtil.getCurrentBindingContainerPath = function(successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock getBindingContainerPath");
         successCallback(null);
      }
      else
      {
         adf.mf.api.getContextId(successCallback, failCallback);
      }
   }
   
   ElUtil.resultToBoolean = function(value)
   {
      var result = false;
      if (value != null)
      {
         if (value == true)
         {
            result = true;
         }
         else
         {
            if (value instanceof Boolean)
            {
               result = value.valueOf();
            }
            else
            {
               value = new String(value);
               if (value.toLowerCase() == "true")
               {
                  result = true;
               }
            }
         }
      }
      return result;
   }
   
   ElUtil.useMockEl = function()
   {
      var result = true;
      if (typeof adf !== "undefined")
      {
         if (typeof adf.mf !== "undefined")
         {
             if (typeof adf.mf.internal !== "undefined")
             {
                 if (typeof adf.mf.internal.isJavaAvailable !== "undefined")
                 {
                    result = !adf.mf.internal.isJavaAvailable();
                 }
             }
         }
      }
      return result;
   }
   
   ElUtil.useMockContext = function()
   {
      var result = ElUtil.useMockEl();
      return result;
   }
   
   /**
    *  Set a collection of managed bean definitions.  The collection of bean
    *  definitions supplied here _REPLACES_ any existing definitions, it does
    *  not add to the existing set.
    */
   ElUtil.setBeanDefinitions = function(beanDefs, successCallback, failCallback)
   {
      if (beanDefs != null)
      {
         adfc.internal.LogUtil.fine("defining " + beanDefs.length + " managed beans");
      }
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtil.currentBeanDefs = beanDefs;
         successCallback();
      }
      else
      {
         var elBeanDefs = ElUtil.createBeanDefinitions(beanDefs);
         adf.mf.internal.mb.setBeanDefinitions(elBeanDefs, successCallback, failCallback);
      }
   }
   
   /**
    *  Create an array of bean definitions in the format used by the EL from the format
    *  used internally by the controller.
    */
   ElUtil.createBeanDefinitions = function(internalBeanDefs)
   {
      var elBeanDefs = new Array();
      if (internalBeanDefs != null)
      {
         for (var i = 0; i < internalBeanDefs.length; i++)
         {
            var bean = internalBeanDefs[i];
            var props = ElUtil.createPropDefinitions(bean.getManagedProperties());
            var elBean = new adf.mf.internal.mb.ManagedBeanDefinition(bean.getBeanName(), bean.getBeanClass(), 
                                                                      bean.getBeanScope(), props);
            elBeanDefs.push(elBean);
         }
      }
      return elBeanDefs;
   }
   
   /**
    *  Create an array of bean definitions in the format used by the EL from the format
    *  used internally by the controller.
    */
   ElUtil.createPropDefinitions = function(internalPropDefs)
   {
      var elPropDefs = new Array();
      if (internalPropDefs != null)
      {
         if (internalPropDefs != null) 
         {
            for (var i = 0; i < internalPropDefs.length; i++)
            {
               var propDef = internalPropDefs[i];
               var elPropDef = new adf.mf.internal.mb.ManagedPropertyDefinition(propDef.getName(), 
                                                                                propDef.getType(), 
                                                                                propDef.getValue());
               elPropDefs.push(elPropDef);
            }
         }
      }
      return elPropDefs;
   }
   
   /**
    *  Push a new pageFlowScope instance and a new data control context, if needed.
    *  This methods marks the beginning of the scope's lifespan.
    */
   ElUtil.pushScopesIfNeeded = function(/* boolean */ pushPageFlowScope, /* boolean */ pushDataControlContext, 
                                        /* function */ successCallback, /* function */ failCallback) 
   {
      var pushSucceeded = true;
      var pushSuccess = function(req, status)
      {
         pushSucceeded = status;
         
         if (pushSucceeded)
         {
           if (pushPageFlowScope)
           {
             // Clear out the cache of the page flow scope to ensure that we have a clean scope
             adf.mf.internal.context.getVariableMapper().setVariable("pageFlowScope", {});
           }
           successCallback();
         }
         else
         {
           var msg = "Maximum data control context stack depth exceeded.";
           adfc.internal.LogUtil.severe(msg);
           if (adfc.internal.ElUtil.useMockContext())
           {
             adfc.internal.LogUtil.showAlert(msg);
           }
           else
           {
             adf.mf.api.amx.addMessage("severe", msg, null, null);    
           }
           failCallback(message);
         }
      }
      if (!(pushPageFlowScope || pushDataControlContext))
      {
        successCallback();
      }
      else
      {
        if (adfc.internal.ElUtil.useMockContext())
        {
           if (pushPageFlowScope)
           {
              adfc.internal.LogUtil.fine("pushing page flow scope");
           }
           if (pushDataControlContext)
           {
             adfc.internal.LogUtil.fine("pushing data control context");
           }
           successCallback();
        }
        else
        {
           adf.mf.api.invokeMethod(ElUtil.TASK_FLOW_UTILITIES, "handleTaskFlowCall",
                                   pushPageFlowScope, pushDataControlContext, pushSuccess, failCallback);                      
        }
      }
   }

   
    /**
    *  Pop the current pageFlowScope instance and data control context, if needed.
    *  This methods marks the end of the scope's lifespan.
    */
   ElUtil.popScopesIfNeeded = function(/* boolean */ popPageFlowScope, /* boolean */ popDataControlContext,
                                       /* function */ successCallback, /* function */ failCallback) 
   {
      var popSucceeded = true;
      var popSuccess = function(req, status)
      {
         popSucceeded = status;
         
         if (popSucceeded)
         {
           if (popPageFlowScope)
           {
              // Clear out the cache of the page flow scope to ensure that we have a clean scope
              adf.mf.internal.context.getVariableMapper().setVariable("pageFlowScope", {});
           }
           successCallback();
         }
         else
         {
           var msg = "Data control context stack is empty.";
           adfc.internal.LogUtil.severe(msg);
           if (adfc.internal.ElUtil.useMockContext())
           {
             adfc.internal.LogUtil.showAlert(msg);
           }
           else
           {
             adf.mf.api.amx.addMessage("severe", msg, null, null);    
           } 
           failCallback(message);
         }
      }
      if (!(popPageFlowScope || popDataControlContext))
      {
        successCallback();
      }
      else
      {
         if (adfc.internal.ElUtil.useMockContext())
         {
           if (popPageFlowScope)
           {
              adfc.internal.LogUtil.fine("popping page flow scope");
           }
           if (popDataControlContext)
           {
             adfc.internal.LogUtil.fine("popping data control context");
           }
           successCallback();
        }
        else
        {  
           adf.mf.api.invokeMethod(ElUtil.TASK_FLOW_UTILITIES, "handleTaskFlowReturn",
                                   popPageFlowScope, popDataControlContext, popSuccess, failCallback);
         }
      }
   }
   
   ElUtil.setMfContextInstance = function(viewHistoryItem, newInstance)
   {
      if ((typeof adf.mf.internal.useNavHandlerViewHistory !== "undefined") && adf.mf.internal.useNavHandlerViewHistory)
      {
         if (typeof adf.mf.internal.amx !== "undefined")
         {
            if (typeof adf.mf.internal.amx.setMfContextInstance !== "undefined")
            {
               if (adfc.internal.LogUtil.isFine())
               {
                  adfc.internal.LogUtil.fine("ADFc: setting MfContextInstance, newInstance=" + newInstance + ".");
               }
               adf.mf.internal.amx.setMfContextInstance(viewHistoryItem, newInstance);
            }
         }
      }
   }
   
   ElUtil.removeMfContextInstance = function(viewHistoryItem)
   {
      if ((typeof adf.mf.internal.useNavHandlerViewHistory !== "undefined") && adf.mf.internal.useNavHandlerViewHistory)
      {
         if (typeof adf.mf.internal.amx !== "undefined")
         {
            if (typeof adf.mf.internal.amx.removeMfContextInstance !== "undefined")
            {
               if (adfc.internal.LogUtil.isFine())
               {
                  adfc.internal.LogUtil.fine("ADFc: removing MfContextInstance.");
               }
               adf.mf.internal.amx.removeMfContextInstance(viewHistoryItem);
            }
         }
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ElUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowDefinitionXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.TaskFlowDefinitionXmlParser = {};
adfc.internal.TaskFlowDefinitionXmlParser.parse = function(docPath, document, tfNode)
{
   var result = null;
   if (tfNode)
   {
      var taskFlowId = null;
      var defaultActivityId = null;
      var initializer = null;
      var finalizer = null;
      var inParams = new Array();
      var returnValues = new Array();
      var activities = new Array();
      var cfRules = new Array();
      var managedBeans = new Array();
      var pageFlowScopeBehavior = "preserve";

      //
      //  If the document path is non-null then get the ID attribute from the
      //  task flow node and construct a taskFlowId.  If the document path is
      //  null then this is the unbounded flow and the taskFlowId should be null.
      //
      if (docPath != null)
      {
         var tfIdStr = tfNode.attributes.getNamedItem("id").nodeValue;
         taskFlowId = new adfc.internal.TaskFlowId(docPath, tfIdStr);
      }

      //
      //  Iterate over the children parsing as we go.
      //
      var children = tfNode.childNodes;
      for (var i = 0; i < children.length; i++)
      {
         var node = children.item(i);
         var nodeName = node.localName;
         var obj = null;
         if (nodeName)
         {
            if (nodeName == "default-activity")
            {
               var defActivityLocalId = adfc.internal.XmlUtil.getNodeText(node);
               defaultActivityId = new adfc.internal.ActivityId(taskFlowId, defActivityLocalId);
            }
            else if (nodeName == "initializer")
            {
               initializer = adfc.internal.XmlUtil.getNodeText(node);
            }
            else if (nodeName == "finalizer")
            {
               finalizer = adfc.internal.XmlUtil.getNodeText(node);
            }
            else if (nodeName == "input-parameter-definition")
            {
               obj = adfc.internal.TaskFlowInputParameterXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  inParams.push(obj);
               }
            }
            else if (nodeName == "return-value-definition")
            {
               obj = adfc.internal.TaskFlowInputParameterXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  returnValues.push(obj);
               }
            }
            else if ((nodeName == "view") || (nodeName == "router") ||
                     (nodeName == "method-call") || (nodeName == "task-flow-return") ||
                     (nodeName == "task-flow-call"))
            {
               obj = adfc.internal.ActivityXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  activities.push(obj);
               }
            }
            else if (nodeName == "control-flow-rule")
            {
               obj = adfc.internal.ControlFlowRuleXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  cfRules.push(obj);
               }
            }
            else if (nodeName == "managed-bean")
            {
               obj = adfc.internal.ManagedBeanDefinitionXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  managedBeans.push(obj);
               }
            }
            else if (nodeName == "page-flow-scope-behavior")
            {
               var pfsbChildren = node.childNodes;
               for (var j = 0, size = pfsbChildren.length; j < size; ++j)
               {
                  var childNode = pfsbChildren[j];
                  if (childNode.nodeType == 1 /*Node.ELEMENT_NODE*/)
                  {
                    if (childNode.localName == "push-new")
                    {
                       pageFlowScopeBehavior = "pushNew";
                       break;
                    }
                    else if (childNode.localName == "preserve")
                    {
                       pageFlowScopeBehavior = "preserve";
                       break;
                    }
                  }
               }
            }
         }
      }

      //
      //  Convert the activities array to a map keyed by local activityId.
      //
      var temp = activities;
      activities = new Object();
      for (var index in temp)
      {
         var activity = temp[index];
         activities[activity.getActivityId().getLocalActivityId()] = activity;
      }

      //
      //  Convert the control flow rules to a map keyed by the from activity's local ID.
      //
      temp = cfRules;
      cfRules = new Object();
      for (var index in temp)
      {
         var rule = temp[index];
         var fromId = rule.getFromActivityId().getLocalActivityId();
         var existingRule = cfRules[fromId];
         if (existingRule == null)
         {
            cfRules[rule.getFromActivityId().getLocalActivityId()] = rule;
         }
         else
         {
            existingRule.addControlFlowCases(rule.getControlFlowCases());
         }
      }

      result = new adfc.internal.TaskFlowDefinition(taskFlowId, defaultActivityId, initializer,
         finalizer, inParams, returnValues, activities, cfRules, managedBeans,
         pageFlowScopeBehavior);
   }
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowDefinitionXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowRule.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow control flow rule.
    */
   adfc.internal.ControlFlowRule = ControlFlowRule;
   function ControlFlowRule(fromActivityId, controlFlowCases)
   {
      this.mFromActivityId = fromActivityId;
      this.mControlFlowCases = controlFlowCases;
   }

   ControlFlowRule.prototype.getFromActivityId = function()
   {
      return this.mFromActivityId;
   }

   ControlFlowRule.prototype.getControlFlowCases = function()
   {
      return this.mControlFlowCases;
   }
   
   ControlFlowRule.prototype.addControlFlowCases = function(cases)
   {
      if (cases != null)
      {
         for (var newIndex in cases)
         {
            var newCase = cases[newIndex];
            var outcome = newCase.getOutcome();
            var index = this.getControlFlowCaseIndex(outcome);
            if (index >= 0)
            {
               this.mControlFlowCases[index] = newCase;
            }
            else
            {
               this.mControlFlowCases.push(newCase)
            }
         }
      }
   }
   
   /**
    *  Get the control flow case for a specific outcome value.  If there is no matching case for the given outcome and a
    *  default case exists (null from-outcome) then we'll return the default
    */
   ControlFlowRule.prototype.getControlFlowCase = function(outcome)
   {
      var result = null;
      var index = this.getControlFlowCaseIndex(outcome);
      if (index >= 0)
      {
         result = this.mControlFlowCases[index];
      }
      return result;
   }

   ControlFlowRule.prototype.getControlFlowCaseIndex = function(outcome)
   {
      // ADFmf handles default control flow case logic slightly differently than bigADF.  All cases are stored in the 
      // same Array.  The default (if it exists) has a null Outcome, so while we're iterating over the cases we'll also 
      // attempt to find the default.  If we don't find an exact match, then return the default.
      
      var result = -1;
      for (var index in this.mControlFlowCases)
      {
         var cfCase = this.mControlFlowCases[index];
         var testOutcome = cfCase.getOutcome();
         if (testOutcome == outcome)
         {
            result = index;
            break;
         }
         if (testOutcome == null)
         {
            result = index;
            // we've found the default to use if we don't find an exact match.  Don't break here because we need to 
            // continue searching for an exact match
         }
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowRule.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ViewActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewActivityLogic = ViewActivityLogic;
   function ViewActivityLogic()
   {
   }
      
   ViewActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.perfLog("BEGIN: ViewActivityLogic.execute");
      routingState.setViewReached(true);
      routingState.setRoutingComplete(true);
      var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
      currentTaskFlowEntry.setViewReached(true);
      adfc.internal.LogUtil.perfLog("END: ViewActivityLogic.execute");
      successCallback(routingState);
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ViewActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow definition.
    */
   adfc.internal.TaskFlowDefinition = TaskFlowDefinition;
   
   /*
    * Represents one of the possible page flow scope behavior settings for the task flow.
    */
   TaskFlowDefinition.PUSH_NEW = "pushNew";
   
   function TaskFlowDefinition(taskFlowId, defActId, initializer, finalizer, inParams, returnValues,
      activities, cfRules, beanDefs, pageFlowScopeBehavior)
   {
      //
      //  Initialize the fields.
      //
      this.mTaskFlowId = taskFlowId;
      this.mDefaultActivityId = defActId;
      this.mInitializer = initializer;
      this.mFinalizer = finalizer;
      this.mActivities = activities;
      this.mControlFlowRules = cfRules;
      this.mBeanDefinitions = beanDefs;
      this.mInputParams = inParams;
      this.mReturnValues = returnValues;
      this.mPageFlowScopeBehavior = pageFlowScopeBehavior;
   }

   TaskFlowDefinition.prototype.getTaskFlowId = function()
   {
      return this.mTaskFlowId;
   };

   TaskFlowDefinition.prototype.getControlFlowRules = function()
   {
      return this.mControlFlowRules;
   };

   TaskFlowDefinition.prototype.getActivities = function()
   {
      return this.mActivities;
   };

   TaskFlowDefinition.prototype.getDefaultActivityId = function()
   {
      return this.mDefaultActivityId;
   };

   TaskFlowDefinition.prototype.getInitializer = function()
   {
      return this.mInitializer;
   };

   TaskFlowDefinition.prototype.getFinalizer = function()
   {
      return this.mFinalizer;
   };

   TaskFlowDefinition.prototype.getInputParameters = function()
   {
      return this.mInputParams;
   };

   TaskFlowDefinition.prototype.getReturnValues = function()
   {
      return this.mReturnValues;
   };

   /**
    *  Returns an array of ManagedBeanDefinition objects.
    */
   TaskFlowDefinition.prototype.getBeanDefinitions = function()
   {
      return this.mBeanDefinitions;
   };

   /**
    * Get the page flow scope behavior. One of "pushNew" or "preserve".
    * @return {string} the page flow scope behavior
    */
   TaskFlowDefinition.prototype.getPageFlowScopeBehavior = function()
   {
      return this.mPageFlowScopeBehavior;
   };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationResult.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationResult = NavigationResult;

  /**
   * NavigationResult represents the results of navigation handling.
   */
  function NavigationResult(isNewViewId, isBackNav, viewId, vdlDocPath, transitionType, featureExited, isDifferentViewId)
  {
      this.mNewViewId = isNewViewId;
      this.mBackNavigation = isBackNav;
      this.mViewId = viewId;
      this.mVdlDocumentPath = vdlDocPath;
      this.mTransitionType = transitionType;
      this.mFeatureExited = featureExited;
      if (isDifferentViewId !== "undefined")
      {
        this.mDifferentViewId = isDifferentViewId;
      }
      else
      {
        this.mDifferentViewId = isNewViewId;
      }
  }
  
  /**
   * Did navigation result in a transition to a different viewId?  The difference between this
   * and the new viewId flag in that back navigation results in a transition to a different view,
   * but it's not a new view in the view history stack.
   * @return {Boolean} true if navigation resulted in a transition to
   * a different viewId, false if it didn't.
   * @export
   */
  NavigationResult.prototype.isDifferentViewId = function() 
  {
      return this.mDifferentViewId;
  }
  
  /**
   * Did navigation result in a transition to a new viewId?
   * @return {Boolean} true if navigation resulted in a transition to
   * a new viewId, false if it didn't.
   * @export
   */
  NavigationResult.prototype.isNewViewId = function() 
  {
      return this.mNewViewId;
  }
  
  /**
   * Was the navigation due to a "back-button" navigation?
   * @return {Boolean}
   * @export
   */
  NavigationResult.prototype.isBackNavigation = function()
  {
      return this.mBackNavigation;
  }

  /**
   * The new viewId or null if navigation did not transition to a new view.
   * @export
   */
  NavigationResult.prototype.getViewId = function()
  {
      return this.mViewId;
  }

  /**
   * The path to the new view's VDL document or null if navigation did not
   * transition to a new view.
   * @export
   */
  NavigationResult.prototype.getVdlDocumentPath = function()
  {
      return this.mVdlDocumentPath;
  }
  
  /**
   * The type of screen transition to use when displaying the new view or 
   * null if navigation did not transition to a new view.
   * @export
   */
  NavigationResult.prototype.getTransitionType = function()
  {
      return this.mTransitionType;
  }
  
  /**
   * @export
   */
  NavigationResult.prototype.isTaskFlowExited = function()
  {
      adfc.internal.LogUtil.warning("function adfc.NavigationResult.isTaskFlowExited() is deprecated, use adfc.NavigationResult.isFeatureExited() instead.");
      return this.isFeatureExited();
  }
  
  /**
   * Was the initial entry point task flow exited?
   * @export
   */
  NavigationResult.prototype.isFeatureExited = function()
  {
      return this.mTaskFlowExited;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationResult.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallParameter.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a method-call activity parameter.
    */
   adfc.internal.MethodCallParameter = MethodCallParameter;
   function MethodCallParameter(type, valueExpression)
   {
      this.mType = type;
      this.mValueExpression = valueExpression;
   }
   
   MethodCallParameter.prototype.getType = function()
   {
      return this.mType;
   }
   
   MethodCallParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowCase.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow control flow case.
    */
   adfc.internal.ControlFlowCase = ControlFlowCase;
   ControlFlowCase.DEFAULT_TRANSITION = "slide";
   function ControlFlowCase(outcome, guardCondition, toActivityId, transition)
   {
      this.mOutcome = outcome;
      this.mGuardCondition = guardCondition;
      this.mTargetActivityId = toActivityId;
      if (transition != null)
      {
         this.mTransition = transition;
      }
      else
      {
         this.mTransition = ControlFlowCase.DEFAULT_TRANSITION;
      }
   }

   ControlFlowCase.prototype.getOutcome = function()
   {
      return this.mOutcome;
   }

   ControlFlowCase.prototype.getGuardCondition = function()
   {
      return this.mGuardCondition;
   }

   ControlFlowCase.prototype.getTargetActivityId = function()
   {
      return this.mTargetActivityId;
   }

   ControlFlowCase.prototype.getTransition = function()
   {
      return this.mTransition;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowCase.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/XmlUtil.js///////////////////////////////////////

/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.XmlUtil = XmlUtil;
  function XmlUtil()
  {}

  /**
   * Loads an XML resource and returns it as a DOM.
   */
  XmlUtil.loadXmlFile = function(resourceName, callback)
  {
    var handler = function(xmlString)
      {
        var result = null;
        if ((xmlString != null) && (xmlString.length > 0))
        {
          var parser = new DOMParser();
          result = parser.parseFromString(xmlString, "text/xml");
        }
        else
        {
          adfc.internal.LogUtil.warning("failed to load XML for document: " + resourceName);
        }
        callback(result);
      };

    adf.mf.api.resourceFile._loadFileWithAjax(
      resourceName,
      true,
      function(responseText)
      {
        handler(responseText);
       },
      function()
      {
        handler(null);
      });
  };

  XmlUtil.getNodeText = function(node)
  {
    var result = null;
    if (node)
    {
      var children = node.childNodes;
      for (var i = 0; i < children.length; i++)
      {
        var child = children.item(i);
        if (child.nodeType == Node.TEXT_NODE)
        {
          result = child.nodeValue;
          break;
        }
      }
    }
    if (result && (result.length == 0))
    {
      result = null;
    }
    return result;
  };

  XmlUtil.isTaskFlowDocument = function(callback, path)
  {
    //
    //  Remove the '#' character from the path.
    //
    var index = path.indexOf('#');
    if (index > 0)
    {
       path = path.substring(0, index);
    }

    //
    //  Load the file content.
    //
    adf.mf.api.resourceFile._loadFileWithAjax(
      path,
      true,
      function(responseText)
      {
        //
        //  Look for the 'adfc-mobile-config' element/string.
        //
        var result = false;
        var content = responseText;
        if (content != null)
        {
          if (content.indexOf("adfc-mobile-config") > 0)
          {
            result = true;
          }
        }
        callback(result);
       },
      function()
      {
        throw new Error("failed to read entry point document " + path);
      });
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/XmlUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/AdfcContext.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.AdfcContext = AdfcContext;
   function AdfcContext()
   {
      this.mInitialized = false;
      this.mFinlized = false;
      this.mControllerState = null;
   }
   
   AdfcContext.initialize = function(successCallback, failCallback)
   {
      if (!this.mInitialized)
      {
         this.mInitialized = true;
         this.mControllerState = new adfc.internal.ControllerState();
         adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback);
      }
   }
   
   AdfcContext.finalize = function()
   {
      this.mController = null;
      this.mFinlized = true;
   }
  
   AdfcContext.getControllerState = function()
   {
      if (!this.mInitialized)
      {
         throw new Error("ADFc: AdfcContext is not initialized.");
      }
      if (this.mFinalized)
      {
         throw new Error("ADFc: AdfcContext has already been finalized.");
      }
      return this.mControllerState;
   }
   
   /**
    * Allow re-setting to initial conditions for unit testing.
    */
   AdfcContext.reinitialize = function()
   {
      this.mInitialized = false;
      this.mFinlized = false;
      this.mControllerState = null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/AdfcContext.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/Util.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
adfc.Util = {};

(function(){

   /**
    * Adds the feature root prefix to a resource path located under the
    * feature's public_html directory.
    */
   adfc.Util.addFeatureRootPrefix = function(path)
   {
      var result = path;
      if (adf.FEATURE_ROOT != null)
      {
         result = adf.FEATURE_ROOT + "/public_html";
         if ((path != null) && (path.length > 0) && (path.charAt(0) != "/"))
         {
            result = result + "/";
         }
         result = result + path;
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/Util.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ActivityLogic = ActivityLogic;
   ActivityLogic.sImplementations = {};
   function ActivityLogic()
   {
   }
   
   ActivityLogic.getImplementation = function(type)
   {
      var result = this.sImplementations[type];
      if (!result)
      {
         if (type == adfc.internal.ActivityType.VIEW)
         {
            result = new adfc.internal.ViewActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.VIEW] = result;
         }
         else if (type == adfc.internal.ActivityType.ROUTER)
         {
            result = new adfc.internal.RouterActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.ROUTER] = result;
         }
         else if (type == adfc.internal.ActivityType.METHOD_CALL)
         {
            result = new adfc.internal.MethodCallActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.METHOD_CALL] = result;
         }
         else if (type == adfc.internal.ActivityType.TASK_FLOW_CALL)
         {
            result = new adfc.internal.TaskFlowCallActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.TASK_FLOW_CALL] = result;
         }
         else if (type == adfc.internal.ActivityType.TASK_FLOW_RETURN)
         {
            result = new adfc.internal.TaskFlowReturnActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.TASK_FLOW_RETURN] = result;
         }
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/LogUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.LogUtil = LogUtil;
   
   adfc.internal.LogUtil.UseMockLog = (typeof adf === "undefined") || 
                                      (typeof adf.mf === "undefined") || 
                                      (typeof adf.mf.log === "undefined") || 
                                      (typeof adf.mf.log.Framework === "undefined");
   
   function LogUtil()
   {}
   
   LogUtil.LOG_LEVEL_FINE     =  0;
   LogUtil.LOG_LEVEL_INFO     =  1;
   LogUtil.LOG_LEVEL_WARNING  =  2;
   LogUtil.LOG_LEVEL_SEVERE   =  3;

   if (!adfc.internal.LogUtil.UseMockLog)
   {
      LogUtil.LOG_LEVEL_FINE     = adf.mf.log.level.FINE;
      LogUtil.LOG_LEVEL_INFO     = adf.mf.log.level.INFO;
      LogUtil.LOG_LEVEL_WARNING  = adf.mf.log.level.WARNING;
      LogUtil.LOG_LEVEL_SEVERE   = adf.mf.log.level.SEVERE;
   }
   
   LogUtil.currentMockLogLevel = LogUtil.LOG_LEVEL_FINE;
   
   LogUtil.severe = function(message) 
   {
      LogUtil.output("SEVERE", LogUtil.LOG_LEVEL_SEVERE, message);
   }
   
   LogUtil.warning = function(message) 
   {
      LogUtil.output("WARNING", LogUtil.LOG_LEVEL_WARNING, message);
   }
   
   LogUtil.info = function(message) 
   {
      LogUtil.output("INFO", LogUtil.LOG_LEVEL_INFO, message);
   }
   
   LogUtil.fine = function(message) 
   {
      LogUtil.output("FINE", LogUtil.LOG_LEVEL_FINE, message);
   }
   
   LogUtil.showAlert = function(message)
   {
      if (message != null)
      {
         alert(message);
      }
   }
   
   LogUtil.output = function(prefix, level, message)
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          if ((message != null) && (level >= LogUtil.currentMockLogLevel))
          {
             var text = "[ADFc:" + prefix + "] " + LogUtil.formatMessage(message);
             console.log(text);
          }
       }
       else
       {
          var label = "ADFc";
          if (level == LogUtil.LOG_LEVEL_FINE)
          {
             label = "==== ADFc DEBUG ====";
          }
          adf.mf.log.Framework.logp(level, label, "--", message);
       }
   }

   LogUtil.formatMessage = function(message) 
   {
      var text = message;
      if (!(text instanceof String))
      {
        text = new String(message);
      }
      if (text.indexOf("ADFc:") != 0)
      {
        text = "ADFc: " + text;
      }
      return text;
   }
   
   LogUtil.perfLog = function(message)
   {
      if (!adfc.internal.LogUtil.UseMockLog)
      {
         adf.mf.internal.perf.perfTimings(false, false, true, message);
      }
   }
   
   LogUtil.isSevere = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_SEVERE);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_SEVERE);
       }
   }
   
   LogUtil.isWarning = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_WARNING);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_WARNING);
       }
   }
   
   LogUtil.isInfo = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_INFO);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_INFO);
       }
   }
   
   LogUtil.isFine = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_FINE);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_FINE);
       }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/LogUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/MsgUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    *  Central location for getting localized text strings.
    */
   adfc.internal.MsgUtil = MsgUtil;
   function MsgUtil()
   {}
   MsgUtil.messages = {};
   
   MsgUtil.getLocalizedText = function(msgId)
   {
      var msg = "<bad message ID>";
      if (typeof MsgUtil.messages[msgId] !== "undefined")
      {
         msg = MsgUtil.messages[msgId];
      }
      return msg;
   }
   
   MsgUtil.NO_FEATURE_ENTRY_POINT = 0;
   MsgUtil.messages[MsgUtil.NO_FEATURE_ENTRY_POINT] = "no feature entry point path found on URL";
   

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/MsgUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/TaskFlowIdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.TaskFlowIdUtil = TaskFlowIdUtil;

   function TaskFlowIdUtil()
   {}
   
   TaskFlowIdUtil.parseTaskFlowId = function(taskFlowIdString)
   {
      if (taskFlowIdString && (taskFlowIdString != null))
      {
         var taskFlowId = adfc.internal.TaskFlowId.parse(taskFlowIdString);
         if (taskFlowId && (taskFlowId != null))
         {
            return taskFlowId;
         }
      }
      return null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/TaskFlowIdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/RoutingState.js///////////////////////////////////////

/**
*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.RoutingState = RoutingState;
   function RoutingState(startingTfInstanceId, startingViewId, currentActivityId, currentOutcome)
   {
      this.mStartingTfInstanceId = startingTfInstanceId;
      this.mStartingViewId = startingViewId;
      this.mStartingActivityId = currentActivityId;
      this.mCurrentActivityId = currentActivityId;
      this.mCurrentOutcome = currentOutcome;
      this.mNextActivityId = null;
      this.mRoutingComplete = false;
      this.mViewReached = false;
      this.mBackNavigation = false;
      this.mTaskFlowReturnExecuted = false;
      this.mTransition = null;
      this.mControlFlowCase = null;
      this.mTriedCfRules = {};
      
      this.mNavigationResult = null;
      
      this.mRoutingSuccessCallback = null;
      this.mRoutingFailedCallback = null;
      this.mFindCfCaseCallback = null;
      
      this.mBackNavTfPopped = false;  //  If back nav out of a TF has the TF been popped yet?
      this.mBackNavTfLeftViewItem = null;  //  If back nav out of a TF the view item being left.
      
      this.mLastReturnedFromTfEntry = null;  // Stack entry popped during the last TF return activity.
   }

   RoutingState.prototype.getStartingTaskFlowInstanceId = function()
   {
      return this.mStartingTfInstanceId;
   }
   
   RoutingState.prototype.getStartingViewId = function()
   {
      return this.mStartingViewId;
   }
   
   RoutingState.prototype.getStartingActivityId = function()
   {
      return this.mStartingActivityId;
   }
   
   RoutingState.prototype.getCurrentActivityId = function()
   {
      return this.mCurrentActivityId;
   }
   
   RoutingState.prototype.setCurrentActivityId = function(activityId)
   {
      this.mCurrentActivityId = activityId;
   }
   
   RoutingState.prototype.getCurrentOutcome = function()
   {
      return this.mCurrentOutcome;
   }
   
   RoutingState.prototype.setCurrentOutcome = function(outcome)
   {
      this.mCurrentOutcome = outcome;
   }
   
   RoutingState.prototype.getNextActivityId = function()
   {
      return this.mNextActivityId;
   }
   
   RoutingState.prototype.setNextActivityId = function(activityId)
   {
      this.mNextActivityId = activityId;
   }
   
   RoutingState.prototype.isRoutingComplete = function()
   {
      return this.mRoutingComplete;
   }
   
   RoutingState.prototype.setRoutingComplete = function(value)
   {
      this.mRoutingComplete = value;
   }
   
   RoutingState.prototype.isViewReached = function()
   {
      return this.mViewReached;
   }
   
   RoutingState.prototype.setViewReached = function(value)
   {
      this.mViewReached = value;
   }
   
   RoutingState.prototype.setNavigationResult = function(result)
   {
      this.mNavigationResult = result;
   }
   
   RoutingState.prototype.getNavigationResult = function()
   {
      return this.mNavigationResult;
   }
   
   RoutingState.prototype.setRoutingSuccessCallback = function(callback)
   {
      this.mRoutingSuccessCallback = callback;
   }
   
   RoutingState.prototype.getRoutingSuccessCallback = function()
   {
      return this.mRoutingSuccessCallback;
   }
   
   RoutingState.prototype.setRoutingFailedCallback = function(callback)
   {
      this.mRoutingFailedCallback = callback;
   }
   
   RoutingState.prototype.getRoutingFailedCallback = function()
   {
      return this.mRoutingFailedCallback;
   }
   
   RoutingState.prototype.setBackNavigation = function(value)
   {
      this.mBackNavigation = value;
   }
   
   RoutingState.prototype.getBackNavigation = function()
   {
      return this.mBackNavigation;
   }
   
   RoutingState.prototype.setTaskFlowReturnExecuted = function(value) 
   {
      this.mTaskFlowReturnExecuted = value;
   }
   
   RoutingState.prototype.isTaskFlowReturnExecuted = function() 
   {
      return this.mTaskFlowReturnExecuted;
   }
   
   RoutingState.prototype.setTransition = function(value) 
   {
      this.mTransition = value;
   }
   
   RoutingState.prototype.getTransition = function() 
   {
      return this.mTransition;
   }
   
   RoutingState.prototype.setFindCfCaseCallback = function(callback) 
   {
      this.mFindCfCaseCallback = callback;
   }
   
   RoutingState.prototype.getFindCfCaseCallback = function() 
   {
      return this.mFindCfCaseCallback;
   }
   
   RoutingState.prototype.setControlFlowCase = function(cfCase) 
   {
      this.mControlFlowCase = cfCase;
   }
   
   RoutingState.prototype.getControlFlowCase = function() 
   {
      return this.mControlFlowCase;
   }
   
   RoutingState.prototype.getTriedCfRules = function() 
   {
      return this.mTriedCfRules;
   }

   RoutingState.prototype.isBackNavTfPopped = function() 
   {
      return this.mBackNavTfPopped;
   }

   RoutingState.prototype.setBackNavTfPopped = function(value) 
   {
      this.mBackNavTfPopped = value;
   }

   RoutingState.prototype.setBackNavTfLeftViewItem = function(item) 
   {
      this.mBackNavTfLeftViewItem = item;
   }
   
   RoutingState.prototype.getBackNavTfLeftViewItem = function() 
   {
      return this.mBackNavTfLeftViewItem;
   }

   RoutingState.prototype.setLastReturnedFromTfEntry = function(entry) 
   {
      this.mLastReturnedFromTfEntry = entry;
   }
   
   RoutingState.prototype.getLastReturnedFromTfEntry = function() 
   {
      return this.mLastReturnedFromTfEntry;
   }

   /**
    * Reset the routing state before control flow rule evaluation.
    */
   RoutingState.prototype.resetCfRuleEvaluation = function() 
   {
      this.mTriedCfRules = {};
      this.mControlFlowCase = null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/RoutingState.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a method-call activity.
    */
   adfc.internal.MethodCallActivity = MethodCallActivity;
   function MethodCallActivity(id, methodEl, defaultOutcome, convertToString, params, returnValue)
   {
      this.mActivityId = id;
      this.mMethodElExpression = methodEl;
      this.mDefaultOutcome = defaultOutcome;
      this.mConvertToString = convertToString;
      this.mParameters = params;
      this.mReturnValue = returnValue;
   }
  
   MethodCallActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.METHOD_CALL;
   }
  
   MethodCallActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   MethodCallActivity.prototype.getMethodElExpression = function()
   {
      return this.mMethodElExpression;
   }
   
   MethodCallActivity.prototype.getDefaultOutcome = function()
   {
      return this.mDefaultOutcome;
   }
   
   MethodCallActivity.prototype.isConvertToString = function()
   {
      return this.mConvertToString;
   }
   
   MethodCallActivity.prototype.getParameters = function()
   {
      return this.mParameters;
   }
   
   MethodCallActivity.prototype.getReturnValue = function()
   {
      return this.mReturnValue;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ControllerState.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ControllerState = ControllerState;
   function ControllerState()
   {
      this.mTaskFlowStack = new Array();
   }

   ControllerState.prototype.getTaskFlowStackSize = function()
   {
      var result = this.mTaskFlowStack.length;
      return result;
   }

   ControllerState.prototype.peekTaskFlowStack = function()
   {
      var result = this.mTaskFlowStack[this.mTaskFlowStack.length-1];
      return result;
   }

   ControllerState.prototype.pushTaskFlow = function(taskFlow, taskFlowCallActivity, callingViewActivityId, successCallback, failCallback)
   {
      var pushScopeSuccess = function()
      {
        var updateBeanDefsSuccess = function()
        {
          if (adfc.internal.LogUtil.isFine())
          {
             var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
             currentTaskFlowEntry.getTaskFlowDefinition(
               function(taskFlowDef)
               {
                 var tfId = taskFlowDef.getTaskFlowId();
                 var instanceId = currentTaskFlowEntry.getInstanceId();
                 var msg = "ADFc: pushed task flow, taskFlowId=" + tfId + ", instanceId=" + instanceId;
                 adfc.internal.LogUtil.fine(msg);
               });
          }
          successCallback();
        }

        var updateBeanDefsFailed = function(message)
        {
          var msg = "Failed to set managed bean definitions.";
          adfc.internal.LogUtil.severe(msg);
          adfc.internal.LogUtil.showAlert(msg);
          failCallback(message);
        }

        var controllerState = adfc.internal.AdfcContext.getControllerState();
        controllerState.mTaskFlowStack.push(new adfc.internal.TaskFlowStackEntry(taskFlow.getTaskFlowId(), taskFlowCallActivity, callingViewActivityId, 
                                            pushPageFlowScope, pushDataControlContext));
        controllerState.updateBeanDefinitions(updateBeanDefsSuccess, updateBeanDefsFailed);
      }

      var pushPageFlowScope = (taskFlow.getPageFlowScopeBehavior() == adfc.internal.TaskFlowDefinition.PUSH_NEW);
      var pushDataControlContext = ((taskFlowCallActivity != null) && 
                                    adfc.internal.TaskFlowCallActivityLogic.isDataControlContextIsolated(taskFlowCallActivity, failCallback));
                                    
      adfc.internal.ElUtil.pushScopesIfNeeded(pushPageFlowScope, pushDataControlContext, pushScopeSuccess, failCallback);
   };

   ControllerState.prototype.popTaskFlow = function(successCallback, failCallback)
   {
      var controllerState = adfc.internal.AdfcContext.getControllerState();
      var tfStackEntry = null;

      var popScopeSuccess = function()
      {
         var updateBeanDefsSuccess = function()
         {
            if (adfc.internal.LogUtil.isFine())
            {
              tfStackEntry.getTaskFlowDefinition(
               function(taskFlowDef)
               {
                 var tfId = taskFlowDef.getTaskFlowId();
                 var instanceId = tfStackEntry.getInstanceId();
                 var msg = "ADFc: popped task flow, taskFlowId=" + tfId + ", instanceId=" + instanceId;
                 adfc.internal.LogUtil.fine(msg);
               });
            }
            tfStackEntry.clearViewHistory();
            successCallback(tfStackEntry);
         }
         var updateBeanDefsFailed = function(message)
         {
            var msg = "Failed to set managed bean definitions.";
            adfc.internal.LogUtil.severe(msg);
            adfc.internal.LogUtil.showAlert(msg);
            failCallback(message);
         }

         tfStackEntry = controllerState.mTaskFlowStack.pop();
         controllerState.updateBeanDefinitions(updateBeanDefsSuccess, updateBeanDefsFailed);
      }

      var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
      var popPageFlowScope = currentTaskFlowEntry.shouldPopPageFlowScope();
      var popDataControlContext = currentTaskFlowEntry.shouldPopDataControlContext();
                                    
      adfc.internal.ElUtil.popScopesIfNeeded(popPageFlowScope, popDataControlContext, popScopeSuccess, failCallback);
   };

  ControllerState.prototype.updateBeanDefinitions = function(successCallback, failCallback)
  {
    if (this.mTaskFlowStack.length > 1)
    {
      //
      //  If there's more than one task flow on the stack then we want to get
      //  the application scoped bean definitions from the unbounded flow
      //  and then add in the definitions from the current top of the stack.
      //
      var beanDefs = new Array();
      var controllerState = this;
      this.mTaskFlowStack[0].getTaskFlowDefinition(
        function(unboundedTaskFlowDef)
        {
          var unboundedBeans = unboundedTaskFlowDef.getBeanDefinitions();
          for (var i = 0; i < unboundedBeans.length; i++)
          {
            if (unboundedBeans[i].getBeanScope() == adfc.internal.ManagedBeanDefinition.APPLICATION)
            {
              beanDefs.push(unboundedBeans[i]);
            }
          }

          //
          //  Add in the bean definitions from the current top of stack.
          //
          controllerState.mTaskFlowStack[controllerState.mTaskFlowStack.length-1].getTaskFlowDefinition(
            function(topTaskFlowDef)
            {
              var tfBeans = topTaskFlowDef.getBeanDefinitions();
              beanDefs = beanDefs.concat(tfBeans);
              ControllerState._updateBeanDefinitionsPhase2(
                beanDefs,
                successCallback,
                failCallback);
            });
        });
    }
    else if (this.mTaskFlowStack.length == 1)
    {
      this.mTaskFlowStack[0].getTaskFlowDefinition(
        function(taskFlowDef)
        {
          ControllerState._updateBeanDefinitionsPhase2(
            taskFlowDef.getBeanDefinitions(),
            successCallback,
            failCallback);
        });
    }
    else
    {
      ControllerState._updateBeanDefinitionsPhase2(
        new Array(),
        successCallback,
        failCallback);
    }
  };

  ControllerState._updateBeanDefinitionsPhase2 = function(beanDefs, successCallback, failCallback)
  {
    var setBeanDefsSuccess = function()
    {
      successCallback();
    }

    var setBeanDefsFailed = function(message)
    {
      failCallback(message);
    }

    adfc.internal.ElUtil.setBeanDefinitions(beanDefs, setBeanDefsSuccess, setBeanDefsFailed);
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ControllerState.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ViewHistoryItem.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewHistoryItem = ViewHistoryItem;
   function ViewHistoryItem(viewId, amxPage, transType)
   {
      this.itemId = adfc.internal.IdUtil.uuid(); // Unique item ID.
      this.viewId = viewId;
      this.amxPage = amxPage;
      this.transitionType = transType;
      this.mBackNavIsValid = true;    // To signal cases where back navigation is not valid.
   }
   
   ViewHistoryItem.prototype.isBackNavigationValid = function()
   {
      return this.mBackNavIsValid;
   }
   
   ViewHistoryItem.prototype.setBackNavigationValid = function(value)
   {
      this.mBackNavIsValid = value;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ViewHistoryItem.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/SystemUtil.js///////////////////////////////////////

/*
* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.SystemUtil = SystemUtil;
   function SystemUtil()
   {}
   
   /**
    * Hides the loading indicator
    */
   SystemUtil.hideLoadingIndicator = function()
   {
      adf.mf.api.amx.hideLoadingIndicator();
   };
   
   /**
    * Optionally performs platform-specific system back action handling
    *
    * @returns true if the action was handled, false otherwise
    */
   SystemUtil.onBackUnhandled = function()
   {
      if (adf.mf.internal.amx.agent["type"] == "Android")
      {
        if (window && window["AdfmfCallback"])
        {
          window.AdfmfCallback.onBackUnhandled();
          return true;
        }
      }
      
      return false;
   };
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/SystemUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallActivity.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */
 
if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-call activity.
    */
   adfc.internal.TaskFlowCallActivity = TaskFlowCallActivity;
   function TaskFlowCallActivity(id, taskFlowReference, dynamicTaskFlowIdElExpression, inputParams, inputParamMapElExpression, returnValues, beforeListener, afterListener, dcContext)
   {
      this.mActivityId = id;
      this.mTaskFlowReference = taskFlowReference;
      this.mDynamicTaskFlowIdElExpression = dynamicTaskFlowIdElExpression;
      this.mIsDynamic = dynamicTaskFlowIdElExpression != null;
      this.mInputParameters = inputParams;
      this.mInputParameterMapElExpression = inputParamMapElExpression;
      this.mReturnValues = returnValues;
      this.mBeforeListener = beforeListener;
      this.mAfterListener = afterListener;
      this.mDCContext = dcContext;
   }
    
   TaskFlowCallActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.TASK_FLOW_CALL;
   }
    
   TaskFlowCallActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   TaskFlowCallActivity.prototype.getTaskFlowReference = function() 
   {
      return this.mTaskFlowReference;
   }
   
   TaskFlowCallActivity.prototype.isDynamic = function() 
   {
      return this.mIsDynamic;
   }
   
   TaskFlowCallActivity.prototype.getDynamicTaskFlowIdElExpression = function() 
   {
      return this.mDynamicTaskFlowIdElExpression;
   }
   
   TaskFlowCallActivity.prototype.getInputParameters = function() 
   {
      return this.mInputParameters;
   }
   
   TaskFlowCallActivity.prototype.getInputParameterMapElExpression = function() 
   {
      return this.mInputParameterMapElExpression;
   }
   
   TaskFlowCallActivity.prototype.getReturnValues = function()
   {
      return this.mReturnValues;
   }
   
   TaskFlowCallActivity.prototype.getBeforeListener = function()
   {
      return this.mBeforeListener;
   }
   
   TaskFlowCallActivity.prototype.getAfterListener = function()
   {
      return this.mAfterListener;
   }
   
   TaskFlowCallActivity.prototype.getDataControlContextType = function()
   {
      return this.mDCContext;
   }
   
})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterCase.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a router activity case.
    */
   adfc.internal.RouterCase = RouterCase;
   function RouterCase(expression, outcome)
   {
      this.mExpression = expression;
      this.mOutcome = outcome;
   }

   RouterCase.prototype.getExpression = function()
   {
      return this.mExpression;
   }
  
   RouterCase.prototype.getOutcome = function()
   {
      return this.mOutcome;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterCase.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------------- */
/* ------------------- base-controller.js ---------------------- */
/* ------------------------------------------------------------- */

// ===========================================================================
// ======= Any touching of this file must have architectural approval. =======
// ===========================================================================

// Let the controller know about the feature root (since adfc-mobile.js re-initializes it to false):
//adf.FEATURE_ROOT =

// Let the controller know about the DT mode (since adfc-mobile.js re-initializes it to false):
adf.AMX_DTMODE = adf.mf.environment.profile.dtMode;

// Initialize the Trinidad library.
if (!adf.mf.environment.profile.dtMode)
{
  // TODO should this be skipped for mock mode too?
  adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
    "base-controller.js", "init", "Loading trinidad lib");

  if (adf.mf.environment.profile.messageBundleBaseUrl != null)
    adf.mf.api.amx.loadTrinidadResources(adf.mf.environment.profile.messageBundleBaseUrl); // defined in amx-resource.js
  else
    adf.mf.api.amx.loadTrinidadResources("js"); // defined in amx-resource.js
}

// PRIVATE FUNCTION USED ONLY BY THIS FILE
function getFeatureRoot()
{
  var queryString = adf.mf.api.getQueryString();
  var featureRoot = adfc.internal.UrlUtil.getFeatureRoot(queryString);
  adf.FEATURE_ROOT = featureRoot; // this variable is used by adfc-mobile.js
  if (featureRoot == null)
  {
    adfc.internal.LogUtil.fine("no feature root specified");
  }
  else
  {
    adfc.internal.LogUtil.fine("using feature root of: " + featureRoot);
  }
}

// PRIVATE FUNCTION USED ONLY BY THIS FILE
function getEntryPointDocumentPath()
{
  var queryString = adf.mf.api.getQueryString();
  var path = adfc.internal.UrlUtil.getEntryPointDocumentPath(queryString);
  if (path == null)
  {
    var msg = adfc.internal.MsgUtil.getLocalizedText(adfc.internal.MsgUtil.NO_FEATURE_ENTRY_POINT);
    adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(msg));
    throw new Error(msg);
  }
  return path;
}

// PRIVATE FUNCTION USED ONLY BY base-core.js
adf.mf.internal.api.showFirstAmxPage = function()
{
  adfc.internal.LogUtil.fine("BEGIN: showFirstAmxPage()");

  adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
    "adf.mf.internal.api", "showFirstAmxPage", "document ready event received");
  adfc.internal.LogUtil.fine("document.ready event received");

  // Get the feature root from the URL if there's one there.
  getFeatureRoot();

  var AdfcContextInitSuccess = function()
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.api", "showFirstAmxPage", "END: initialize AdfcContext");

     // Get the entry point document.
     var entryDocPath = getEntryPointDocumentPath();
     adfc.internal.LogUtil.fine("entryDocPath=" + entryDocPath);

     // Get the initial view to display.
     var request = {};
     request.entryPoint = entryDocPath;
     var navigationSuccess = function(req, response)
     {
       adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "END: determine first viewId");
       if (response.isNewViewId())
       {
         var amxPage = response.getVdlDocumentPath();
         var displayAmxDone = function()
         {
           adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
             "adf.mf.internal.api", "showFirstAmxPage", "END: display first AMX page");
         };
         adfc.internal.LogUtil.fine("displaying initial view, page=" + amxPage);

         adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
           "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: display firxt AMX page");
         adf.mf.api.amx.displayAmxPage(amxPage).then(displayAmxDone);
       }
       else
       {
         var msg = "failed to determine initial view to display";
         adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(msg));
         throw new Error(msg);
       }
     };

     var navigationFailed = function (req, message)
     {
       adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(message));
       throw new Error(message);
     };

     if (!adf.mf.environment.profile.dtMode)
     {
       adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: determine first viewId");
       adfc.NavigationHandler.getInitialViewId(request, navigationSuccess, navigationFailed);
     }
     else
     {
       // AMX DT mode.
       var navResponse = new adfc.NavigationResult(true, false, entryDocPath, entryDocPath, "", false, true);
       navigationSuccess(request, navResponse);
     }
  }; // End AdfcContextInitSuccess() callback function

  var AdfcContextInitFailed = function(message)
  {
    adfc.internal.LogUtil.showAlert("Failed to initialize the AdfcContext: " + adf.mf.internal.log.getStringifedIfNeeded(message));
  }

  // Load the bootstrap metadata.
  try
  {
    if (!adf.mf.environment.profile.dtMode)
    {
      // Not design-time mode.
      adfc.internal.LogUtil.fine("initializing the AdfcContext ...");
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: initialize AdfcContext");
      adfc.internal.AdfcContext.initialize(AdfcContextInitSuccess, AdfcContextInitFailed);
    }
    else
    {
      // We're running in design-time mode.
      AdfcContextInitSuccess();
    }
  }
  catch (exp)
  {
    adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(exp.message));
    throw exp;
  }
} // End of showFirstAmxPage() function.
/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

// Flag used by partial page rendering and the back issue
// to indicate whether or not we need to restore the saved inline scripts.
var _pprBackRestoreInlineScripts = false;

// _pprBlocking is true if we're blocked waiting on a PPR event
var _pprBlocking = false;

// ER 4014884: block on every submit if requested.
var _blockOnEverySubmit = false;

// Controls whether or not Trinidad will allow the first click to go through in
// certain instances. When a PPR event occurs, we block all subsequent user
// input until it completes. However, there may be instances where the client
// wants to receive the very first click. For example, If the user has entered
// text in a textInput field with autoSubmit attached, then
// immediately clicked a submit button two events will be triggered - an
// onChange followed by an onClick. The onChange will trigger the autoSubmit
// which will immediately start the PPR blocking, so the onClick will get
// consumed by the blocking code and no submit will occur. Setting this value
// to true will allow the click to go through. This value can be controlled by
// the firstClickPassed attribute on the body element.
// TODO: Because PPR is now queued, is this still relevant?
var _pprFirstClickPass = false;

// We block using a special DIV element. This is its name
var _pprdivElementName = 'tr_pprBlockingDiv';

// stores the variables needed to load the libraries for IE
var _pprLibStore;


// The time at which we started the latest PPR block
var _pprBlockStartTime = 0;


// A holder for the pending timeout (Gecko only).
var _pprBlockingTimeout = null;

// Keeps track of the last element to initiate a PPR request
var _pprEventElement = null;

// We block input while a PPR request is in transit.
// _pprSavedCursor holds the cursor that the client had before the PPR event
// and _pprSavedCursorFlag keeps track of if we set _pprSavedCursor.
// var _pprSavedCursor = null;
var _pprSavedCursorFlag = false;

// Keeps track of whether the user has actually made a choice from the popup
var _pprChoiceChanged = false;


// Object containing information about the user agent
var _agent = new Object();

// Object for the last time we submitted
var _lastDateSubmitted;

// Object for the last time we reset a form
var _lastDateReset = 0;

// Variables tracking the last time we validated a field, and the last time the
// validation actually failed.
var _lastDateValidated  = 0;
var _lastValidationFailure  = 0;


// Keeps track of arguments that will be needed for a delayed event
var _delayedEventParams = new Object();

// this is the id of the component which gets the initial focus when the
// page loads.
var _initialFocusID = null;

// Certain Trinidad facilities can request that focus be set to a particular node,
// or the node AFTER a particular node following a PPR update. These three
// variables store the values needed to track down that node.
var _TrFocusRequestDoc = null;
var _TrFocusRequestID = null;
var _TrFocusRequestNext = false;

// Flag to indicate if inline validation is event based.
var _TrEventBasedValidation = false;

// _checkUnload is set on our body tag and is called when the window
// unloads. In our dialog windows, we call _checkUnload via an intermediary
// function _unloadADFDialog to work around Google's pop-up blocker
// feature which blocks onUnload event handlers from window's opened
// with window.open.
// We don't want to call _checkUnload twice in a row,
// once from dialog code and once from body's onUnload event handler,
// so we block the second call in _unloadADFDialog.
var _blockCheckUnloadFromDialog = false;


// variables needed if _submitForm was called before the form had
// completely rendered.
var _saveForm = null;
var _saveDoValidate = null;
var _saveParameters = null;
var _submitRejected = false;
var _inPartialSubmit = false;

// Flag used for timing issues with radioButtons
var _pendingRadioButton = false;

// List of mouse event names to capture
var _IE_MOUSE_CAPTURE_EVENTS = [
  "onclick",
  "ondblclick",
  "onmousedown",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup"
  ];

// List of mouse event names to capture
var _GECKO_MOUSE_CAPTURE_EVENTS = [
  "click",
  "mousedown",
  "mouseup",
  "mouseover",
  "mousemove",
  "mouseout",
  "contextmenu"
  ];

/**
 * Return true if the agent is at least the specified agent type and version.
 */
function _atLeast(
  kind,
  version
  )
{
  return (!kind    || (kind    == _agent.kind))    &&
         (!version || (version <= _agent.version));
}


/**
 * Return true if the agent is at most the specified agent type and version.
 */
function _atMost(
  kind,
  version
  )
{
  return (kind == _agent.kind) && (version >= _agent.version);
}

function _supportsDOM()
{
  var retVal = false;

  if (_agent.isIE)
  {
    retVal = _agent.version >= 5.5;
  }
  else if (_agent.isNav)
  {
    retVal = false;
  }
  else if (_agent.isGecko || _agent.isSafari || _agent.isOpera)
  {
    retVal = true;
  }
  else if(_agent.isBlackBerry)
  {
    retVal = false;
    retVal = _agent.version >= 4.6;
  }

  return retVal;
}

/**
 * initialize information about the agent
 */
function _agentInit()
{
  // convert all characters to lowercase to simplify testing
  var agentString = navigator.userAgent.toLowerCase();

  // note that this only returns m.n (e.g. if the
  // version number is 2.3.4, this returns the float 2.3)
  var version = parseFloat(navigator.appVersion);

  // note that isBlackBerry refers to the BlackBerry browser
  // we do not currently specify the BlackBerry platform
  // because it is not necessary (if we decide to support
  // other browsers on the BlackBerry platform it may become necessary)
  var isBlackBerry      = false;
  var isGecko           = false;
  var isIE              = false;
  var isMac             = false;
  var isNav             = false;
  var isOpera           = false;
  var isPIE             = false;
  var isSafari          = false;
  var isSolaris         = false;
  var isWindows         = false;
  var isWindowsMobile6  = false;
  var isNokiaPhone      = false;
  var kind              = "unknown";

  // Group IE and IE based browsers such as IE Mobile on WM5 and WM6
  var isIEGroup         = false;

  // Indicate browser's PPR capability support
  var pprUnsupported    = false;

  // Indicate whether the browser and platform are capable of
  // sending PPR requests via JSF Ajax
  var useJsfAjax = true;

  // Flag to indicate that document object is sufficiently implemented to
  // provide good level of access to HTML, XHTML and XML document.
  // For example, Windows Mobile 5 and Blackberry does not implement
  // document.body, document.forms or document.documentElement and this
  // flag is set to false. Some features implemented in Core.js and
  // Page.js are not executed for the browsers when it is set to false.
  var supportsDomDocument = true;

  // Identifies browsers that do not support node.nodeType
  var supportsNodeType    = true;

  // Indicate browser's validation capability support
  var supportsValidation  = true;

  if (agentString.indexOf("msie") != -1)
  {
    // extract ie's version from the ie string
    var matches = agentString.match(/msie (.*);/);
    version = parseFloat(matches[1]);
    isIEGroup = true;

    // All IE based mobile browsers
    if (agentString.indexOf("windows ce") != -1)
    {
      supportsNodeType = false;
      supportsDomDocument = false;
      supportsValidation = false;

      // PPC200X and Windows Mobile 5
      if (agentString.indexOf("ppc") != -1 &&
          version >= 4.0)
      {
        // This user agent indicates the browser is WindowsMobile 5 or
        // earlier version of PIE
        isPIE = true;

        // Windows Mobile 5 DOM and XMLHttpRequest support are not
        // sufficient to support PPR in this framework effectively.
        pprUnsupported = true;
        kind = "pie";
      }
      else
      {
        // This user agent indicates the browser is WindowsMobile 6 PIE
        isWindowsMobile6 = true;
        // A new kind string was given to WM6 browser as the
        // capability is significantly different from predecessors.
        kind = "iemobile";
        // Switch off JSF ajax for time being. There are still unresolved
        // issues with Mojarra in supporting mobile-browsers
        useJsfAjax = false;
      }
    }
    else
    {
      isIE = true;
      kind = "ie";
    }
  }
  else if (agentString.indexOf("opera") != -1)
  {
    isOpera = true;
    kind = "opera";
  }
  else if ((agentString.indexOf("applewebkit") != -1) ||
           (agentString.indexOf("safari") != -1))
  {
    isSafari = true
    kind = "safari";
  }
  else if (agentString.indexOf("gecko/") != -1)
  {
    isGecko = true;
    kind = "gecko";
    version = 1.0;
  }
  else if(agentString.indexOf("blackberry") != -1)
  {
    // if we support non-BlackBerry Browser agents on blackberry
    // devices in the future, we may need to revisit this because
    // those agents may include "blackberry" in the User-Agent
    // string; we can't just check if the User-Agent "starts with"
    // blackberry because navigator.userAgent on BlackBery Browser 4.0
    // starts with Mozilla/4.0 (even though the User-Agent sent to the
    // server starts with BlackBerry<model>/<version>)

    // BlackBerry Browser 4.0+ supports navigator.appVersion,
    // and earlier versions don't support script, so we can
    // leave the version as defined above

    // BlackBerryXXXX/Y.Y.Y.Y is the BlackBerry user agent format
    // XXXX is the model number and Y.Y.Y.Y is the OS version number.
    // At this moment, BlackBerry below version 4.6 is regarded as
    // basic HTML browser for the JS performance reason.
    // The following lines should be uncommented when we decide to
    // handle BlackBerry version 4.0~4.5 separate from the batch of
    // Basic HTML browsers after its JS performance improves.
    /*
    var versionStart = agentString.substring(agentString.indexOf(
                                                      "blackberry") + 9);
    versionStart = versionStart.substring(versionStart.indexOf("/") + 1);
    version = parseFloat(versionStart);

    if (version < 4.6)
    {
      pprUnsupported = true;
      supportsDomDocument = false;
      supportsValidation = false;
    }
    */

    isBlackBerry = true;
    kind = "blackberry";
    // Switch off the JSF ajax for time being. There are still unresolved
    // issues with Mojarra in supporting mobile browsers
    useJsfAjax = false;
  }
  else if ((agentString.indexOf('mozilla')    != -1) &&
           (agentString.indexOf('spoofer')    == -1) &&
           (agentString.indexOf('compatible') == -1))
  {
    if (version >= 5.0)
    {
      isGecko = true;
      kind = "gecko";
      version = 1.0;
    }
    else
    {
      isNav = true;
      kind = "nn";
    }
  }
  if (agentString.indexOf('win') != -1)
  {
    isWindows = true;
  }
  else if (agentString.indexOf('mac') != -1)
  {
    isMac = true;
  }
  else if (agentString.indexOf('sunos') != -1)
  {
    isSolaris = true;
  }
  else if ((agentString.indexOf('symbian') != -1) ||
           (agentString.indexOf('nokia') != -1))
  {
     isNokiaPhone = true;
     pprUnsupported = true;
  }

  _agent.isBlackBerry           = isBlackBerry;
  _agent.isGecko                = isGecko;
  _agent.isIE                   = isIE;
  _agent.isIEGroup              = isIEGroup;
  _agent.isMac                  = isMac;
  _agent.isNav                  = isNav;
  _agent.isNokiaPhone           = isNokiaPhone;
  _agent.isOpera                = isOpera;
  _agent.isPIE                  = isPIE;
  _agent.isSafari               = isSafari;
  _agent.isSolaris              = isSolaris;
  _agent.isWindows              = isWindows;
  _agent.isWindowsMobile6       = isWindowsMobile6;
  _agent.kind                   = kind;
  _agent.pprUnsupported         = pprUnsupported;
  _agent.useJsfAjax             = useJsfAjax;
  _agent.supportsDomDocument    = supportsDomDocument;
  _agent.supportsNodeType       = supportsNodeType;
  _agent.supportsValidation     = supportsValidation;
  _agent.version                = version;

  _agent.atLeast                = _atLeast;
  _agent.atMost                 = _atMost;
}


_agentInit();

// available features in ie
var _ieFeatures =
{
  channelmode:1, // ie 5.0
  copyhistory:1,
  directories:1,
  fullscreen:1,  // ie 5.0
  height:1,
  location:1,
  menubar:1,
  resizable:1,
  scrollbars:1,
  status:1,
  titlebar:1,    // ie 5.0 when trusted
  toolbar:1,
  width:1
};

// available features in Netscape
var _nnFeatures =
{
  alwayslowered:1,
  alwaysraised:1,
  copyhistory:1,
  dependent:1,
  directories:1,
  height:1,
  hotkeys:1,
  innerheight:1,
  innerwidth:1,
  location:1,
  menubar:1,
  outerwidth:1,
  outerheight:1,
  resizable:1,
  scrollbars:1,
  status:1,
  titlebar:1,
  toolbar:1,
  width:1,
  "z-lock":1
}

// override values for modeless windows. Values in this
// list can't be overridden by the caller for modeless windows
var _modelessFeatureOverrides =
{
};

// override values for modal windows. Values in this
// list can't be overridden by the caller for modal windows
var _modalFeatureOverrides =
{
};


var _featureDefaults =
{
  // default values for features of document windows
  document:
  {
    channelmode:false,
    copyhistory:true,
    dependent:false,
    directories:true,
    fullscreen:false,
    hotkeys:false,
    location:true,
    menubar:true,
    resizable:true,
    scrollbars:true,
    status:true,
    toolbar:true
  },
  // default values for features of dialog windows
  dialog:
  {
    channelmode:false,
    copyhistory:false,
    dependent:true,
    directories:false,
    fullscreen:false,
    hotkeys:true,
    location:false,
    menubar:false,
    resizable:true,
    scrollbars:true,
    status:true
  }
}


// featues that require signbing in order to be set
var _signedFeatures =
{
  alwayslowered:1,
  alwaysraised:1,
  titlebar:1,
  "z-lock":1
};

// features that are boolean values
var _booleanFeatures =
{
  alwayslowered:1,
  alwaysraised:1,
  channelmode:1,
  copyhistory:1,
  dependent:1,
  directories:1,
  fullscreen:1,
  hotkeys:1,
  location:1,
  menubar:1,
  resizable:1,
  scrollbars:1,
  status:1,
  titlebar:1,
  toolbar:1,
  "z-lock":1
};


/**
 * Adds an event handler to an element.
 * @param obj The element against which the event handler should be registered
 * @param exType The event handler type such as 'change', 'blur', 'click' etc.
 * @param fn The function to call when the event occurs
 */
function _addEvent(obj, evType, fn)
{
  if (obj.addEventListener)
  {
    obj.addEventListener(evType, fn, false);
    return true;
  }
  else if (obj.attachEvent)
  {
    var r = obj.attachEvent("on"+evType, fn);
    return r;
  }
  else
  {
    return false;
  }
}

/**
 * Removes an event handler from an element.
 * @param obj The element against which the event handler is regsitered
 * @param exType The event handler type such as 'change', 'blur', 'click' etc.
 * @param fn The event handler function to remove from the element
 */
function _removeEvent(obj, evType, fn)
{
  // TODO: abstract onto Agent object
  if (obj.removeEventListener)
  {
    obj.removeEventListener(evType, fn, false);
    return true;
  }
  else if (obj.detachEvent)
  {
    var r = obj.detachEvent("on"+evType, fn);
    return r;
  }
  else
  {
    return false;
  }
}

/**
 * Gets the preferred width of the content
 */
function _getBodyWidth(
  element,
  offsetWidth,
  offsetLeft
  )
{
  var maxWidth = _getContentWidth(element, offsetWidth, 0);

  // bogusly double the offset to guess the right margin...
  // However, in right to left languages, the left margin can get very large,
  // and cause the window to become huge (Bug 2846393). Limit it to an
  // empirically reasonable value.
  var marginWidth = 10;

  if (_isLTR() || (offsetLeft <= 5))
  {
      marginWidth = 2 * offsetLeft;
  }

  return maxWidth + marginWidth;
}

/**
 * Gets the preferred width of the content
 */
function _getContentWidth(
  element,
  offsetWidth,
  offsetLeft
  )
{
  var children = element.childNodes;

  // XXXSafari: what to do here?
  var isIE = _agent.isIE;

  var hasContentProp = (isIE)
                         ? "canHaveHTML"
                         : "tagName";
  var maxWidth = 0;

  for (var i = 0; i < children.length; i++)
  {
    var currChild = children[i];

    if (currChild[hasContentProp] && (currChild.offsetWidth > 0))
    {
      var currWidth = 0;
      var currOffsetWidth = currChild["offsetWidth"];

      if (!isIE)
      {
        if ((currOffsetWidth == offsetWidth) ||
            (currOffsetWidth <= 1))
        {
          var currOffsetLeft = currChild.offsetLeft;
          if (currChild.parentNode != currChild.offsetParent)
          {
            currOffsetLeft = currOffsetLeft -
                             (currChild.parentNode.offsetLeft);
          }

          currWidth = _getContentWidth(currChild,
                                       currOffsetWidth,
                                       currOffsetLeft);
        }
        else
        {
          currWidth = currOffsetWidth;
        }
      }
      else
      {
        currWidth = currChild["clientWidth"];

        if (currWidth == 0)
        {
          var currOffsetLeft = currChild.offsetLeft;
          if (currChild.parentElement != currChild.offsetParent)
          {
            currOffsetLeft = currOffsetLeft -
                             (currChild.parentElement.offsetLeft);
          }

          currWidth = _getContentWidth(currChild,
                                       currOffsetWidth,
                                       currOffsetLeft);
        }
      }

      if (currWidth > maxWidth)
      {
        maxWidth = currWidth;
      }
    }
  }

  // handle error cases
  if (maxWidth == 0)
    maxWidth = offsetWidth;

  return maxWidth + offsetLeft;
}

/**
 * Safely returns the parent window of a window, or undefined if security doesn't allow us to
 * retrieve the parent
 */
function _getParentWindow(currWindow)
{
  var parentWindow = currWindow.parent;

  try
  {
    // dummy read to test security error
    parentWindow.name;

    return parentWindow;
  }
  catch (e)
  {
    return undefined;
  }
}

/**
 * Safely retrieve the top accessible window
 */
function _getTop(currWindow)
{
  // since top might be in another domain, crawl up as high as possible manually
  var currParentWindow = _getParentWindow(currWindow);

  while (currParentWindow && (currParentWindow != currWindow))
  {
    currWindow = currParentWindow;
    currParentWindow = _getParentWindow(currWindow);
  }

  return currWindow;
}


/**
 * renders transparent image for spacing
 */
window.t = function(width,height)
{
  // if the transparent url is not null render img tag
  if (_tURL)
  {
    document.write('<img src="' + _tURL + '"');

    if (width)
      document.write(' width="' + width + '"');
    if (height)
      document.write(' height="' + height + '"');

    // if accessibility mode is not null, render alt attribute
    if (_axm)
      document.write(' alt=""');

    document.write('>');
  }
};

/**
 * Returns the object containing the dependent windows.
 */
function _getDependents(
  parentWindow,
  createIfNecessary
  )
{
  var depends;

  if (parentWindow)
  {
    depends = parentWindow["_dependents"];

    if (!depends)
    {
      if (createIfNecessary)
      {
        depends = new Object();
        parentWindow["_dependents"] = depends;
      }
    }
  }

  return depends;
}

/**
 * Get the named dependent
 */
function _getDependent(
  parentWindow,
  dependentName
  )
{
  var depends = _getDependents(parentWindow);
  var dependent;

  if (depends)
  {
    dependent = depends[dependentName];
  }

  return dependent;
}


/**
 * Sets the value of the named dependent
 */
function _setDependent(
  parentWindow,
  dependentName,
  dependentValue
  )
{
  var depends = _getDependents(parentWindow, true);

  if (depends)
  {
    depends[dependentName] = dependentValue;
  }
}


/**
 * Returns the dependent which is modal.
 */
function _getModalDependent(
  parentWindow
  )
{
  return _getDependent(parentWindow, "modalWindow");
}


/**
 * Returns true if the passed in dependent is the modal dependent
 * of the parent window,
 */
function _isModalDependent(
  parentWindow,
  dependent
  )
{
  return (dependent == _getModalDependent(parentWindow));
}


/**
 * Called by our modal windows when changes are applied and
 * the window is closed to make sure that the parent window
 * is updated appropriately. Due to bug 3184718 (Google
 * pop-up blocker does not call onUnload event handlers from
 * dialog windows) we cannot rely on _checkUnload being
 * called by the unload event. We call this function
 * instead which in turn calls _checkUnload.
 */
function _unloadADFDialog(
  event
  )
{
  // _checkUnload is called from body's
  // unload event when
  // We use this flag to keep it from
  // running through _checkUnload function twice.
  // If Google's pop-up blocker is
  // not enabled, then _checkUnload is called from body's
  // unload event as well as from here.

  _blockCheckUnloadFromDialog = false;
  _checkUnload(event);
  _blockCheckUnloadFromDialog = true;
}

/**
 * Called by the unload handler of modal windows to call the event
 * handler and make sure that the parent window is updated appropriately
 * to show that no modal window is up anymore.
 */
function _checkUnload(
  event
  )
{
  //PH:set the right event object;
  event = _getEventObj();

  // Make sure we don't run through this function twice
  // when we close a dialog. The
  // _unloadADFDialog function blocks a second run
  // using the _blockCheckUnloadFromDialog flag.

  if (_blockCheckUnloadFromDialog)
  {
    _blockCheckUnloadFromDialog = false;
    return;
  }

  // Check to see if we are a modal window that has been
  // abandoned (who's parent has changed out from under us).
  // In this case, we skip the unload handler, since the
  // modal window no longer has permission to access its
  // parent, and JavaScript errors may occur
  if (_isModalAbandoned())
    return;

  // Check to see if we have an open modal child window
  var modalWindow = _getModalDependent(window);
  if (modalWindow != null)
  {
    // If we are being unloaded before our modal child has been
    // closed, that means that the user must have navigated
    // to a new page just before the modal window was displayed.
    // In this case, let's just close our modal child.  We need
    // to be extra careful to make sure that the modal child does
    // not try to access any properties on the parent window
    // when closing, because the modal child may no longer have
    // permission to access us at this point.  Set a property
    // on the modal window to let it know that it has been
    // abandoned.
    _setModalAbandoned(modalWindow);

    // Now we can safely close the modal window
    modalWindow.close();
  }

  var topWindow = _getTop(self);

  if (!topWindow)
    return;

  var parentWindow = topWindow["opener"];

  if (!parentWindow)
    return;

  var unloader = _getDependent(parentWindow, self.name);

  if (_isModalDependent(parentWindow, self))
  {
    // remove the modal window
    _setDependent(parentWindow, "modalWindow", (void 0));

    parentWindow.onfocus = null;

    if (_agent.supportsDomDocument)
    {
      var parentBody = parentWindow.document.body;

      // release the ie mouse grab
      if (_agent.atLeast("ie", 4))
      {
        if (_agent.atLeast("ie", 5) && _agent.isWindows)
        {
          parentBody.onlosecapture = null;

          _removeModalCaptureIE(parentBody);
        }
        parentBody.style.filter = null;
      }

      if (_agent.isGecko)
      {
        if (parentBody != (void 0))
        {
          _removeModalCaptureGecko(parentWindow, parentBody);
        }
      }
    }
  }

  if (unloader != (void 0))
  {
    // remove our dependent info
    _setDependent(parentWindow, self.name, (void 0));

    // try the passed in event (netscape way first), then
    // try to get the event the IE way
    if (event == (void 0))
      event = self.event;

    // call the unloader with the unloading window and the event
    unloader(topWindow, event);
  }
}

// Adds a (IE-specific) capture to the specified element
// for blocking mouse events during modal dialog display
function _addModalCaptureIE(element)
{
  // Captured events still bubble on IE.  Register
  // mouse event handlers to cancel event bubbling
  // and save away old listeners so we can restore
  // them when the capture is removed.
  var savedListeners = new Object();
  var events = _IE_MOUSE_CAPTURE_EVENTS;
  var eventCount = events.length;

  for (var i = 0; i < eventCount; i++)
  {
    var eventName = events[i];
    savedListeners[eventName] = element[eventName];
    element[eventName] = _captureEventIE;
  }

  // Stash away the saved listener somewhere where
  // we can get at them later
  window._modalSavedListeners = savedListeners;

  // Set the capture
  window._trIeCapture = element;
  window._trIeCaptureCurrent = true;
  element.setCapture();
}

// Removes a (IE-specific) capture added via _addModalCaptureIE()
function _removeModalCaptureIE(element)
{
  // Release the capture
  element.releaseCapture();

  // Restore event handlers that were saved away
  // during _addModalCaptureIE().
  var savedListeners = window._modalSavedListeners;

  if (savedListeners)
  {
    var events = _IE_MOUSE_CAPTURE_EVENTS;
    var eventCount = events.length;

    for (var i = 0; i < eventCount; i++)
    {
      var eventName = events[i];

      element[eventName] = savedListeners[eventName];
    }

    window._modalSavedListeners = null;
  }
  window._trIeCapture = undefined;
}

// Captures (and consumes) events during modal grabs
// on IE browsers
function _captureEventIE()
{
  // do not capture events outside the document body, this leads to the inability for users
  // to click on IE toolbars, menubars, etc.
  var event = window.event;
  if (event.screenY >= window.screenTop && event.screenX >= window.screenLeft)
  {
    if (!window._trIeCaptureCurrent && window._trIeCapture)
    {
      window._trIeCaptureCurrent = true;
      window._trIeCapture.setCapture();
    }
    event.cancelBubble = true;
  }
  else if (window._trIeCapture)
  {
    window._trIeCaptureCurrent = false;
    window._trIeCapture.releaseCapture();
  }
}

// Adds a (Gecko-specific) capture to the specified element
// for blocking mouse events during modal dialog display
function _addModalCaptureGecko(element)
{
  var events = _GECKO_MOUSE_CAPTURE_EVENTS;
  var eventCount = events.length;

  for (var i = 0; i < eventCount; i++)
  {
    var eventName = events[i];
    element.addEventListener(eventName, _captureEventGecko, true);
  }
}

// Removes a (Gecko-specific) capture added via _addModalCapture()
function _removeModalCaptureGecko(parentWindow, element)
{
  var events = _GECKO_MOUSE_CAPTURE_EVENTS;
  var eventCount = events.length;

  for (var i = 0; i < eventCount; i++)
  {
    var eventName = events[i];
    element.removeEventListener(eventName,
                                parentWindow._captureEventGecko,
                                true);
  }
}

// Captures (and consumes) events during modal grabs
// on Gecko browsers
function _captureEventGecko(
  event
  )
{
  // Stop propagation and suppress default action
  event.stopPropagation();
  window.preventDefault = true;
}

// Tests whether the current window is an "abandoned"
// modal window.  This is a modal window who's parent
// window has navigated to a new page, in which case
// the modal window is out of context.
function _isModalAbandoned()
{
  // We look for the _abandoned property on the modal window.
  // Note that in the LOV case, we actually have two onunload
  // event handlers that need to be suppressed: The onunload
  // handler for the LOV window and the onunload handler for
  // the actual contents of the LOV window which are nested
  // within a frame.  So, we check for the _abandoned property
  // on the "top" window.
  var topWindow = _getTop(self);

  return topWindow._abandoned;
}

// Marks the specified modal window as abandoned
function _setModalAbandoned(
  modalWindow
  )
{
  // Just set the _abandoned property on the modal window.
  modalWindow._abandoned = true;
}


/**
 * Function that returns a single key/value pair String
 */
function _getKeyValueString(
  target,
  keyName,
  index
  )
{
  var value = target[keyName];

  if (typeof(value) == "function")
  {
    value = "[function]";
  }

  // XXXSafari: what to do here?
  var separator = (_agent.isGecko)
                    ? ((index + 1) % 3 == 0)
                      ? '\n'
                      : '    '
                    : '\t';

  return keyName + ':' + value + separator;
}

function _dumpSuppress(
  target
  )
{
  _dump(target, {innerText:1, outerText:1, outerHTML:1, innerHTML:1});
}

/**
 * Utility for dumping the contents of a JavaScript object.
 */
function _dump(
  target,
  suppressProps,
  name
  )
{
  var props = "";

  if (target)
  {
    // default the name if none provided
    if (!name)
    {
      name = target["name"];
    }

    //
    // Because we need to catch exceptions that IE throws if
    // for some object reads, we need to have separate ie and netscape
    // code for the exception catching.  Unfortunately, "try" and
    // catch are reserved words, so we have to dynamically create
    // our adding function so that Netscape doesn't throw it's own
    // exception when it parses our file
    //
    // var adderContent = "return i + ':' + target[i] + '\\n';";
    var adderContent = "return _getKeyValueString(target, key, index);";

    // wrap adder content with a try and eat the bogus ie exception
    if (_agent.atLeast("ie", 5) || _agent.isGecko || _agent.isSafari)
      adderContent = "try{" + adderContent + "}catch(e){return '';}";

    var adder = new Function("target", "key", "index", adderContent);
    var propCount = 0;
    var propArray = new Array();

    for (var key in target)
    {
      // don't add properties that should be suppressed
      if ((!suppressProps || !suppressProps[key]) && !key.match(/DOM/))
      {
        propArray[propCount] = key;
        propCount++;
      }
    }

    // sort the array so that we can find stuff
    propArray.sort();

    for (var i = 0; i < propArray.length; i++)
    {
      props += adder(target, propArray[i], i);
    }
  }
  else
  {
    // the object to dump was undefined
    name = "(Undefined)";
  }

  // tell the user that the object has no properties
  if (props == "")
  {
    props = "No properties";
  }

  alert(name + ":\n" + props);
}

function _getJavascriptId(name)
{
  return name.split(':').join('_');
}

function _getFormName(form)
{
  var name = form.name;

  if ((typeof name) != 'string')
  {
    if (_agent.isIE)
    {
      name = form.attributes['name'].nodeValue;
    }
    else
    {
      name = form.getAttribute('name');
    }
  }

  return name;
}


/**
 * Calls the correct validations function for the form and returns true
 * if the validation succeeded.
 */
function _validateForm(
  form,
  source
  )
{
  // Blackberry does not set valiation script in the fields
  // and it is not possible to execute validation.
  // Return true if validation is not supported.
  if (!_agent.supportsValidation)
  {
    return true;
  }

  var funcName = '_' + _getJavascriptId(_getFormName(form)) + 'Validator';
  var formWind = window[funcName];
  if (formWind)
  {
    try
    {
      ret = formWind(form, source);
    }
    catch (e)
    {
      // Validator did not execute normally.
      // In case for mobile devices, BlackBerry, Nokia, Windows Mobile and PPC
      // return true in order to submit the form.
      if (_agent.isPIE || _agent.isNokiaPhone || _agent.isBlackBerry)
      {
        ret = true;
      }
      else
      {
        ret = false;
      }
    }
      return ret;
  }

  return false;
}


/**
 * Validate the specified field.
 */
function _valField(
  formName,
  nameInForm
  )
{
  if (nameInForm)
  {
    // get the target whose validation we want to run
    var target = document.forms[formName][nameInForm];

    // get its onblur function
    var blurFunc = target.onblur;

    if (blurFunc)
    {
      // FIXME: this is *NOT* portable.  Safari, for example,
      // does not implement toString() on functions this way,
      // and nothing requires that it does
      var valFunc = blurFunc.toString();

      // whack off the beginning and end of the function, leaving the content
      var valContents = valFunc.substring(valFunc.indexOf("{") + 1,
                                          valFunc.lastIndexOf("}"));

      var targetString = "document.forms['" +
                         formName +
                         "']['" +
                         nameInForm +
                         "']";

      // replace 'this' with the actual target
      valContents = valContents.replace(/this/, targetString);

      // trim off last argument
      var lastArg = valContents.lastIndexOf(",");

      valContents = valContents.substring(0, lastArg) + ")";

      // perform the validation
      eval(valContents);
    }
  }
}

function _validateAlert(
  form,
  source,
  validators,
  globalMessage,
  errorTitle
  )
{
  if (!validators)
    validators = _getValidators(form);

  var failureMap = _multiValidate(form, source,  validators);

  var firstFailure = true;
  var failureString = errorTitle + '\n';

  for (var currId in validators)
  {
    // Get the messages array for currId, skip if none
    var messages = failureMap[currId];
    if (!messages || messages.length==0)
      continue;

    // Get the input element
    var currInput = _getFormElement(form, currId);
    if (!currInput)
      continue;

    // Get the label text for this input
    var label = validators[currId].label;

    // Loop through the messages for this input
    for (var j=0; j < messages.length; j = j+2)
    {
      // Move the focus back to the first failed field
      if (firstFailure)
      {
        _setFocus(currInput);
        firstFailure = false;
      }

      // Get the current message
      var facesMessage = messages[j];

      if (_agent.isNokiaPhone)
      {
        errorString = _getGlobalErrorString(currInput,
                            globalMessage,
                            facesMessage,
                            label);
      }
      else
      {
        errorString = _getGlobalErrorString(currInput,
                            globalMessage,
                            facesMessage.getDetail(),
                            label);
      }

      failureString += errorString + '\n';
    }
  }

  if (firstFailure)
    return true;

  // Show the error and note the time we finished this validation.
  // Record the validation both before and after the alert so that we
  // halt any validations caused by events triggered along with this
  // one, or by the closing of this alert.
  _recordValidation(true, 0);
  alert(failureString);
  _recordValidation(true, 0);

  return false;
}

function _validateInline(
  form,
  source,
  validators
  )
{
  // If not passed explicitly, return
  if (!validators)
    validators = _getValidators(form);

  var failureMap = _multiValidate(form, source,  validators);

  var noFailures = true;

  for (var currId in validators)
  {
    var foundMsg = false;

    // Get the icon if any
    var iconElem = _getElementById(document, currId + "::icon");

    // If component hasn't got a message element, then skip
    var msgElem = _getElementById(document, currId+ "::msg");

    // Clear any existing inline message
    if (msgElem && msgElem.innerHTML !="")
      msgElem.innerHTML = "";

    // Clear any existing messages from the MessageBox
    TrMessageBox.removeMessages(currId);

    // Get the messages array for currId, skip if none
    var messages = failureMap[currId];
    if (!messages || messages.length==0)
    {
      // Hide the inline message and icon
      if (msgElem)
        msgElem.style.display = "none";
      if (iconElem)
        iconElem.style.display = "none";
      continue;
    }

    // Get the input element
    var currInput = _getFormElement(form, currId);
    if (!currInput)
      continue;

    // Get the label text for this input
    var label = validators[currId].label;

    // Loop through the messages for this input
    for (var j=0; j < messages.length; j = j+2)
    {
      if (noFailures)
      {
        noFailures = false;

        // Move the focus back to the first failed field
        // TODO - Remove once inline validation uses onblur/onchange
        _setFocus(currInput);
      }

      // Get the current message
      var facesMessage = messages[j];

      if (msgElem)
      {
        if (_agent.isNokiaPhone)
        {
          msgElem.innerHTML = facesMessage;
        }
        else
        {
          msgElem.innerHTML = facesMessage.getDetail();
        }
      }

      // if there's nowhere to display the message in either
      // summary or detail, then pop an alert to warn the page developer
      if (!msgElem && !TrMessageBox.isPresent())
      {
        if (_agent.isNokiaPhone)
        {
          alert("Field Error [" + currId + "] - " + facesMessage);
        }
        else
        {
          alert("Field Error [" + currId + "] - " + facesMessage.getDetail());
        }
      }

      // Add the message to the MessageBox
      TrMessageBox.addMessage(currId, label, facesMessage);
    }

    // If we got this far, we know there's something to display so
    // make the inline message and icon visible.
    if (msgElem)
      msgElem.style.display = "";
    if (iconElem)
      iconElem.style.display = "";
  }

  return noFailures;
}

/**
 * Performs validation on the supplied input element.  If validation fails
 * the appropriate message will be displayed in the message component for this
 * input field.
 * <p>
 * The simplest usage of this method is from the onblur attribute of the
 * input component. e.g. onblur="_validateInput(event);"
 * <p>
 * @param event(Event) The event object provided by the event handler.
 * @param falseOnFail(boolean) Force method to return false if validation failed.
 * @return boolean, false if validation failed and falseOnFail set to true, otherwise true.
 */
// TODO: make this a public function only after hanging it on
// a namespaced object, *and* making it not specific to inline
// validation
function _validateInput(event, falseOnFail)
{
  if (!event)
    return true;

  // Get the element associated with the event
  var inputElem = event.target || event.srcElement;

  if (!inputElem || !inputElem.id)
    return true;

  var form = _getForm(inputElem);
  if (!form)
    return true;

  var validators = _getValidators(form);
  if (!validators)
    return true;

  var id = inputElem.id;

  var descriptor = validators[id];

  // If we couldn't find the descriptor by id, then try by name
  // as it might be a radio button
  if (!descriptor && inputElem.name)
  {
    id = inputElem.name;
    descriptor = validators[id];
  }
  if (!descriptor)
    return true;

  // Create a new temporary validators object and run with just the
  // one descriptor
  var validatorsToRun = new Object();
  validatorsToRun[id] = descriptor;

  // Call inline validation using only the appropriate validators
  var retval = _validateInline(form, null, validatorsToRun, 1, null);

  // Only return the actual outcome if asked to do so
  if (falseOnFail)
    return retval;
}

// Records the time of this validation event.
// If fail is set, this is a validation failure, that is noted also.
function _recordValidation(fail, now)
{
  if (!now)
    now = new Date();

  _lastDateValidated = now;
  if (fail)
    _lastValidationFailure = now;
}


// returns true if a validation has occurred "recently"
// failures: True means only report on recent failures, false means report on
//           any validation.
function _recentValidation(failures)
{
  var retVal = false;
  var timeWindow = 250;

  // Assuming that a reasonable user won't close the dialog and change the
  // text within a quarter of a second, we ignore any validations within
  // 250ms. of the last failed validation. The timings I've seen here range
  // in the 60 - 90 ms. range, but that is on fast development machines. We
  // could probably lower this to 150 if we're seeing dropped validations
  // for really fast, ambitious users.
  // With Macintosh IE, we manage to crash the browser!
  if (_agent.isMac)
  {
    // The iBook can have diffs of up to about 480 ms.
    // Call it 600 to be safe.
    timeWindow = 600;
  }

  var newDate = new Date();
  var diff;

  // If failures are requested, the caller is only interested in failures.
  // If simple validation requested, caller interested in any validation fail
  // or not.
  diff = newDate - _lastValidationFailure;
  if ((diff >= 0) && (diff < timeWindow))
  {
    retVal = true;
  }
  else if (!failures)
  {
    diff = newDate - _lastDateValidated;
    if ((diff >= 0) && (diff < timeWindow))
    {
      retVal = true;
    }
  }
  return retVal;
}

/**
 * Used to submit a selected item in a choice as if it's a commandLink
 * or commandButton
 */
function _commandChoice(
  form,
  choice
)
{
  var src = document.forms[form].elements[choice].value;

  // need this strange [0] for when choice repeated,
  // for example a processChoiceBar in actions facet of panelPage.
  if (src == void(0))
    src = (document.forms[form].elements[choice])[0].value;

  // if it starts with a '#', it's an url.
  var gtIndex = src.indexOf("#");
  if ( gtIndex == 0)
    window.document.location.href = src.substring(1,src.length);
  else
  {
    var openBracketIndex = src.indexOf("[");
    var srcID = src.substring(0, openBracketIndex);
    var validateString = src.substring(openBracketIndex+1, openBracketIndex+2)
    var validate = parseInt(validateString);
    submitForm(form,validate,{source:srcID});
  }
}



/**
 * Attempts to submits the form, potentially firing validation and notifying
 * any Cabo onSubmit handlers registered on the form, returning
 * <code>true</code> if the submission actually occurred.
 * <p>
 * If the <code>doValidate</code> parameter is false, no validation will
 * be performed, and the form is guaranteed to be submitted.  Otherwise,
 * the form will be submitted if both the validation succeeds and any
 * registered Cabo onSubmit handlers do not return <code>false</code>.
 * <p>
 * @param form The form to submit.  This can either be the name of the form
 *             in the current <code>document</code>, the index of the form
 *             in the current <code>document</code> or the form itself.
 * @param doValidate boolean value specifying whether validation should
 *   occur before the form is submitted.  (As per a common Javascript
 *   idiom, it is acceptable to pass true/false as well as 0/1).  If
 *   this parameter is ommitted, it defaults to true.
 * @param parameters a single Javascript object that specifies
 *   all the additional key-value pairs to submit.  There must be
 *   pre-existing &lt;input type="hidden"&gt; elements as targets
 *   for each of these parameters.
 */
window.submitForm = function(
  form,
  doValidate,
  parameters,
  isPartial,
  event)
{
  // If we've delayed any sort of event submission, we won't want to do it at
  // all now that the form is getting submitted. Blow away the saved data. Any
  // timeout handler will cancel the event submission if the data no longer
  // exists.
  var pending = true;
  if (_agent.isIEGroup)
  {
    pending = false;
    // keep track of whether there was a pending event
    for (var key in _delayedEventParams)
    {
      pending = true;
      break;
    }
  }

  if (pending)
  {
    _delayedEventParams = new Object();
    _delayedEventParams["reset"] = true;
  }

  // if the form was passed as a form name, get the form object
  if ((typeof form) == "string")
  {
    form = document[form];
  }
  // if the form was passed as a form index, get the form object
  else if ((typeof form) == "number")
  {
    form = document.forms[form];
  }

  // we had better have a form now
  if (!form)
    return false;

  // Check to see if submitForm is called before the form
  // has been rendered completely. If so, save the parameters
  // and return. At the end of the form, we always call _submitFormCheck
  // which will re-call submitForm if it had been rejected.
  // This is for bug 2752257.

  // Bug #3058770: In LovInput, we have to hack up a form for NLS. It's not
  // validated, so there is no real validator, we've just hacked one. The
  // submit always sets doValidate to false. Just make sure that you never use
  // this validator if doValidate is false (it might just be the value '1').
  var formComplete = window["_"+ _getJavascriptId(_getFormName(form)) + "Validator"];

  if (formComplete == (void 0))
  {
    _saveFormForLaterSubmit(form, doValidate, parameters);

    // Do not submit the form,
    // since the form hasn't been rendered completely yet.
    return false;
  }

  // Bug 1789483: ignore a second form submission that happens
  // less than 0.5 seconds after the first one
  var newDate = new Date();
  if (_recentSubmit(newDate))
  {
    // However if we're allowing the first click through... we queue up this
    // submit.
    if (_pprFirstClickPass && _pprBlocking)
    {
      _saveFormForLaterSubmit(form, doValidate, parameters);
    }
    return;
  }

  // just in case, clear it the delayed submit flags
  _submitRejected = false;
  _inPartialSubmit = false;

  _lastDateSubmitted = newDate;

  // default value for doValidate is true
  if (doValidate == (void 0))
    doValidate = true;

  // assume that we should submit the form
  var doSubmit = true;

  // validate the form if necessary, and don't submit the
  // form if validation fails
  var paramSource;
  if (parameters != null)
    paramSource = parameters.source;
  else
    paramSource = "";

  if (doValidate && !_validateForm(form, paramSource))
    doSubmit = false;

  //
  // If we have an onSubmit handler, call it
  //
  var onSubmit = window["_" + _getJavascriptId(_getFormName(form)) + "_Submit"];

  if (typeof onSubmit != "undefined" && doSubmit)
  {
    // create function so that "return" is handled correctly,
    var func = new Function("doValidate", onSubmit);
    var handlerResult;

    // WindowsMobile 5 doesn't support installing Funtion object
    // to "this", so just invoke the Function object instead.
    if (_agent.isPIE)
    {
      handlerResult = func(event);
    }
    else
    {
      // install the function on the object so that "this" is
      // handled correctly
      form._tempFunc = func;

      // call the submit handler with the doValidate flag,
      handlerResult = form._tempFunc(doValidate);

      // uninstall the temporary function
      form._tempFunc = (void 0);
    }
    // if we're validating and the handler returns false,
    // don't submit the form
    if (doValidate && (handlerResult == false))
    {
      doSubmit = false;
    }
  }

  if (doSubmit)
  {
    // reset any hidden form values before submitting
    TrPage.getInstance()._resetHiddenValues(form);

    // While WM6 can support PPR, WM5 and PPC lacks enough support
    // for DOM and/or HMLHTTP. Disable partial form post for PPC and
    // WM5.
    if (isPartial && _supportsPPR())
    {
      // In the case of Windows-mobile(WM) browsers, during rendering,
      // Trinidad stores the value of the request-header field, UA-pixels,
      // into a hidden-parameter's value attribute. WM browsers' PPRs don't
      // contain UA-pixels in their request-headers. So during a WM browser's
      // PPR, we need to manually set the field, UA-pixels, into the
      // request-header with the hidden parameter's value.

      if (_agent.isPIE || _agent.isWindowsMobile6)
      {
        var header = new Array(1);
        header['UA-pixels'] = form.elements['uapixels'].value;
        TrPage.getInstance().sendPartialFormPost(form, parameters, header);
      }
      else
      {
        TrPage.getInstance().sendPartialFormPost(form, parameters, null, event);
      }
    }
    else
    {
      //
      // assign any dynamic values before submitting
      //
      var isDOM = _supportsDOM();
      var tempParams = new Object();

      if (parameters)
      {
        for (var paramName in parameters)
        {
          var paramValue = parameters[paramName];
          if (paramValue != (void 0))
          {
            // do not try to get properties from the form element directly.
            // Some code somewhere was setting an htmlInputElement as
            // a property on the formElement, but not as a child.
            // This was causing bug 4536656.
            // I can't yet figure out who is setting the htmlInputElement as
            // a property (instead of a child).
            // As a workaround get them from the elements array instead.
            // In any case it is always safe to get the element from the
            // elements array.
            //var hiddenField = form[paramName];
            var hiddenField = form.elements[paramName];
            if (_agent.isPIE)
            {
              hiddenField.value = paramValue;
            }
            else
            {
              var hiddenFieldCreated = false;
              // See if the hidden field exists.  And, because
              // of some rather strange IE behavior w/regards to
              // form.elements['id'], make sure we haven't accidentally
              // grabbed a string
              if (hiddenField && (typeof(hiddenField) != "string"))
              {
                // This condition was added to support enter key
                // on forms for hcommandButton
                if (hiddenField.type == 'submit' || hiddenField.type == 'button')
                {
                  var tmpField = document.createElement("input");
                  tmpField.type = "hidden";
                  tmpField.name = paramName;
                  tmpField.value = parameters[paramName];
                  form.appendChild(tmpField);
                  tempParams[paramName] = tmpField;
                  hiddenFieldCreated = true;
                }
                else
                {
                  hiddenField.value = paramValue;
                }
              }
              //VAC- added so that PDA's do not enter this flow. Since no PDA currently
              //supports createElement function on the document.  Furthermore, if the
              //hidden field exists there should be no reason to create a new hidden field
              //with the same name and attach it to the form.
              else
              {
                if (isDOM)
                {
                  if (! hiddenFieldCreated)
                  {
                    // as a convenience to the client, build a hidden field to hold
                    // this parameter.
                    var tmpField = document.createElement("input");
                    tmpField.type = "hidden";
                    tmpField.name = paramName;
                    tmpField.value = parameters[paramName];
                    form.appendChild(tmpField);
                    tempParams[paramName] = tmpField;
                  }
                }
              }
            }
          }
        }
      }
      // IE BUG, see TRINIDAD-704
      if(_agent.isIE)
        _autoCompleteForm(form);

      try
      {
        form.submit();
      }
      catch (e)
      {
        if (TrPage.getInstance().getRequestQueue()._isMultipartForm(form))
        {
          // IE will fail on an input file submission of a file that does not exist
          var facesMessage = _createFacesMessage(
            'org.apache.myfaces.trinidad.component.core.input.CoreInputFile.INPUT_FILE_ERROR');
          // if there's nowhere to display the message in either
          // summary or detail, then pop an alert to warn the page developer
          if (!TrMessageBox.isPresent())
            alert(facesMessage.getDetail());
          else
            // Add the message to the MessageBox
            TrMessageBox.addMessage(null, null, facesMessage);
        }
        else
        {
          throw e;
        }
      }

      if (_blockOnEverySubmit)
        _pprStartBlocking(window);


      // Remove any dynamically added form parameters. We do this for two
      // reasons:
      // 1. IE6 does not return dynamically-added form elements in the form map,
      // so we end up re-adding the same form elements again.
      // 2. If we don't remove them, then subsequent form submits behave like
      // they are PPR requests (because the dynamically added "partial" and
      // "partialTargets" parameters will be on the request).
      // (Bug #3623890. This seems to break on a few Apps pages with bad form
      // setups)
      if (isDOM)
      {
        for (var paramName in tempParams)
          form.removeChild(tempParams[paramName]);
      }
    }
  }

  return doSubmit;
};

/**
 * Internet Explorer has a bug, that the autocomplete does not work when
 * using JavaScript to submit a form.
 */
function _autoCompleteForm(form)
{
  var theExternal = window.external;

  if (theExternal && (typeof theExternal.AutoCompleteSaveForm != "undefined"))
  {
    try
    {
      theExternal.AutoCompleteSaveForm(form);
    }
    catch (e)
    {
      // ignore
    }
  }
}

/**
 * This function is called when enter key is hit on any form input element.
 * @src if non-null, the ID of the object to fire
 */
function _submitOnEnter(e, frm, src, immediate, ppr)
{
  if (window.event != null)
    e = window.event;

  var eventSource;
  if (e.srcElement == undefined)
    // Gecko browsers
    eventSource = e.target;
  else
    eventSource = e.srcElement;

  if (!eventSource) return true;
  // Only process for "INPUT": but not for submit and reset
  // buttons
  if(eventSource.tagName == 'A') return true;

  if ((eventSource.tagName == 'INPUT') &&
      (eventSource.type != 'submit') &&
      (eventSource.type != 'reset'))
  {
    if (_getKC(e)==13)
    {
      if (src != null)
      {
        var params = new Object();
        params[src] = src;
        params['source'] = src;

        if(ppr != true)
        {
          submitForm(frm,immediate,params);
        }
        else
        {
          TrPage._autoSubmit(frm, src, e, immediate, params);
        }
      }

      return false;
    }
  }

  return true;
}

/**
 * In some cases we need to hold off on a submit for a while (waiting for the
 * page to complete rendering, waiting for another submit to complete, etc.).
 * This function will save off the state of the submit request for later
 * processing in _submitFormCheck().
 */
function _saveFormForLaterSubmit(form, val, params)
{
  // TODO: fix for PPR
  _saveForm = form;
  _saveDoValidate = val;
  _saveParameters = params;
  _submitRejected = true;
}

/**
 * Checks if _submitForm had been called before the form had completely
 * rendered, and if so, recall it. This function is rendered at the end of the
 * form, so it is guaranteed that the form is complete when this is called.
 */
function _submitFormCheck()
{
  if (_submitRejected)
  {
    if (_inPartialSubmit)
    {
      _submitPartialChange(_saveForm, _saveDoValidate, _saveParameters);
      _inPartialSubmit = false;
    }
    else
    {
      submitForm(_saveForm, _saveDoValidate, _saveParameters);
    }
    _saveForm = null;
    _saveDoValidate = null;
    _saveParameters = null;
  }
}

/**
 * Attempts to reset the form, calling
 * any reset function calls registered on the form.
 * The form will be reloaded if any
 * reset function call returns <code>true</code>.
 * This function returns <code>true</code> if the page
 * had to be reloaded, and false otherwise.
 * <p>
 * @param form The form to submit.  This can either be the name of the form
 *             in the current <code>document</code>, the index of the form
 *             in the current <code>document</code> or the form itself.
 */
window.resetForm = function(form)
{
  var doReload = false;

  // if the form was passed as a form name, get the form object
  if ((typeof form) == "string")
  {
    form = document[form];
  }
  // if the form was passed as a form index, get the form object
  else if ((typeof form) == "number")
  {
    form = document.forms[form];
  }

  // we had better have a form now
  if (!form)
    return false;

  var doReload = TrPage.getInstance()._resetForm(form);
  if ( doReload )
  {
    window.document.location.reload();
  }
  else
  {
    form.reset();
  }

  _lastDateReset = new Date();
  return doReload;
};

// Create  query string with the data from a given form
window.createNameValueString = function(form)
{
  var datatosend = "";
  try
  {
    var arr = form.elements;
    for (var i = 0; i < arr.length; i++)
    {
      try
      {
        var element = arr[i];
        if(element.name)
        {
          if (element.type == "text"
              || element.type == "password"
              || element.type == "textarea"
              || element.type == "hidden")
          {
            datatosend += (element.name + "=" + escape(element.value) + "&");
          }
          else if (element.type.indexOf("select") != -1)
          {
            //PH:selectdata must be initialized to "". Otherwise, results for
            //selectdata+="stringtoconcatenate" is "undefinedstringtoconcatenate"
            var selectdata ="" ;
            for (var j = 0; j < element.options.length; j++)
            {
              if (element.options[j].selected == true)
                selectdata += element.name + "="
                              + escape(element.options[j].value) + "&";
            }
            if( !selectdata)
            {
              var val = _getValue(element);
              if (val)
              {
                selectdata += element.name + "=" + escape(val) + "&";
              }
            }
            if (selectdata)
            {
              datatosend += selectdata;
            }
          }
          else if (element.type == "checkbox" && element.checked)
            datatosend += ( element.name + "=" + escape(element.value) + "&");
          else if (element.type == "radio" && element.checked == true)
            datatosend +=  (element.name + "=" + escape(element.value) + "&");
        }
      }
      catch (e)
      {
      }
      element = null;
    }
  }
  catch(e)
  {
  }
  return ( datatosend.substring(0, datatosend.length - 1));
};

/**
 * Returns the value of a form element.
 */
function _getValue(formElement)
{
  var shadowElem = formElement;
  var elementType = formElement.type;

  // When we're dealing with an array of elements, find the
  // real element type by looking inside the array.
  if (!elementType && formElement.length)
  {
    // See bug 3651045;  IE can put "fieldsets" in with
    // form elements!
    for (var i = 0; i < formElement.length; i++)
    {
      elementType = formElement[i].type;
      if (elementType != (void 0))
      {
        shadowElem = formElement[i];
        break;
      }
    }
  }

  if (elementType == "checkbox")
  {
    if (formElement.length)
    {
      for (var i = 0; i < formElement.length; i++)
      {
        // See above for why we check each element's type
        if (formElement[i].type == "checkbox" &&
            formElement[i].checked)
        {
          return formElement[i].value;
        }
      }
    }
    else
    {
      return formElement.checked;
    }
  }
  else if (elementType == "select-multiple")
  {
    var multiResult = new Array();
    for (var i = 0; i < formElement.length; i++)
    {
      if(formElement.options[i].selected)
      {
        multiResult[multiResult.length] = formElement.options[i].value;
      }
    }
    return (multiResult.length > 0) ? multiResult : "";
  }
  else if (elementType.substring(0,6) == "select")
  {
    formElement = shadowElem;
    var selectedIndex = formElement.selectedIndex;

    // selectedIndex exists and non-negative
    if (selectedIndex != (void 0) &&
        selectedIndex != null &&
        selectedIndex >= 0)
    {
      var opt = formElement.options[selectedIndex];
      var value = opt.value;
      if (!value)
      {
        // If there's no value, it could be for two reasons:
        //  (1) The user has only specified "text".
        //  (2) The user explicitly wanted "value" to be empty.
        // We can't really tell the difference between the two,
        // unless we assume that users will be consistent with
        // all options of a choice.  So, if _any_ option
        // has a value, assume this one was possibility (2)
        for (var i = 0; i < formElement.options.length; i++)
        {
          if (formElement.options[i].value)
            return value;
        }

        // OK, none had a value set - this is option (1) - default
        // the "value" to the "text"
        return opt.text;
      }

      return value;
    }

    // no selected value
    return "";
  }
  else if (elementType == "radio")
  {
    if (formElement.length)
    {
      for (var i = 0; i < formElement.length; i++)
      {
        // See above for why we check each element's type
        if (formElement[i].type == "radio" &&
            formElement[i].checked)
        {
          return formElement[i].value;
        }
      }
    }
    else
    {
      if (formElement.checked)
      {
        return formElement.value;
      }
    }

    // no selected value
    return "";
  }
  else
  {
    return formElement.value;
  }
}

/**
 * Sets the selected index
 */
function _setSelectIndexById(id, index)
{
  var element = _getElementById(document, id);
  if (element != null)
    element.selectedIndex = index;
}


/**
 * Synchronizes the index of a repeated choice.
 */
function _syncChoiceIndex(ch)
{
  var form = ch.form;
  var name = ch.name;
  var comps = form.elements[name];
  for (i=0; i<comps.length; i++)
  {
    comps[i].selectedIndex = ch.selectedIndex;
  }
}


/**
 * Clears a password field if it contains the magic postback string.
 */
function _clearPassword(field, e)
{
  if (window.event != (void 0))
    e = window.event;

  if (field.value != "******")
    return true;

  // Backspace
  if ((e.keyCode == 8) ||
     // Delete (46) through F1 (112)
      ((e.keyCode >= 46) && (e.keyCode < 112)))
    field.value="";
  return true;
}


/**
 * If appropriate sets the focus on the input passed in
 */
function _setFocus(currInput)
{
  // check if currInput is showing before setting focus, for example
  // ColorField has required validation on hidden field,
  // but cannot receive focus.
  if (_isShowing(currInput))
  {
    if (currInput.focus)
      currInput.focus();

    //PH:element["value"] is not supported for PIE,IEM and BB. Therefore
    //use element.value which is supported by all
    if ((currInput.type == "text")
        && (currInput.value != (void 0))
        && (currInput.value != null)
        && (currInput.value.length > 0))
    {
      // IE fails on this select if a timeout occurs to handle a
      // pending event. Don't do it if we've reset the delayed
      // events object.
      if (true != _delayedEventParams["reset"])
        currInput.select();
    }
  }
}

function _addValidators(formName, validators, validations, labels, formats)
{
  var form = document.forms[formName];
  var validatorMap = _getValidators(form);
  if (!validatorMap)
    validatorMap = new Object();

  // Now, iterate through the array we've been given
  for (var i = 0; i < validators.length; i += 5)
  {
    var id = validators[i];
    var descriptor = new Object();

    // If the field is required, replace the format index with the
    // actual message
    if (validators[i + 1])
    {
      var formatIndex = validators[i + 2];
      descriptor.required = true;
      descriptor.requiredFormat = formats[formatIndex];
    }

    // If the converter exists, change it from an index to a converter
    var converterIndex = validators[i + 3];
    if (converterIndex != null)
    {
      descriptor.converter = validations[converterIndex];
    }

    // If there's a validator array, reuse it after converting
    // the indices to validator objects
    var validatorArray = validators[i + 4];
    if (validatorArray)
    {
      for (j = 0; j < validatorArray.length; j++)
      {
        validatorArray[j] = validations[validatorArray[j]];
      }

      descriptor.validators = validatorArray;
    }

    // Store the label on the descriptor
    var label = labels[id];
    if (label)
      descriptor.label = label;

    // Stash the descriptor on the validator map
    validatorMap[id] = descriptor;

    // If enabled, setup event based validation
    if (_TrEventBasedValidation)
    {
      var inputElem = _getElementById(document, id);
      if (inputElem)
      {
        _addEvent(inputElem, "change", _validateInput);
      }
    }
  }

  // And store the new validator map away
  window["_" + _getJavascriptId(_getFormName(form)) + "_Validators"] = validatorMap;
}

/**
 * Calls an array of validation functions and returns a map of validation
 * errors.  Each map entry is keyed by an id of an input component
 * and contains an array of TrFacesMessage objects relating to the
 * component (i.e. <String, TrFacesMessage[]>).
 */
function _multiValidate(
  form,
  source,
  validators
  )
{
  // Initialise the return map.
  var failureMap = new Object();

  var subforms = window[_getFormName(form) + "_SF"];
  var ignorePrefixes = new Array();
  var foundUsedSubform = false;
  var key;
  if (source != (void 0))
  {
    // Find if there's any prefix that matches
    for (key in subforms)
    {
      if (source.indexOf(key + ":") == 0)
      {
        foundUsedSubform = true;
        break;
      }
    }

    // Build up all prefixes that don't match
    for (key in subforms)
    {
      if (source.indexOf(key + ":") != 0)
      {
        if ((foundUsedSubform) || (subforms[key] == 1))
          ignorePrefixes.push(key + ":");
      }
    }
  }

  // We check for any relevent validation failures here, not just validations.
  // If a validation has been run on one field in the form (e.g. an onBlur), we
  // still need to run every other validation. However, if that one validation
  // failed, the user has seen one alert, don't bug them with a second til they
  // have fixed the first error.
  if (validators && !_recentValidation(true))
  {
    for (var id in validators)
    {
      if(_getElementById(document, id) == null)
      {
          continue;
      }

      var isIgnored = false;
      // If this field is one that's specifically being ignored,
      // then don't validate here.
      for (var j = 0; j < ignorePrefixes.length; j++)
      {
        if (id.indexOf(ignorePrefixes[j]) == 0)
        {
          isIgnored = true;
          break;
        }
      }

      if (isIgnored)
        continue;

      // get the current form element to validate
      var currInput = _getFormElement(form, id);

      // Make sure we have a non-null input control.  It is possible
      // that in rich client environments the DOM for the input
      // control may have been temporarily removed from the document.
      // If we don't find DOM for the current input, move on to the
      // next input.

      // todo: Should also check for visibility of currInput, since
      //       rich client may have "hidden" the input, in which case
      //       validation shouldn't fire.
      if (!currInput)
        continue;

      //Initialize the failure array for this input
      var inputFailures = new Array();

      var descriptor = validators[id];
      var label = descriptor.label;

      // if currInput is an array then multiple elements have the same name.
      // Only the first will be validated as subsequent values should be in sync
      var elementType = currInput.type;

      if (!elementType && currInput.length)
      {
        var firstType = currInput[0].type;
        if (firstType != "radio" && firstType != "checkbox")
        {
          currInput = currInput[0];
        }
      }

      var value = _getValue(currInput);
      var required = descriptor.required;
      if ( required && ((value == "" ) || (value == null)))
      {

        // get the formatted error string for the current input and
        var requiredErrorString = _getErrorString(currInput, label,
                                                  descriptor.requiredFormat);

        // Populate the failureMap with the current error
        inputFailures[inputFailures.length] =
            new TrFacesMessage(requiredErrorString, requiredErrorString);
      }
      else
      {
        var converterConstructor = descriptor.converter;

        // set the converterError var to false for each input, otherwise nothing
        // after the first conversion error is validated
        var converterError = false;

        if ( converterConstructor )
        {

          // do the conversion if this element has a value
          if ((value != null) &&
              !((typeof value == "string") && (value == "")))
          {
            var converter = eval(converterConstructor);
            try
            {
              value = converter.getAsObject(value, label);
            }
            catch (e)
            {
              converterError = true;
              // Populate the failureMap with the current error
             if (_agent.isPIE || _agent.isNokiaPhone || _agent.isBlackBerry)
             {
               inputFailures[inputFailures.length] = e.message;
             }
             else
             {
               inputFailures[inputFailures.length] = e.getFacesMessage();
             }
            }
          }
        }

        if ( converterError == false)
        {
          var validatorArray = descriptor.validators;
          if (validatorArray)
          {
            for ( var j = 0; j < validatorArray.length; j = j + 1)
            {
              // do the validation if this element has a value
              // Don't just compare against "", since the value has
              // already been converted to a non-string type
              if ((value !== null) &&
                  !((typeof value == "string") && value == ""))
              {
                // evaluate the validator
                var validatorConstructor = validatorArray[j];
                if (validatorConstructor && value !== undefined)
                {
                  var validator = eval(validatorConstructor);

                  try
                  {
                    validator.validate(value, label, converter);
                  }
                  catch (e)
                  {
                    // Populate the failureMap with the current error
                    if (_agent.isPIE || _agent.isNokiaPhone || _agent.isBlackBerry)
                    {
                      inputFailures[inputFailures.length] = e.message;
                    }
                    else
                    {
                      inputFailures[inputFailures.length] = e.getFacesMessage();
                    }
                  }
                }
              }
            }
          }
        }
      }

      // if there were failures, then add the current input to the failuresMap
      if (inputFailures.length > 0)
      {
        // TRINIDAD-123: Use input 'name' from validators array rather than currInput.id
        // to avoid issues with radio buttons having numeric id suffixes
        failureMap[id] = inputFailures;
      }
    }
  }

  return failureMap;
}


function _getGlobalErrorString(
  input,
  errorFormat,
  errorString,
  label
  )
{
  var form = _getForm(input);
  if (errorFormat && label != null)
  {
    return _formatErrorString(errorFormat,
                             {
                               "0":label,
                               "1":errorString
                             });
  }

  return errorString;
}


/**
 * Returns true if the element is visible such that it could
 * receive focus or have its value selected, otherwise false.
 */
 function _isShowing(
   input)
 {
   //PH: removed !input.focus because firstly, focus() function is supported by
   //all browsers (PIE,IEM,BB,FF,IE) and secondly, _isShowing should be treated
   //as a function to test visibility only. If there is a case where one really
   //wants to test whether focus function exists or not, do it in an if
   //statement and call _isShowing within it.
   if (input.type == 'hidden')
       return false;

   // determine visibility from style information
   if (_agent.isIEGroup)
   {
     var node = input;

     // IE does not give a "computed" style, so we
     // need to walk up the DOM to get the styles
     while (node != (void 0))
     {
       computedStyle = node.currentStyle;

       if ((computedStyle != (void 0)) &&
           ( (computedStyle["visibility"] == "hidden") ||
             (computedStyle["display"] == "none")))
       {
         // node or one of its parents parents are NOT showing
         return false;
       }

       // consider parent style
       node = node.parentNode;
     }

     // node and all parents are showing
     return true;
   }

   if (_agent.isGecko || _agent.isSafari || _agent.BlackBerry)
   {
     // Radio buttons:  it'll be an array
     if (!input.ownerDocument && input.length)
       input = input[0];

     var computedStyle = input.ownerDocument.defaultView.getComputedStyle(input,
                                                                          null);

     // either of these styles will prevent focus from succeeding
     return ((computedStyle["visibility"] != "hidden") &&
             (computedStyle["display"] != "none"));
   }

   return true;
 }

/**
 * Returns the id of an input element on either IE or Netscape, dealing
 * with the fact that Netscape doesn't support IDs locally.
 */
 function _getID(
   input
   )
 {
   //VAC- bug 4205372 for PIE devices return the name of the input element
   if (_agent.isPIE)
   {
     return input.name;
   }

   // for non-Netscape return the ID directly
   var id = input.id;

   var inputType = input.type;

   if (!inputType && input.length)
     inputType = input[0].type;

   // for radio buttons, return ID of enclosing <span>
   if (inputType == "radio")
   {
     var inputParent;
     if (input.length)
     {
       inputParent = input[0].parentNode;
       if (inputParent.tagName == 'FIELDSET')
         inputParent = inputParent.parentNode;
     }
     else
     {
       inputParent = input.parentNode;
     }

     id = inputParent.id;
   }

   return id;
 }


/**
 * Returns the form of an input element on either IE or Netscape, dealing
 * with the fact that radio inputs do not directly support the form attribute.
 */
 function _getForm(
   input
   )
 {
   var form = input.form;

   if (form == (void 0))
   {
     // Try the first item of the array
     if (input.length)
     {
       form = input[0].form;
     }
   }

   return form;
 }

/**
 * Returns the element of name elementName for the given form
 */
 function _getFormElement(
   form,
   elementName)
{
  var formElement = null;
  if (_agent.isPIE)
  {
      formElement = form.elements[elementName];
  }
  else
  {
    formElement = form[elementName];
    // To support required validation on shuttle component
    if(formElement == undefined)
    {
      formElement = form.elements[elementName+":trailing:items"];
    }
  }
  return formElement;
}


/**
 * Returns the name of an input element on either IE or Netscape, dealing
 * with the fact that radio inputs do not directly support the name attribute.
 */
 function _getName(
   input
   )
 {
   var name = input.name;

   if (name == (void 0))
   {
     var inputType = input.type;

     if (!inputType && input.length)
       inputType = input[0].type;

     // for radio buttons, return ID of enclosing <span>
     if (inputType == "radio" && input.length)
     {
       name = input[0].name;
     }
   }

   return name;
 }

/**
 * Return true if the object or any of its prototypes'
 * are an instance of the specified object type.
 */
function _instanceof(
  obj,  // the object instance
  type  // the constructor function
)
{
  if (type == (void 0))
    return false;

  if (obj == (void 0))
    return false;

  while (typeof(obj) == "object")
  {
    if (obj.constructor == type)
      return true;

    // walk up the prototype hierarchy
    obj = obj.prototype;
  }

  return false;
}



/**
 * Return the formatted error string for an input field
 * and an errorFormatIndex
 */
function _getErrorString(
  input,
  label,
  defaultErrorFormat,
  validationError
  )
{
  var errorFormat;

  var form = _getForm(input);
  var value = _getValue(input);

  // use the message embedded in the validationError, if any
  if (_instanceof(validationError, window["TrConverterException"]))
  {
    errorFormat = validationError.getFacesMessage().getDetail();
  }
  // use the message embedded in the validationError, if any
  else if (_instanceof(validationError, window["TrValidatorException"]))
  {
    errorFormat = validationError.getFacesMessage().getDetail();
  }
  else
  {
    errorFormat = defaultErrorFormat;
  }

  if (errorFormat)
  {
    // format the error string, replacing the following tokens
    //   {0}    the value of the label
    //   {1}    the value of the input element
    var errorString = _formatErrorString(errorFormat,
                                         {
                                           "0":label,
                                           "1":value
                                         });
    // return the error
    return errorString;
  }
}




/**
 * Returns the array of form validators.
 */
function _getValidators(
  form
  )
{
  return window["_" + _getJavascriptId(_getFormName(form)) + "_Validators"];
}



/**
 * Performs token replacement on the the error format, replacing each
 * token found in the token Object with the value for that token.
 */
function _formatErrorString(
  errorFormat, // error format string with embedded tokens to be replaced
  tokens       // tokens Object containin token names and values to be replaced
  )
{
  var currString = errorFormat;

  // loop through all of the tokens, replacing them if they are present
  for (var currToken in tokens)
  {
    var currValue = tokens[currToken];

    // if the token has no value
    if (!currValue)
    {
      currValue = "";
    }

    // TRINIDAD-829:
    // we replace '{' and '}' to ensure, that tokens containing values
    // like {3} aren't parsed more than once...
    // Only do this if it is typeof string (see TRINIDAD-873)
    if (typeof currValue == "string")
    {
    currValue = currValue.replace("{","{'");
    currValue = currValue.replace("}","'}");
    }

    // the tokens are delimited by '{' before and '}' after the token
    var currRegExp = "{" + currToken + "}";

    // support tokens of the form %token% as well as {token}
    currString = currString.replace(new RegExp('%' + currToken + '%', 'g'),
                                    currRegExp);

    // Replace the token.  Don't use String.replace, as the value may
    // include dollar signs, which leads Netscape astray (bug 2242675)
    var indexOf = currString.indexOf(currRegExp);

    if (currValue.indexOf && currValue.indexOf(currRegExp) >= 0)
    {
     var b1 = '';
     for (i=0; i<currValue.length; i++)
     {
       b1 = b1 + 'placeHolderString';
     }

     while (indexOf >= 0)
    {
      currString=(currString.substring(0,indexOf)
           + b1
           + currString.substring(indexOf+currRegExp.length));
      indexOf = currString.indexOf(currRegExp);
    }

    indexOf = currString.indexOf(b1);

    while (indexOf >= 0)
    {
      currString =(currString.substring(0,indexOf)
           + currValue
           + currString.substring(indexOf+b1.length));
      indexOf = currString.indexOf(b1);
    }
  }
  else
    while (indexOf >= 0)
    {
      currString = (currString.substring(0, indexOf)
                      + currValue
                      + currString.substring(indexOf + currRegExp.length));
      indexOf = currString.indexOf(currRegExp);
    }
 }

  // TRINIDAD-829:
  // we finally re-replace the '{' and '}'...
  while(currString.indexOf("{'")!=-1)
  {
    currString= currString.replace("{'","{");
    currString= currString.replace("'}","}");
  }

  // And now take any doubled-up single quotes down to one,
  // to handle escaping
  var twoSingleQuotes = /''/g;

  return currString.replace(twoSingleQuotes, "'");
}


/**
 * Chain two functions together returning whether the default
 * event handling should occur
 */
function _chain(
  evh1,        // event handler 1 string
  evh2,        // event handler 2 string
  target,      // target of event
  event,       // the fired event
  shortCircuit // shortcircuit if handler 1 false
  )
{
  return _chainMultiple([evh1, evh2], target, event, shortCircuit);
}

/**
 * Chain two or more functions together returning whether the default
 * event handling should occur
 */
function _chainMultiple(
  eventHandlers, // Array of event handler JavaScript strings
  target,        // target of event
  event,         // the fired event (or null)
  shortCircuit   // shortcircuit if handler 1 false
  )
{
  var overallResult = true;
  for (var i = 0, size = eventHandlers.length; i < size; ++i)
  {
    var result = _callChained(eventHandlers[i], target, event);
    if (result === false)
    {
      if (shortCircuit)
      {
        return false;
      }
      overallResult = false;
    }
  }

  return overallResult;
}

function _callChained(
  handler,
  target,
  event
  )
{

  if (handler && (handler.length > 0))
  {
    // handle ie case, where we have no event parameter

    if( (typeof(event) == 'undefined') || (event == (void 0) ) )
    {
      event = window.event;
    }

    // create function so that "return" is handled correctly,
    // use event parameter so that both ie and netscape
    // functions work
    var func = new Function("event", handler);
    var result;

    // WindowsMobile 5 doesn't support installing Funtion object
    // to "this", so just invoke the Function object instead.
    if (_agent.isPIE)
    {
      result = func(event);
    }
    else
    {
      // install the function on the object so that "this" is
      // handled correctly
      target._tempFunc = func;

      // evaluate the result
      result = target._tempFunc(event);

      // clear the temporary function
      target._tempFunc = (void 0);
    }

    // undefined results should be evaluated as true,
    return !(result == false);
  }
  else
  {
    return true;
  }
}

// Enforce the maximum length of a form element
// Returns true if event processing should continue, false otherwise.
function _checkLength(formElement, length, event)
{
  elementLength = formElement.value.length;
  if (elementLength > length)
  {
    // Input is longer than max, truncate and return false.
    // This takes care of the case where the user has pasted in text
    // that's too long. Return true here because the onChange event can
    // continue (now that we've truncated the value). This allows chained
    // handlers to work.
    formElement.value = formElement.value.substr(0, length);
    return true;
  }

  // If less than max length (i.e. within acceptable range), return true
  if (elementLength < length)
    return true;

  // If we've made it to here, we know that elementLength == length

  if (_agent.isIE)
  {
    // in many forms there is a hidden field named "event"
    // Sometimes IE gets confused and sends us that instead of
    // the true event, so...
    if (event["type"] == "hidden")
      event = window.event;
  }

  // If this is a change event, the field has already been updated to a string
  // of the maximum allowable length. This is fine. Continue processing.
  if (event.type == 'change')
    return true;

  // If we've made it to here, we know that this is a keyPress event

  // If the input is something less than a space (e.g. tab, CR, etc.)
  // return true.
  // If key was CTRL-v, which will be used to paste some new text,
  // pass it along.
  if (event)
  {
    if ((event.which < 32)
        || ((event.which == 118) && (event["ctrlKey"])))
      return true;
  }

  // Default return FALSE. If we're here, this is an onKeyPress event, it's a
  // printable character, and elementLength already equals the maximum allowed.
  // We need to return false here to cancel the event otherwise this last
  // character will end up in the input field in position MAX+1.
  return false;
}

/**
 * Cover for document.getElementById that works on IE 4.x
 */
function _getElementById(
  doc,
  id
  )
{
  //PH: Since BB supports getDocumentById use this to obtain the element.
  if(typeof(doc.getElementById) != 'undefined')
  {
    //
    // If we arent' on Internet Explorers before 5,
    // use the DOM way of doing this
    //
    //PH:exclude BlackBerry
    if (((_agent.kind != "ie") || (_agent.version >= 5)) && (!_agent.isBlackBerry))
    {
      var element = doc.getElementById(id);

      // IE's implementation of getElementById() is buggy.  If
      // the page contains an anchor which has the same name
      // as the requested id, IE will return the anchor, even
      // if the anchor's id attribute is not set.  So, make
      // sure that we actually get back an element with the
      // correct id.
      if ((element == null) || (element.id == id))
        return element;
      // If we get here, that means that IE has probably returned
      // an anchor instead of the desired element.  Let's scan
      // the entire DOM tree to find the element we want.
      return _findElementById(doc, id);
    }

    return doc.getElementById(id);
  }
  else if (typeof(doc.all) == 'undefined')
  {
    // Browser does not support getElementById nor DOM documnet.all object.
    // One example of such browser today is BlackBerry 4.0 browser.

    //if element is not within a form
    if(doc.forms.length == 0)
      return window[id];
    else
      //check to see if element is within the form, if so return the element else do nothing
      for(var i = 0; i<doc.forms.length; i++)
      {
        var f = doc.forms[i];
        if(f[id])
          return f[id];
      }

    //element is not within the form but form(s) is(are) present.
    return window[id];
  }
  else
  {
    // Browser does not support getElementById but supports DOM documnet.all
    // object. One example of such browser today is Windows Mobile browser.
    return doc.all[id];
  }
}

// A recursive method which searches the entire DOM tree
// to find the element with the specified ID
function _findElementById(
  node,
  id
  )
{
  // Check to see if the current node is the node
  // that we are looking for
  if (node.id == id)
    return node;

  // Check all children of the current node
  if (node.childNodes)
  {
    var childNodes = node.childNodes;
    for (var i = 0; i < childNodes.length; i++)
    {
      var foundNode = _findElementById(childNodes.item(i), id);
      if (foundNode != null)
        return foundNode;
    }
  }

  return null;
}

// Returns '?' or '&' depending on whether the
// baseURL already contains a query string
function _getQuerySeparator(baseURL)
{
  var lastChar = baseURL.charAt(baseURL.length - 1);
  if ((lastChar == '&') || (lastChar == '?'))
    return "";

  return (baseURL.indexOf('?') >= 0) ? '&' : '?';
}

/**
 * Adds a parameter to an existing URL, replacing the parameter if
 * it already exists
 */
function _addParameter(
  baseURL,
  paramName,
  paramValue
  )
{
  // check if we have parameters
  var queryIndex = baseURL.indexOf('?');

  if (queryIndex == -1)
  {
    // no parameters, so append to parameters
    return baseURL + '?' + paramName + '=' + paramValue;
  }
  else
  {
    // check if the parameter already exists
    var paramIndex = baseURL.indexOf('?' + paramName + '=', queryIndex);

    if (paramIndex == -1)
      paramIndex = baseURL.indexOf('&' + paramName + '=', queryIndex + 1);

    if (paramIndex == -1)
    {
      // parameter isn't in the URL
      return baseURL + '&' + paramName + '=' + paramValue;
    }
    else
    {
      //
      // replace the value of the parameter
      //
      // the +2 skips over the '&' or '?' and the '='
      var valueIndex = paramIndex + paramName.length + 2;

      // get the URL + the parameter
      var newString = baseURL.substring(0, valueIndex);

      // append the new value
      newString += paramValue;

      var lastIndex = baseURL.indexOf('&', valueIndex);

      if (lastIndex != -1)
      {
        // append the rest of the string after the replaced value
        newString += baseURL.substring(lastIndex);
      }

      return newString;
    }
  }
}

/**
 * Adds a parameter to the parameters object for form submission
 */
function _addFormParameter(
  parameters,
  paramName,
  paramValue
  )
{
  // Always create a new object, since we don't want to mess with
  // the caller's parameters
  var newParameters = new Object();

  // Copy over existing parameters
  if (parameters)
  {
    for (var name in parameters)
      newParameters[name] = parameters[name];
  }

  // Now set the new parameter value
  newParameters[paramName] = paramValue;

  return newParameters;
}

//
// _pprInstallBlockingHandlers: Helps implement blocking
//                              This function just installs or de-installs the
//                              event consuming handlers.
//
function _pprInstallBlockingHandlers(win, install)
{
  var doc = win.document;

  if (doc == (void 0))
    return;

  // Some mobile browser do not support attaching event listner
  // to document
  if (!doc.attachEvent && !doc.addEventListener)
  {
    return;
  }

  if (doc.attachEvent) // IE
  {
    var el = win._pprConsumeFirstClick;
    if (install)
    {
      // See comment in _pprConsumeFirstClick().
      // If the event that started this PPR chain was an onChange or onBlur,
      // AND the event location is the element on which the change happened
      // (i.e. the user didn't click somewhere outside the element)
      // then we want to make sure that the blocking starts immediately.
      var ev = win.event;
      if (ev != (void 0))
      {
        var destElt = document.elementFromPoint(ev.x, ev.y);
        if (!win._pprFirstClickPass // never attach unless passing first click
            || (((ev.type == 'change') || (ev.type == 'blur'))
                && (ev.srcElement == destElt))
            || (!_isSubmittingElement(destElt)))
        {
          _pprControlCapture(win, true);
          return;
        }
      }

      // If we're here, we didn't set up a capture.
      // For an onClick, we have to pass on the first click,
      // then we'll capture every subsequent event.
      doc.attachEvent('onclick', el);
    }
    else
    {
      doc.detachEvent('onclick', el);
      _pprControlCapture(win, false);
    }
  }
  else // Gecko or other standards based browser
  {
    var el = win._pprConsumeBlockedEvent;

    // Set up the same handler on all these events. The handler will just eat
    // the event unless it's the first click and we're passing that.
    var handlers = { 'click':1, 'keyup':1, 'keydown':1, 'keypress':1};
    for (var h in handlers)
    {
      if (install)
        doc.addEventListener(h, el, true);
      else
        doc.removeEventListener(h, el, true);
    }
  }
}

//
// _pprConsumeClick: Helps implement blocking. This function just consumes
//                   every click that falls within the body.
//
function _pprConsumeClick(event)
{
  if (_agent.isIE)
  {
    var body = document.body;
    if ((event.x < body.offsetLeft) || (event.y < body.offsetTop)
        || (event.x > body.offsetWidth) || (event.y > body.offsetHeight))
    {
      // OK, we've caught an event outside the body of the document. Assume
      // that the user is clicking somewhere on the menu bar, or another
      // window. At this point, we release the mouse and continue (that's
      // better than keeping the user in limbo).

      _pprStopBlocking(window);
    }
  }
  return false;
}


//
// _pprStartBlocking: Starts consuming every click (to implement blocking)
//
function _pprStartBlocking(win)
{
  // No blocking is performed on WM, Nokia, PPC and BlackBerry devices
  if (_agent.isPIE || _agent.isNokiaPhone || _agent.isBlackBerry)
    return;

  if (_agent.isIE)
  {
    // see TRINIDAD-952 - IE does not update the activeElement in time before
    // blocking starts. Use a timeout to allow the update.
    win._pprTimeoutFunc = win.setTimeout("_doPprStartBlocking(window);",
                                             1);
    return;
  }
  else
  {
     _doPprStartBlocking (win);
  }
}

function _doPprStartBlocking (win)
{
  // Clean up timeout set in _pprStartBlocking()
  if (win._pprTimeoutFunc)
  {
    win.clearTimeout(win._pprTimeoutFunc);
    win._pprTimeoutFunc = null;
  }

  // In order to force the user to allow a PPR update to complete, we
  // block all mouse clicks between the start of a PPR update, and the end.
  // We do this by building a dummy DIV element and having it grab all clicks.
  // On Mozilla, we just expand it to cover the entire body as a glass frame.
  // On IE, we leave the DIV at zero size, but route every click to it.
  if (!win._pprBlocking)
  {
    var body = win.document.body;
    win._pprBlockStartTime = new Date();

    // XXXSafari: What to do for Safari? Safari will probably work like gecko,
    //            but... need to check.
    if (_agent.isGecko)
    {
      // If the user clicks the stop button, then we'll be stuck blocking.
      // So we don't hang, this timeout will clear the block in eight
      // seconds whether we've finished or not, but first we clear any
      // previously existing timeout.
      if (win._pprBlockingTimeout != null)
      {
        win.clearTimeout(win._pprBlockingTimeout);
      }
      win._pprBlockingTimeout = win.setTimeout("_pprStopBlocking(window);",
                                               8000);
    }
    else if (_agent.isIEGroup)
    {
      // save off the element we'll return focus to
      _pprEventElement = window.document.activeElement;
    }
    _pprInstallBlockingHandlers(win, true);
    win._pprBlocking = true;
  }
}

//
// _pprStopBlocking: Finishes up the blocking, releases the page back
//                   to normal processing
//
function _pprStopBlocking(win)
{
  // see TRINIDAD-1833. If _pprStartBlocking() was delayed with setTimeout(),
  // we need to clear it here. Otherwise _pprStartBlocking() will be called later,
  // and will end up winning
  if (win._pprTimeoutFunc)
  {
    win.clearTimeout(win._pprTimeoutFunc);
    win._pprTimeoutFunc = null;
  }
  // No blocking is performed on Nokia, PPC and BlackBerry devices
  if (_agent.isPIE || _agent.isNokiaPhone || _agent.isBlackBerry)
    return;

  var doc = win.document;

  if (win._pprBlocking)
  {
    // XXXSafari: What to do for Safari? Safari will probably work like gecko,
    //            but... need to check.
    if (_agent.isGecko)
    {
      // If we've set a timeout, clear it now.
      if (win._pprBlockingTimeout != null)
      {
        win.clearTimeout(win._pprBlockingTimeout);
        win._pprBlockingTimeout == null;
      }
    }
    // and turn off the event capture
    _pprInstallBlockingHandlers(win, false);

    win._pprEventElement = null;
    win._pprBlocking = false;
  }
  win._pprBlocking = false;
}

/*
 * After updates we often can't just set focus to a node, it has to be prepared
 * in a browser specific way (different idosyncracies cause poor focus
 * behavior).
 */
function _pprFocus(node, doc)
{
  if (_agent.isIEGroup)
  {
    // If the node's parent has changed through a DOM update then
    // this node hasn't been fully added to the tree yet so we
    // can't set focus to it.
    if (node.parentNode == null)
      return;

    // On IE, if a node has focus and we update it, then setting focus to it
    // seems to have no effect. Setting the focus to another node, then back to
    // the target seems to work correctly. Here we set the focus to a hidden
    // field.
    var divnode = _getElementById(doc, _pprdivElementName);
    if ((divnode) && (divnode["focus"]))
      divnode.focus();
  }
  node.focus();
}

//
// _pprConsumeBlockedEvent: Helps implement blocking. This function attached
//                          as the event handler. It just consumes every event
//                          it gets.
//
//                          This function is used on standards based browsers.
//
function _pprConsumeBlockedEvent(evt)
{
  var rv = true;

  if (_pprBlocking)
  {
    var blockTheEvent = true;

    if (window._pprFirstClickPass)
    {
      var newDate = new Date();
      var diff = newDate - _pprBlockStartTime;

      // If we've got a click on a button (or an image within a link that does
      // a submit), less than 150ms after the beginning of a PPR update, assume
      // the user has started an onChange type event with a click on a button.
      // This addresses the problems that people were seeing, but could cause
      // overlapping PPR events in rare cases.
      var delay = 150;
      if ((diff < delay) && (evt.type == 'click'))
      {
        // To try to further limit the overlaps, we only allow clicks on
        // buttons, or images that will cause a submit to go through.
        // get the target of the click
        var orig = evt.explicitOriginalTarget;
        // this function is never called on IE, but if it were, this would be:
        // var orig = (_agent.isIE
        //            ? evt.srcElement
        //            : evt.explicitOriginalTarget);
        blockTheEvent = ! _isSubmittingElement(orig);
      }
    }
    if (blockTheEvent)
    {
      // just swallow the event
      evt.stopPropagation();
      evt.preventDefault();
      rv = false;
    }
  }
  return rv;
}


//
// _pprConsumeFirstClick: Helps implement blocking.
//
// On IE, the capture doesn't allow us to hand off the first click - we can
// only eat it, but attachEvent only allows us to do something with the event
// AFTER it's been delivered to the element. There's no way to make a decision
// whether or not to deliver a particular event. Therefore, since we want to
// deliver the first click, and block everything else, we attachEvent using
// this handler. This handler then just immediately switches over the the
// capture. This function is only used on IE.
//
function _pprConsumeFirstClick(event)
{
  // This is an IE only function
  if (_agent.isIE)
  {
    // switch over to capture
    _pprControlCapture(window, true);
    // and remove this one-time function
    window.document.detachEvent('onclick', _pprConsumeFirstClick);
  }
  return false;
}


//
// _pprControlCapture: Set up the pprDivElement to capture all
//                     mouse events. It will then ignore them.
//
function _pprControlCapture(win, set)
{
  // This is an IE only function
  if (_agent.isIE)
  {
    var doc = win.document;
    var body = doc.body;
    var divElement = _getElementById(doc, _pprdivElementName);
    if (divElement)
    {
      if (set)
      {
        divElement.setCapture();
        // If we've got an element to return focus to,
        // then capture keyboard events also.
        if (win._pprEventElement)
          divElement.focus();
        // save current cursor and display a wait cursor
        win._pprSavedCursor = body.style.cursor;
        body.style.cursor = "wait";
        win._pprSavedCursorFlag = true;
      }
      else if (win._pprSavedCursorFlag)
      {
        divElement.releaseCapture();

        // return focus to the post-PPR target element
        if (win._pprEventElement)
          win._pprEventElement.focus();
        body.style.cursor = win._pprSavedCursor;
        win._pprSavedCursor = null;
        win._pprSavedCursorFlag = false;
      }
    }
  }
  return;
}

// handle the onClick or onBlur for an IE SELECT element
// Returns true if the user has finally made a selection, and is ready to go.
function _pprChoiceAction()
{
  // this function is only needed to handle IE's weird select element
  if (!_agent.isIE)
    return true;

  var rv = false;

  // This gets called as both onClick and onBlur, but both really only want
  // to submit the event if a change has been made.
  if ((!window._pprBlocking) && (_pprChoiceChanged))
  {
    // clear the choice tracker
    _pprChoiceChanged = false;
    rv = true;
  }
  return rv;
}

// handle the onChange for an IE SELECT element
function _pprChoiceChangeEvent(event)
{
  if (!_agent.isIE)
    return true;

  // Just remember the fact that a change has occurred.
  if (!window._pprBlocking)
    _pprChoiceChanged = true;

  return true;
}


// Tests whether a partial submit should be performed
function _supportsPPR()
{
  return !_agent.pprUnsupported;
}


// Fires a PPR request entirely as a GET operation
function _firePartialChange(url)
{
  // FIXME: shouldn't be using a private method on TrPage - this should
  // really be made into a public API on TrPage
  var page = TrPage.getInstance();
  var queue = page.getRequestQueue();
  queue.sendRequest(
    page, page._requestStatusChanged, url);
}

// Fires a partial page request via form submission.
// The args are the same as submitForm().  The
// partialTargets are passed in as parameters
function _submitPartialChange(
  form,
  doValidate,
  parameters,
  event)
{
  // If there's no PPR iframe, then just perform a normal,
  // full-page submission.
  if (!_supportsPPR())
    return submitForm(form, doValidate, parameters);

  // Get the actual form object
  if ((typeof form) == "string")
    form = document[form];

  if (!form)
    return false;

  // Tack on the "partial" event parameter parameter
  parameters = _addFormParameter(parameters, "partial", "true");

  // block all mouse clicks until the submit is done
  _pprStartBlocking(window);

  // Submit the form
  var submitted = submitForm(form, doValidate, parameters, true, event);

  // If the form wasn't actually submitted, update the ref count
  if (!submitted)
  {
    _pprStopBlocking(window);
  }
}

/* If the Trinidad facility needs to set focus to a particular node after a PPR
 * update, calling this function saves off the data needed to find that node
 *
 * Args:
 *    doc : The document that the node lives in
 * nodeid : The id attached to the desired node
 *   next : If true, we'll try to focus on the node following the one above,
 *          otherwise, we'll try to focus on the requested node.
 */
function _setRequestedFocusNode(doc, nodeid, next, win)
{
  // degenerate case - default to something that won't cause an error
  if (!win)
    win = window;

  // we only allow one outstanding focus request
  win._TrFocusRequestDoc = doc;
  win._TrFocusRequestID = nodeid;
  win._TrFocusRequestNext = (next == true);
}


/* If a request was made to focus on a particular node, this function will
 * attempt to get that node.
 */
function _getRequestedFocusNode(win)
{
  // degenerate case - default to something that won't cause an error
  if (win == (void 0))
    win = window;

  if ((win._TrFocusRequestDoc != null)
      && (win._TrFocusRequestID != null))
  {
    var element = _getElementById(win._TrFocusRequestDoc,
                                  win._TrFocusRequestID);
    if (!element)
      return null;

    if (win._TrFocusRequestNext)
    {
      // If "next" was set, the caller doesn't want this node, but the next
      // one. Try to find something that'll accept focus.
      for (var next = element.nextSibling;
           next != null;
           next = next.nextSibling)
      {
        if (_isFocusable(next)
            // we actually DO want to "tab" to links
            || ((_agent.isIE) && (next.nodeName.toLowerCase() == 'a')))
        {
          element = next;
          break;
        }
      }
    }
    return element;
  }
  return null;
}



// Returns the first focusable node under the specified node
function _getFirstFocusable(node)
{
  if ((node == null) || _isFocusable(node))
    return node;

  if (node.hasChildNodes)
  {
    var children = node.childNodes;
    for (var i = 0; i < children.length; i++)
    {
      var child = children[i];
      var firstFocusable = _getFirstFocusable(child);
      if (firstFocusable != null)
        return firstFocusable;
    }
  }

  return null;
}

// Restores the focus to the specified node
function _restoreFocus(node, isFirstFocusable, doc)
{
  if (node == null)
    return;

  // If we are in a scrolled DIV, restoring the focus to the
  // first focusable node may cause the DIV to scroll back to 0,0.
  // So, for now we just avoid restoring the focus in this situation.
  // In the future we should see less cases where scrolling occurs,
  // since we should do a better job locating the correct node to
  // receive the focus.
  var divNode = _getAncestorByName(node, "DIV");
  if (!divNode)
  {
    _pprFocus(node, doc);
  }
  else
  {
    var scrollTop = divNode.scrollTop;
    var scrollLeft = divNode.scrollLeft;

    // If we aren't scrolled at all, or if we are restoring the
    // focus to the correct focusable owner (and not just the
    // first focusable node), then restore the focus.  Otherwise,
    // we do nothing, in order to avoid unnecessary scrolling.
    if (((scrollTop == 0) && (scrollLeft == 0)) || !isFirstFocusable)
    {
      _pprFocus(node, doc);
    }
  }

  // Bug #2753958: IE doesn't seem to want to re-set the focus when we're
  // done with a PPR update if the input element happens to be enclosed
  // within a table. However, if we make a second request, the focus is set
  // correctly. This is limited to the one interesting case.
  if ((_agent.isIE)
      && (node.tagName == 'INPUT')
      && (_getAncestorByName(node, 'TABLE')))
  {
    _pprFocus(node, doc);
  }
}

// Returns an ancestor with the specified name
function _getAncestorByName(
  node,
  ancestorName
  )
{
  ancestorName = ancestorName.toUpperCase();

  while (node)
  {
    if (ancestorName == node.nodeName)
      return node;

    node = node.parentNode;
  }

  return null;
}

// Tests whether one node is a descendent of another
function _isDescendent(
  node,
  ancestorNode
  )
{
  if (node == null)
    return false;

  while (node.parentNode)
  {
    if (node == ancestorNode)
      return true;

    node = node.parentNode;
  }

  return false;
}

// Tests whether the specified node is focusable
function _isFocusable(node)
{
  if (node == null)
    return false;

  var name = node.nodeName.toLowerCase();

  // Links that have a destination are generally focusable
  if (('a' == name) && (node.href))
  {
    // We need to be careful on IE - it seems that
    // IE has problems setting the focus to links
    // which contain a single image.  We see this when
    // IE tries to set the focus to the link around the
    // previous icon in the table.  Actually, this does
    // not seem to be a problem if the link has its
    // id set, so we first check for that.

    // If we're not on IE, or if the link has an id,
    // the link should be focusable
    if (!_agent.isIE || (node.id))
      return true;

    // If we're on IE, we only consider the link to be
    // focusable if it has something other than a single
    // image for its contents.
    var children = node.childNodes;
    if ((children) && (children.length == 1))
    {
      var childName = children[0].nodeName;
      if ('img' == childName.toLowerCase())
        return false;
    }

    return true;
  }

  // Blow off any disabled elements
  if (node.disabled)
    return false;

  // Input elements are also usually focusable
  if ('input' == name)
  {
    // But don't set the focus to hidden fields
    return (node.type != 'hidden');
  }

  // Catch everything else here...
  return (('select' == name) ||
          ('button' == name) ||
          ('textarea' == name));
}

// Evaluates the specified code in the target window
function _eval(targetWindow, code)
{
  if (code == null)
    return;

  // For IE, we use window.execScript().  For Mozilla, we use
  // window.eval().  It would be nice if we could use eval() on
  // IE too, but IE's implementation of eval() always executes
  // the script in the current context, even if some other
  // window is specified.
  if (_agent.isIEGroup)
  {
    targetWindow.execScript(code);
  }
  else
    targetWindow.eval(code);
}

/**
 * Called to identify the input field from an event
 * This is called not only below, but also from LovInput.js.
 */
function _getInputField(event)
{
  var input = (void 0);
  var src = (void 0);

  if (window.event)
  {
    kc = window.event.keyCode;
    src = window.event.srcElement;
  }
  else if (event)
  {
    kc = event.which;
    src = event.target;
  }

  if (src != (void 0)
      && (src.tagName == "INPUT" ||
          src.tagName == "TEXTAREA" ))
    input = src;

  return input;
}

/**
 * Called when a field receives focus.
 * Prepares for a later reset of this field by saving its current value.
 */
function _enterField(
  event
  )
{
  var input;
  var src;
  var retv = true;

  var input = _getInputField(event);

  if (input != (void 0))
  {
    input.form._mayResetByInput = false;
    // save the last valid value for later restoration
    input._validValue = input.value;
    retv = false;
  }

  return retv;
}

/**
 * Resets the form input to its last valid value.
 * This function is called from the onKeyDown for a form input.
 * If called twice in succession for the same form, with the
 * escape keycode both times, this function will reset the form.
 */
function _resetOnEscape(event)
{
  var kc;
  var input = _getInputField(event);

  if (input != (void 0))
  {
    var form = input.form;

    if (kc == 27)  // escape keycode
    {
      // reset the form input to its last valid value
      // providing there is no selection (consistent with IE)

      var hasSelection = false;

      if ((input.selectionStart != (void 0)) &&
          (input.selectionEnd   != (void 0)))
      {
        hasSelection = (input.selectionStart != input.selectionEnd);
      }
      else if (document.selection)
      {
        hasSelection = (document.selection.createRange().text.length != 0);
      }

      if (!hasSelection)
      {
        // always reset the field
        input.value = input._validValue;

        // determine if a full form reset is required
        if (form._mayResetByInput == true)
        {
          // reset the form
          // unset the flag for form reset
          form.reset();
          form._mayResetByInput = false;
        }
        else
        {
          // set the flag for form reset
          form._mayResetByInput = true;
        }
      }

      // consume this event to prevent any browser behavior from kicking in
      return false;
    }
    else // any keycode other than escape
    {
      // unset the flag for form reset
      // since some other key was pressed
      form._mayResetByInput = false;
    }
  }
  return true;
}

/**PH:  Currently, if a browser supports PPR, the _checkLoad function
 * is set as the body onload to perform some initialization, both PPR related
 * and not (such as setting the initial focus).
 * Because this function was not called for non-PPR browsers (like BlackBerry
 * 4.0), the non-PPR initialization was not happening on those browsers.
 * Therefore, I created another function called _checkLoadNoPPR to handle
 * non-PPR related initialization, such as setting the initialFocus, and
 * set the body onload to this method for browsers that do not support PPR.
 */
function _checkLoadNoPPR()
{
  if(_initialFocusID != null)
    _setFocus(_getElementById(document,_initialFocusID));
  _agent.pprUnsupported = true;
}

/**
 * Called by the load handler of each document body to prepare event handlers
 * for forms, etc.
 */
function _checkLoad()
{
  // set focus to the window if a dialog. This fixes the bug where our dialog
  // windows don't have focus, so the first keystroke is ignored. 3544304
  // if I used window.focus(), I caused this bug 3876472 -
  // PAGES COME TO THE FOREGROUND WHEN THE PAGE LOADS
  // We are using _pprdivElementName cuz we need an empty div to set focus
  // to. If we get rid of this element, we'll need to set focus to
  // another element that we know is always on the page.

  // This was causing focus to go off and NEVER COME BACK in the shopping cart
  // demo. I think we can limit this to just a dialog if we can detect that
  // we're in one. For now, we'll have to live with the extra keystroke.
  /*
  if (_agent.isIE)
  {
    var divElement = _getElementById(document, _pprdivElementName);
    if (divElement && divElement.focus)
      divElement.focus();
  }
  */

  // IE has a document.activeElement property. Most other
  // browsers do not (though Firefox 3.0 will).
  if (!_agent.isIEGroup && document.addEventListener)
  {
    document.addEventListener("keyup", _trTrackActiveElement, false);
    document.addEventListener("mousedown", _trTrackActiveElement, false);
  }

  if (document.forms)
  {
    for (var i = 0; i < document.forms.length; i++)
    {
      var form = document.forms[i];

      // Note: event listener functions must already be defined above
      //       no forward references
      if (form.addEventListener) // DOM events
      {
        form.addEventListener('focus', _enterField, true);
        form.addEventListener('keydown', _resetOnEscape, true);
      }
      else if (form.attachEvent) // IE5 events
      {
        form.attachEvent('onfocusin', _enterField);
        form.attachEvent('onkeydown', _resetOnEscape);
      }
    }
  }

  // If we're inside a frameset, and the top frame wants
  // reloads blocked, install a _noReload handler.
  var topWindow = _getTop(self);

  if ((self != topWindow) && topWindow["_blockReload"])
  {
    document.onkeydown = _noReload;
  }

  // Set initialFocus if necessary
  if ((!_agent.isNav) && (_initialFocusID != null))
  {
    var myElement = _getElementById(document,_initialFocusID);

    //PH: Set Focus on element for all browsers.
    if(myElement)
      _setFocus(myElement);
  }

  // Initialize ourselves if we're in a PopupDialog except for Nokia
  if (!_agent.isNokiaPhone)
  {
    TrPopupDialog._initDialogPage();
  }
}


function _getActiveElement()
{
  if (document.activeElement)
    return document.activeElement;
  return window._trActiveElement;
}

function _trTrackActiveElement(e)
{
  window._trActiveElement = e.target;
}

//
// Event handle that blocks keys that lead to a page reloading.
//
function _noReload(e)
{
  if (!e) e=window.event;
  var kc=e.keyCode;
  // F5 and Ctrl-R
  if ((kc==116)||(kc==82 && e.ctrlKey))
  {
    if (e.preventDefault) e.preventDefault();
    e.keyCode=0;
    return false;
  }
}


//
// Deliver a client event with the specified type, source and parameters
// to the handler body.
//
function _handleClientEvent(type, source, params, handlerBody)
{
  var event = new Object();
  event.type = type;
  event.source = source;
  event.params = params;
  var func = new Function("event", handlerBody);
  return func(event);
}


//
// APIs dealing with cookies.  We currently have no supported
// public functions.  _getCookie() and _setCookie() are good candidates.
//

function _getCookie(name)
{
  var dc = document.cookie;

  var value = "";
  var prefix = name + "=";
  if (dc)
  {
    // Look for the cookie name in in the middle.
    var begin = dc.indexOf("; " + prefix);

    if (begin < 0)
    {
      // Not there: look for it at the beginning
      begin = dc.indexOf(prefix);
      if (begin > 0)
        begin = -1;
    }
    else
      // Found it - now skip over the colon and space
      begin += 2;

    if (begin >= 0)
    {
      var end = dc.indexOf(";", begin);
      if (end < 0)
        end = dc.length;

      value = unescape(dc.substring(begin + name.length + 1, end));
    }
  }

  return value;
}

//
// Sets a cookie value.
// This function isn't especially general (yet) as it doesn't
// allow overriding the domain, path, or expiry.
//
function _setCookie(name, value)
{
  // Compute the domain to scope as widely as is legit
  // by scoping off.
  // =-=AEW "localhost" just doesn't work.  I don't know how to
  // deal with this...  It'll confuse developers, even though
  // it will never have any real impact.
  var domain = window.location.host;

  /* =-=AEW The current Oracle Cookie design guidelines require
     cookies to _not_ be scoped widely.  So don't!
  var periodIndex = domain.indexOf(".");
  if ((periodIndex >= 0) &&
      (domain.lastIndexOf(".") != periodIndex))
  {
    // But don't scope off anything that's entirely a number,
    // since then we're probably dealing with an IP address
    var startOfDomain = domain.substr(0, periodIndex);
    if (!(((startOfDomain * startOfDomain) == 0) ||
          ((startOfDomain / startOfDomain) == 1)))
      domain = domain.substr(periodIndex);
  }
  */

  var colonIndex = domain.indexOf(":");
  if (colonIndex >= 0)
    domain = domain.substr(0, colonIndex);

  // Expire 10 years after today
  var expires = new Date();
  expires.setFullYear(expires.getFullYear() + 10);

  // And here's the cookie:
  // (Reordering the parameters seemed to break some browsers)
  var curCookie = name + "=" + value +
      "; path=/;domain=" + domain + "; expires=" + expires.toGMTString();

  document.cookie = curCookie;
}


//
// Compute the time zone ID, of form GMT+-XX:YY
//
function _getTimeZoneID()
{
  // Get the time zone offset, then flip the sign, as this
  // is opposite in meaning to the time zone ID
  var tzOffset = -(new Date()).getTimezoneOffset();
  var newTZ;

  // Build up the name of the time zone
  if (tzOffset > 0)
    newTZ = "GMT+";
  else
  {
    newTZ = "GMT-";
    tzOffset = -tzOffset;
  }

  var minutes = "" + tzOffset % 60;
  if (minutes.length == 1)
    minutes = "0" + minutes;
  return (newTZ + (Math.floor(tzOffset / 60)) + ":" + minutes);
}


//
// Returns true if the current document reads left to right.
//
function _isLTR()
{
  return document.documentElement["dir"].toUpperCase() == "LTR";
}


//
// _isSubmittingElement : Is the given element likely to submit?
//
function _isSubmittingElement(element)
{
  var isSub = false;
  var eltype = element.nodeName.toUpperCase();
  // Assume any button click is wanted
  if (eltype == "BUTTON")
  {
    isSub = true;
  }
  else if (eltype == "IMG")
  {
    // If the click was on an image, check to see if the image
    // is inside a link element.
    var pnode = element.parentNode;
    var ptype = pnode.nodeName.toUpperCase();
    if (('A' == ptype) && (pnode.href))
    {
      // OK, it's a link, now check if the onClick goes to one of our
      // submit functions.
      var oc = "" + pnode["onclick"];
      if ((oc != (void 0)) && (oc != null))
      {
        isSub = ((oc.indexOf("submitForm") > 0)
                 || (oc.indexOf("_uixspu") > 0)
                 || (oc.indexOf("_adfspu") > 0)
                 || (oc.indexOf("_addRowSubmit") > 0));
      }
    }
  }
  return isSub;
}



// Get the keycode from an event
function _getKC(event)
{
  if (window.event)
    return window.event.keyCode;
  else if (event)
    return event.which;
  return -1;
}


// Returns true if a form has been submitted a "short" time before newDate
function _recentSubmit(newDate)
{
  if (_lastDateSubmitted)
  {
    var diff = newDate - _lastDateSubmitted;
    if ((diff >= 0) && (diff < 200))
      return true;
  }
  return false;
}

// Returns true if a form has been reset a "short" time before newDate
function _recentReset(newDate)
{
  if (_lastDateReset)
  {
    var diff = newDate - _lastDateReset;
    if ((diff >= 0) && (diff < 200))
      return true;
  }
  return false;
}

function _radioSet_uixspu(f,v,e,s,pt,p,o)
{
  _radioSet_adfspu(f,v,e,s,o);
}

function _radioSet_adfspu(f,v,e,s,o)
{
  if (window._pprBlocking)
    return;

  // Once again we've got timing issues. When the user clicks on the
  // text of a radio button, we get an onClick for the enclosing span before we
  // get the onClick for the button itself. This wouldn't be so bad if the
  // selected state was already changed, but it isn't. So we have to send the
  // second click if there is one, otherwise we have to send the first (only)
  // click. There's already code in submitForm to check for multiple submits
  // within 200ms, so we just send the first click after waiting 200ms.
  //
  // Of course the obvious answer to this is to use onChange instead of
  // onClick, but IE doesn't deliver onChange events to the container

  if (_pendingRadioButton)
  {
    // This is the second onClick call. We want to run the call to adfspu.
    // Eventually submitform will be called, do a submit, and set the
    // _lastDateSubmitted.

    // clear the pending flag for next time
    _pendingRadioButton = false;
    // and call
    _adfspu(f,v,e,s,o);
  }
  else
  {
    // This is the first click.

    // Remember that we've got a pending click.
    _pendingRadioButton = true;

    // Now build up a string representation of the call,
    // and put it into a timeout.

    // clear the pending flag for next time - in case there was no second click.
    var spucall = "_pendingRadioButton=false;_adfspu(";
    // Form
    if ((f != (void 0)) && (f != null))
      spucall += "'" + f + "'";
    spucall += ",";
    // Validation
    if (v != (void 0))
      spucall += v;
    spucall += ",";
    // Event
    if ((e != (void 0)) && (e != null))
      spucall += "'" + e + "'";
    spucall += ",";
    // Source
    if ((s != (void 0)) && (s != null))
      spucall += "'" + s + "'";

    // RadioSet does not pass an object
    spucall += ");";
    window.setTimeout(spucall, 200);
  }
}

/** This function is called from _spinboxRepeat.
 * This function increments or decrements the value that is in the
 * input field by the stepSize. If the max/min is reached, check circular.
 * If circular is true, then circle the number around.
 * we default circular for now, because we do not support it yet.
 * Else, stop at the max or min.
 */
function _stepSpinboxValue(id, increment, stepSize, min, max)
{
   var circular = false;
   var input = _getElementById(document, id);
   if (input)
   {
      var value = input.value;
      if (isNaN(value) || isNaN(stepSize) || isNaN(min) || isNaN(max))
      {
        alert("value, stepSize, min, and max must all be numbers. value: "+
               value+", stepSize: "+stepSize+", min: "+min+", max: "+max);
        return false;
      }
      if (increment)
      {
        var incrementedValue = parseFloat(value) + parseFloat(stepSize);
        if (incrementedValue < max)
              input.value = incrementedValue;
        else if (circular)
              input.value = min;
        else input.value = max;
      }
      else
      {
        var decrementedValue = parseFloat(value) - parseFloat(stepSize);

        if (decrementedValue > min)
          input.value = decrementedValue;
        else if (circular)
          input.value = max;
        else input.value = min;
      }
      return true;
   }
   return false;
}

/* This function is called when the inputNumberSpinbox component's spinbox
 * buttons are released (onmouseup).
 * This function stops the spinboxTimer.
 * The spinboxTimer calls _stepSpinboxValue in one second increments.
 */
function _clearSpinbox()
{
  window.clearTimeout(_spinboxRepeat.timer);
  _spinboxRepeat.functionString = null;
}

/**
  * This function is called when the inputNumberSpinbox component's
  * spinbox buttons are pressed. This is called onmousedown.
  * It calls the _stepSpinboxValue function to increment or decrement
  * the input element's value. We call this repeatedly every second.
  * onmouseup the component calls _clearSpinbox which clears the timeout.
  */
function _spinboxRepeat(id, increment, stepSize, min, max)
{
  // increment/decrement
  var success = _stepSpinboxValue(id, increment, stepSize, min, max);
  // if not successful, then clear the timeout and return
  if (!success)
  {
    window.clearTimeout(_spinboxRepeat.timer);
  }
  else
  {
    if (_spinboxRepeat.functionString == null)
    {
      // setup the function to pass to the timeout.
      _spinboxRepeat.functionString =
          "_spinboxRepeat('"+id+"',"+increment+
          ","+stepSize+","+min+","+max+");";
    }
    _spinboxRepeat.timer =
      window.setTimeout(_spinboxRepeat.functionString, 1000);
  }

}

//PH:This method returns the 'event' object
function _getEventObj()
{
  if(typeof(event) == 'undefined')
    return window.event;
  else
    return event;

  return null;
}

//***********************************************************
// "Object Oriented" js below
//***********************************************************
/**
 * User interfaces utility methods
 */
window.TrUIUtils = new Object();

/**
 * Creates a function instance that will callback the passed in function
 * with "thisObj" as "this".  This is extremely useful for creating callbacks
 */
TrUIUtils.createCallback = function(thisObj, func)
{
  // create a function that sets up "this" and delegates all of the parameters
  // to the passed in function
  var proxyFunction = new Function(
    "var f=arguments.callee; return f._func.apply(f._owner, arguments);");

  // attach ourselves as "this" to the created function
  proxyFunction._owner = thisObj;

  // attach function to delegate to
  proxyFunction._func = func;

  return proxyFunction;
}

/**
 * Get the client window size.
 * TODO - make this public?
 *
 * @return {Object} the client size of the window. The returned object will have w and h properties.
 */
TrUIUtils._getWindowClientSize = function()
{
  var func;

  if (TrUIUtils['_getWinClientSize'] == null)
  {
    // IE is abnormal
    if(_agent.isIE)
    {
      TrUIUtils._getWinClientSize = function()
      {
        var e = ((document.compatMode == "BackCompat") ? document.body : document.documentElement);
        return { w: e.clientWidth, h: e.clientHeight };
      }
    }
    else
    {
      TrUIUtils._getWinClientSize = function()
      {
        return { w: window.innerWidth, h: window.innerHeight };
      }
    }
  }

  return TrUIUtils._getWinClientSize();
}

/**
 * Return the offset bounds of an element
 * TODO - make this public?
 *
 * @param elem {String or Element} the ID of an element or an element reference
 * @return {Object} the returned object will have x, y, w and h properties.
 * Returns null if the element does not exist
 */
TrUIUtils._getElementBounds = function(elem)
{
  if (typeof(elem) == "string")
  {
    elem = document.getElementById(elem);
  }
  if (!elem)
  {
    return null;
  }
  var loc = TrUIUtils._getElementLocation(elem);
  return { x: loc.x, y: loc.y, w: elem.offsetWidth, h: elem.offsetHeight };
}

/**
 * Get the location of an element in relation to the view port.
 * This will return the same co-ordinates as browser events (i.e. mouse event locations).
 * TODO - make this public?
 *
 * @param elem {String or Element} the ID of an element or an element reference
 * @return {Object} the location on the page. The returned object will have x and y properties.
 * Returns null if the element does not exist
 */
TrUIUtils._getElementLocation = function(elem)
{
  if (typeof(elem) == "string")
  {
    elem = document.getElementById(elem);
  }
  if (!elem)
  {
    return null;
  }

  var func;

  if (TrUIUtils['_getElemLoc'] == null)
  {
    // if possible, use more accurate browser specific methods
    if (_agent.isGecko)
    {
      TrUIUtils._getElemLoc = function(elem)
      {
        var doc = elem.ownerDocument;

        if (doc.getBoxObjectFor === undefined)
        {
          var boundingRect = elem.getBoundingClientRect();
          // top and bottom are not rounded off in Gecko1.9
          // http://www.quirksmode.org/dom/w3c_cssom.html#elementviewm
          var elemTop = Math.round(boundingRect.top);
          var elemLeft = boundingRect.left;
          var docElement = doc.documentElement;
          // clientLeft and clientTop would be 0 for Gecko1.9
          // https://bugzilla.mozilla.org/show_bug.cgi?id=174397#c34
          elemLeft += docElement.scrollLeft;
          elemTop += docElement.scrollTop;
          return {x:elemLeft, y:elemTop};
        }
        else
        {
          var box = doc.getBoxObjectFor(elem);
          var loc = { x: box.screenX, y: box.screenY };
          box = doc.getBoxObjectFor(doc.documentElement);
          loc.x -= box.screenX;
          loc.y -= box.screenY;
          return loc;
        }
      }
    }
    else if(_agent.isIE)
    {
      TrUIUtils._getElemLoc = function(elem)
      {
        var doc = elem.ownerDocument;
        var rect = elem.getBoundingClientRect();
        var loc = { x: rect.left, y: rect.top };
        var docElem = doc.documentElement;
        var scrollLeft = docElem.scrollLeft;

        var rtl = docElem["dir"] == "rtl";
        // IE scroll bar adjustment
        if (rtl)
        {
          scrollLeft += docElem.clientWidth - docElem.scrollWidth;
        }
        loc.x -= docElem.clientLeft - scrollLeft;
        loc.y -= (docElem.clientTop - docElem.scrollTop);
        return loc;
      }
    }
    else
    {
      TrUIUtils._getElemLoc = function(elem)
      {
        var win = elem.ownerDocument.contentWindow;
        // use offset* properties to determine location
        var curleft = 0;
        var curtop = 0;
        for (var obj = elem; obj && obj != win; obj = obj.offsetParent)
        {
          curleft += obj.offsetLeft;
          curtop += obj.offsetTop;
        }
        return { x: curleft, y: curtop };
      }
    }
  }

  return TrUIUtils._getElemLoc(elem);
}


/**
 * Get a css property as its JavaScript variable name
 */
TrUIUtils._cssToJs = function(prop)
{
  var jsProp = '';
  var upperNext = false;
  for (var c = 0; c < prop.length; c++)
  {
    if (prop.charAt(c) == '-')
    {
      upperNext = true;
      continue;
    }

    if (upperNext)
    {
      jsProp += prop.charAt(c).toUpperCase();
    }
    else
    {
      jsProp += prop.charAt(c);
    }

    upperNext = false;
  }

  return jsProp;
}

/**
 * Get a calculated CSS style value
 */
TrUIUtils._getStyle = function(element, prop)
{
  if (element.currentStyle)
  {
    // remove dashes and uppercase next letter
    var jsProp = this._cssToJs(prop);
    return element.currentStyle[jsProp];
  }
  else if (window.getComputedStyle)
  {
    return document.defaultView.getComputedStyle(element, '')
      .getPropertyValue(prop);
  }
  return '';
}

/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

window.TrIntegerConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrIntegerConverter";
};

TrIntegerConverter.prototype = new TrConverter();

TrIntegerConverter.prototype.getFormatHint = function()
{
  return null;
}

TrIntegerConverter.prototype.getAsString = function(
  number,
  label
  )
{
  return "" + number;
}

TrIntegerConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  return _decimalParse(numberString, 
                       this._message,
                       "org.apache.myfaces.trinidad.convert.IntegerConverter",
                       this._maxPrecision,
                       this._maxScale,
                       this._maxValue,
                       this._minValue,
                       label,
                       null);
}
window.TrLongConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrLongConverter";
};

TrLongConverter.prototype = new TrConverter();

TrLongConverter.prototype.getFormatHint = function()
{
  return null;
}

TrLongConverter.prototype.getAsString = function(
  number,
  label
  )
{
  return "" + number;
}

TrLongConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  if(TrFormatUtils.isNumberConvertible(numberString))
  {
    return _decimalParse(numberString, 
                         this._message,
                         "org.apache.myfaces.trinidad.convert.LongConverter",
                         this._maxPrecision,
                         this._maxScale,
                         this._maxValue,
                         this._minValue,
                         label,
                         null);
  }
  else
  {
    return undefined;
  }
}

window.TrShortConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrShortConverter";
};

TrShortConverter.prototype = new TrConverter();

TrShortConverter.prototype.getFormatHint = function()
{
  return null;
}

TrShortConverter.prototype.getAsString = function(
  number,
  label
  )
{
  return "" + number;
}

TrShortConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  return _decimalParse(numberString, 
                       this._message,
                       "org.apache.myfaces.trinidad.convert.ShortConverter",
                       this._maxPrecision,
                       this._maxScale,
                       this._maxValue,
                       this._minValue,
                       label,
                       null);
}
window.TrByteConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrByteConverter";
};

TrByteConverter.prototype = new TrConverter();

TrByteConverter.prototype.getFormatHint = function()
{
  return null;
}

TrByteConverter.prototype.getAsString = function(
  number,
  label
  )
{
  return "" + number;
}

TrByteConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  return _decimalParse(numberString, 
                       this._message,
                       "org.apache.myfaces.trinidad.convert.ByteConverter",
                       this._maxPrecision,
                       this._maxScale,
                       this._maxValue,
                       this._minValue,
                       label,
                       null);
}

window.TrDoubleConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrDoubleConverter";
};

TrDoubleConverter.prototype = new TrConverter();

TrDoubleConverter.prototype.getFormatHint = function()
{
  return null;
}

TrDoubleConverter.prototype.getAsString = function(
  number,
  label
  )
{
  var numberString = "" + number;
  var index = numberString.indexOf(".");
  if(index != -1)
    return numberString;
  else
    return "" + number.toFixed(1);
}

TrDoubleConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  return _decimalParse(numberString, 
                       this._message,
                       "org.apache.myfaces.trinidad.convert.DoubleConverter",
                       this._maxPrecision,
                       this._maxScale,
                       this._maxValue,
                       this._minValue,
                       label,
                       true, 
                       true);
}
window.TrFloatConverter = function(
  message,
  maxPrecision,
  maxScale,
  maxValue,
  minValue)
{
  this._message = message;
  this._maxPrecision = maxPrecision;
  this._maxScale = maxScale;
  this._maxValue = maxValue;
  this._minValue = minValue;

  // for debugging
  this._class = "TrFloatConverter";
};

TrFloatConverter.prototype = new TrConverter();

TrFloatConverter.prototype.getFormatHint = function()
{
  return null;
}

TrFloatConverter.prototype.getAsString = function(
  number,
  label
  )
{
  var numberString = "" + number;
  var index = numberString.indexOf(".");
  if(index != -1)
    return numberString;
  else
    return "" + number.toFixed(1);
}

TrFloatConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  return _decimalParse(numberString, 
                       this._message,
                       "org.apache.myfaces.trinidad.convert.FloatConverter",
                       this._maxPrecision,
                       this._maxScale,
                       this._maxValue,
                       this._minValue,
                       label,
                       true,
                       true);
}

window.TrRangeValidator = function(
  maxValue,
  minValue,
  messages)
{
  this._maxValue = maxValue;
  this._minValue = minValue;
  this._messages = messages;

  // for debugging
  this._class = "TrRangeValidator";
};

TrRangeValidator.prototype = new TrValidator();
TrRangeValidator.prototype.getHints = function(
  converter
  )
{
  return _returnRangeHints(
    this._messages,
    this._maxValue,
    this._minValue,
    "org.apache.myfaces.trinidad.validator.RangeValidator.MAXIMUM_HINT",
    "org.apache.myfaces.trinidad.validator.RangeValidator.MINIMUM_HINT",
    "org.apache.myfaces.trinidad.validator.RangeValidator.RANGE_HINT",
    "hintMax",
    "hintMin",
    "hintRange"
  );
}
TrRangeValidator.prototype.validate  = function(
  value,
  label,
  converter
)
{
  string = "" + value;
  numberValue = parseFloat(string);
  var facesMessage;
  if(this._minValue != null && this._maxValue != null)
  {
    //range
    if(numberValue >= this._minValue && numberValue <= this._maxValue)
    {
      return string;
    }
    else
    {
      var key = "org.apache.myfaces.trinidad.validator.LongRangeValidator.NOT_IN_RANGE";
      if(this._messages && this._messages["range"])
      {
        facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["range"],
                                        label,
                                        string,
                                        ""+this._minValue,
                                        ""+this._maxValue);
      }
      else
      {
        facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._minValue,
                                        ""+this._maxValue);
      }
    }
  }
  else
  {
    //only min
    if(this._minValue != null)
    {
      if(numberValue >= this._minValue)
      {
        return string;
      }
      else
      {
        var key = "org.apache.myfaces.trinidad.validator.LongRangeValidator.MINIMUM";
        if(this._messages && this._messages["min"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["min"],
                                        label,
                                        string,
                                        ""+this._minValue);
        }
        else
        {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._minValue);
        }
      }
    }
    //max only
    else
    {
      if(this._maxValue  == null || numberValue <= this._maxValue)
      {
        return string;
      }
      else
      {
        var key = "org.apache.myfaces.trinidad.validator.LongRangeValidator.MAXIMUM";
        if(this._messages && this._messages["max"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["max"],
                                        label,
                                        string,
                                        ""+this._maxValue);
        }
        else
        {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._maxValue);
        }
      }
    }
  }
  throw new TrConverterException(facesMessage);
}

window.TrLengthValidator = function(
  maxValue,
  minValue,
  messages)
{
  this._maxValue = maxValue;
  this._minValue = minValue;
  this._messages = messages;

  // for debugging
  this._class = "TrLengthValidator";
};

TrLengthValidator.prototype = new TrValidator();
TrLengthValidator.prototype.getHints = function(
  converter
  )
{
  return _returnRangeHints(
    this._messages,
    this._maxValue,
    this._minValue,
    "org.apache.myfaces.trinidad.validator.LengthValidator.MAXIMUM_HINT",
    "org.apache.myfaces.trinidad.validator.LengthValidator.MINIMUM_HINT",
    (this._minValue == this._maxValue)
      ? "org.apache.myfaces.trinidad.validator.LengthValidator.EXACT_HINT"
      : "org.apache.myfaces.trinidad.validator.LengthValidator.RANGE_HINT",
    "hintMax",
    "hintMin",
    // The server always sends down "hintRange" for exact or non-exact
    "hintRange"
  );
}
TrLengthValidator.prototype.validate  = function(
  value,
  label,
  converter
)
{

  var string = "" + value;
  var length = string.length;
  
  // If validation succeeds, return
  if (length >= this._minValue &&
     ((this._maxValue == null) || (length <= this._maxValue)))
  {
    return string;
  }
  else
  {
    if ((this._minValue > 0) && (this._maxValue != null))
    {
      var exact = (this._minValue == this._maxValue);
      var key = exact
        ? "org.apache.myfaces.trinidad.validator.LengthValidator.EXACT"
        : "org.apache.myfaces.trinidad.validator.LengthValidator.NOT_IN_RANGE";
      var facesMessage;
      var customKey = "range";

      if(this._messages && this._messages[customKey])
      {
        facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages[customKey],
                                        label,
                                        string,
                                        ""+this._minValue,
                                        ""+this._maxValue);
      }
      else
      {
        facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._minValue,
                                        ""+this._maxValue);
      }
      throw new TrConverterException(facesMessage);
    }
    else if (length < this._minValue) //too short
    {
      var key = "org.apache.myfaces.trinidad.validator.LengthValidator.MINIMUM";
      var facesMessage;
      if(this._messages && this._messages["min"])
      {
        facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["min"],
                                        label,
                                        string,
                                        ""+this._minValue);
      }
      else
      {
        facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._minValue);
      }
      throw new TrConverterException(facesMessage);
    }
    else // too long
    {
      var key = "org.apache.myfaces.trinidad.validator.LengthValidator.MAXIMUM";
      var facesMessage;
      if(this._messages && this._messages["max"])
      {
        facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["max"],
                                        label,
                                        string,
                                        ""+this._maxValue);
      }
      else
      {
        facesMessage = _createFacesMessage(key,
                                        label,
                                        string,
                                        ""+this._maxValue);
      }
      throw new TrConverterException(facesMessage);
    }
  }
}

// Trinidad-1818: When min/max is specified, use two pieces of information
// min/maxValue         : The date as a string parseable by the converter (for hints)
// minISODate/maxISODate: The date as an ISO-like string to correctly recreate the Date object.
//                        This is because the converter pattern could lose information, e.g. with a
//                        Date of 4712-12-31 and converter with YY, min/maxValue would be "12-12-31"
//                        and the converter would parse that into 2012-12-31. See TRINIDAD-1920
window.TrDateTimeRangeValidator = function(
  maxValue,
  minValue,
  messages,
  maxISODate,
  minISODate
)
{
  this._maxValue = maxValue;
  this._maxISODate = maxISODate;
  this._minValue = minValue;
  this._minISODate = minISODate;
  this._messages = messages;
  // for debugging
  this._class = "TrDateTimeRangeValidator";
};

TrDateTimeRangeValidator.prototype = new TrValidator();
TrDateTimeRangeValidator.prototype.getHints = function(
  converter
  )
{
  var max = null;
  var min = null;

  if (this._maxValue)
    max = this._maxValue;

  if (this._minValue)
    min = this._minValue;

  return _returnRangeHints(
    this._messages,
    max,
    min,
    "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.MAXIMUM_HINT",
    "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.MINIMUM_HINT",
    "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.RANGE_HINT",
    "hintMax",
    "hintMin",
    "hintRange"
  );
}

TrDateTimeRangeValidator.prototype.validate  = function(
  value,
  label,
  converter
)
{
  dateTime = value.getTime();
  var facesMessage;
  var isoConverter = this._getISOConverter ();
  //range
  if(this._minValue && this._maxValue)
  {
    try
    {
       // min/maxISODate were introduced in TRINIDAD-1920, pre-existing callers may have them null.
       // If so, revert to previous  behavior where we just parse the min/maxValue string, though
       // that may have less information than the ISO version. 
        minDate = (this._minISODate == null) ? 
                    converter.getAsObject (this._minValue).getTime() :
                    isoConverter.getAsObject (this._minISODate).getTime ();

        maxDate = (this._maxISODate == null) ? 
                    converter.getAsObject (this._maxValue).getTime () :
                    isoConverter.getAsObject (this._maxISODate).getTime ();
    }
    catch (e)
    {
      // Make the validator lenient: let the server convert/validate if 
      // client conversion fails
      return value;
    }
    
    if(dateTime >= minDate && dateTime <= maxDate)
    {
      return value;
    }
    else
    {
      var key = "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.NOT_IN_RANGE";
      if(this._messages && this._messages["range"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["range"],
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._minValue,
                                        ""+this._maxValue);
        }
      else
      {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._minValue,
                                        ""+this._maxValue);
      }
    }
  }
  else
  {
    //only min
    if(this._minValue)
    {
      try
      {
        minDate = (this._minISODate == null) ? 
                    converter.getAsObject (this._minValue).getTime ():
                    isoConverter.getAsObject (this._minISODate).getTime ();
      }
      catch (e)
      {
        // Make the validator lenient: let the server convert/validate if 
        // client conversion fails
        return value;
      }

      if(dateTime >= minDate)
      {
        return value;
      }
      else
      {
        var key = "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.MINIMUM";
      if(this._messages && this._messages["min"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["min"],
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._minValue);
        }
      else
      {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._minValue);
      }
      }
    }
    //max only
    else if(this._maxValue)
    {
      try
      {
        maxDate = (this._maxISODate == null) ? 
                    converter.getAsObject (this._maxValue).getTime ():
                    isoConverter.getAsObject (this._maxISODate).getTime ();
      }
      catch (e)
      {
        // Make the validator lenient: let the server convert/validate if 
        // client conversion fails
        return value;
      }
      if(dateTime <= maxDate)
      {
        return value;
      }
      else
      {
        var key = "org.apache.myfaces.trinidad.validator.DateTimeRangeValidator.MAXIMUM";
        if(this._messages && this._messages["max"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["max"],
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._maxValue);
        }
        else
        {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        ""+converter.getAsString(value),
                                        ""+this._maxValue);
        }
      }
    }
    else
    {
      //no min/max specified
      return value;
    }
  }
  throw new TrConverterException(facesMessage);
}

TrDateTimeRangeValidator.prototype._getISOConverter = function ()
{
  // This pattern must be kept in sync with DateTimeRangeValidator#_ISO_FORMAT
  if (this._ISO_CONVERTER == null)
   this._ISO_CONVERTER = new TrDateTimeConverter("yyyy-MM-dd HH:mm:ss",  null, null, null, null);
  return this._ISO_CONVERTER;
}

window.TrDateRestrictionValidator = function(
  weekdaysValue,
  monthValue,
  messages)
{
  this._weekdaysValue = weekdaysValue;
  this._monthValue = monthValue;
  this._messages = messages;
  this._weekdaysMap = {'2':'tue','4':'thu','6':'sat','1':'mon','3':'wed','5':'fri','0':'sun'};
  this._translatedWeekdaysMap = {'sun':'0','mon':'1','tue':'2','wed':'3','thu':'4','fri':'5','sat':'6'};
  this._monthMap = {'2':'mar','4':'may','9':'oct','8':'sep','11':'dec','6':'jul','1':'feb','3':'apr','10':'nov','7':'aug','5':'jun','0':'jan'};
  this._translatedMonthMap = {'jan':'0','feb':'1','mar':'2','apr':'3','may':'4','jun':'5','jul':'6','aug':'7','sep':'8','oct':'9','nov':'10','dec':'11'};

  // for debugging
  this._class = "TrDateRestrictionValidator";
};

TrDateRestrictionValidator.prototype = new TrValidator();
TrDateRestrictionValidator.prototype.getHints = function(
  converter
  )
{
  var allWeekdays = ['mon','tue','wed','thu','fri','sat','sun'];
  var allMonth = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
  
  //if needed, remove the submitted values, which are invalid, to display only the valid ones
  if(this._weekdaysValue)
    this._removeDisabledValues(this._weekdaysValue, allWeekdays);
  if(this._monthValue)
    this._removeDisabledValues(this._monthValue, allMonth);
  
  return _returnHints(
    this._messages,
    !this._weekdaysValue ? this._weekdaysValue : this._translate(allWeekdays, this._translatedWeekdaysMap, converter.getLocaleSymbols().getWeekdays()),
    !this._monthValue ? this._monthValue : this._translate(allMonth, this._translatedMonthMap, converter.getLocaleSymbols().getMonths()),
    "org.apache.myfaces.trinidad.validator.DateRestrictionValidator.WEEKDAY_HINT",
    "org.apache.myfaces.trinidad.validator.DateRestrictionValidator.MONTH_HINT",
    "hintWeek",
    "hintMonth"
  );
}

TrDateRestrictionValidator.prototype._translate = function(
  values,
  map,
  valueArray
  )
{
  if(values)
  {
    var translatedValues = new Array();
    var valuesAsArray = eval(values);
    for(i = 0; i<valuesAsArray.length; i++)
    {
      translatedValues.push(valueArray[map[valuesAsArray[i].toLowerCase()]]);
    }
    return eval(translatedValues);
  }
  else
  {
    return values;
  }
}

/**
 * For all values in allValueArray, check if it is disabled by looking up
 * map disabledValueMap, if so, remove it from allValueArray
 */
TrDateRestrictionValidator.prototype._removeDisabledValues = function(
  disabledValueMap,
  allValueArray
  )
{
  if(disabledValueMap && allValueArray)
  {
    for (i=0; i<allValueArray.length; i++)
    {
      if(disabledValueMap[allValueArray[i].toLowerCase()] != undefined)
      {
        allValueArray.splice(i,1);

        // the element originally at index i is removed, and 
        // we now have a new element at index i, thus we need
        // to stay on the same position to check whether we
        // need to remove it.
        i--;
      }
    }
  }
}

TrDateRestrictionValidator.prototype.validate  = function(
  value,
  label,
  converter
)
{
  submittedDay = value.getDay();
  weekDaysArray = eval(this._weekdaysValue);
  if(weekDaysArray)
  {
    var dayString = this._weekdaysMap[submittedDay];
    for(var i = 0; i < weekDaysArray.length; ++i)
    {
      if(weekDaysArray[i].toLowerCase() == dayString)
      {
        var allWeekdays = ['mon','tue','wed','thu','fri','sat','sun'];
        this._removeDisabledValues(this._weekdaysValue, allWeekdays);
        var days = _trToString(this._translate(allWeekdays, this._translatedWeekdaysMap, converter.getLocaleSymbols().getWeekdays()));

        var facesMessage;
        var key = "org.apache.myfaces.trinidad.validator.DateRestrictionValidator.WEEKDAY";
        if(this._messages && this._messages["days"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["days"],
                                        label,
                                        ""+converter.getAsString(value),
                                        days);
        }
        else
        {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        ""+converter.getAsString(value),
                                        days);
        }
        throw new TrConverterException(facesMessage);
      }
    }
  }
  
  submittedMonth = value.getMonth();
  monthArray = eval(this._monthValue);
  if(monthArray)
  {
    var monthString = this._monthMap[submittedMonth];
    for(var i = 0; i < monthArray.length; ++i)
    {
      if(monthArray[i].toLowerCase() == monthString)
      {
        var allMonth = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
        TrCollections.removeValuesFromArray(this._monthValue, allMonth);
        var month = _trToString(this._translate(allMonth, this._translatedMonthMap, converter.getLocaleSymbols().getMonths()));
        
        var facesMessage;
        var key = "org.apache.myfaces.trinidad.validator.DateRestrictionValidator.MONTH";
        if(this._messages && this._messages["month"])
        {
          facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                        this._messages["month"],
                                        label,
                                        ""+converter.getAsString(value),
                                        month);
        }
        else
        {
          facesMessage = _createFacesMessage(key,
                                        label,
                                        ""+converter.getAsString(value),
                                        month);
        }
        throw new TrConverterException(facesMessage);
      }
    }
  }
  return value;
}

/**
 * @param parsefloat 
 *   null  ==> we expect the input to be an integral type, throw exception otherwise
 *   false ==> integerOnly="true", parse input as an integer
 *   true  ==> parse input as a float
 */
window._decimalParse = function(
  numberString,
  message,
  standardKey,
  maxPrecision,
  maxScale,
  maxValue,
  minValue,
  label,
  parsefloat,
  ignoreLocaleSymbols
  )
{
  // The following are from the javadoc for TrNumberConverter
  // If the specified String is null, return a null. Otherwise, trim leading and trailing whitespace before proceeding.
  // If the specified String - after trimming - has a zero length, return null.
  if (numberString == null)
    return null;
    
  if (typeof numberString != "string")
    numberString = ""+numberString;

  numberString = TrFormatUtils.trim(numberString);
  if (numberString.length == 0)
    return null;
    
  var facesMessage = null;        

  // Get LocaleSymbols (from Locale.js)
  var symbols = getLocaleSymbols();
  if (symbols && (ignoreLocaleSymbols != true))
  {
    // We don't want leading or trailing grouping separators
    var grouping = symbols.getGroupingSeparator();
    if ((numberString.indexOf(grouping) == 0) ||
        (numberString.lastIndexOf(grouping) ==  (numberString.length - 1)))
    {
      facesMessage =  _createFacesMessage( standardKey+".CONVERT",
                                        label,
                                        numberString);
                                        
      throw new TrConverterException(facesMessage);
    }

    if (grouping == "\xa0"){
      var normalSpace = new RegExp("\\ " , "g");
      numberString = numberString.replace(normalSpace, "\xa0");
    }
    
    // Remove the thousands separator - which Javascript doesn't want to see
    
    //is this a i18n bug?...
    //see TRINIDAD-2
    var thousands = new RegExp("\\" + grouping, "g");
    numberString = numberString.replace(thousands, "");
    // Then change the decimal separator into a period, the only
    // decimal separator allowed by JS
    var decimal = new RegExp("\\" + symbols.getDecimalSeparator(),  "g");
    numberString = numberString.replace(decimal, ".");
  }


  // OK; it's non-empty.  Now, disallow exponential
  // notation, and then use some JS magic to exclude
  // non-numbers
  if ((numberString.indexOf('e') < 0) &&
      (numberString.indexOf('E') < 0) &&
      (((numberString * numberString) == 0) ||
       ((numberString / numberString) == 1)))
  {
    var result = null;
    var floater = false;
    if (parsefloat != null)
    {
      // Why trim leading zeroes? parseFloat behaves the same way as the server NumberConverter, 
      // but parseInt interprets octal, and thus we need to trim leading zeroes. 
      // Note the following:
      // parseInt interprets octal and hex:
      //   alert(parseInt("0xA")); // returns 10
      //   alert(parseInt("008")); // returns 0, as it stops parsing octal at the first invalid character, 8
      // parseFloat interprets neither octal nor hex:
      //   alert(parseFloat("0xA")); // returns 0, as it stops parsing decimal at the first invalid character, x
      //   alert(parseFloat("008")); // returns 8
      numberString = TrNumberFormat.trimLeadingZeroes(numberString);
      result = parsefloat ? parseFloat(numberString) : parseInt(numberString);
    }
    else
    {
      result = parseInt(numberString);
      if (Math.abs(result) < Math.abs(parseFloat(numberString)))
      {
        //a non-floating converter was the caller;
        floater = true;
      }
    }
    if (!floater && !isNaN(result))
    {
      var integerDigits = numberString.length;
      var fractionDigits = 0;

      var sepIndex = numberString.lastIndexOf('.');
      if (sepIndex != -1)
      {
        integerDigits = sepIndex;
        fractionDigits = parseInt(numberString.length - parseInt(sepIndex + 1));
      }
      
      var messageKey;
      var rangeLimit;
      //not true for float/double converter
      if ((maxValue != null) &&
          (result  > maxValue))
      {
        messageKey = standardKey+".MAXIMUM";
        rangeLimit = maxValue;
      }
      else if ((minValue != null) &&
               (result  < minValue))
      {
        messageKey = standardKey+".MINIMUM";
        rangeLimit = minValue;
      }

      if (messageKey)
      {
        facesMessage = _createFacesMessage(messageKey,
                                      label,
                                      numberString,
                                      ""+rangeLimit);

        throw new TrConverterException(facesMessage);
      }
      return result;
    }
  }
  var usedKey = null;
  var custom = false;
  if(standardKey.indexOf("NumberConverter")==-1)
  {
    usedKey = standardKey+".CONVERT";
  }
  else
  {
    usedKey = standardKey+".CONVERT_NUMBER";
    if(message && message["number"])
    {
      facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(usedKey),
                                        message["number"],
                                        label,
                                        numberString);
      custom = true;
    }
  }
  if(!custom)
  {
    facesMessage = _createFacesMessage( usedKey,
                                        label,
                                        numberString);
  }

  throw new TrConverterException(facesMessage);
}

window.TrRegExpValidator = function(
  pattern,
  messages)
{
  this._pattern  = pattern;
  this._messages = messages;
  this._class = "TrRegExpValidator";
};

TrRegExpValidator.prototype = new TrValidator();
TrRegExpValidator.prototype.getHints = function(
  converter
  )
{
  var hints = null;
  if(this._messages["hint"])
  {
    hints = new Array();
    hints.push(TrMessageFactory.createCustomMessage(
      this._messages["hint"],
      ""+this._pattern)
    );
  }
  return hints;
}
TrRegExpValidator.prototype.validate  = function(
  parseString,
  label,
  converter
  )
{
  //For some reason when using digits as input values 
  // parseString becomes a integer type, so get away with it.  
  parseString = parseString + '';
  
  // We intend that the pattern provided is matched exactly
  var exactPattern = "^(" + this._pattern + ")$";

  var matchArr = parseString.match(exactPattern); 
        
  if ((matchArr != (void 0)) && (matchArr[0] == parseString))
  {
    return parseString;
  }
  else
  {
    var key = "org.apache.myfaces.trinidad.validator.RegExpValidator.NO_MATCH";
    var facesMessage;
    if(this._messages && this._messages["detail"])
    {
      facesMessage = _createCustomFacesMessage(
                                         TrMessageFactory.getSummaryString(key),
                                         this._messages["detail"],
                                         label,
                                         parseString,
                                         this._pattern);
    }
    else
    {
      facesMessage = _createFacesMessage(key,
                                         label,
                                         parseString,
                                         this._pattern);                                          
    }
    throw new TrValidatorException(facesMessage); 
  }
}

function _returnRangeHints(
  messages,
  max,
  min,
  maxKey,
  minKey,
  rangeKey,
  maxHint,
  minHint,
  rangeHint
)
{
  
  //we have both, max and min, so we only use the range Hint
  if(max != null && min != null)
  {
    var hints = new Array();
    if(messages && messages[rangeHint])
    {
      hints.push(
        TrMessageFactory.createCustomMessage(
        messages[rangeHint],
        ""+min,
        ""+max)
      );
    }
    else
    {
      hints.push(
        TrMessageFactory.createMessage(
        rangeKey,
        ""+min,
        ""+max)
      );
    }
    return hints;
  }
  
  return _returnHints(
    messages,
    max,
    min,
    maxKey,
    minKey,
    maxHint,
    minHint
  );
  
}

function _trToString(param) 
{
  if (Array.prototype.isPrototypeOf(param))
  {
    return param.join(", ");
  }
  else
  {
    return "" + param;
  }
}

function _returnHints(
  messages,
  max,
  min,
  maxKey,
  minKey,
  maxHint,
  minHint
)
{
  var hints;
  if (max != null)
  {
    hints = new Array();
    if (messages && messages[maxHint])
    {
      hints.push(
        TrMessageFactory.createCustomMessage(
          messages[maxHint],
          _trToString(max))
      );
    }
    else
    {
      hints.push(
        TrMessageFactory.createMessage(
          maxKey,
          _trToString(max))
      );
    }
    
  }
  if (min != null)
  {
    if (!hints)
    {
      hints = new Array();
    }
    if (messages && messages[minHint])
    {
      hints.push(
        TrMessageFactory.createCustomMessage(
          messages[minHint],
          _trToString(min))
       );
    }
    else
    {
      hints.push(
        TrMessageFactory.createMessage(
          minKey,
          _trToString(min))
       );
    }
  }
  return hints;
}
/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

// External variables used:
//  _df2DYS: Sets the two-digit year start.

var _AD_ERA = null;


function _getADEra()
{
  if (_AD_ERA == null)
  {
    _AD_ERA = new Date(0);
    _AD_ERA.setFullYear(1);
  }
  
  return _AD_ERA;
}


/**
 * Determine whether the parsed time is a strictly parsed value.
 */
function _isStrict(
  parseContext,
  parsedTime)
{
  var checks = ["FullYear", "Month", "Date", "Hours", "Minutes",
                "Seconds", "Milliseconds"];

  for (var i=0; i < checks.length; i++)
  {
    var parsed = "parsed" + checks[i];

    if (parseContext[parsed] != null &&
        parseContext[parsed] != parsedTime["get" + checks[i]]())
    {
      // failure for strict parsing
      return false;
    }
  }

  return true;
}


/**
 * Clump up similar runs of pattern characters from the format patter and
 * call the subfunction for each result.  Return whether the clumping
 * succeeded.
 */
function _doClumping(
  formatPattern,
  localeSymbols,
  locale,
  subFunction,
  param,
  outValue
  )
{  
  var formatLength = formatPattern.length;
  var inQuote      = false;
  var kindCount    = 0;
  var lastChar     = void 0;
  var startIndex   = 0;
  var quoteIndex = null;
  
  for (var i = 0; i < formatLength; i++)
  {
    var currChar = formatPattern.charAt(i);
    
    if (inQuote)
    {
      if (currChar == "\'")
      {
        // test strings to test escaping working properly
        // "'one '' two '' three''' 'four '' five'"   ->     "one ' two ' three' four ' five
        // "HH:mm:ss 'o''clock' z"                    ->     "[time] o'clock [timezone]"
        // "HH:mm:ss 'oclock' z"                      ->     "[time] oclock [timezone]"
        // "HH:mm:ss '' z"                            ->     "[time] ' [timezone]"
        
        inQuote = false;
        
        // handle to single quotes in a row as escaping the quote
        // by not skipping it when outputting
        if (kindCount != 1 && startIndex != quoteIndex)
        {
          startIndex++;
          kindCount--;
        }

        // output the quoted text
        if (!subFunction(formatPattern,
                         localeSymbols,
                         locale,
                         "\'",
                         startIndex,
                         kindCount,
                         param,
                         outValue))
        {
          // failure
          // alert("failure at " + startIndex + " with " + lastChar);
          return false;
        }
               
        var nextIndex = i + 1;
    
        if (nextIndex < formatLength)
        {
          var nextChar = formatPattern.charAt(nextIndex);
          
          if (nextChar == "\'")
          {
            quoteIndex = nextIndex;
          }
        } 
        
        kindCount = 0;
        lastChar  = void 0; 
      }
      else
      {
        // keep adding characters to the escaped String
        kindCount++;
      }
    }
    else
    {
      // the characters that we are collecting have changed
      if (currChar != lastChar)
      {
        if (kindCount != 0)
        {       
          // output the previously collected string
          if (!subFunction(formatPattern,
                           localeSymbols,
                           locale,
                           lastChar,
                           startIndex,
                           kindCount,
                           param,
                           outValue))
          {
            // failure
            //alert("failure at " + startIndex + " with " + lastChar);
            return false;
          }
          
          kindCount = 0;
          lastChar  = void 0;
        }
        
        if (currChar == '\'')
        {
          inQuote = true;
        }
  
        startIndex = i;      
        lastChar = currChar;
      }

      // keep collecting this kind of character together
      kindCount++;
    }   
  }
  
  // output any left over substring being collected
  if (kindCount != 0)
  {
    if (!subFunction(formatPattern,
                     localeSymbols,
                     locale,
                     lastChar,
                     startIndex,
                     kindCount,
                     param,
                     outValue))
    {
      // failure
      //alert("failure at " + startIndex + " with " + lastChar);
      return false;
    }
  }
  
  // success
  return true;
}


/**
 * Format a clump of pattern elements using the specified time.
 */
function _subformat(
  inString,
  localeSymbols,
  locale,
  formatType,
  startIndex,
  charCount,
  time,
  stringHolder
  )
{    

  // string to append to the toString
  var appendString = null;
  
  var amPMAdjust = false;
    
  if ((formatType >= 'A') && (formatType <= 'Z') ||
      (formatType >= 'a') && (formatType <= 'z'))
  {
    switch (formatType)
    {
      case 'D': // day in year
        // Bug 13940707 (KPALMER)
        // Before:
        // appendString = "(Day in Year)";
        // After:
        var millisecsPerDay = 86400000;
        var janFirstThisYear = new Date(time.getFullYear(), 0, 1);
        appendString = Math.ceil((time - janFirstThisYear) / millisecsPerDay) + "";
        break;
      
      case 'E': // day in week
      {
        var dayOfWeek = time.getDay();
        
        appendString = (charCount <= 3)
                         ? localeSymbols.getShortWeekdays()[dayOfWeek]
                         : localeSymbols.getWeekdays()[dayOfWeek];
      }
      break;
      
      case 'F': // day of week in month
        // Bug 14032368 (KPALMER)
        // Before:
        // appendString = "(Day of week in month)";
        // After:
        appendString = Math.floor((time.getDate() - 1) / 7) + 1 + "";
        break;
      
      case 'G': // era designator
      {
        var eras = localeSymbols.getEras();
        
        appendString = (time.getTime() < _getADEra().getTime())
                         ? eras[0]
                         : eras[1];
 
      }
      break;
                  
      case 'M': // month in year
      {
        var monthIndex = time.getMonth();
        
        if (charCount <= 2)
        {
          // use the month number
          appendString = _getPaddedNumber(monthIndex + 1, charCount);
        }
        else if (charCount == 3)
        {
          // use the month abbreviation
          appendString = localeSymbols.getShortMonths()[monthIndex];
        }
        else
        {
          // use the full month name
          appendString = localeSymbols.getMonths()[monthIndex];
        }
      }
      break;
      
      case 'S': // millisecond (0 - 999)
        appendString = _getPaddedNumber(time.getMilliseconds(), charCount);
        break;
      
      case 'W': // week in month
        // Bug 14032379 (KPALMER)
        // Before:
        // appendString = "(Week in Month)";
        // After:
        var millisecsPerDay = 86400000;
        var firstDayThisMonth = new Date(time.getFullYear(), time.getMonth(), 1);
        appendString = Math.ceil((((time - firstDayThisMonth) / millisecsPerDay) + firstDayThisMonth.getDay()) / 7) + "";
        break;
      
      case 'a': // am/pm marker
      {
        var amPMs = localeSymbols.getAmPmStrings();
        
        appendString =  (_isPM(time.getHours()))
                          ? amPMs[1]
                          : amPMs[0];
      }
      break;
      
      case 'd': // day in month
        appendString = _getPaddedNumber(time.getDate(), charCount);
        break;
      
      case 'h': // hour in am/pm (1-12)
        hours = time.getHours();
        
        if (_isPM(hours))
          hours -= 12;
        
        if (hours == 0)
          hours = 12;

        appendString = _getPaddedNumber(hours, charCount);
        break;
      
      case 'K': // hour in am/pm (0-11)
         hours = time.getHours();
        
        if (_isPM(hours))
           hours -= 12;
         
        appendString = _getPaddedNumber(hours, charCount);
        break;

      case 'k': // hour in day (1-24)
        hours = time.getHours();
        if (hours == 0)
          hours = 24;
        appendString = _getPaddedNumber(hours, charCount);
        break;

      case 'H': // hour in day (0-23)
        appendString = _getPaddedNumber(time.getHours(), charCount);
        break;


      case 'm': // minute in hour 0 - 59)
        appendString = _getPaddedNumber(time.getMinutes(), charCount);
        break;
 
      case 's': // seconds in minute 0 - 59)
        appendString = _getPaddedNumber(time.getSeconds(), charCount);
        break;
   
      case 'w': // week in year
        // Bug 14032396 (KPALMER)
        // Before:
        // appendString = "(Week in year)";
        // After:
        var millisecsPerDay = 86400000;
        var janFirstThisYear = new Date(time.getFullYear(), 0, 1);
        appendString = Math.ceil((((time - janFirstThisYear) / millisecsPerDay) + janFirstThisYear.getDay()) / 7) + "";
        break;
      
      case 'y': // year
      {
        var year = time.getFullYear();
        
        // Trinidad-2013: Thai Buddhist Calendar is offset by 543 years
        if (locale == "th-th")
          year += 543;
        
        // truncate 2 and 1 digit years to that number of digits
        var maxDigits = (charCount <= 2)
                          ? charCount
                          : null;
                          
                          
        appendString = _getPaddedNumber(year, charCount, maxDigits);
      }
      break;
        
        
      case 'z': // GMT timezone - "GMT Sign Hours : Minutes"
      {
        appendString = "GMT";
        
        var tzString = _getTimeZoneOffsetString(time, false);
        if (tzString)
        {
          // +/-HH:mm
          appendString += tzString[0];
          appendString += ":"
          appendString += tzString[1];
        }
      }
      break;
      
      case 'Z': // RFC 822 timeZone - "Sign TwoDigitHours Minutes"
      { 
        var tzString = _getTimeZoneOffsetString(time, true);
        if (tzString)
        {
          // +/-HHmm
          appendString = tzString[0];
          appendString += tzString[1];
        }
        else
        {
          appendString = "";
        }
      }
      break;
    
      default:
        // do nothing rather than throw an exception
        appendString = "";
    }
  }
  else
  {
    // all other results are literal
    appendString = inString.substring(startIndex, startIndex + charCount);
  }
  
  stringHolder.value += appendString;
  
  // formatting should never fail
  return true;
}

/**
 * Returns the timeZone offset from GMT in the array:
 * [0] = "+/-HH", [1] = "mm".
 */
function _getTimeZoneOffsetString(time, rfcFormat)
{

  // timeZoneOffset in javascript gives
  // the wrong sign, so I am switching it.
  var timeZnOffset = -1* time.getTimezoneOffset();

  // LRN 20120113 - Commented the following line as it will always
  // zero the offset. I suspect this is a copy/paste bug since the
  // comment on _getLocaleTimeZoneDifference refers to the potential
  // discrepancy between server tz offset and browser tz offset, but
  // every time zone in this calculation originates in the browser.
  // timeZnOffset += _getLocaleTimeZoneDifference();
  
  if(rfcFormat || timeZnOffset != 0)
  {
    var timeOffsetString = new Array(2);
    // sign
    if (timeZnOffset < 0)
    {
      timeOffsetString[0] = "-";
      // abs value
      timeZnOffset = -timeZnOffset
    }
    else
    {
      timeOffsetString[0] = "+";
    }
    
    // HH
    timeOffsetString[0] += _getPaddedNumber(Math.floor(timeZnOffset / 60), 2);
    
    // mm
    timeOffsetString[1] = _getPaddedNumber(timeZnOffset % 60, 2);
    
    return timeOffsetString;
  }
}

/**
 * compare the time zone that is on the client with the time zone that
 * came from the localeContext on the server, and return the difference
 * in hours.
 * This can be used to adjust the date/time value that will be displayed in
 * the date field to use the timezone set on the locale context on the 
 * server instead of the timezone we get from javascript's getTimezoneOffset.
 * see bug 3167883
 */
function _getLocaleTimeZoneDifference()
{
  var currentDate = new Date();
  // timeZoneOffset in javascript appears to give
  // the wrong sign, so I am switching it.
  // the timeZoneOffset is in minutes.
  var currentDateTzOffset = currentDate.getTimezoneOffset() * -1;
  var tzOffsetDiff = 0;
  
  return tzOffsetDiff - currentDateTzOffset;
}

/**
 * Parse a substring using a clump of format elements.
 */
function _subparse(
  inString,      // the pattern string, such as "yyMMdd"
  localeSymbols,
  locale,
  formatType,    // the current format char, such as 'y'
  startIndex,    // index into inString
  charCount,     // the number of chars of type formatType
  parseContext,  // information pertaining to the user input string
  parsedTime
  )
{
  // Start index of the string being parsed (as opposed
  // to startIndex, which is the index on the format mask)
  var inStartIndex = parseContext.currIndex;
    
  var nextFormatType = (startIndex + charCount < inString.length) ? 
    inString.charAt(startIndex + charCount) : null;
    
  // Consider the pattern "yyMMdd". Say that formatType is 'y' and nextFormatType is 'M'. Normally 
  // we would allow for leniency such that the user could input 2 or 4 digits for the year, but 
  // since this pattern contains no date separators and both the year and month can consist of 
  // digits, there's no easy way of telling whether the first 4 digits apply to just the year, or 
  // to both the year and month. Therefore, if nextFormatType is one of the reserved format types, 
  // then we go into strict parsing mode for formatType, where charCount represents the maximum 
  // number of user input characters that will be parsed when matching the current formatType.
  var isStrict = ("DFMSWdhkHKmswy".indexOf(nextFormatType) != -1);

  if ((formatType >= 'A') && (formatType <= 'Z') ||
      (formatType >= 'a') && (formatType <= 'z'))
  {
    switch (formatType)
    {
      case 'D': // day in year
        // skip this number
        if (_accumulateNumber(parseContext, !isStrict ? 3 : charCount) == null)
        {
          return false;
        }
        break;
      
      case 'E': // day in week
      {
        // extract the day but do nothing with it, as there is not setDay()
        // on Date
        var dayIndex = _matchArray(parseContext,
                                   (charCount <= 3)
                                     ? localeSymbols.getShortWeekdays()
                                     : localeSymbols.getWeekdays());
                                     
        if (dayIndex == null)
        {
          return false;
        }
      }
      break;
      
      case 'F': // day of week in month
        // skip this number
        if (_accumulateNumber(parseContext, !isStrict ? 2 : charCount) == null)
        {
          return false;
        }
        break;
      
      case 'G': // era designator
      {
        var eraIndex = _matchArray(parseContext, localeSymbols.getEras());
        
        if (eraIndex != null)
        {
          if (eraIndex == 0)
          {
            parseContext.parsedBC = true;
          }
        }
        else
        {
          return false;
        }
      }
      break;
                  
      case 'M': // month in year
      {
        var monthIndex;
        var monthOffset = 0;

        if (charCount <= 2)
        {
          // match month number
          monthIndex = _accumulateNumber(parseContext, !isStrict ? 2 : charCount);
          
          // subtract 1 from the monthIndex to make it 0-based
          monthOffset = -1;
        }
        else
        {
          var nameArray = (charCount == 3)
                            ? localeSymbols.getShortMonths()
                            : localeSymbols.getMonths();

          monthIndex = _matchArray(parseContext, nameArray);
        }

        if (monthIndex != null)
        {
          parseContext.parsedMonth = (monthIndex + monthOffset);
        }
        else
        {
          return false;
        }
      }
      break;

      case 'S': // millisecond (0 - 999)
      {
        var milliseconds = _accumulateNumber(parseContext, !isStrict ? 3 : charCount);

        if (milliseconds != null)
        {
          parseContext.parsedMilliseconds = milliseconds;
        }
        else
        {
          return false;
        }
      }
      break;
      
      case 'W': // week in month
        // skip this number
        if (_accumulateNumber(parseContext, !isStrict ? 2 : charCount) == null)
        {
          return false;
        }
        break;
      
      case 'a': // am/pm marker
      {
        var amPMIndex = _matchArray(parseContext,
                                    localeSymbols.getAmPmStrings());
        
        if (amPMIndex == null)
        {
          return false;
        }
        else
        {
          if (amPMIndex == 1)
          {
            parseContext.isPM = true;
          }
        }
      }
      break;
      
      case 'd': // day in month
      {
        var dayOfMonth = _accumulateNumber(parseContext, !isStrict ? 2 : charCount);
                
        if (dayOfMonth != null)
        {
          parseContext.parsedDate = dayOfMonth;
        }
        else
        {
          return false;
        }
      }
      break;
        
      case 'h': // hour in am/pm (1-12)
      case 'k': // hour in day (1-24)
      case 'H': // hour in day (0-23)
      case 'K': // hour in am/pm (0-11)
      {
        var hour = _accumulateNumber(parseContext, !isStrict ? 2 : charCount);
        
        if (hour != null)
        {
          if ((formatType == 'h') && (hour == 12))
            hour = 0;
          if ((formatType == 'k') && (hour == 24))
            hour = 0;

          parseContext.parsedHour = hour;
        }
        else
        {
          return false;
        }
      }
      break;


      case 'm': // minute in hour 0 - 59)
      {
        var minutes = _accumulateNumber(parseContext, !isStrict ? 2 : charCount);
        
        if (minutes != null)
        {
          parseContext.parsedMinutes = minutes;
        }
        else
        {
          return false;
        }
      }
      break;
      
      case 's': // seconds in minute 0 - 59)
      {
        var seconds = _accumulateNumber(parseContext, !isStrict ? 2 : charCount);

        if (seconds != null)
        {
          parseContext.parsedSeconds = seconds;
        }
        else
        {
          return false;
        }
      }
      break;

      case 'w': // week in year
        // skip this number
        if (_accumulateNumber(parseContext, !isStrict ? 2 : charCount) == null)
        {
          return false;
        }
        break;

      case 'y': // year
      {
        var year = _accumulateNumber(parseContext, !isStrict ? 4 : charCount);
        var enteredChars = parseContext.currIndex - inStartIndex;
        // if we have a 2-digit year, add in the default year
        if (year != null)
        {
          if ((enteredChars > 2) &&
              (charCount <= 2) &&
              (year <= 999))
          {
            // Block bonus characters;  if they've specified
            // a two-year mask, and there's more than two characters,
            // there might be a problem.  But allow four digits.
            return false;
          }
          else if ((charCount <= 2) && (year >= 0) && (year <= 100))
          {
            year = _fix2DYear(year);
          }
          else if (charCount == 4)
          {
            // Bug 2169562: For four-digit year formats, reject
            // three-year entries.  Fair enough!
            if (enteredChars == 3)
              return false;    
            if (enteredChars <= 2)
              year = _fix2DYear(year);
          }

          // There is no year "0"
          if (year == 0)
            return false;
            
          // Trinidad-2013: Thai Buddhist Calendar is offset by 543 years
          if (locale == "th-th")
            year -= 543;
            
          parseContext.parsedFullYear = year;
        }
        else
        {
          return false;
        }
      }
      break;
        
      case 'z': // GMT timezone - "GMT Sign Hours : Minutes"
      {
        // consume the GMT portion
        if (!_matchText(parseContext, "GMT"))
        {
          // GMT is must for timeZone entry.
          return false;
        }
        
        // if we have any more chars then parse the remaining "+HH:mm" string.
        if( (parseContext.parseString.length - parseContext.currIndex) > 0)
        {
          // consume the plus or minus
          if(_matchArray(parseContext, ["-", "+"]) == null)
          {
            return false;
          }
          
          // accumulate the hour offset number
          var hourOffset = _accumulateNumber(parseContext, 2);
          if(hourOffset == null)
          {
            return false;
          }
          parseContext.hourOffset = hourOffset;
          
          // consume the separator between HH and mm
          if (!_matchText(parseContext, ":"))
          {
            return false;
          }
          
          // accumulate minute offset number (should have 2 digits)
          var minOffset;
          if(((parseContext.parseString.length - parseContext.currIndex) < 2) ||
             (minOffset = _accumulateNumber(parseContext, 2)) == null)
          {
            return false;
          }
          parseContext.minOffset = minOffset;
        }
      }
      break;
      
      case 'Z': // RFC 822 timezone - "Sign TwoDigitHours Minutes"
      {
        // RFC 822 TimeZone format should have 5 chars (+/-HHmm)
        if ((parseContext.parseString.length - parseContext.currIndex) < 5)
        {
          return false;
        }
        
        // consume the plus or minus
        if(_matchArray(parseContext, ["-", "+"]) == null)
        {
          return false;
        }
          
        // accumulate the hour offset number
        var hourOffset = _accumulateNumber(parseContext, 2)
        if(hourOffset == null)
        {
          return false;
        }
        parseContext.hourOffset = hourOffset;
        
        // accumulate the minute offset number
        var minOffset = _accumulateNumber(parseContext, 2)
        if(minOffset == null)
        {
          return false;
        }
        parseContext.minOffset = null;
      }
      break;
    
      default:
    }
  }
  else
  {
    // consume constants
    return _matchText(parseContext,
                      inString.substring(startIndex, startIndex + charCount));
  }
  
  // match succeeded
  return true;
}


/**
 * Fix two-digit years.
 */
function _fix2DYear(year)
{
  var defaultCentury;

  if (_df2DYS != null)
  {
    // year               51    01
    // offsetYear       1950  1950
    // defaultCentury   1900  1900
    // year             1951  1901
    // year             1951  2001
    var offsetYear = _df2DYS;
    defaultCentury = offsetYear - (offsetYear % 100);

    year += defaultCentury;
    if (year < offsetYear)
      year += 100;
  }
  else
  {
    var currentYear = new Date().getFullYear();
    defaultCentury = currentYear - (currentYear % 100) - 100;

    year += defaultCentury;
 
    // if the new year is now more than 80 years in the past,
    // then it is actually a date in the future, so add the 100 years
    // back in.  The 80 years rule, matches Java's spec
    if (year + 80 < currentYear)
    {
      year += 100;
    }
  }

  return year;
}


/**
 * Match the current text against an array of possibilities, returning
 * the index of the succesful match, or undefined if no match succeeded.
 */
function _matchArray(
  parseContext,
  matchArray
  )
{
  for (var i = 0; i < matchArray.length; i++)
  {
    if (_matchText(parseContext, matchArray[i]))
    {
      return i;
    }
  }
  
  // no match
  return null;
}


/**
 * Match the specified text in a case insensitive manner,
 * returning true and updating the
 * <code>parseContext</code> if the match succeeded.
 */
function _matchText(
  parseContext,
  text
  )
{
  // if no text to match then match will fail
  if (!text)
    return false;

  // get the length of the text to match
  var textLength  = text.length;

  var currIndex   = parseContext.currIndex;
  var parseString = parseContext.parseString;
  
  // determine whether we have enough of the parseString left to match
  if (textLength > parseString.length - currIndex)
  {
    return false;
  }

  //
  // Convert to lowercase for case insensitive match
  //
  // =-= bts Maybe toLocaleLowerCase would be better, but that would cause
  //         problems if the browser locale were different from the application
  //         locale.
  //  
  var parseText  = parseString.substring(currIndex, currIndex + textLength);
  var parseMatch = parseText.toLowerCase();
  var textMatch  = text.toLowerCase();
  
  if (parseMatch != textMatch)
    return false;
    
  // update the current parseContext
  parseContext.currIndex += textLength;
  
  return true;
}
 

/**
 * Accumlates and returns a number at this location or undefined, if
 * there is no number.
 */
function _accumulateNumber(
  parseContext,
  maxLength
  )
{
  var startIndex  = parseContext.currIndex;
  var currIndex   = startIndex;
  var parseString = parseContext.parseString;
  var parseLength = parseString.length;
  if (parseLength > currIndex + maxLength)
    parseLength = currIndex + maxLength;

  var currValue = 0;

  // gather up all of the digits
  while (currIndex < parseLength)
  {
    var currDigit = parseDigit(parseString.charAt(currIndex));

    if (!isNaN(currDigit))
    {
      // add on the digit and shift over the results
      currValue *= 10;
      currValue += currDigit;

      currIndex++;
    }
    else
    {
      break;
    }
  }

  if (startIndex != currIndex)
  {
    // update the current parseContext
    parseContext.currIndex = currIndex;

    // return the numeric version
    return currValue;
  }
  else
  {
    // no number at this location
    return null;
  }
}


/**
 * Returns true if the hour index is considered PM.
 */
function _isPM(
  hours
  )
{
  return (hours >= 12);
}


/**
 * Pad out a number with leading 0's to meet the minDigits digits or
 * truncate to meet the minDigits.
 */
function _getPaddedNumber(
  number,
  minDigits,
  maxDigits
  )
{  
  var stringNumber = number.toString();
  
  //
  // pad out any number strings that are too short
  //
  if (minDigits != null)
  {    
    var addedDigits = minDigits - stringNumber.length;
  
    while (addedDigits > 0)
    {
      stringNumber = "0" + stringNumber;
      addedDigits--;
    }
  }
  
  //
  // truncate any number strings that are too long
  //
  if (maxDigits != null)
  {
    var extraDigits = stringNumber.length - maxDigits;
    
    if (extraDigits > 0)
    {
      stringNumber = stringNumber.substring(extraDigits,
                                            extraDigits + maxDigits);
    }
  }
  
  return stringNumber;
}


/**
 * External variable for TrDateTimeConverter. Maps locales to lists of 
 * convenience patterns.
 */
var _CONVENIENCE_PATTERNS = null;

/**
 * Construct a TrDateTimeConverter with the specifed date pattern for
 * the specified locale.
 */
window.TrDateTimeConverter = function(
  pattern,  
  locale,
  exampleString,
  type,
  messages)
{
  // for debugging
  this._class = "TrDateTimeConverter";
  this._exampleString = exampleString;
  this._type = type;
  this._messages = messages;
  this._offset = null;
  
  // save the Locale elements for the specified locale, or client locale
  // if no locale is specified
  this._localeSymbols = getLocaleSymbols(locale);

  // =-= bts need to change default pattern to match JDK
  if (pattern == null)
    pattern = this._localeSymbols.getShortDatePatternString();

  var patterns = this._initPatterns(pattern, locale);

  // Stash away the patterns for later use.
  this._pattern = patterns;

  // Use a fallback example string if necessary
  if (this._exampleString == null && patterns != null && patterns.length > 0)
    this._exampleString = patterns[0];

  this._locale = (locale != null) ? locale : getJavaLanguage(locale);
};

TrDateTimeConverter.prototype = new TrConverter();

TrDateTimeConverter.prototype.getFormatHint = function()
{
	//customized hint
	if(this._messages && this._messages["hint"])
	{
    return TrMessageFactory.createCustomMessage(
      this._messages["hint"],
      ""+this._exampleString);
		
	}
	else
	{
		//no customized hint
		var key = "org.apache.myfaces.trinidad.convert.DateTimeConverter." + this._type + "_HINT";
    return TrMessageFactory.createMessage(
      key,
      ""+this._exampleString);
	}
}

TrDateTimeConverter.prototype.getAsString = function(
  formatTime
  )
{

  //correct Date Time ?
  if(this._offset)
  {
    var min = formatTime.getMinutes();
    formatTime.setMinutes((+min) - parseInt(this._offset));
  }
  var stringHolder = new Object();
  stringHolder.value ="";
  
  var pattern = this._pattern;
  if (typeof pattern != "string")
    pattern = pattern[0];
    
  _doClumping(pattern,
              this._localeSymbols,
              this._locale,
              _subformat,
              formatTime,
              stringHolder);

  if(this._offset)
  {
  	var gmtDiff = (((this._offset + formatTime.getTimezoneOffset()) * -1) / 60);
  	if(parseInt(gmtDiff) > 0)
  	{
  		stringHolder.value = stringHolder.value + "+"
  	}
  	stringHolder.value = stringHolder.value + gmtDiff + ":00";
  }
  return stringHolder.value;
}

TrDateTimeConverter.prototype.setDiffInMins = function(
  offset
  )
{ 
  this._offset = offset;
}

TrDateTimeConverter.prototype.getDiffInMins = function()
{
  return this._offset;
}

TrDateTimeConverter.prototype.getLocaleSymbols = function()
{
  return this._localeSymbols;
}


/**
 * Parses a String into a Date using the current object's pattern.  If the
 * parsing fails, undefined will be returned.
 */
TrDateTimeConverter.prototype.getAsObject  = function(
  parseString,
  label
  )
{
  // The following are from the javadoc for DateTimeConverter
  // If the specified String is null, return a null. Otherwise, trim leading and trailing whitespace before proceeding.
  // If the specified String - after trimming - has a zero length, return null.
  if (parseString == null)
    return null;

  parseString = TrFormatUtils.trim(parseString);
  if (parseString.length == 0)
    return null;

  var pattern = this._pattern;
  
  var invalidFormatMsg;
  var key = "org.apache.myfaces.trinidad.convert.DateTimeConverter.CONVERT_"+this._type;
  if(this._messages && this._messages["detail"])
  {
    invalidFormatMsg = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key),
                                          this._messages["detail"],
                                          label,
                                          parseString,
                                          this._exampleString);
  }
  else
  {
    invalidFormatMsg = _createFacesMessage( key,
                                          label,
                                          parseString,
                                          this._exampleString);
  }
  
  var invalidDateMsg = _createFacesMessage ("org.apache.myfaces.trinidad.convert.DateTimeConverter.CONVERT_DATE_INVALID_DATE", 
                                            label, 
                                            parseString);
  
  if (typeof pattern == "string")
  {
    return this._simpleDateParseImpl(parseString,
                                pattern,
                                this._localeSymbols,
                                this._locale,
                                invalidFormatMsg,
                                invalidDateMsg);
  }
  else
  { 
    var i;
    for (i = 0; i < pattern.length; i++)
    {
      try{
        var date = this._simpleDateParseImpl(parseString,
                                        pattern[i],
                                        this._localeSymbols,
                                        this._locale,
                                        invalidFormatMsg,
                                        invalidDateMsg);
        return date;
      }
      catch (e)
      {
        // Trinidad-1634: If the format is valid, but the date is invalid,
        // return that error instead of trying other formats.
        if (e.isDateInvalid)
          throw e;
          
        // if we're not on the last pattern try the next one, 
        // but if we're on the last pattern, throw the exception
        if ( i == pattern.length-1 )
          throw e;
      }
    }
  }
}

TrDateTimeConverter.prototype._endsWith = function(
  value,
  suffix
  )
{
  // TODO: add to a String utils class ?
  var startPos = value.length - suffix.length;
  if (startPos < 0)
    return false;
  return (value.lastIndexOf(suffix, startPos) == startPos);
}

TrDateTimeConverter.prototype._initPatterns  = function(
  pattern, locale)
{
  // We need to build up an Array of all acceptable patterns,
  // which we'll stash away for later use.  If we do lenient
  // parsing, then we may end up supporting a variety of patterns
  // that weren't passed in via the "pattern" arg.  Previously,
  // if the "pattern" arg is itself an Array, we just tacked
  // any additional lentient patterns right into the "pattern"
  // Array.  However, the "pattern" Array is actually referenced
  // from other locations, so we should avoid modifying this
  // array directly.  Instead, we create our own "patterns"
  // Array and append all supported patterns into this Array.
  var patterns = new Array();

  // Array from which the patterns array will be constructed.
  var tmpPatterns = new Array();
  
  // If pattern is non-null, append it to the tmpPatterns array.
  if (pattern)
    tmpPatterns = tmpPatterns.concat(pattern);

  // At this point 'locale' is the value of the locale attribute; if 'locale' is 
  // null, we should make sure to grab the same locale that was grabbed by getLocaleSymbols() (i.e.,getJavaLanguage)
  if (!locale)
    locale = getJavaLanguage(locale);
  
  // Make sure the static map of convenience patterns has been initialized.
  if (!_CONVENIENCE_PATTERNS)
    this._initConveniencePatterns();
  
  // see TRINIDAD-859
  var convPatterns = _CONVENIENCE_PATTERNS[locale];
  if (convPatterns)
    tmpPatterns = tmpPatterns.concat(convPatterns);
  
  // Add the tmp patterns and all their lenient pattern variants.
  var len = tmpPatterns.length;
  for (var c = 0; c < len; c++)
  {
    var convPattern = tmpPatterns[c];
    patterns[patterns.length] = convPattern;
    var baseCount = 1;
    
    // Bug 2002065: 
    // Be forgiving of users who prefer a different separator and alternative 
    // month styles. We are to be lenient by default with ADF Faces.
    
    // We should add all the leniency patterns for this default pattern first.
    // First add in replacements for month parsing.
    if (convPattern.indexOf('MMM') != -1)
    {
      patterns[patterns.length] = convPattern.replace(/MMM/g, 'MM');
      patterns[patterns.length] = convPattern.replace(/MMM/g, 'M');
      baseCount = 3;
    }
    
    // Now add support for all of the above with any of the separators below. 
    // The separator is the same for all patterns since we only replaced month.
    var idx = patterns.length - baseCount;
    if (convPattern.indexOf('/') !=  - 1)
    {
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/\//g, '-');
      
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/\//g, '.');
    }
    else if (convPattern.indexOf('-') !=  - 1)
    {
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/-/g, '/');
      
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/-/g, '.');
    }
    else if (convPattern.indexOf('.') !=  - 1)
    {
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/\./g, '-');
      
      for (var i = idx; i < idx + baseCount; i++)
        patterns[patterns.length] = patterns[i].replace(/\./g, '/');
    }
  }
  
  return patterns;
}

/**
 * Initialize the static map of convenience patterns. This should only be called 
 * if _CONVENIENCE_PATTERNS is null (so that this map is recreated only when the 
 * page is reloaded). All map entries MUST match those of the server map:
 * trinidad-api\src\main\java\org\apache\myfaces\trinidad\convert\DateTimeConverter.java->_CONVENIENCE_PATTERNS
 */
TrDateTimeConverter.prototype._initConveniencePatterns = function() 
{
  _CONVENIENCE_PATTERNS = new Object();
  
  // All map entries added here MUST match the entries added to the server map:
  // trinidad-api\src\main\java\org\apache\myfaces\trinidad\convert\DateTimeConverter.java->_CONVENIENCE_PATTERNS
  _CONVENIENCE_PATTERNS.en_US = ["MMMM dd, yy", "MMMM/dd/yy", "dd-MMMM-yy"];  
}

TrDateTimeConverter.prototype._simpleDateParseImpl = function(
  parseString,
  parsePattern,
  localeSymbols,
  locale,
  invalidFormatMsg,
  invalidDateMsg)
{
  // When a pattern (e.g. dd.MM.yyyy HH:mm' Uhr ') requires a whitespace
  // at the end, we should honor that. As the JSF spec (see http://bit.ly/kTelf)
  // wants the converter to trim leading/trailing whitespace, we have to append
  // one, if the pattern requires it at the end...
  if(this._endsWith(parsePattern, " '"))
  {
    parseString += " ";
  }
	
  var parseContext = new Object();
  parseContext.currIndex = 0;
  parseContext.parseString = parseString;
  parseContext.parsedHour = null;
  parseContext.parsedMinutes = null;
  parseContext.parsedSeconds = null;
  parseContext.parsedMilliseconds = null;
  parseContext.isPM = false;
  parseContext.parsedBC = false;
  parseContext.parsedFullYear = null;
  parseContext.parsedMonth = null;
  parseContext.parsedDate = null;
  parseContext.hourOffset = null;
  parseContext.minOffset = null;

  var parsedTime = new Date(0);
  parsedTime.setDate(1);

  // parse the time
  if (_doClumping(parsePattern,
                  localeSymbols,
                  locale,
                  _subparse,
                  parseContext,
                  parsedTime))
  {
    if (parseString.length != parseContext.currIndex)
    {
      parseContext.parseException = new TrConverterException (invalidFormatMsg);
      throw parseContext.parseException;
    }

    // give up instantly if we encounter timezone because
    // the client can never correctly convert to a milliseconds
    // value accurately due to lack of timezone and Daylight savings
    // rules in Javascript
    // Undefined is used in _multiValidate as a flag to skip
    // validation and avoid required errors (which returning null would trigger)
    if ((parseContext.hourOffset != null) || 
       (parseContext.minOffset != null))
      return undefined;

    // Set the parsed year, if any;  adjust for AD vs. BC
    var year = parseContext.parsedFullYear;
    if (year != null)
    {
      // convert year to BC
      if (parseContext.parsedBC)
      {
        year = _getADEra().getFullYear() - year;
      }

      parsedTime.setFullYear(year);
      parseContext.parsedFullYear = year;
    }

    // Set the parsed month, if any
    var month = parseContext.parsedMonth;
    if (month != null)
      parsedTime.setMonth(month);

    // Set the parsed day-of-month, if any
    var date = parseContext.parsedDate;
    if (date != null)
      parsedTime.setDate(date);

    // Set the parsed hour, if any.  Adjust for AM vs. PM
    var hour = parseContext.parsedHour;
    if (hour != null)
    {
      if (parseContext.isPM && (hour < 12))
      {
        hour += 12;
      }

      parsedTime.setHours(hour);
      parseContext.parsedHour = hour;
    }

    // Set the parsed minutes, if any
    var minutes = parseContext.parsedMinutes;
    if (minutes != null)
      parsedTime.setMinutes(minutes);

    // Set the parsed seconds, if any
    var seconds = parseContext.parsedSeconds;
    if (seconds != null)
      parsedTime.setSeconds(seconds);

    // Set the parsed milliseconds, if any
    var milliseconds = parseContext.parsedMilliseconds;
    if (milliseconds != null)
      parsedTime.setMilliseconds(milliseconds);

    // so far we have done a lenient parse
    // now we check for strictness
    if (!_isStrict(parseContext, parsedTime))
    {
      // Trinidad-1634: If the format is correct, but the date doesn't 
      // match, throw a different error.
      parseContext.parseException = new TrConverterException (invalidDateMsg);
      parseContext.parseException.isDateInvalid = true;
      throw parseContext.parseException;
    }
      
    //correct Date Time ?
    if(this._offset)
    {
      var min = parsedTime.getMinutes();
      parsedTime.setMinutes((+min) + parseInt(this._offset));
    }

    return parsedTime;
  }
  else
  {
    // failure
     parseContext.parseException = new TrConverterException (invalidFormatMsg);
     throw parseContext.parseException;
  }
}
/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 * constructor for TrNumberFormat.
 */
window.TrNumberFormat = function(type, locale)
{
  if(!type)
    alert("type for TrNumberFormat not defined!");
  this._type = type;
  
  this._localeSymbols = getLocaleSymbols(locale);
  this._pPre = this._localeSymbols.getPositivePrefix();
  this._pSuf = this._localeSymbols.getPositiveSuffix();
  this._nPre = this._localeSymbols.getNegativePrefix();
  this._nSuf = this._localeSymbols.getNegativeSuffix();

  //default values, similar to JDK (values from Apache Harmony)
  this._maxFractionDigits = 3;
  this._maxIntegerDigits  = 40;
  if(this._type=="currency")
  {
    this._minFractionDigits = 2;
  }
  else
  {
    this._minFractionDigits = 0;
  }
  this._minIntegerDigits  = 1;
  this._groupingUsed = true;
};

//***********************
// static
//***********************

/**
 * Returns a number formater.
 */
TrNumberFormat.getNumberInstance = function(locale)
{
  return new TrNumberFormat("number", locale);
}

/**
 * Returns a currency formater.
 */
TrNumberFormat.getCurrencyInstance = function(locale, currencyCode, currencySymbol)
{
  var numberFormat = new TrNumberFormat("currency", locale);

  // In Trinidad the currencyCode gets preference over currencySymbol
  // this is similar on the server-side
  if (currencyCode)
  {
    var generalCurrencyCode = getLocaleSymbols().getCurrencyCode();
    numberFormat._pPre = numberFormat._pPre.replace(generalCurrencyCode, currencyCode);
    numberFormat._pSuf = numberFormat._pSuf.replace(generalCurrencyCode, currencyCode);
    numberFormat._nPre = numberFormat._nPre.replace(generalCurrencyCode, currencyCode);
    numberFormat._nSuf = numberFormat._nSuf.replace(generalCurrencyCode, currencyCode);
  }
  else if (currencySymbol)
  {
    var generalCurrencySymbol = getLocaleSymbols().getCurrencySymbol();
    numberFormat._pPre = numberFormat._pPre.replace(generalCurrencySymbol, currencySymbol);
    numberFormat._pSuf = numberFormat._pSuf.replace(generalCurrencySymbol, currencySymbol);
    numberFormat._nPre = numberFormat._nPre.replace(generalCurrencySymbol, currencySymbol);
    numberFormat._nSuf = numberFormat._nSuf.replace(generalCurrencySymbol, currencySymbol);
  }

  return numberFormat;
}

/**
 * Returns a percent formater.
 */
TrNumberFormat.getPercentInstance = function(locale)
{
  return new TrNumberFormat("percent", locale);
}

/**
 * Sets whether this NumberFormat formats and parses numbers using a
 * grouping separator.
 * 
 * @param value true when a grouping separator is used, false otherwise
 */
TrNumberFormat.prototype.setGroupingUsed = function(groupingUsed)
{
  this._groupingUsed = groupingUsed;
}

/**
 * Answers whether this NumberFormat formats and parses numbers using a
 * grouping separator.
 * 
 * @return true when a grouping separator is used, false otherwise
 */
TrNumberFormat.prototype.isGroupingUsed = function()
{
  return this._groupingUsed;
}

/**
 * Used to specify the new maximum count of integer digits that are printed
 * when formatting. If the maximum is less than the number of integer
 * digits, the most significant digits are truncated.
 * 
 * @param value the new maximum number of integer numerals for display
 */
TrNumberFormat.prototype.setMaximumIntegerDigits = function(number)
{
  //taken from the Apache Harmony project
  if(number)
  {
    this._maxIntegerDigits = number < 0 ? 0 : number;
    if (this._minIntegerDigits > this._maxIntegerDigits)
    {
      this._minIntegerDigits = this._maxIntegerDigits;
    }
  }
} 

/**
 * Answers the maximum number of integer digits that are printed when
 * formatting. If the maximum is less than the number of integer digits, the
 * most significant digits are truncated.
 * 
 * @return the maximum number of integer digits
 */
TrNumberFormat.prototype.getMaximumIntegerDigits = function()
{
  //taken from the Apache Harmony project
  return this._maxIntegerDigits;
}

/**
 * Sets the maximum number of fraction digits that are printed when
 * formatting. If the maximum is less than the number of fraction digits,
 * the least significant digits are truncated.
 * 
 * @param value the maximum number of fraction digits
 */
TrNumberFormat.prototype.setMaximumFractionDigits = function(number)
{
  //taken from the Apache Harmony project
  if(number)
  {
    this._maxFractionDigits = number < 0 ? 0 : number;
    if (this._maxFractionDigits < this._minFractionDigits)
    {
      this._minFractionDigits = this._maxFractionDigits;
    }
    this._isMaxFractionDigitsSet  = true;    
  }
} 

/**
 * Answers the maximum number of fraction digits that are printed when
 * formatting. If the maximum is less than the number of fraction digits,
 * the least significant digits are truncated.
 * 
 * @return the maximum number of fraction digits
 */
TrNumberFormat.prototype.getMaximumFractionDigits = function()
{
  //taken from the Apache Harmony project
  return this._maxFractionDigits;
}

/**
 * Sets the minimum number of integer digits that are printed when
 * formatting.
 * 
 * @param value the minimum number of integer digits
 */
TrNumberFormat.prototype.setMinimumIntegerDigits = function(number)
{
  //taken from the Apache Harmony project
  if(number)
  {
    this._minIntegerDigits = number < 0 ? 0 : number;
    if(this._minIntegerDigits > this._maxIntegerDigits)
    {
      this._maxIntegerDigits = this._minIntegerDigits;
    }
  }
}

/**
 * Answers the minimum number of integer digits that are printed when
 * formatting.
 * 
 * @return the minimum number of integer digits
 */
TrNumberFormat.prototype.getMinimumIntegerDigits = function()
{
  //taken from the Apache Harmony project
  return this._minIntegerDigits;
}

/**
 * Sets the minimum number of fraction digits that are printed when
 * formatting.
 * 
 * @param value the minimum number of fraction digits
 */
TrNumberFormat.prototype.setMinimumFractionDigits = function(number)
{
  //taken from the Apache Harmony project
  if(number)
  {
    this._minFractionDigits = number < 0 ? 0 : number;
    if (this._maxFractionDigits < this._minFractionDigits)
    {
      this._maxFractionDigits = this._minFractionDigits;
    }
  }
}

/**
 * Answers the minimum number of fraction digits that are printed when
 * formatting.
 * 
 * @return the minimum number of fraction digits
 */
TrNumberFormat.prototype.getMinimumFractionDigits = function()
{
  //taken from the Apache Harmony project
  return this._minFractionDigits;
}

/**
 * Based on the type this func returns a percentage, currency or number string.
 */
TrNumberFormat.prototype.format = function(number)
{
  if(this._type=="percent")
    return this.percentageToString(number);
  else if (this._type=="currency")
    return this.currencyToString(number);
  else if (this._type=="number")
    return this.numberToString(number);
}

/**
 * Based on the type this func returns a number result, from the given formatted string.
 */
TrNumberFormat.prototype.parse = function(string)
{
  if(this._type=="percent")
    return this.stringToPercentage(string);
  else if (this._type=="currency")
    return this.stringToCurrency(string);
    
  // ELSE: assume this._type=="number"
  return this.stringToNumber(string);
}

/**
 * Formats a number string into a number.
 */
TrNumberFormat.prototype.stringToNumber = function(numberString)
{
  // parseFloat("123abc45") returns 123, but 123abc45 is considered an invalid number on the server, 
  // so check for a valid number first. Exclude non-numbers and disallow exponential notation.
  if (isNaN(numberString) || numberString.indexOf('e') != -1 || numberString.indexOf('E') != -1)
  {
    throw new TrParseException("not able to parse number");
  }
  return parseFloat(numberString);
}

/**
 * Formats a currency string into a number.
 */
TrNumberFormat.prototype.stringToCurrency = function(numberString)
{
  //is the string negative ?
  var negP = numberString.indexOf(this._nPre);
  var nSufNoSpace = this._nSuf;
  if (nSufNoSpace.charAt(0) == ' ' || nSufNoSpace.charAt(0) == '\xa0')
    nSufNoSpace = nSufNoSpace.substring(1);
  var negS = numberString.indexOf(nSufNoSpace);


  // TRINIDAD-1958: In Arabic the values for negPrefix and posPrefix are the same, so it is insufficient to test for
  // the presence of (only) negPrefix to determine if the number is negative. 
  if(negP != -1 && negS != -1)
  {
    numberString = numberString.substr(this._nPre.length, numberString.length - (this._nPre.length + nSufNoSpace.length));
    return (this.stringToNumber(numberString) * -1);
  }
  else
  {
    var posP = numberString.indexOf(this._pPre);
    var pSufNoSpace = this._pSuf;
    if (pSufNoSpace.charAt(0) == ' ' || pSufNoSpace.charAt(0) == '\xa0')
      pSufNoSpace = pSufNoSpace.substring(1);
    var posS = numberString.indexOf(pSufNoSpace);

    if(posP != -1 && posS != -1)
    {
      numberString = numberString.substr (this._pPre.length, numberString.length - (this._pPre.length + pSufNoSpace.length));
      numberString = this.stringToNumber(numberString);
      return numberString;
    }
    else
    {
       throw new TrParseException("not able to parse number");
    }//end-if we could not find a positive or negative prefix/suffix pair
  }//end-if not negative
}

/**
 * Formats a percent string into a number.
 */
TrNumberFormat.prototype.stringToPercentage = function(percentString)
{
  var isPercentage = (percentString.indexOf('%') != -1);
  if (!isPercentage)
  {
    throw new TrParseException("not able to parse number");
  }

  var numberString = percentString.replace(/\%/g, '');
  return this.stringToNumber(numberString);
}

/**
 * Formats a number into a a formatted string.
 */
TrNumberFormat.prototype.numberToString = function(number)
{
  //negative ?
  var negative = number<0;
  if(negative)
    number = (number*-1);

  var numberString = number + "";
  
  // check for scientific notation
  numberString = TrNumberFormat.scientificToExpanded(numberString);
  
  var index = numberString.indexOf(".");
  var numberStringLength = numberString.length;
  var ints;
  var fracs;
  if(index != -1)
  {
    ints = numberString.substring(0, index);
    fracs = numberString.substring(index+1, numberStringLength);
  }
  else
  {
    ints = numberString;
    fracs = "";
  }

  ints  = this._formatIntegers(ints);
  fracs = this._formatFractions(fracs)
  
  var decimalSeparator = this._localeSymbols.getDecimalSeparator();

  if(fracs!="")
    numberString = (ints+decimalSeparator+fracs);
  else
    numberString = (ints);
  
  if(negative)
    numberString = "-" + numberString;
  
  return numberString;
  
}

/**
 * Formats a number into a a formatted currency string.
 */
TrNumberFormat.prototype.currencyToString = function(number)
{
  //negative ?
  if(number<0)
  {
    number = (number*-1)+"";
    number = this.numberToString(number);
    return this._nPre + number + this._nSuf;
  }
  else
  {
    number = this.numberToString(number);
    return this._pPre + number + this._pSuf;
  }
}

/**
 * Formats a number into a a formatted percent string.
 */
TrNumberFormat.prototype.percentageToString = function(number)
{
  number = number * 100;
  // TRINIDAD-2139: getRounded calls Math.round() on number. Since number is
  // multiplied by 100 before this call and later divided, the result will 
  // have at most 2 fractional digits, regardless of the value of maxFractionDigits. 
  // Hence, if maxFractionDigits is set, don't call this method and let 
  // numberToString format the string appropriately. 
  if (this._isMaxFractionDigitsSet == null)
    {
      number = this.getRounded(number);
    }
    else
    {
      // Bug 14407633. The above call to getRounded() doesn't get called if the
      // maxFractionDigits is specified. getRoundedFixedDigits() was added to handle
      // rounding in this case.
      if (this._maxFractionDigits != null)
      {
        number = this.getRoundedFixedDigits(number, this._maxFractionDigits);
      }
    }
  if (isNaN(number))
  {
    throw new TrParseException("not able to parse number");
  } 

  // Get the percent suffix. I.e. in French the suffix is " %", not just "%". The following assumes 
  // the percent suffix is the same when the number is positive or negative.
  var suffix = this._localeSymbols.getPercentSuffix();
  // Get the percent prefix. I.e. in Turkish percentage sign (%) should precede the numeral. 
  // There should be no spaces between percentage sign and number. e.g. %5, %76,5, -%5. Also
  // a trim() operation is add in:
  // Build/CustomAntTasks/src/oracle/adfmobile/ant/tasks/GenerateLocaleElementsTask.java to 
  // avoid the extra space between percentage sign and number.
  var prefix;
  if (number >= 0)
  {
    prefix = this._localeSymbols.getPercentPositivePrefix();
  }
  else
  {
    prefix = this._localeSymbols.getPercentNegativePrefix();
  }
  var formattedString = null;
  if (suffix && suffix != "")
  {
    formattedString = this.numberToString(number) + suffix;
  }
  else if (prefix || prefix != "")
  {
    formattedString = prefix + this.numberToString(Math.abs(number));
  }
    
  // It also assumes that the locale indeed uses a percent suffix or a prefix, if that assumption is 
  // wrong, we should be notified by the following exception. If any changes need to be made, you 
  // should start by looking at _getPercentData() in:
  // Build/CustomAntTasks/src/oracle/adfmobile/ant/tasks/GenerateLocaleElementsTask.java
  else
  {
    throw new TrParseException("both percent suffix and prefix are undefined or empty");
  }
  return formattedString;
}

/**
 * Static utility function.
 * Converts a number string from scientific notation to standard expanded notation.
 */
TrNumberFormat.scientificToExpanded = function(numberString)
{
  // check for scientific notation
  var expIndex = numberString.indexOf('e');
  if (expIndex == -1)
    return numberString;
    
  var prefix = "";
  if (numberString.charAt(0) == '-')
  {
    prefix = "-";
    numberString = numberString.substring(1);
    expIndex -= 1;
  }
  
  var isPosExp = numberString.charAt(expIndex + 1) == '+';
  var exp = parseInt(numberString.substring(expIndex + 2));
  var nFractionDigits = expIndex - 2;
  var zeroes = "";
  
  // The exponent should always be greater than the number of fraction digits.
  if (isPosExp)
  {
    for (var i = 0; i < exp - nFractionDigits; ++i)
      zeroes += "0";
      
    return prefix + numberString.charAt(0) + numberString.substring(2, expIndex) + zeroes;
  }
  
  // ELSE: negative exponent
  for (var i = 0; i < exp - 1; ++i)
    zeroes += "0";
    
  return prefix + "0." + zeroes + numberString.charAt(0) + numberString.substring(2, expIndex);
}

/**
 * Static utility function.
 * Trims extraneous leading zeroes.
 */
TrNumberFormat.trimLeadingZeroes = function(numberString)
{
  var strbuf = [];
  var i, ch;
  for (i = 0; i < numberString.length; ++i)
  {
    ch = numberString.charAt(i);
    
    if ((ch >= '1' && ch <= '9') || ch == '.')
      break;
      
    if (ch == '0' && i+1 < numberString.length && numberString.charAt(i+1) != '.')
      continue;
      
    strbuf.push(ch);
  }
  
  return strbuf.join('') + numberString.substring(i);
}

/**
 * Bug 14407633. Helper method for rounding values when digits of precision are known. 
 **/

TrNumberFormat.prototype.getRoundedFixedDigits = function(val, digits)
{
  var newVal = Math.round(val * Math.pow(10, digits)) / Math.pow(10, digits);
  return newVal;
}

/**
 * helper for rounding values
 */
TrNumberFormat.prototype.getRounded = function(val)
{
  val = this.moveDecimalRight(val);
  val = Math.round(val);
  val = this.moveDecimalLeft(val);
  return val;
}

/**
 * helper for rounding values
 */
TrNumberFormat.prototype.moveDecimalRight = function(val)
{
  var newVal = '';
  newVal = this.moveDecimal(val, false);
  return newVal;
}

/**
 * helper for rounding values
 */
TrNumberFormat.prototype.moveDecimalLeft = function (val)
{
  var newVal = '';
  newVal = this.moveDecimal(val, true);
  return newVal;
}

/**
 * helper for rounding values
 */
TrNumberFormat.prototype.moveDecimal = function(val, left)
{
  var newVal = '';
  newVal = this.moveDecimalAsString(val, left);
  return parseFloat(newVal);
}

/**
 * helper for rounding values
 */
TrNumberFormat.prototype.moveDecimalAsString = function(val, left)
{
  //TODO: matzew make it nicer....
  var spaces = 2;
  if (spaces <= 0)
    return val; 
  var newVal = val + '';
  var extraZ = this.getZeros(spaces);
  var re1 = new RegExp('([0-9.]+)');
  if (left)
  {
    newVal = newVal.replace(re1, extraZ + '$1');
    var re2 = new RegExp('(-?)([0-9]*)([0-9]{' + spaces + '})(\\.?)');
    newVal = newVal.replace(re2, '$1$2.$3');
  }
  else
  {
    var reArray = re1.exec(newVal); 
    if (reArray != null)
    {
      newVal = newVal.substring(0,reArray.index) + reArray[1] + extraZ + newVal.substring(reArray.index + reArray[0].length); 
    }
    var re2 = new RegExp('(-?)([0-9]*)(\\.?)([0-9]{' + spaces + '})');
    newVal = newVal.replace(re2, '$1$2$4.');
  }
  newVal = newVal.replace(/\.$/, ''); 
  return newVal;
}

/**
 * 
 */
TrNumberFormat.prototype.getZeros = function(places)
{
  var extraZ = '';
  var i;
  for (i=0; i<places; i++) {
    extraZ += '0';
  }
  return extraZ;
}

//***********************
// PRIVATE
//***********************

/**
 * Formats the integer part of a number
 */
TrNumberFormat.prototype._formatIntegers = function(ints)
{
  var intsLength = ints.length;
  var maxInt = this.getMaximumIntegerDigits();
  var minInt = this.getMinimumIntegerDigits();

  var gap;
  if(intsLength>maxInt)
  {
    gap = intsLength-maxInt;
    ints = ints.substring(gap, intsLength);
  }
  else if(intsLength<minInt)
  {
    gap = minInt-intsLength;
    var leadingZeros = "";
    
    //we need some more leadingZeros
    while(gap>0)
    {
      leadingZeros = "0"+leadingZeros;
      --gap;
    }
    
    ints = leadingZeros + ints;
  }
  
  if(this.isGroupingUsed())
  {
    ints = this._addGroupingSeparators(ints);
  }

  return ints;
}

/**
 * Formats the fraction part of a number
 */
TrNumberFormat.prototype._formatFractions = function(fracs)
{
  var fracsLength = fracs.length;
  var maxFra = this.getMaximumFractionDigits();
  var minFra = this.getMinimumFractionDigits();

  if(fracsLength > maxFra && maxFra >= minFra)
  {
    fracs = fracs.substring(0, maxFra);
  }
  if(fracsLength <minFra)
  {
    var gap = minFra-fracsLength;
    
    //we need to add some zeros
    while(gap>0)
    {
      fracs = fracs + "0";
      --gap;
    }
  }
  return fracs;
}

/**
 * Adds localized grouping separators to a number string.
 */
TrNumberFormat.prototype._addGroupingSeparators = function(ints)
{
  var counter = ints.length;
  var toMuch = counter%3;
  var balance;
  var toFormat;
  var formatted = "";
  var groupingSeparator = this._localeSymbols.getGroupingSeparator();

  if(toMuch>0)
  {
    balance = (counter < 4) ? ints.substring(0, toMuch) : ints.substring(0, toMuch) + groupingSeparator;
    toFormat = ints.substring(toMuch, counter);
  }
  else
  {
    balance = "";
    toFormat = ints;
  }

  for(i=0; i < toFormat.length; i++)
  {
    if(i%3==0 && i!=0)
    {
      formatted += groupingSeparator;
    }
    formatted += toFormat.charAt(i);
  }
  ints = balance + formatted;
  return ints;
}
/** 
 * TrParseException is an exception thrown by the TrNumberFormater.
 * TODO: loclized messages ?
 */
window.TrParseException = function(message)
{
  this._message = message;
};

TrParseException.prototype.getMessage = function()
{
  return this._message;
}
/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 * constructor of client side NumberConverter class
 */ 
window.TrNumberConverter = function(
  pattern,  
  type,
  locale,
  messages,
  integerOnly,
  groupingUsed,
  currencyCode,
  currencySymbol,
  maxFractionDigits,
  maxIntegerDigits,
  minFractionDigits,
  minIntegerDigits)
{
  this._pattern = pattern;
  this._type = type;
  this._locale = locale;
  this._messages = messages;
  this._currencyCode = currencyCode;
  this._currencySymbol = currencySymbol;
  this._maxFractionDigits = maxFractionDigits;
  this._maxIntegerDigits = maxIntegerDigits;
  this._minFractionDigits = minFractionDigits;
  this._minIntegerDigits = minIntegerDigits;
  
  //set the integerOnly value
  if(integerOnly !== undefined)
    this._integerOnly = integerOnly;
  else
    this._integerOnly = false;
    
  //set the groupingUsed value
  if(groupingUsed !== undefined)
    this._groupingUsed = groupingUsed;
  else
    this._groupingUsed = true;
    
  //init the TrNumberFormat
  this._initNumberFormat(locale);
  
  // for debugging
  this._class = "TrNumberConverter";
};

TrNumberConverter.prototype = new TrConverter();

//***********************
// PUBLIC
//***********************

TrNumberConverter.prototype.setCurrencyCode = function(currencyCode)
{
  this._currencyCode = currencyCode;
}
TrNumberConverter.prototype.getCurrencyCode = function()
{
  return this._currencyCode;
}
TrNumberConverter.prototype.setCurrencySymbol = function(currencySymbol)
{
  this._currencySymbol = currencySymbol;
}
TrNumberConverter.prototype.getCurrencySymbol = function()
{
  return this._currencySymbol;
}

TrNumberConverter.prototype.setMaxFractionDigits = function(maxFractionDigits)
{
  this._maxFractionDigits = maxFractionDigits;
}
TrNumberConverter.prototype.getMaxFractionDigits = function()
{
  return this._maxFractionDigits;
}

TrNumberConverter.prototype.setMaxIntegerDigits = function(maxIntegerDigits)
{
  this._maxIntegerDigits = maxIntegerDigits;
}
TrNumberConverter.prototype.getMaxIntegerDigits = function()
{
  return this._maxIntegerDigits ;
}

TrNumberConverter.prototype.setMinFractionDigits = function(minFractionDigits)
{
  this._minFractionDigits = minFractionDigits;
}
TrNumberConverter.prototype.getMinFractionDigits = function()
{
  return this._minFractionDigits;
}

TrNumberConverter.prototype.setMinIntegerDigits = function(minIntegerDigits)
{
  this._minIntegerDigits = minIntegerDigits;
}
TrNumberConverter.prototype.getMinIntegerDigits = function()
{
  return this._minIntegerDigits;
}

TrNumberConverter.prototype.setGroupingUsed = function(groupingUsed)
{
  this._groupingUsed = groupingUsed;
}
TrNumberConverter.prototype.isGroupingUsed = function()
{
  return this._groupingUsed;
}

TrNumberConverter.prototype.setIntegerOnly = function(integerOnly)
{
  this._integerOnly = integerOnly;
}
TrNumberConverter.prototype.isIntegerOnly = function()
{
  return this._integerOnly;
}

TrNumberConverter.prototype.getFormatHint = function()
{
  if(this._messages && this._messages["hintPattern"])
  {
    return TrMessageFactory.createCustomMessage(
      this._messages["hintPattern"],
      this._pattern);
  }
  else
  {
    if(this._pattern)
    {
      return TrMessageFactory.createMessage(
      "org.apache.myfaces.trinidad.convert.NumberConverter.FORMAT_HINT",
      this._pattern);
    }
    else
    {
      return null;
    }
  }
}

/**
 * Returns the number value as string or undefined (see also _isConvertible).
 */
TrNumberConverter.prototype.getAsString = function(
  number,
  label
  )
{
  if(this._isConvertible()) // TODO nothing was passed in here but seems a string is needed?
  {
    if(this._type=="percent" || this._type=="currency")
    {
      var string = this._numberFormat.format(number);
      if(this._type=="currency")
      {
        //In Trinidad the currencyCode gets preference over currencySymbol
        //this is similar on the server-side
        if(this._currencyCode)
        {
          string = string.replace(getLocaleSymbols().getCurrencyCode(), this._currencyCode);
        }
        else if(this._currencySymbol)
        {
          string = string.replace(getLocaleSymbols().getCurrencySymbol(), this._currencySymbol);
        }
      }
      return string;
    }
    else
    {
      if(typeof number === "string")
      {
        return this._numberFormat.format(parseFloat(number));
      }
      else
      {
        return this._numberFormat.format(parseFloat(number.toFixed(this._numberFormat.getMaximumFractionDigits())));
      }
    }
  }
  else
  {
    return undefined;
  }
}

/**
 * Returns the number value for the submitted string or undefined (see also _isConvertible).
 */
TrNumberConverter.prototype.getAsObject = function(
  numberString,
  label
  )
{
  numberString = TrFormatUtils.trim(numberString);
  
  if(this._isConvertible(numberString))
  {
    // The following are from the javadoc for Number and DateTimeConverter.
    // If the specified String is null, return a null. Otherwise, trim leading and trailing whitespace before proceeding.
    // If the specified String - after trimming - has a zero length, return null.
    if (numberString == null)
      return null;
    
    if (typeof numberString != "string")
      numberString = ""+numberString;
    
    if (numberString.length == 0)
      return null

    var parsedValue;
    if(this._type=="percent" || this._type=="currency")
    {
      var localeSymbols = getLocaleSymbols(this._locale);
      
      // TODO matzew - see TRINIDAD-682
      // Remove the thousands separator - which Javascript doesn't want to see
      var groupingSeparator = localeSymbols.getGroupingSeparator();
      
      if (groupingSeparator == "\xa0")
      {
        var normalSpace = new RegExp("\\ " , "g");
        numberString = numberString.replace(normalSpace, "\xa0");
      }
      
      var grouping = new RegExp("\\" + groupingSeparator, "g");
      numberString = numberString.replace(grouping, "");

      // Then change the decimal separator into a period, the only
      // decimal separator allowed by JS
      var decimalSeparator = localeSymbols.getDecimalSeparator();
      var decimal = new RegExp("\\" + decimalSeparator, "g");
      numberString = numberString.replace(decimal, ".");
      
      try
      {
        // parse the numberString
        numberString = this._numberFormat.parse(numberString)+"";     
      }
      catch(e)
      {
        // The user could have just left off the percent/currency symbol, so try 
        // parsing 'numberString' as a Number instead; if it still fails, then 
        // throw a converter exception.
        try
        {
          numberString = TrNumberFormat.getNumberInstance().parse(numberString)+"";
        }
        catch (e)
        {
          var facesMessage;
          var example = this._numberFormat.format(this._example);
          var key = "org.apache.myfaces.trinidad.convert.NumberConverter.CONVERT_" + this._type.toUpperCase();
          if (this._messages && this._messages[this._type])
          {
            facesMessage = _createCustomFacesMessage(TrMessageFactory.getSummaryString(key), this._messages[this._type], label, numberString, example);
          }
          else 
          {
            facesMessage = _createFacesMessage(key, label, numberString, example);
          }

          throw new TrConverterException(facesMessage);
        }
      }
      
      // to be able to pass the _decimalParse, we replace the decimal separator...
      // Note that _decimalParse uses the page locale.
      var jsSeparator = new RegExp("\\" + ".",  "g");
      numberString = numberString.replace(jsSeparator, getLocaleSymbols().getDecimalSeparator());
    }
    
    parsedValue = _decimalParse(numberString, 
                         this._messages,
                         "org.apache.myfaces.trinidad.convert.NumberConverter",
                         null,
                         null,
                         null,
                         null,
                         label,
                         !this.isIntegerOnly());

    parsedValue = parseFloat(parsedValue.toFixed(this._numberFormat.getMaximumFractionDigits()));

    if(this._type=="percent")
    {
      parsedValue = parsedValue / 100;
    }
    return parsedValue;
  }
  else
  {
    return undefined;
  }
}

//***********************
// PRIVATE
//***********************

/**
 * Checks if this converter can convert the value, which
 * is only true, if no pattern is set and the type is a number
 */
TrNumberConverter.prototype._isConvertible = function(numberString)
{
  // The locale attribute is now supported on convertNumber.
  if (this._pattern != null)
    return false;

  // check other common criteria as well.
  return TrFormatUtils.isNumberConvertible(numberString);   

}

/**
 * runs the creation of the used TrNumberFormat class
 */
TrNumberConverter.prototype._initNumberFormat = function(locale)
{
  if(this._type=="percent")
  {
    this._example = 0.3423;
    this._numberFormat = TrNumberFormat.getPercentInstance(locale);
  }
  else if(this._type=="currency")
  {
    this._example = 10250;
    this._numberFormat = TrNumberFormat.getCurrencyInstance(locale, this._currencyCode, this._currencySymbol);
  }
  else if(this._type=="number")
  {
  	this._numberFormat = TrNumberFormat.getNumberInstance(locale);
  }

  this._numberFormat.setGroupingUsed(this.isGroupingUsed());
  this._numberFormat.setMaximumFractionDigits(this.getMaxFractionDigits());
  this._numberFormat.setMaximumIntegerDigits(this.getMaxIntegerDigits());
  this._numberFormat.setMinimumFractionDigits(this.getMinFractionDigits());
  this._numberFormat.setMinimumIntegerDigits(this.getMinIntegerDigits());
}
adf.mf.internal.BUILD_INFO = {
PRODUCT_VERSION: "2.3.2.0.0",
JOB_NAME: "MAF-v2.3.2.0.0-And-iOS",
BUILD_NUMBER: "39"
};
