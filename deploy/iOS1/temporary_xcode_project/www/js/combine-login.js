// @compiled on Sat Aug 13 01:07:13 MDT 2016
// Note: this is a generated file all changes will be lost. 


/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ManagedBeans.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ManagedBeans.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.api.bean            = adf.mf.api.bean            || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

adf.mf.internal.mb.ManagedBeanDefinition = adf.mf.internal.mb.ManagedBeanDefinition || {
  "APPLICATION": "applicationScope",
  "PAGE_FLOW":   "pageFlowScope",
  "VIEW":        "viewScope"
};

/**
 * Set a collection of managed bean definitions.  The collection of bean
 * definitions supplied here _REPLACES_ any existing definitions, it does
 * not add to the existing set.
 *
 * @param {Array.<adf.mf.internal.mb.ManagedBeanDefinition>} beanDefs an array of
 *        ManagedBeanDefinition objects.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.internal.mb.setBeanDefinitions = function(beanDefs, success, failed)
{
  // ensure defs is an array
  var defs = (adf.mf.internal.util.is_array(beanDefs))? beanDefs : [beanDefs];
  var scb  = (adf.mf.internal.util.is_array(success))?  success  : [success];

  if (!adf.mf.internal.isJavaAvailable())
  {
    if (defs.length == 0)
    {
      /* if there are no beans being defined, this command is a NOOP */
      for (var i = 0; i < scb.length; ++i)
      {
        try
        {
          scb[i](null, null);
        }
        catch(e) { /* ignore */ }
      }
      return;  /* do not actually make the java call since it will error out */
    }
    else
    {
      /* since there were beans defined, log a message and then let it error out in the invoke */
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.mb.setBeanDefinitions", "ERROR_MNGD_BEANS_NOT_SUPPORTED");
    }
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setBeanDefinitions",
    defs, success, failed);
};

/**
 * Add a managed bean definition
 *
 * @param {adf.mf.api.bean.ManagedBeanDefinition} beanDefinition the managed bean definition to add
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.api.bean.addBeanDefinition = function(beanDefinition, success, failed)
{
  if (!adf.mf.internal.isJavaAvailable())
  {
   var scb = (adf.mf.internal.util.is_array(success)) ? success : [success];
   for (var i = 0, size = scb.length; i < size; ++i)
   {
      try
      {
        scb[i](null, null);
      }
      catch(e) { /* ignore */ }
    }
    return;
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "addBeanDefinition",
    beanDefinition, success, failed);
};

/**
 * Remove a bean definition from the current context
 *
 * @param {adf.mf.api.bean.ManagedBeanDefinition} beanDefinition the definition of the bean to remove.
 *        The managed properties array does not need to be populated, all other properties are required.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} success invoked when
 *        the method is successful invoked. Functions accept a request and response object as
 *        arguments.
 * @param {Array.<function(Object,Object):void>|function(Object,Object)} failed invoked when
 *        an error is encountered. Functions accept a request and response object as arguments.
 */
adf.mf.api.bean.removeBeanDefinition = function(beanDefinition, success, failed)
{
  if (!adf.mf.internal.isJavaAvailable())
  {
    var scb = (adf.mf.internal.util.is_array(success)) ? success : [success];
    for (var i = 0, size = scb.length; i < size; ++i)
    {
      try
      {
        scb[i](null, null);
      }
      catch(e) { /* ignore */ }
    }
    return;
  }

  adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "removeBeanDefinition",
    beanDefinition, success, failed);
};

/**
 * Managed Bean definition
 *
 * @param {string} name managed bean's name
 * @param {string} type managed bean's type
 * @param {string} scope managed bean's scope
 * @param {Array.<adf.mf.internal.mb.ManagedPropertyDefinition>} props managed bean's managed
 *        properties
 */
adf.mf.api.bean.ManagedBeanDefinition = function(name, type, scope, props)
{
  this.beanName     = name;  /* managed bean's name  */
  this.fqnClassname = type;  /* managed bean's type  */
  this.scope        = scope; /* managed bean's scope */
  this.props        = props; /* managed bean's props */
};

/**
 * @deprecated Use adf.mf.api.bean.ManagedBeanDefinition instead
 */
adf.mf.internal.mb.ManagedBeanDefinition = adf.mf.api.bean.ManagedBeanDefinition;

/**
 * @return {string} the managed bean's name
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getBeanName = function()
{
  return this.beanName;
};

/**
 * @return {string} the managed bean's fully qualified Java class name
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getBeanClass = function()
{
  return this.fqnClassname;
};

/**
 * @return {string} the managed bean's associated scope
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getScope = function()
{
  return this.scope;
};

/**
 * @return {Array.<adf.mf.internal.mb.ManagedPropertyDefinition>} the associated managed bean's
 *         properties
 */
adf.mf.api.bean.ManagedBeanDefinition.prototype.getManagedProperties = function()
{
  return this.props;
};

/**
 * Managed property definition used in the managed bean definition
 * that should be set by the controller layer on creation
 *
 * @param {string} name managed bean property
 * @param {string} type managed bean property's fully qualified Java classname
 * @param {Object} value managed bean property's value
 */
adf.mf.api.bean.ManagedPropertyDefinition = function(name, type, value)
{
  this.name  = name;  /* managed property's name  */
  this.type  = type;  /* managed property's type  */
  this.value = value; /* managed property's value */
};

/**
 * @deprecated Use adf.mf.api.bean.ManagedPropertyDefinition instead
 */
adf.mf.internal.mb.ManagedPropertyDefinition = adf.mf.api.bean.ManagedPropertyDefinition;

/**
 * @return {string} the managed property's name
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getName = function()
{
  return this.name;
};

/**
 * @return {string} the managed property's fully qualified class name
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getType = function()
{
  return this.type;
};

/**
 * @return {Object} the managed property's value
 */
adf.mf.api.bean.ManagedPropertyDefinition.prototype.getValue = function()
{
  return this.value;
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ManagedBeans.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ContainerIntegration.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ContainerIntegration.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

(function()
{
  var ADFMF_CONTAINER_UTILITIES = "oracle.adfmf.framework.api.AdfmfContainerUtilities"
  var ADFMF_CONTAINER_UTILITIES_INTERNAL =
    "oracle.adfmf.framework.internal.AdfmfContainerUtilitiesInternal";
  var ASYNC_SUCCESS_CALLBACK = "asyncContainerJavaScriptFunctionResponseSuccess";
  var ASYNC_FAILED_CALLBACK = "asyncContainerJavaScriptFunctionResponseFailed";

  /**
   * Checks and obtains new configuration if available.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is checkForNewConfiguration, which is defined
   * as:
   * public static void checkForNewConfiguration() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.checkForNewConfiguration = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.checkForNewConfiguration(
       function(req, res) &#123; alert("checkForNewConfiguration complete"); },
       function(req, res) &#123; alert("checkForNewConfiguration failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.checkForNewConfiguration = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "checkForNewConfiguration", success, failed);
  };

  /**
   * Gets an array of <code>FeatureInformation</code> objects that provide
   * information about the features that are available in this session of the
   * ADF Mobile application and should be displayed on a custom springboard.
   * These features have already been filtered by the evaluation of constraints.
   * These are the features that would normally be displayed on the default
   * springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatures, which is defined
   * as:
   * public static FeatureInformation[] getFeatures() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatures = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>
   *
   *      An array of <code>FeatureInformation</code> objects each
   *      representing a feature that is available. This will include the
   *      feature id, the feature name, a path to the feature icon and a path
   *      to the feature image. Normally a springboard will display the name
   *      of the feature and the image for that feature.
   *
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatures(
       function(req, res) &#123; alert("getFeatures complete"); },
       function(req, res) &#123; alert("getFeatures failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatures = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatures", success, failed);
  };

  /**
   * Gets <code>ApplicatiaonInformation</code> object containing the information
   * about the application. This can be used to get the application name for a
   * custom springboard. Additional information such as vendor, version and
   * application id are provided as well.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getApplicationInformation, which is defined
   * as:
   * public static ApplicatiaonInformation getApplicationInformation() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getApplicationInformation = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>
   *
   *      A <code>ApplicatiaonInformation</code> object containing
   *      application level metadata. This includes application name, vendor,
   *      version and application id.
   *
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getApplicationInformation(
       function(req, res) &#123; alert("getApplicationInformation complete"); },
       function(req, res) &#123; alert("getApplicationInformation failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getApplicationInformation = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getApplicationInformation", success, failed);
  };

  /**
   * Activates the feature with the given ID.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoFeature, which is defined
   * as:
   * public static void gotoFeature(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoFeature = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature to activate
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
   * adf.mf.api.gotoFeature("feature0",
   *  function(req, res) &#123; alert("gotoFeature complete"); },
   *  function(req, res) &#123; alert("gotoFeature failed with " + adf.mf.util.stringify(res); }
   * );
   * </pre>
   */
  adf.mf.api.gotoFeature = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoFeature", featureId, success, failed);
  };

  /**
   * Activates the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoSpringboard, which is defined
   * as:
   * public static void gotoSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.gotoSpringboard(
       function(req, res) &#123; alert("gotoSpringboard complete"); },
       function(req, res) &#123; alert("gotoSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.gotoSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoSpringboard", success, failed);
  };

  /**
   * Hides the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is hideSpringboard, which is defined
   * as:
   * public static void hideSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.hideSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.hideSpringboard(
       function(req, res) &#123; alert("hideSpringboard complete"); },
       function(req, res) &#123; alert("hideSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.hideSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "hideSpringboard", success, failed);
  };

  /**
   * Shows the springboard.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showSpringboard, which is defined
   * as:
   * public static void showSpringboard() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showSpringboard = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showSpringboard(
       function(req, res) &#123; alert("showSpringboard complete"); },
       function(req, res) &#123; alert("showSpringboard failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showSpringboard = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showSpringboard", success, failed);
  };

  /**
   * Activates the default feature.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is gotoDefaultFeature, which is defined
   * as:
   * public static void gotoDefaultFeature() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.gotoDefaultFeature = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error (AdfException).
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.gotoDefaultFeature(
       function(req, res) &#123; alert("gotoDefaultFeature complete"); },
       function(req, res) &#123; alert("gotoDefaultFeature failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.gotoDefaultFeature = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "gotoDefaultFeature", success, failed);
  };

  /**
   * Resets the feature with the given ID.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is resetFeature, which is defined
   * as:
   * public static void resetFeature(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.resetFeature = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature to reset
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.resetFeature("feature0",
       function(req, res) &#123; alert("resetFeature complete"); },
       function(req, res) &#123; alert("resetFeature failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.resetFeature = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "resetFeature", featureId, success, failed);
  };

  /**
   * Hides navigation bar.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is hideNavigationBar, which is defined
   * as:
   * public static void hideNavigationBar() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.hideNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.hideNavigationBar(
       function(req, res) &#123; alert("hideNavigationBar complete"); },
       function(req, res) &#123; alert("hideNavigationBar failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.hideNavigationBar = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "hideNavigationBar", success, failed);
  };

  /**
   * Shows navigation bar.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showNavigationBar, which is defined
   * as:
   * public static void showNavigationBar() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showNavigationBar(
       function(req, res) &#123; alert("showNavigationBar complete"); },
       function(req, res) &#123; alert("showNavigationBar failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showNavigationBar = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showNavigationBar", success, failed);
  };

  /**
   * Shows the preferences screen.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is showPreferences, which is defined
   * as:
   * public static void showPreferences() throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showPreferences = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.showPreferences(
       function(req, res) &#123; alert("showPreferences complete"); },
       function(req, res) &#123; alert("showPreferences failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.showPreferences = function(success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "showPreferences", success, failed);
  };

  /**
   * Invokes a Javascript method with the given arguments on the specified
   * feature. Returns the result of the method execution.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is invokeContainerJavaScriptFunction, which is defined
   * as:
   * public static Object invokeContainerJavaScriptFunction(String featureId, String methodName, Object[] args) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.showNavigationBar = function(success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of feature on which to invoke the method
   * @param methodName
   *       method name
   * @param args
   *       array of arguments to be passed to method
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Object
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   *  <ul>
   *  <li>included a simple appFunction.js file to feature1 (by adding it to feature1 content's include in JDeveloper).</li>
   *  <li>added calls to adf.mf.api.invokeContainerJavaScriptFunction to your code</li>
   *  </ul>
   * <br/>
   * <b>appFunctions.js</b>
   * <pre>
   (function()
   &#123;
     if (!window.application) window.application = &#123;};

     application.testFunction = function()
     &#123;
       var args = arguments;

       alert("APP ALERT " + args.length + " ");
       return "application.testFunction - passed";
     };
   })();
   * </pre>
   * <br/>
   * <pre>
  adf.mf.api.invokeContainerJavaScriptFunction("feature1",
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  or
  adf.mf.api.invokeContainerJavaScriptFunction("feature1", [ "P1" ],
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  );
  or
  adf.mf.api.invokeContainerJavaScriptFunction("feature1", [ "P1", "P2" ],
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction complete"); },
       function(req, res) &#123; alert("invokeContainerJavaScriptFunction failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   * <br/>
   * Now when the user presses the button they will see three alerts (from the appFunctions.js):
   * <pre>
      APP ALERT 0
      APP ALERT 1
      APP ALERT 2
   * </pre>
   */
  adf.mf.api.invokeContainerJavaScriptFunction = function(/* String */ featureId, /* String */ methodName, /* Object[] */ args, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "invokeContainerJavaScriptFunction", featureId, methodName, args, success, failed);
  };

  /**
   * Invokes a native method on the specified class with the given arguments.
   * Returns the result of method execution.
   *
   * @param className
   *       class name
   * @param methodName
   *       method name
   * @param args
   *       array of arguments to be passed to method
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Object
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.invokeContainerMethod = function(/* String */ classname, /* String */ methodName, /* Object[] */ args, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "invokeContainerMethod", classname, methodName, args, success, failed);
  };

  /**
   * Returns the feature information for the passed in feature id.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatureById, which is defined
   * as:
   * public static FeatureInformation getFeatureById(String featureId) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatureById = function(featureId, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureId
   *       ID of the feature to retrieve
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>Feature
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatureById("feature.id",
       function(req, res) &#123; alert("getFeatureById complete"); },
       function(req, res) &#123; alert("getFeatureById failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatureById = function(/* String */ featureId, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatureById", featureId, success, failed);
  };

  /**
   * Returns the feature information for the passed in feature name.
   * <br/>
   * The associated AdfmfContainerUtilites method that is invoked
   * is getFeatureByName, which is defined
   * as:
   * public static FeatureInformation getFeatureByName(String featureName) throws AdfException
   * <br/>
   * so the associated JavaScript  function will be defined as
   * <br/>
   * adf.mf.api.getFeatureByName = function(featureName, success, failed)
   * <br/>
   * The success and failed callbacks were added so the return value
   * and exception could be passed back to the JavaScript  calling code.
   * <br/>
   * @param featureName
   *       Name of the feature to retrieve
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   * <br/>
   * <b>Example</b>
   * <pre>
  adf.mf.api.getFeatureByName("feature.name",
       function(req, res) &#123; alert("getFeatureByName complete"); },
       function(req, res) &#123; alert("getFeatureByName failed with " + adf.mf.util.stringify(res); }
  );
   * </pre>
   */
  adf.mf.api.getFeatureByName = function(/* String */ featureName, success, failed)
  {
    adf.mf.api.invokeMethod(ADFMF_CONTAINER_UTILITIES, "getFeatureByName", featureName, success, failed);
  };

  /**
   * internal api for invoke Java
   * e.g. adf.mf.internal.api.invokeMethod(commId, classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
   */

  adf.mf.internal.api.invokeMethod = function()
  {
    argc  = arguments.length;
    params = new Array();

    for (var i=3; i < argc-2; i++)
    {
      params[i-3] = arguments[i];
    }

    var request = { "classname"  : arguments[1], /* clazz  */
      "method"    : arguments[2], /* method */
      "params"    : params };

    adf.mf.internal.context.invokeJavaMethod(/* CommId */ arguments[0], request, arguments[argc-2], arguments[argc-1]);
  };

  /**
   * The framework enables you to display the device's e-mail interface, and optionally pre-populate certain fields:
   *
   *  @param options
   *    is a JSON object with the following optional properties:
   *    <ul>
   *    <li>to: recipients (comma-separated)</li>
   *    <li>cc: CC recipients (comma-separated)</li>
   *    <li>subject: message subject</li>
   *    <li>body: message body</li>
   *    <li>bcc: BCC recipients (comma-separated)</li>
   *    <li>attachments: list of filenames to attach to the e-mail (comma-separated)</li>
   *    <li>mimeTypes:
   *    <ul><li><b>iOS</b>: List of MIME types to use for the attachments (comma-separated).
   *    Specify null to let the framework automatically determine the MIME types.
   *    It is also possible to only specify the MIME types for selected attachments; see examples below.</li>
   *    <li><b>Android</b>: MIME type in Android isn't true MIME type but just a way for Android to filter
   *    applications to be shown in the application chooser dialog. But empty MIME type doesn't work
   *    and throws exception. So if no MIME type is passed in, we use "plain/text" by default. Also, if
   *    there are multiple attachment types, user doesn't need to provide multiple MIME types, but can
   *    provide just most suitable MIME type (as per Android documentation). That being said, if the user
   *    has an application which is being deployed to both iOS and Android, they can pass in the comma-separated
   *    list of mime types and Android will still work fine.</li></ul>
   *    </li>
   *    </ul>
   *  <br/>
   *  After this interface is displayed, the user can choose to either send the e-mail or discard it. Note that it
   *  is not possible to automatically send the e-mail due to device/carrier restrictions; only the end user can actually
   *  send the e-mail. The device must also have at least one e-mail account configured to send e-mail; otherwise, an
   *  error will be displayed indicating that no e-mail accounts could be found.
   *  <br/>
   *  Examples:
   *
   * Populate an e-mail to 'john.doe@foo.com', copy 'jane.doe@bar.com', with the subject 'Test message',
   * and the body 'This is a test message'
   * <br/>
   * <pre>
  adf.mf.api.sendEmail(&#123;to: "john.doe@foo.com",
                 cc: "jane.doe@bar.com",
                 subject: "Test message",
                 body: "This is a test message"},
                success, failed);
   * </pre>
   * <br/>
   * Taking the same example, but now adding a BCC to 'mary.may@another.com' and 'lary.day@another.com'
   * and attaching two files.<br/>
   * <b>NOTE:</b> By not specifying a value for the mimeTypes parameter, you are telling the framework to automatically
   * determine the MIME type for each of the attachments
   * <br/>
   * <pre>
  adf.mf.api.sendEmail(&#123;to: "john.doe@foo.com",
                 cc: "jane.doe@bar.com",
                 bcc: "mary.may@another.com,lary.day@another.com"
                 subject: "Test message",
                 attachments: "path/to/file1.txt,path/to/file2.png"},
                success, failed);
   * </pre>
   *
   * <b>success callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the associated AdfmfContainerUtilities
   *   method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *   function(request, response) where the request
   *   contains the original request and the response
   *   contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.sendEmail = function(/* JSON */ options, success, failed)
  {
    if (options)
    {
      var attachments = options["attachments"];
      var mimeTypes = options["mimeTypes"];
      if (attachments || mimeTypes)
      {
        var attachmentsArray = attachments ? attachments.split(",") : [];
        var mimeTypesArray = mimeTypes ? mimeTypes.split(",") : [];
        var numMimeTypes = mimeTypesArray.length;
        var numAttachments = attachmentsArray.length;
        if (numMimeTypes > 0 && numAttachments != numMimeTypes)
        {
          // When attachments and MIME types are both specified, the number of each
          // must match.
          if (failed != null)
          {
            var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
              "ERROR_MIMETYPES_NOTEQUAL_ATTACHMENTS", [numMimeTypes, numAttachments]);
            failed(rmsg);
            return;
          }
        }
      }
    }
    cordova.exec( success, failed, "AdfmfEmail", "sendEmail", [options]);
  };

  // This variant of the sendEmail API is ONLY used when invoking sendEmail from Embedded Java code
  adf.mf.internal.api.sendEmail = function (commId, requestId, emailOptions)
  {
    try
    {
      adf.mf.api.sendEmail(emailOptions, /* Options to pre-populate e-mail dialog */

        function(result) /* Success callback */
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendEmail", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail",
              se);
          }
        },

        function(result) /* Error callback */
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendEmail", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail",
              se);
          }
        });
     }
     catch(se)
     {
       adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
         "adf.mf.api.sendEmail", "ERROR_EXCEPTION");

       // Only log the exception at a fine level for security reasons
       adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendEmail", se);

       adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
         ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  /**
   * The framework enables you to display the device's text messaging (SMS) interface, and
   * optionally pre-populate certain fields:
   *
   *  @param options
   *     is a JSON object with the following optional properties:
   *     <ul>
   *     <li>to: recipients (comma-separated)</li>
   *     <li>body: message body</li>
   *     </ul>
   *  <br/>
   *  After this interface is displayed, the user can choose to either send the
   *  SMS or discard it. Note that it is not possible to automatically send the
   *  SMS due to device/carrier restrictions; only the end user can actually send the SMS.
   *  <br/>
   *  Examples:
   *
   * Populate an SMS message to '1234567890' with the body 'This is a test message'
   * <br/>
   * <pre>
   adf.mf.api.sendSMS(&#123;to: "1234567890",
                       body: "This is a test message"},
                      success, failed);
   * </pre>
   *
   * <b>success callback</b> must be in the form of
   *    function(request, response) where the request
   *    contains the original request and the response
   *    contains the associated AdfmfContainerUtilities
   *    method's return value.
   *  <br/>i.e.<br/>void
   *  <br/>
   *  <b>failed callback</b> must be in the form of
   *    function(request, response) where the request
   *    contains the original request and the response
   *    contains the error.
   *
   * @throws AdfException
   */
  adf.mf.api.sendSMS = function(/* JSON */ options, success, failed)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.api.sendSMS",
        "CORDOVA_DEBUG",
        "Inside the ContainterIntegration.js invoking AdfmfSMS.sendSMS Cordova plugin");
    }
    cordova.exec(success, failed, "AdfmfSMS", "sendSMS", [options]);
  };

  // This variant of the sendSMS API is ONLY used when invoking sendSMS from Embedded Java code
  adf.mf.internal.api.sendSMS = function (commId, requestId, smsOptions)
  {
    try
    {
      adf.mf.api.sendSMS(smsOptions,
        // Options to pre-populate SMS dialog
        // Success callback
        function(result)
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendSMS", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);
          }
        },
        // Error callback
        function(result)
        {
          var responseData = result || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.sendSMS", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.sendSMS", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api", "sendSMS", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.api.getDeviceProperties = function(success, failed)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api.getDeviceProperties",
        "CORDOVA_DEBUG",
        "Inside the ContainterIntegration.js invoking " +
          "ADFMobileDeviceProperties.getDeviceProperties Cordova plugin");
    }
    cordova.exec(success, failed, "ADFMobileDeviceProperties", "getDeviceProperties", []);
  };

  adf.mf.internal.api.getCurrentPosition = function (commId, requestId)
  {
    try
    {
      navigator.geolocation.getCurrentPosition(

        function (data)
        {
          // 'data' is a complex object with prototypical inheritance and is not guaranteed
          // to return expected results when serialized using JSON.stringify.
          // Therefore, convert it into a POJO - 'position'- and pass-on 'position' instead.
          var position =
          {
            timestamp: null,
            coords:
            {
              speed: null,
              longitude: null,
              latitude: null,
              heading: null,
              altitudeAccuracy: null,
              altitude: null,
              accuracy: null
            }
          };
          if (data != null)
          {
            // This pattern is used so that if the value that is being assigned is undefined,
            // the default value of the LHS variable is preserved.
            position.timestamp = (data.timestamp === undefined ? position.timestamp : data.timestamp);
            if (data.coords != null)
            {
              position.coords.accuracy = (data.coords.accuracy === undefined ? position.coords.accuracy : data.coords.accuracy);
              position.coords.altitude = (data.coords.altitude === undefined ? position.coords.altitude : data.coords.altitude);
              position.coords.altitudeAccuracy = (data.coords.altitudeAccuracy === undefined ? position.coords.altitudeAccuracy : data.coords.altitudeAccuracy);
              position.coords.heading = (data.coords.heading === undefined ? position.coords.heading : data.coords.heading);
              position.coords.latitude = (data.coords.latitude === undefined ? position.coords.latitude : data.coords.latitude);
              position.coords.longitude = (data.coords.longitude === undefined ? position.coords.longitude : data.coords.longitude);
              position.coords.speed = (data.coords.speed === undefined ? position.coords.speed : data.coords.speed);
            }
            else
            {
              position.coords = data.coords;
            }
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, position, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getCurrentPosition", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getCurrentPosition", se);
          }
        },

        function (data)
        {
          var message = ((data != null) && (data.message != null)) ? data.message : "unknown error";
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getCurrentPosition", "ERROR_IN_REQUEST", ASYNC_FAILED_CALLBACK,
              se);
          }
      });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "navigator.geolocation.getCurrentPosition", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getCurrentPosition", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.watchPosition = function (commId, requestId, userWatchId, geolocationOptions)
  {
    var firstTime = true;
    try
    {
      var watchId = navigator.geolocation.watchPosition(

        function (data)
        {
          // 'data' is a complex object with prototypical inheritance and is not guaranteed to
          // return expected results when serialized using JSON.stringify.
          // Therefore, convert it into a POJO - 'position'- and pass-on 'position' instead.
          var position =
          {
            timestamp: null,
            coords:
            {
              speed: null,
              longitude: null,
              latitude: null,
              heading: null,
              altitudeAccuracy: null,
              altitude: null,
              accuracy: null
            }
          };

          if (data != null)
          {
            // This pattern is used so that if the value that is being assigned is undefined,
            // the default value of the LHS variable is preserved.
            position.timestamp = data.timestamp || position.timestamp;
            if (data.coords != null)
            {
              position.coords.accuracy = data.coords.accuracy || position.coords.accuracy;
              position.coords.altitude = data.coords.altitude || position.coords.altitude;
              position.coords.altitudeAccuracy = data.coords.altitudeAccuracy || position.coords.altitudeAccuracy;
              position.coords.heading = data.coords.heading || position.coords.heading;
              position.coords.latitude = data.coords.latitude || position.coords.latitude;
              position.coords.longitude = data.coords.longitude || position.coords.longitude;
              position.coords.speed = data.coords.speed || position.coords.speed;
            }
          }

          if (firstTime)
          {
            // unblock the calling thread only on the first callback.
            try
            {
              adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
                ASYNC_SUCCESS_CALLBACK,
                requestId, String(watchId), function () {}, function () {});
            }
            catch (se)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.watchPosition", "ERROR_IN_REQUEST");

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.internal.api", "watchPosition", se);
            }
            firstTime = false;
          }
          try
          {
            adf.mf.api.invokeMethod("oracle.adf.model.datacontrols.device.GeolocationProxy",
               "invokeEmbeddedCallback", userWatchId, position, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.watchPosition.invokeEmbeddedCallback", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.watchPosition", "invokeEmbeddedCallback", se);
          }
        },

        function (data)
        {
          // if error, need to clear watchId so there is no dangling callbacks
          navigator.geolocation.clearWatch(String(watchId));

          var message = ((data != null) && (data.message != null)) ? data.message : "unknown error";

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.watchPosition", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.watchPosition", ASYNC_FAILED_CALLBACK, se);
          }
        },
        geolocationOptions);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.watchPosition", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "watchPosition", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.clearWatch = function (watchID)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.clearWatch",
        "CORDOVA_DEBUG", watchID);
    }
    navigator.geolocation.clearWatch(watchID); // no callbacks
  };

  adf.mf.internal.api.createContact = function (commId, requestId, properties)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.createContact",
            "CORDOVA_DEBUG", adf.mf.util.stringify(properties));
    }

    try
    {
      // Fix for Bug 16433413: If displayName is passed as null, then Cordova returns "null" for displayName.
      // If empty string is passed in, either valid displayName is returned or null is returned when there is
      // no displayName.
      if (properties !== undefined && properties !== null)
      {
        // Remove all dot properties from javascript object (JSON) to be sent to Cordova layer
        adf.mf.internal.removeDotProperties(properties);

        if (properties.displayName == null)
        {
          properties.displayName = "";
        }
      }

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.createContact",
          "CORDOVA_DEBUG_JUST_BEFORE_CREATE_CONTACT_CALL_TO_CORDOVA", adf.mf.util.stringify(properties));
      }

      var contact = navigator.contacts.create(properties);
      if (contact.note == null)
      {
        contact.note = '';
      }
      if (contact.nickname == null)
      {
        contact.nickname = '';
      }

      contact.save(

        function (data)
        {
          var contact = data || {};

          // In cordova-2.2.0.js, createIn method adds "Invalid Object" value for null Birthday
          // so we need to put back null there to serialize in to Java layer properly.
          var bDay = contact.birthday;
          if (isNaN(bDay) || ("undefined" == typeof bDay.getDate))
          {
            contact.birthday = null;
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK,
              requestId, contact, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.createContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "createContact", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.createContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "createContact", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.createContact", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "createContact", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.findContacts = function (commId, requestId, fields, options)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
        "CORDOVA_DEBUG - fields", fields);
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
        "CORDOVA_DEBUG - options", adf.mf.util.stringify(options));
    }

	  try
	  {
		  navigator.contacts.find(fields,
        function (data)
        {
          var contacts = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.find success",
              "CORDOVA_FIND_CONTACTS_BEFORE_CONVERTING", adf.mf.util.stringify(contacts));
          }

          try
          {
            // cordova-2.2.0.js doesn't invoke createIn() method and thus does not convert birthday from
            // long to String for findContact call and thus the contact(s) returned have birthday as
            // long in stringified way. eg. "505003627119". Whereas saveContact call correctly invokes
            // createIn() method and thus returns valid string. eg. "1986-01-01T22:47:07.119Z".
            // As ADFMF supports this string type or just the long (without stringified long) we need to
            // invoke createIn() method for each contact to convert date to supported format before
            // invoking the success callback method.
            for (var i = 0; i < contacts.length; i++)
            {
              var contact = contacts[i];

              // Copied this method body from cordova-2.2.0.js and:
              // 1) Added if condition to safeguard it
              // 2) Removed console.log and added our framework logging.
              var bDay = contact.birthday;
              try
              {
                if (null != bDay && !isNaN(bDay))
                {
                  contact.birthday = new Date(parseFloat(bDay));
                }
              }
              catch (exception)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.find success",
                    "CORDOVA_FIND_CONTACTS_DURING_CONVERT_BDAY",
                    "Exception converting date from long to String");
                }

                adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                  "adf.mf.internal.api.findContacts", "ERROR_EXCEPTION");

                // Only log the exception at a fine level for security reasons
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api", "findContacts", exception);
              }
            }

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.findContacts",
                "CORDOVA_FIND_CONTACTS_AFTER_CONVERTING", adf.mf.util.stringify(contacts));
            }

            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, contacts, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.findContacts", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "findContacts", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.findContacts", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "findContacts", se);
          }
        },
        options);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.findContacts", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "findContacts", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.removeContact = function (commId, requestId, properties)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api.removeContact",
        "CORDOVA_DEBUG",
        adf.mf.util.stringify(properties));
    }

    try
    {
      var contact = navigator.contacts.create(properties);

      contact.remove(
        function (data)
        {
          var contact = data || {};
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, contact, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.removeContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "removeContact", se);
          }
        },

        function (data)
        {
          var errorCode = ((data != null) && (data.code != null)) ?
            data.code : ContactError.UNKNOWN_ERROR;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, errorCode, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.removeContact", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "removeContact", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.removeContact", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "removeContact", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  adf.mf.internal.api.getPicture = function (commId, requestId, cameraOptions)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.getPicture",
        "CORDOVA_DEBUG", adf.mf.util.stringify(cameraOptions));
    }

    try
    {
      navigator.camera.getPicture(

        function (data)
        {
          var imageData = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getPicture success",
              "CORDOVA_DEBUG", "");
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, imageData, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getPicture", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getPicture", se);
          }
        },

        function (data)
        {
          var message = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.getPicture",
              "CORDOVA_DEBUG", message);
          }

          // Return empty string as image data and call success callback instead of calling failure
          // callback
          var imageData = "";
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
               ASYNC_SUCCESS_CALLBACK, requestId, imageData, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getPicture", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getPicture", se);
          }
        }, cameraOptions);
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.getPicture", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getPicture", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };


  adf.mf.internal.api.getDeviceProperties = function(commId, requestId)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal.api.getDeviceProperties",
        "CORDOVA_DEBUG", "");
    }

    try
    {
      adf.mf.api.getDeviceProperties(

        function (data)
        {
          var deviceProperties = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getDeviceProperties success", "CORDOVA_DEBUG",
              adf.mf.util.stringify(deviceProperties));
          }

          // Replace the phonegap version with the value from device.cordova
          // deviceProperties.device.phonegap = window.device.cordova;

          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_SUCCESS_CALLBACK, requestId, deviceProperties, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getDeviceProperties", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getDeviceProperties", se);
          }
        },

        function (data)
        {
          var message = data || {};
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.getDeviceProperties failed", "CORDOVA_DEBUG", "");
          }
          try
          {
            adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
              ASYNC_FAILED_CALLBACK, requestId, message, function () {}, function () {});
          }
          catch (se)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.getDeviceProperties", "ERROR_IN_REQUEST");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api", "getDeviceProperties", se);
          }
        });
    }
    catch(se)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.getDeviceProperties", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.api", "getDeviceProperties", se);

      adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
        ASYNC_FAILED_CALLBACK, requestId, msg, function() {}, function() {});
    }
  };

  /**
   * INTERNAL FUNCTION used to to remove dot properties from JSON
   */
  adf.mf.internal.removeDotProperties = function(dat)
  {
	  if (dat !== undefined && dat !== null)
	  {
		  if (Array.isArray(dat))
		  {
			  for (var i = 0; i < dat.length; i++)
			  {
				  var retValue = this.removeDotProperties(dat[i]);
				  if (retValue === null)
				  {
					  dat.splice (i, 1);
					  i--;
				  }
			  }
		  }
		  else if (typeof dat === 'object')
		  {
			  for (var property in dat)
			  {
				  if (property !== undefined && property !== null)
				  {
					  if (property == '.null')
					  {
						  if (dat[property] == true)
						  {
							  return null;
						  }
					  }
					  else if (property.indexOf (".") == 0)
					  {
						  // If the property is a dot property, delete it, as those shouldn't be sent to Cordova layer.
						  delete dat[property];
					  }
					  else if ((typeof dat[property]) != 'function')
					  {
						  var retValue = this.removeDotProperties(dat[property]);
						  if (retValue === null)
						  {
							  delete dat[property];
						  }
					  }
				  }
			  }
		  }
	  }

	  return dat;
  };

  /**
   * INTERNAL API used for Push Notification
   *
   * namespace : adf.mf.internal.api.pushnotifications
   *
   * methods :
   * 	public :
   * 		register(params)
   * 			Register with APNs/GCM. Calls container.internal.device.integration.PushNotifications(params, tokenHandler, errorHandler)
   * 			@params : JSON formatted registration parameters. Ex : {"badge":"true", "sound":"true"}
   * 	private :
   * 		tokenHandler(request, token)
   * 			Success callback for registration on iOS. Here we use adf.mf.api.invokeMethod to pass on the token to embedded's eventing mechanism.
   * 			@token : Device token received from APNs
   * 		successHandler(request, response)
   * 			Success callback for registration on Android.
   *            This is merely a success callback for a successful attempt to register - no token is received from GCM at this point.
   * 		errorHandler(request, error)
   * 			Failure callback for registration. Right now not utilized but will be hooked to error handling callbacks in Embedded when they are available.
   * 			@error Error
   * 		onNotificationAPN(notification)
   * 			Called by PushPlugin upon a notification from APNs. Here we use adf.mf.api.invokeMethod to pass on the notification to Embedded's eventing mechanism
   * 			@notification  JSON object representing notification payload
   * 		onNotificationGCM(notification)
   * 			General event callback used by PushPlugin on Android to report :
   * 				- token upon successful registration with GCM
   * 				- incoming notification event from GCM
   * 				- errors if any
   * 			Calls into tokenHandler/onNotificationAPN in order to pass on data to embedded's eventing mechanism depending on the event type.
   * 			@notification JSON notification event with following keys
   * 				event   : If "registered", its a successful registration callback, if "message" its a notification event
   * 				payload : Value is JSON of notification payload if event is "message"
   * 				regid   : Value is a string representing registration ID issued by GCM in response to a registration request
   */
  window.PushNotifications = function()
  {
    /* PUBLIC - Register for Push Notifications */
    this.register = function(params)
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "PushNotifications", "register",
          "invoking push notification command.");
      }
      try
      {
        var isAndroid = (navigator.userAgent.toLowerCase().indexOf("android") != -1);
        if (isAndroid)
        {
          params['ecb'] = "adf.mf.internal.api.pushnotifications.onNotificationGCM";
          container.internal.device.integration.PushNotifications.register(params,
            successHandler, errorHandler);
        }
        else
        {
          params['ecb'] = "adf.mf.internal.api.pushnotifications.onNotificationAPN";
          container.internal.device.integration.PushNotifications.register(params,
            tokenHandler, errorHandler);
        }
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.api.pushnotifications", "ERROR_REGISTER_PUSH_NOTIFICATION");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api", "pushnotifications", e);
      }
    };

    /* PRIVATE - Gets called by PushPlugin on iOS after successful registration */
    var tokenHandler = function(request, token)
    {
      adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedToken",
        token,
        //success
        function(req,res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "tokenHandler",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        },
        //failure
        function(req,res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.tokenHandler",
            "ERROR_PUSH_NOTIFICATION_CALLBACK_EXCEPTION");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "tokenHandler",
              "Inside the failure callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    /* PRIVATE - Gets called by PushPlugin if there was an error trying to register*/
    var errorHandler = function(request, error)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.api.pushnotifications", "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

      // For security purposes, only log the request and response details at FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api.pushnotifications", "errorHandler",
          "There was an error in processing this request : " + adf.mf.util.stringify(request) +
          ". Error : " + adf.mf.util.stringify(error));
      }

      adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedError",
        adf.mf.util.stringify(error),
        // success
        function(req, res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications",
              "errorHandler",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        },
        // failure
        function(req, res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.errorHandler",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "errorHandler",
            "Inside the failure callback for request " + adf.mf.util.stringify(req) +
              " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    /* PRIVATE - Gets called by PushPlugin if the call to register on Android succeeded */
    var successHandler = function(request, response)
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api.pushnotifications",
          "successHandler",
          "Request: " + adf.mf.util.stringify(request) + " Response: " +
            adf.mf.util.stringify(response));
      }
    };

    /* PRIVATE Gets called by PushPlugin on iOS when notification arrives */
    this.onNotificationAPN = function(notification)
    {
      // appState
      var appState = 0;
      if (notification.triggersStartup === "true")
      {
        appState = 1;
      }
      else if (notification.foreground === "0")
      {
        appState = 2;
      }
      else if (notification.foreground === "1")
      {
        appState = 3;
      }

      // token
      var token = "";
      if (notification.hasOwnProperty('deviceToken'))
      {
        token = notification.deviceToken;
      }

	    adf.mf.api.invokeMethod(
        "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
        "receivedRemoteNotification",
        JSON.stringify(notification),
        appState,
        token,
		    // success
        function(req,res)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications",
              "onNotificationAPN",
              "Inside the success callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        },
        // failure
        function(req,res)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.onNotificationAPN",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "onNotificationAPN",
              "Inside the failure callback for request " + adf.mf.util.stringify(req) +
                " with response " + adf.mf.util.stringify(res));
          }
        }
      );
    };

    // PRIVATE Gets called by PushPlugin on Android when a notification event (registration success,
    // registration failure, incoming notification) occurs
    this.onNotificationGCM = function(notification)
    {
      switch (notification.event)
      {
        case 'registered':
          if (notification.regid.length > 0)
          {
            tokenHandler(null,notification.regid);
          }
          break;

        case 'message':
          // appState
          var appState = 0;
          if (notification.coldstart)
          {
            appState = 1;
          }
          else if (notification.foreground)
          {
            appState = 3;
          }
          else
          {
            appState = 2;
          }

          // token
          var token = "";
          if (notification.payload.hasOwnProperty('deviceToken'))
          {
            token = notification.payload.deviceToken;
          }

          adf.mf.api.invokeMethod(
            "oracle.adfmf.framework.event.pushnotification.NativePushNotificationEventInterceptor",
            "receivedRemoteNotification",
            JSON.stringify(notification.payload),
            appState,
            token,
            // success
            function(req, res)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.pushnotifications",
                  "onNotificationGCM",
                  "Inside the success callback for request " + adf.mf.util.stringify(req) +
                    " with response "+adf.mf.util.stringify(res));
              }
            },
            // failure
            function(req, res)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle",
                adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.pushnotifications.onNotificationGCM",
                "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

              // For security purposes, only log the request and response details at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "adf.mf.internal.api.pushnotifications", "onNotificationGCM",
                  "Inside the failure callback for request " + adf.mf.util.stringify(req) +
                    " with response " + adf.mf.util.stringify(res));
              }
            }
          );
          break;

        case 'error':
          adf.mf.log.logInfoResource("ADFErrorBundle",
            adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.pushnotifications.onNotificationGCM",
            "ERROR_PUSH_NOTIFICATION_REQUEST_FAILURE");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.internal.api.pushnotifications", "onNotificationGCM",
              "Error Received : " + JSON.stringify(notification));
          }
          errorHandler(null, notification.error);
        break;

        default:
          // Unknown, an event was received and we do not know what it is
          break;
      }
    };
  };
  adf.mf.internal.api.pushnotifications = new PushNotifications();

  /**
   * Local Notifications
   *
   * @namespace
   */
  adf.mf.api.localnotification =
  {
    /**
     * Schedule a local notification
     *
     * @param {Object} options - notification options
     * @param {string} options.title - notification title
     * @param {string} options.alert - notification alert
     * @param {Date} options.date - date at which notification needs to be triggered
     * @param {Number} options.badge - application icon will be badged by this number when notification is triggered
     * @param {string} options.sound - set it to 'SYSTEM_DEFAULT' to play the default system sound upon a notification
     * @param {string} options.vibration - set it to 'SYSTEM_DEFAULT' for default system vibration upon a notification
     * @param {Object} options.payload - custom payload to be sent via notification
     * @param {successCallback} scb - success callback
     * @param {errorCallback} ecb  - error callback
     */
    add: function(options, scb, ecb)
    {
  	  var successHandler = function(request, response)
  	  {
  	    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  		{
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.localnotification.add",
          "successHandler",
          "Request: "
  				  + adf.mf.util.stringify(request)
  				  + " Response: "
  				  + adf.mf.util.stringify(response));
  	    }
  	    if (typeof(scb) == typeof(Function))
  	      scb(request,response);
  	  };

      var errorHandler = function(request,error)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.add.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"There was an error in processing this request : " + adf.mf.util.stringify(request) +
              ". Error : "+adf.mf.util.stringify(error));
        }

        if (typeof(ecb) == typeof(Function))
          ecb(request, error);
      };

  	  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  	  {
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "LocalNotification", "add", "invoking local notification command.");
  	  }

  	  try
  	  {
        container.internal.device.integration.LocalNotification.add(options, successHandler,
          errorHandler);
  	  }
  	  catch(e)
  	  {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.add.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"LocalNotification.add was not invoked (error=" + adf.mf.util.stringify(e) + ")");
        }
      }
  	},

    /**
     * Cancel a scheduled local notification
     *
     * @param {string} notificationId - id of the scheduled notification that needs to be cancelled
     * @param {successCallback} scb - success callback
     * @param {errorCallback} ecb - error callback
     */
    cancel: function(notificationId, scb, ecb)
    {
      var successHandler = function(request, response)
  	  {
  	    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
  				  "adf.mf.api.localnotification.cancel",
  				  "successHandler",
            "Request: " +
              adf.mf.util.stringify(request) +
              " Response: " +
              adf.mf.util.stringify(response));
  	    }

  	    if (typeof(scb) == typeof(Function))
  	      scb(request,response);
  	  };

      var errorHandler = function(request, error)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.cancel.errorHandler",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification.add", "errorHandler",
        		"There was an error in processing this request : " + adf.mf.util.stringify(request) +
            ". Error : " + adf.mf.util.stringify(error));
        }

        if (typeof(ecb) == typeof(Function))
          ecb(request, error);
      };

  	  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
  	  {
  		  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "LocalNotification",
          "cancel",
          "invoking local notification command.");
  	  }

  	  try
  	  {
        container.internal.device.integration.LocalNotification.cancel(notificationId,
          successHandler, errorHandler);
  	  }
  	  catch(e)
  	  {
        adf.mf.log.logInfoResource("ADFErrorBundle",
          adf.mf.log.level.SEVERE,
          "adf.mf.api.localnotification.cancel",
          "ERROR_LOCAL_NOTIFICATION_REQUEST_FAILURE");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api.localnotification", "cancel",
        		"LocalNotification.cancel was not invoked (error=" + adf.mf.util.stringify(e) + ")");
        }
  	  }
    }

    /**
     * Success Callback
     *
     * @callback successCallback
     * @param {Object} request - request
     * @param {Object} response - response
     * @param {string} response.id - id of the notification
     */

    /**
     * Error Callback
     *
     * @callback errorCallback
     * @param {Object} request - request
     * @param {Object} response - response
     */
  };

  /**
   * Internal API used for local notifications
   *
   * These methods are to be used only by the embedded java code
   */
  adf.mf.internal.api.localnotification = adf.mf.internal.api.localnotification || function()
  {
  };

  adf.mf.internal.api.localnotification.add =
    adf.mf.internal.api.localnotification.add || function(commId, requestId, params)
  {
	  container.internal.device.integration.LocalNotification.add(params,
      // Success callback
      function(request,result)
      {
        var responseData = result.id || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.add", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "add", se);
        }
      },
      // Error callback
      function(request,result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.add", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "add", se);
        }
      });
  };

  adf.mf.internal.api.localnotification.cancel =
    adf.mf.internal.api.localnotification.cancel || function(commId, requestId, params)
  {
	  container.internal.device.integration.LocalNotification.cancel(params,
      // Success callback
      function(request,result)
      {
        var responseData = result.id || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.cancel", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "cancel", se);
        }
      },
      // Error callback
      function(request,result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.localnotification.cancel",
            "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.localnotification", "cancel", se);
        }
      });
  };

  /**
   * Internal API used for sliding window plugins
   *
   * These methods are to be used only by the embedded java code
   */
  adf.mf.internal.api.slidingwindow = adf.mf.internal.api.slidingwindow || function() {};

  adf.mf.internal.api.slidingwindow.create =
    adf.mf.internal.api.slidingwindow.create || function(commId, requestId, featureId)
  {
    container.internal.device.integration.SlidingWindow.create(featureId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId,
            ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK,
            requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.create", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "create", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.create", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "create", se);
        }
      });
  };

  adf.mf.internal.api.slidingwindow.show =
    adf.mf.internal.api.slidingwindow.show || function(commId, requestId, windowId, options)
  {
    container.internal.device.integration.SlidingWindow.show(windowId, options,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.show", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "show", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.show", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "show", se);
        }
    });
  };

  adf.mf.internal.api.slidingwindow.hide =
    adf.mf.internal.api.slidingwindow.hide || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.hide(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.hide", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "hide", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.hide", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "hide", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.destroy =
    adf.mf.internal.api.slidingwindow.destroy || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.destroy(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, "true", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.destroy", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "destroy", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, "false", function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.destroy", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "destroy", se);
        }
    });
  };

  adf.mf.internal.api.slidingwindow.getWindowInfo =
    adf.mf.internal.api.slidingwindow.getWindowInfo || function(commId, requestId, windowId)
  {
    container.internal.device.integration.SlidingWindow.getWindowInfo(windowId,
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowInfo", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowInfo", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowInfo", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowInfo", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getTopWindowId =
    adf.mf.internal.api.slidingwindow.getTopWindowId || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getTopWindowId(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getTopWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getTopWindowId", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getTopWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getTopWindowId", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getWindowIds =
    adf.mf.internal.api.slidingwindow.getWindowIds || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getWindowIds(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowIds", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowIds", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getWindowIds", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getWindowIds", se);
        }
     });
  };

  adf.mf.internal.api.slidingwindow.getCurrentWindowId =
    adf.mf.internal.api.slidingwindow.getCurrentWindowId || function(commId, requestId)
  {
    container.internal.device.integration.SlidingWindow.getCurrentWindowId(
      // Success callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_SUCCESS_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getCurrentWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getCurrentWindowId", se);
        }
      },
      // Error callback
      function(request, result)
      {
        var responseData = result || {};
        try
        {
          adf.mf.internal.api.invokeMethod(commId, ADFMF_CONTAINER_UTILITIES_INTERNAL,
            ASYNC_FAILED_CALLBACK, requestId, responseData, function() {}, function() {});
        }
        catch (se)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.slidingwindow.getCurrentWindowId", "ERROR_IN_REQUEST");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api.slidingwindow", "getCurrentWindowId", se);
        }
      });
  };

  /**
   * PUBLIC FUNCTION used to set the status bar style on iOS
   *
   * e.g. adf.mf.api.setStatusBarStyle(style, callback)
   *
   * The style may be one of the following values
   *    "dark"   : A dark status bar, intended for use on light backgrounds.
   *    "light"  : A light status bar, intended for use on dark backgrounds.
   *
   * @param {string} style     the style to set.  either "dark" or "light"
   * @param {function(string)} callback - function is called back with the current style as the
   *   argument can be null
   *
   * Example:
   *   adf.mf.api.setStatusBarStyle("dark",
   *     function(style) { console.log("new style: " + style); });
   */
  adf.mf.api.setStatusBarStyle = function(style, callback)
  {
    cordova.exec(
      function(result)
      {
        if (callback)
        {
          callback(result);
        }
      },
      function() {},
      "ADFMobileShell",
      "setStatusBarStyle",
      [ style ]);
  }

  /**
   * PUBLIC FUNCTION used to get the status bar style on iOS
   *
   * e.g. adf.mf.api.getStatusBarStyle(callback)
   *
   * The callback function will be invoked with a single string argument which will be one of
   *    "dark"   : A dark status bar, intended for use on light backgrounds.
   *    "light"  : A light status bar, intended for use on dark backgrounds.
   *
   * @param {function(string)} callback - function is called back with the current style as the
   *   argument can be null
   *
   * Example:
   *      adf.mf.api.getStatusBarStyle(function(style) { console.log("current style: " + style); });
   */
  adf.mf.api.getStatusBarStyle = function(callback)
  {
    cordova.exec(
      function(result)
      {
        if (callback)
        {
          callback(result);
        }
      },
      function() {},
      "ADFMobileShell",
      "getStatusBarStyle",
      []);
  }
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ContainerIntegration.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfLocale.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfLocale.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "AdfLocale"
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfLocale.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELErrors.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ELErrors.js ---------------------- */

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};


/*
 * Represents any of the ADF flavored exceptions
 */
adf.mf.AdfException = function(message) { 
	/* since this is the only exception that is know and sent to both sides of the channel it needs to match the Java type */ 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.AdfException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'AdfException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.AdfException.prototype = new Error();


/*
 * Represents any of the exception conditions that can arise during expression evaluation.
 */
adf.mf.ELException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.ELException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'ELException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.ELException.prototype = new Error();


/**
 * Thrown to indicate that a method has been passed an illegal or 
 * inappropriate argument.
 */
adf.mf.IllegalArgumentException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IllegalArgumentException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IllegalArgumentException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IllegalArgumentException.prototype = new Error();

/**
 * Thrown to indicate that an array is being accessed beyond
 * it array boundaries.
 */
adf.mf.IndexOutOfBoundsException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IndexOutOfBoundsException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IndexOutOfBoundsException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IndexOutOfBoundsException.prototype = new Error();

/**
 * Thrown to indicate that the channel is not available.
 */
adf.mf.NoChannelAvailableException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.NoChannelAvailableException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'NoChannelAvailableException';
	this.message                                                = (message || "Operation not supported in the current environment");
	this.stack													= (new Error()).stack;
};     
adf.mf.NoChannelAvailableException.prototype = new Error();


/**
 * Thrown to indicate that a null pointer has been encountered.
 */
adf.mf.NullPointerException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.NullPointerException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'NullPointerException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.NullPointerException.prototype = new Error();


/**
 * Thrown to indicate that a illegal state has been encountered.
 */
adf.mf.IllegalStateException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.IllegalStateException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'IllegalStateException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.IllegalStateException.prototype = new Error();


/**
 * Thrown when a property could not be found while evaluating a {@link adf.mf.el.ValueExpression} or
 * {@link MethodExpression}. For example, this could be triggered by an index out of bounds while
 * setting an array value, or by an unreadable property while getting the value of a JavaBeans
 * property.
 */
adf.mf.PropertyNotFoundException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.PropertyNotFoundException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'PropertyNotFoundException';
	this.message                                                = (message || "");
	// Uncomment this if you want to track where the exception is coming from:
	//this.stack													= (new Error()).stack;
};
adf.mf.PropertyNotFoundException.prototype = new Error();


/**
 * Thrown when a property could not be written to while setting the value on a
 * {@link adf.mf.el.ValueExpression}. For example, this could be triggered by trying to set a map value on an
 * unmodifiable map.
 */
adf.mf.PropertyNotWritableException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.PropertyNotWritableException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'PropertyNotWritableException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.PropertyNotWritableException.prototype = new Error();


/**
 * Thrown to indicate that the requested operation is not supported.
 */
adf.mf.UnsupportedOperationException = function(message) { 
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.UnsupportedOperationException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'UnsupportedOperationException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.UnsupportedOperationException.prototype = new Error();


adf.mf.DataRangeNotPresentException = function(message) {
	this[adf.mf.internal.api.constants.TYPE_PROPERTY]           = "oracle.adfmf.framework.exception.DataRangeNotPresentException";
	this[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] = true;
	this.name                                                   = 'DataRangeNotPresentException';
	this.message                                                = (message || "");
	this.stack													= (new Error()).stack;
};
adf.mf.DataRangeNotPresentException.prototype = new Error();



/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELErrors.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfResource.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfResource.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "AdfResource"
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfResource.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/JavaScriptContext.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- JavaScriptContext.js ---------------------- */
//@requires ELErrors
//@requires AdfPerfTiming


var adf                   = window.adf || {};
adf.mf                    = adf.mf || {};
adf.mf.api                = adf.mf.api || {};
adf.mf.el                 = adf.mf.el || {};
adf.mf.locale             = adf.mf.locale || {};
adf.mf.log                = adf.mf.log || {};
adf.mf.resource           = adf.mf.resource || {};
adf.mf.util               = adf.mf.util || {};

adf.mf.internal           = adf.mf.internal || {};
adf.mf.internal.api       = adf.mf.internal.api || {};
adf.mf.internal.el        = adf.mf.internal.el || {};
adf.mf.internal.el.parser = adf.mf.internal.el.parser || {};
adf.mf.internal.locale    = adf.mf.internal.locale || {};
adf.mf.internal.log       = adf.mf.internal.log || {};
adf.mf.internal.mb        = adf.mf.internal.mb || {};
adf.mf.internal.perf      = adf.mf.internal.perf || {};
adf.mf.internal.resource  = adf.mf.internal.resource || {};
adf.mf.internal.util      = adf.mf.internal.util || {};

/**
 * JavaScriptContext is defined here.  It is an internal object but depends on
 * a couple helper objects (JavaScriptFunctions and JavaScriptVariables) that
 * are defined here as well.  Since only the JavaScriptContext must be exposed
 * to other internal objects, it will have an adf.mf.internal.el namespace.  The
 * others are never exposed and are only local to this initialization function.
 */
(function()
{
  // private to the JavaScriptContext object
  function JavaScriptFunctions() // implements FunctionMapper
  {
    // map from function name to function implementation
    this.map = null;

    /**
     * @param {string} prefix
     * @param {string} localName
     * @return {function}
     */
    this.resolveFunction = function(prefix, localName)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      return this.map[prefix + ":" + localName];
    };

    /**
     * @param {string} prefix
     * @param {string} localName
     * @param {function} func
     */
    this.setFunction = function(prefix, localName, func)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      this.map[prefix + ":" + localName] = func;
    };
  };

  // private to the JavaScriptContext object
  function JavaScriptVariables()
  // implements VariableMapper
  {
    // map from variable name to variable's value
    this.map             = null;
    this.nextModLZWCode  = 0;

    /**
     * @param {string} variable
     * @return {adf.mf.el.ValueExpression}
     */
    this.resolveVariable = function(variable)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      return this.map[variable];
    };

    /**
     *
     * @param {string} variable
     * @param {Object} value
     * @return {adf.mf.el.ValueExpression}
     */
    this.setVariable = function(variable, value)
    {
      if (this.map === null)
      {
        this.map = {};
      }

      this.map[variable] = value;

      return this.map[variable];
    };

    /**
     * @param {string} variable
     */
    this.removeVariable = function(variable)
    {
      if (this.map !== null)
      {
        if (this.map[variable] !== undefined)
        {
          delete this.map[variable];
        }
      }
    };

    this.clearWeakReferences = function()
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          if (this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY] !== undefined)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
             adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
              "JavaScriptVariables","clearWeakReferences",
              "removing weak ref - " + v);
            }
            delete this.map[v];
          }
        }
        this.nextModLZWCode = 0;
      }
    };

    /**
     * @param {string} variable
     * @return {string}
     */
    this.resolveWeakReference = function(variable)
    {
      var v = this.resolveVariable(variable);

      if (v != undefined)
      {
        return v[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];
      }

      return undefined;
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.getWeakReference = function(name)
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          var fqn = this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];

          if ((fqn !== undefined) && (name.indexOf(fqn) == 0))
          {
            var wrn = v + name.substring(fqn.length);

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
               "JavaScriptVariables", "getWeakReference",
               "just found weak ref - " + wrn);
            }

            return wrn;
          }
        }
      }
      return undefined;
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.findMatchingWeakReference = function(name)
    {
      if (this.map !== null)
      {
        for (var v in this.map)
        {
          var fqn = this.map[v][adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];

          if ((fqn !== undefined) && (name == fqn))
          {
            return v;
          }
        }
      }

      return undefined;
    };

    /**
     * @param {string} reference
     * @return {string}
     */
    this.addCompressedReference = function(reference)
    {
      var lzwk = this.findMatchingWeakReference(reference);

      if (lzwk == undefined)
      {
        var key = adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY;
        var wr  = {};

        wr[key] = reference;
        lzwk = "_" + (this.nextModLZWCode++);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "JavaScriptVariables", "addCompressedReference",
            "just added a weak ref - " + wr);
        }

        this.setVariable(lzwk, wr);
      }

      return lzwk;
    };
  };

  /**
   * Still internal but exposed to the other internal objects
   *
   * @param {ELResolver} elResolver
   */
  adf.mf.internal.el.JavaScriptContext = function(elResolver)
    // implements ELContext
  {
    this.context   = this;
    this.functions = null;
    this.resolver  = (elResolver || null);
    this.variables = null;
    this.queue     = null;
    this.vmchannel = null;
    this.security  = null;
    this.modid     = (new Date()).getTime();

    /**
     * Get the modification id for the context.
     * @return {int}
     */
    this.getModId = function()
    {
      return this.modid;
    };

    /**
     * Update the modification id for the context.
     */
    this.updateModId = function()
    {
      this.modid = (new Date()).getTime();
    };

    /**
     * Returns the context object associated with the given key. The ELContext maintains a
     * collection of context objects relevant to the evaluation of an expression. These context
     * objects are used by ELResolvers. This method is used to retrieve the context with the given
     * key from the collection. By convention, the object returned will be of the type specified by
     * the key. However, this is not required and the key is used strictly as a unique identifier.
     *
     * @param {Class} key
     *        The unique identifier that was used to associate the context object with this
     *        ELContext.
     * @return {ELContext} The context object associated with the given key, or null if no such context was
     *      found.
     * @throws NullPointerException
     *         if key is null.
     */
    this.getContext = function(key)
    {
      // First check to make sure we have a context to give back */
      if ((this.context === undefined) || (this.context === null))
      {
        return null;
      }

      // Next check that they passed a key and if not return the root context
      if (key === undefined)
      {
        return this.context;
      }

      // Looks like we have everything so return the key'ed context
      return this.context[key];
    };

    /**
     * Retrieves the ELResolver associated with this context. The ELContext maintains a reference to
     * the ELResolver that will be consulted to resolve variables and properties during an
     * expression evaluation. This method retrieves the reference to the resolver. Once an ELContext
     * is constructed, the reference to the ELResolver associated with the context cannot be
     * changed.
     *
     * @return {ELResolver} The resolver to be consulted for variable and property resolution during expression
     *      evaluation.
     */
    this.getELResolver = function()
    {
      if (this.resolver === null)
      {
        this.resolver = new VariableResolver();

        // Add some scopes to the context */
        this.getVariableMapper().setVariable("viewScope", {});
        this.getVariableMapper().setVariable("pageFlowScope", {});
        this.getVariableMapper().setVariable("applicationScope", {});

        // Represents #{feature} implicit object that allows developers to access runtime state of the feature.
        // The name intentionally does not end with "Scope" as it is more of a context.
        // This constant is defined in Java in oracle.adfmf.Constants, and both names need to be kept in sync.
        this.getVariableMapper().setVariable("feature", {});
        this.getVariableMapper().setVariable("preferenceScope", {});
        this.getVariableMapper().setVariable("validationScope", {});
        this.getVariableMapper().setVariable("deviceScope", {"device": {}, "hardware": {"screen": {}}});
      }

      return this.resolver;
    };

    /**
     * Retrieves the FunctionMapper associated with this ELContext.
     *
     * @return {FunctionMapper} The function mapper to be consulted for the resolution of EL functions.
     */
    this.getFunctionMapper = function()
    {
      if (this.functions === null)
      {
        this.functions = new JavaScriptFunctions();
      }

      return this.functions;
    };

    /**
     * Retrieves the VariableMapper associated with this ELContext.
     *
     * @return {VariableMapper} The variable mapper to be consulted for the resolution of EL variables.
     */
    this.getVariableMapper = function()
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables;
    };


    /**
     * Returns whether an {@link ELResolver} has successfully resolved a given (base, property)
     * pair. The {@link CompositeELResolver} checks this property to determine whether it should
     * consider or skip other component resolvers.
     *
     * @return {boolean} The variable mapper to be consulted for the resolution of EL variables.
     * @see CompositeELResolver
     */
    this.isPropertyResolved = function()
    {
      return this.resolved;
    };

    /**
     * Associates a context object with this ELContext. The ELContext maintains a collection of
     * context objects relevant to the evaluation of an expression. These context objects are used
     * by ELResolvers. This method is used to add a context object to that collection. By
     * convention, the contextObject will be of the type specified by the key. However, this is not
     * required and the key is used strictly as a unique identifier.
     *
     * @param {Class} key
     *        The key used by an {@link ELResolver} to identify this context object.
     * @param {Object} contextObject
     *        The context object to add to the collection.
     * @throws NullPointerException
     *         if key is null or contextObject is null.
     */
    this.putContext = function(key, contextObject)
    {
      if ((this.context === undefined) || (this.context === null))
      {
        this.context = {};
      }

      if ((key === undefined) || (key === null))
      {
        throw Error("invalid key");
      }

      if ((contextObject === undefined) || (contextObject === null))
      {
        throw Error("invalid context object");
      }

      this.context[key] = contextObject;
    };

    /**
     * @param {ELResolver} resolver
     */
    this.setELResolver = function(resolver)
    {
      this.resolver = resolver;
    };

    /**
     * @param {string} prefix
     * @param {string} localName
     * @param {function} func
     */
    this.setFunction = function(prefix, localName, func)
    {
      if (this.functions === null)
      {
        this.functions = new JavaScriptFunctions();
      }

      this.functions.setFunction(prefix, localName, func);
    };

    /**
     * Called to indicate that a ELResolver has successfully resolved a given (base, property) pair.
     * The {@link CompositeELResolver} checks this property to determine whether it should consider
     * or skip other component resolvers.
     *
     * @param {boolean} resolved
     *        true if the property has been resolved, or false if not.
     * @see CompositeELResolver
     */
    this.setPropertyResolved = function(resolved)
    {
      this.resolved = resolved;
    };

    this.clearWeakReferences = function()
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.clearWeakReferences();
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.getWeakReference = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.getWeakReference(name);
    };

    /**
     * @param {string} name
     * @return {string}
     */
    this.addCompressedReference = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.addCompressedReference(name);
    };

    /**
     * @param {ELExpression} elExpression
     */
    this.uncompressReference = function(elExpression)
    {
      try
      {
        if (this.variables == null)
        {
          return elExpression;
        }

        var token = elExpression.tokens [0];
        var result = this.variables.resolveWeakReference(token.index);

        if (!result)
        {
          return elExpression;
        }

        if (result == token.index)
        {
          return elExpression;
        }

        var replacement = {};

        replacement[token.index] = result;

        return elExpression.stripLocalValues(false, replacement, false);
      }
      catch(err)
      {
        return elExpression;
      }
    };

    /**
     * @param {string} name
     * @return {Object}
     */
    this.getVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.resolveVariable(name);
    };


    /**
     * @param {string} name
     * @param {adf.mf.el.ValueExpression} expression
     */
    this.setVariable = function(name, expression)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.setVariable(name, expression);
    };


    /**
     * @param {string} name
     */
    this.removeVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      return this.variables.removeVariable(name);
    };


    /**
     * @param {string} name
     * @param {adf.mf.el.ValueExpression} expression
     */
    this.pushVariable = function(name, expression)
    {
      var prevValue = undefined;

      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      prevValue = this.variables.resolveVariable(name);

      if (this.queue === null)
      {
        this.queue = [];
      }

      if (prevValue != null)
      {
        this.queue[name] = this.queue[name] || [];

        this.queue[name].push(prevValue);
      }

      return this.variables.setVariable(name, expression);
    };

    /**
     * @param {string} name
     */
    this.popVariable = function(name)
    {
      if (this.variables === null)
      {
        this.variables = new JavaScriptVariables();
      }

      if (this.queue === null)
      {
        this.queue = [];
      }

      if ((q = this.queue[name]) != null)
      {
        var v;

        if ((v = q.pop()) != null)
        {
          this.setVariable(name, v);
        }
        else
        {
          if (q.length == 0)
          {
            delete this.queue[name];
            this.variables.removeVariable(name);
          }
        }
      }
    };

    /**
     * @param {Object} commId The communication channel ID (type unsure)
     */
    this.invokeJavaMethod = function(commId, request, success, failed)
    {
      if (this.vmchannel === null)
      {
        this.vmchannel  = new adf.mf.internal.VMChannel(this);
      }

      if (commId != undefined)
      {
        request.featureId = commId;
      }

      this.vmchannel.nonBlockingCall(request, success, failed);
    };

    this.invokeSecurityMethod = function(command, username, password, tenantname, success, failed)
    {
      if (this.security === null)
      {
        //this.security  = new Security(this);
        this.security  = new adf.mf.security(this);
      }

      var fm = this.getFunctionMapper();
      var f  = fm.resolveFunction("Security", command);

      return f.call(undefined, username, password, tenantname, success, failed);
    };

    /**
     * @return {string}
     */
    this.toString = function()
    {
      return "[ ELContext: " + this.context + " ]";
    };
  };

  function VariableResolver()
  {
  }

  adf.mf.internal.el.VariableResolver = VariableResolver;

  /**
   * Attempts to resolve the given property object on the given base object.
   *
   * If the base object is null or undefined, delegates to
   * context.getVariableMapper().resolveVariable(property).
   *
   * If the base object is a Java language array, returns the value at the given index. The index
   * is specified by the property argument, and coerced into an integer. If the coercion could not
   * be performed, an IllegalArgumentException is thrown. If the index is out of bounds, null is
   * returned.
   *
   * If the base object is a map, returns the value associated with the given key, as specified by
   * the property argument. If the key was not found, null is returned. Just as in
   * java.util.Map.get(Object), just because null is returned doesn't mean there
   * is no mapping for the key; it's also possible that the Map explicitly maps
   * the key to null.
   *
   *
   * @param {ELContext} context
   *        The context of this evaluation.
   * @param {Object} base
   *        The base object to return the most general property type for, or null to enumerate
   *        the set of top-level variables that this resolver can evaluate.
   * @param {Object} property
   *        The property or variable to return the acceptable type for.
   * @return {Object} If the propertyResolved property of ELContext was set to true, then the result of the
   *      variable or property resolution; otherwise undefined.
   * @throws NullPointerException
   *         if context is null
   * @throws PropertyNotFoundException
   *         if base is not null and the specified property does not exist or is not readable.
   * @throws ELException
   *         if an exception was thrown while performing the property or variable resolution.
   *         The thrown exception must be included as the cause property of this exception, if
   *         available.
   */
  VariableResolver.prototype.getValue = function(context, base, property)
  {
    var result = undefined;

    if ((base === undefined) || (base === null))
    {
      // Root Property EL Resolver
      var variables = context.getVariableMapper();

      try
      {
        result = variables.resolveVariable(property);

        if ((result instanceof Object) &&
          (result[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY] !== undefined))
        {
          var ref = result[adf.mf.internal.api.constants.WEAK_REFERENCE_PROPERTY];
          var p = adf.mf.internal.el.parser.parse("#{" + ref + "}");

          try
          {
            result = p.evaluate(context);
          }
          catch (e)
          {
            result = {};
            p.setValue(context, result);
          }
        }
      }
      catch (e)
      {
      }
    }
    else if (Array.isArray(base))
    {
      // Array EL Resolver
      result = base[property];
    }
    else if ((typeof base) === 'object')
    {
      var baseType = base['.type'];

      if (baseType === 'Attribute')
      {
        // Attribute EL Resolver
        if (property == "bindings")
        {
          result = new adf.mf.internal.el.AttributeBinding(base);
        }
        else if (property == 'inputValue')
        {
          // getInputValue
          result = base.getPropertyInputValue(property);
        }
        else
        {
          result = base.getProperty(property);
        }
      }
      else if (baseType === 'AttributeBinding')
      {
        // Attribute Binding EL Resolver
        result = new adf.mf.internal.el.Attribute(base, property);
      }
      else if (baseType === 'TreeBindings')
      {
        // Tree Binding EL Resolver
        // special cases:
        //   inputValue: need to read to the provider's object and not here
        if (property == 'iterator')
        {
          try
          {
            result = new adf.mf.el.TreeNodeIterator(base, 0);

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.el", "TreeBindingsELResolver",
                "resolved iterator with " + result.getCachedRowCount(0) + " rows cached.");
            }
          }
          catch (ie)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
               "adf.mf.internal.el", "TreeBindingsELResolver",
               "resolving the iterator resulted in an exception: " + ie);
            }
          }
        }
        else if (base[property] !== undefined)
        {
          result = base[property];
        }
        else
        {
          var ab = base.columnAttributes() || {};

          result = ab[property];
        }
      }
      else if (baseType === 'oracle.adfmf.bindings.dbf.TreeNode')
      {
        // TreeNode EL Resolver
        if (property == "bindings")
        {
          result = new adf.mf.internal.el.AttributeBinding(base);
        }
        else if (property.toLowerCase() == "rowkey")
        {
          result = base.rowKey();
        }
        else if (property == "dataProvider")
        {
          result = base.getProvider();
        }
        else
        {
          var dp = base.getProvider() || {};

          result = dp[property];

          // if it is a row, attempt to resolve row.bindings.property.inputValue
          if (result == undefined && dp[".type"] === 'row')
          {
            result = VariableResolver.getValueFromRow(dp, property);
          }
        }
      }
      else if (baseType === 'OptionalFragmentArgument')
      {
        // Optional Fragment Argument EL Resolver
        result = base;
      }
      else
      {
        // Map EL Resolver
        // First attempt to get the property
        result = base[property];

        // If it is a row, attempt to resolve row.bindings.property.inputValue
        if (result == undefined && baseType === 'row')
        {
          result = VariableResolver.getValueFromRow(base,property);
        }
      }
    } // (typeof base) == 'object'

    if (result === undefined)
    {
      throw new adf.mf.PropertyNotFoundException();
    }
    return result;
  };

  /**
   * Resolves the EL #{row.property} to #{row.bindings.property.inputValue}
   */
  VariableResolver.getValueFromRow = function(row, property)
  {
    var bindings = row["bindings"];

    if (bindings && typeof bindings == 'object')
    {
      var attr = bindings[property];

      if (attr && typeof attr == 'object')
      {
        return attr["inputValue"];
      }
    }

    return undefined;
  }

  /**
   * Set on the EL #{row.property} will be set to #{row.bindings.property.inputValue}
   *
   * @param {Object} row the provider from the collection model on which to set the value
   * @param {string} property the property name for which to set the value
   * @param {Object} value the value to set
   */
  VariableResolver.setValueInRow = function(row, property, value)
  {
    var bindings = row["bindings"];
    if (bindings && typeof bindings == 'object')
    {
      var attr = bindings[property];
      if (attr && typeof attr == 'object')
      {
        attr["inputValue"] = value;
      }
      else if (attr == null)
      {
        // If the attr is null, this means that an attribute that is not defined in the
        // page bindings is trying to be set. If we do not set it, we can get into an
        // infinite loop of re-requesting the bad value on the page (bug 23324654).
        // So instead, set the value to the null object here (do not use the value being passed
        // in) to stop the loop.
        attr = { "inputValue": { ".null": true } };
        bindings[property] = attr;

        // Now log an error so that the page author can detect that something is wrong
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.el.VariableResolver.setValueInRow",
          "ERROR_INVALID_COLLECTION_MODEL_ATTRIBUTE");

        // For security purposes, only log the details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          var valueStr;
          try
          {
            valueStr = adf.mf.util.stringify(value);
          }
          catch (e)
          {
            valueStr = "" + value;
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.el.VariableResolver", "setValueInRow",
            "Trying to set property: " + property + " with value: " + valueStr);
        }
      }
    }
  }

  /**
  * Attempts to set the value of the given property object on the given base object.
  *
  * If the base object is null or undefined, delegates to
  * context.getVariableMapper().setVariable(property, value).
  *
  * If the base object is a Java language array, attempts to set the value at the given index
  * with the given value. The index is specified by the property argument, and coerced into an
  * integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If
  * the index is out of bounds, a PropertyNotFoundException is thrown.
  *
  * If the base object is a map, attempts to set the value associated with the given key, as
  * specified by the property argument.
  *
  * @param {ELContext} context
  *        The context of this evaluation.
  * @param {Object} base
  *        The base object to return the most general property type for, or null to enumerate
  *        the set of top-level variables that this resolver can evaluate.
  * @param {Object} property
  *        The property or variable to return the acceptable type for.
  * @param {Object} value
  *        The value to set the property or variable to.
  * @throws NullPointerException
  *         if context is null
  * @throws PropertyNotFoundException
  *         if base is not null and the specified property does not exist or is not readable.
  * @throws PropertyNotWritableException
  *         if the given (base, property) pair is handled by this ELResolver but the
  *         specified variable or property is not writable.
  * @throws ELException
  *         if an exception was thrown while attempting to set the property or variable. The
  *         thrown exception must be included as the cause property of this exception, if
  *         available.
  */
  VariableResolver.prototype.setValue = function(
    context,
    base,
    property,
    value)
  {
    if ((base === undefined) || (base === null))
    {
      // Root Property EL Resolver
      context.getVariableMapper().setVariable(property, value);
    }
    else if (Array.isArray(base))
    {
      // Array EL Resolver
      base[property] = value;
    }
    else if ((typeof base) == 'object')
    {
      var baseType = base['.type'];

      if (baseType == 'Attribute')
      {
        // Attribute EL Resolver
        if (property == 'inputValue')
        {
          base.setPropertyInputValue(value);
        }
        else
        {
          base.setProperty(property, value);
        }
      }
      else if (baseType == 'AttributeBinding')
      {
        // Attribute Binding EL Resolver
        base[property] = value;
      }
      else if (baseType == 'TreeBindings')
      {
        // Tree Binding EL Resolver
        // special cases:
        //  inputValue: need to written to the provider's object and not here
        if (property == 'iterator')
        {
          throw new adf.mf.PropertyNotWritableException("resolver is read-only");
        }
        else if (base[property] !== undefined)
        {
          base[property] = value;
        }
        else
        {
          if ((typeof value) !== 'AttributeBindings')
          {
            throw new adf.mf.IllegalArgumentException("value is not a AttributeBindings object");
          }

          var ab = base.columnAttributes() || {};

          ab[property] = value;
        }
      }
      else if (baseType == 'oracle.adfmf.bindings.dbf.TreeNode')
      {
        // TreeNode EL Resolver
        if (property == "bindings")
        {
          base.bindings = value;
        }
        else if (property == "dataProvider")
        {
          base.dataProvider = value;
        }
        else if (property == "rowKey")
        {
          throw new adf.mf.PropertyNotWritableException("rowKey is read-only");
        }
        else
        {
          var dp = base.getProvider() || {};

          if (dp[".type"] == "row")
          {
            VariableResolver.setValueInRow(dp, property, value);
          }
          else
          {
            dp[property] = value;
          }
        }
      }
      else if (baseType == 'OptionalFragmentArgument')
      {
        // Optional Fragment Argument EL Resolver
      }
      else if (baseType == "row")
      {
        VariableResolver.setValueInRow(base, property, value);
      }
      else
      {
        // Map EL Resolver
        base[property] = value;
      }
    }
  };

  adf.mf.internal.el.Attribute = function(/* AttributeBinding */ ab, /* string */ name)
  {
    this['ab'] = ab;
    this['.type'] = 'Attribute';
    this['.name'] = name;

    this.toString = function()
    {
      return "Attribute[" + adf.mf.util.stringify(this.getPropertyInputValue()) + "]";
    };

    this.getProperty = function(/* string */ name)
    {
      var bindings = undefined;
      var property = undefined;

      try
      {
        bindings = this.ab.getBindings();
        property = bindings[this['.name']];
      }
      catch (e)
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['.name']);
      }

      return property[name];
    };

    this.getPropertyInputValue = function()
    {
      if ((ab !== undefined) && (ab.tn !== undefined))
      {
        return '' + adf.mf.util.stringify(this.ab.tn.getProvider()[this['.name']]);
      }
      else
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['.name']);
      }
    };

    this.setProperty = function(/* string */ name, /* object */ value)
    {
      var bindings = this.ab.getBindings();
      var property = bindings[this['.name']];

      property[name] = value;
    };

    this.setPropertyInputValue = function(/* object */ value)
    {
      if ((ab !== undefined) && (ab.tn !== undefined))
      {
        var p = this.ab.tn.getProvider();

        p[this['.name']] = value;
      }
      else
      {
        throw new adf.mf.PropertyNotFoundException('unknown property ' + this['_name']);
      }
    };
  };

  adf.mf.internal.el.AttributeBinding = function(/* TreeNode */ tn)
  {
    this['.type'] = 'AttributeBinding';
    this.tn = tn;

    this.getBindings = function()
    {
      return tn.getBindings();
    };

    this.getProvider = function()
    {
      return tn.getProvider();
    };

    this.toString = function()
    {
      return "Attribute Bindings";
    };
  };

  adf.mf.internal.el.OptionalFragmentArgument = function()
  {
    this['.type']  = 'OptionalFragmentArgument';

    this.toString   = function()
    {
      return "OptionalFragmentArgument";
    };

    this.getProperty = function(/* string */ name)
    {
      return this;
    };

    this.setProperty = function(/* string */ name, /* object */ value)
    {
      /* ignore */
    };
  };

  adf.mf.api.OptionalFragmentArgument = adf.mf.api.OptionalFragmentArgument ||
    new adf.mf.internal.el.OptionalFragmentArgument;

  adf.mf.internal.VMChannel = function(/* Context */ context)
  {
    /**
     * blockingCall(java-class-name, java-class-method-name, success-callback, failed-callback, arguments);
     */
    this.blockingCall = function(request, success, failed)
    {
      throw adf.mf.UnsupportedOperationException("blocking calls are not supported in this version");
    };

    this.nonBlockingCall= function(request, success, failed)
    {
      var scb  = [];
      var fcb  = [];
      var op   = request.classname + ":" + request.method;

      if (adf.mf.internal.batchRequest !== undefined)
      {
        var deferedObject = {};

        /* configure up the success and failed callback vectors */
        scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);
        fcb = fcb.concat(adf.mf.internal.util.is_array(failed)?  failed  : [failed ]);

        adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.VMChannel", "nonBlockingCall",
        "appending request on the batch request - actual request is being defered.");
        adf.mf.internal.batchRequest.push(request);

        deferedObject[adf.mf.internal.api.constants.DEFERRED_PROPERTY];

        for (var i = 0; i < scb.length; ++i)
        {
          try
          {
            var callback = scb[i];
            if (callback)
              callback(request, deferedObject);
          }
          catch(se)
          {
            // nothing we can do
          }
        }
      }
      else
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Non blocking call",
          adf.mf.log.level.FINER,
          "adf.mf.internal.VMChannel.nonBlockingCall", op);

        /* configure up the success and failed callback vectors */
        scb = scb.concat([function() { perf.stop(); }]);
        scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);

        fcb = fcb.concat([function() { perf.stop(); }]);
        fcb = fcb.concat(adf.mf.internal.errorHandlers);
        fcb = fcb.concat(adf.mf.internal.util.is_array(failed)?  failed  : [failed ]);

        try
        {
          container.internal.device.integration.vmchannel.invoke(10000, request, scb, fcb);
        }
        catch(e)
        {
          if ((! adf.mf.internal.isJavaAvailable()) || (e.name == "TypeError") ||
            (e.name == "ReferenceError"))
          {
            // this is when navigator, container.internal.device.integration, or
            // container.internal.device.integration.vmchannel is missing.
            e = new adf.mf.NoChannelAvailableException();
          }

          for (var i = 0; i < fcb.length; ++i)
          {
            try
            {
              var callback = fcb[i];
              if (callback)
                callback(request, e);
            }
            catch(fe)
            {
              // nothing we can do
            }
          }
        }
      }
    };

    context.setFunction("VMChannel", "blockingCall", this.blockingCall);
    context.setFunction("VMChannel", "nonBlockingCall", this.nonBlockingCall);
  };

  adf.mf.security = function(/* Context */ context)
  {
    this.login = function(username, password, tenantname)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureLogin(username, password, tenantname);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "login",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.logout = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureLogout();
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "logout",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.isAuthenticated = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureIsAuthenticated();
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "isAuthenticated",
          "adfmf - invoking the Security command");
      }
    };

    this.cancelLogin = function()
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.cancelLogin();
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "cancelLogin",
          "adfmf - invoking the Security command");
      }
    };

    this.isConnectionMultiTenantAware = function(username, password, tenantname, callback)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureIsConnectionMultiTenantAware(
          callback);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security",
            "isConnectionMultiTenantAware",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.getMultiTenantUsername = function(username, password, tenantname, callback)
    {
      if ((container.internal.device.integration !== undefined) &&
        (container.internal.device.integration.Security !== undefined))
      {
        container.internal.device.integration.Security.featureGetMultiTenantUsername(callback);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getMultiTenantUsername",
            "adfmf - invoking the Security command");
        }
      }
    };

    this.getLoginViewInitData = function(username, password, tenantname, success, failed)
    {
      try
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getLoginViewInitData",
            "invoking security command.");
        }

        container.internal.device.integration.Security.getLoginViewInitData(success, failed);
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "Security", "getLoginViewInitData",
            "Security.getLoginViewInitData was not invoked (error=" + e + ")");
        }
      }
    };

    context.setFunction("Security", "cancelLogin", this.cancelLogin);
    context.setFunction("Security", "login", this.login);
    context.setFunction("Security", "logout", this.logout);
    context.setFunction("Security", "isAuthenticated", this.isAuthenticated);
    context.setFunction("Security", "isConnectionMultiTenantAware",
      this.isConnectionMultiTenantAware);
    context.setFunction("Security", "getMultiTenantUsername", this.getMultiTenantUsername);
    context.setFunction("Security", "getLoginViewInitData", this.getLoginViewInitData);
  };
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/JavaScriptContext.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adflog.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Adflog.js ---------------------- */
// moved to base.js
// TODO need to:
// - look for the @-requires messages in all of Bruces code to remove references to "Adflog" (don't think this particular one is required anywhere... maybe just bootstrap)
// - purge this file altogether but be careful to check that Ant doesn't try to reference it

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adflog.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfPerfTiming.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfPerfTiming.js ---------------------- */
// @requires Adflog
// @requires ELErrors

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

/**
 * adf.mf.internal.perf consists of a set of javascript functions
 * to instrument the adf.mf javascript sub-systems
 *
 * HOW-TO USE THIS:
 * Declare the performance loggers
 *
 *    # used to control what monitors are captured in the list of monitors
 *    oracle.maf.performance.monitor.captured.useParentHandlers=false
 *    oracle.maf.performance.monitor.captured.handlers=oracle.adfmf.util.logging.ConsoleHandler
 *    oracle.maf.performance.monitor.captured.level = FINEST
 *    
 *    # used to control what monitor observations (start/stop times) are logged.
 *    oracle.maf.performance.monitor.observations.reported=false
 *    oracle.maf.performance.monitor.observations.reported.handlers=oracle.adfmf.util.logging.ConsoleHandler
 *    oracle.maf.performance.monitor.observations.reported.level = FINEST
 */
 
(function()
{
  //
  // JS representation of "oracle.maf.performance.monitor.observations.reported" logger
  //
  var perfMonReportedLogger = adf.mf.log.PerfMonReported = adf.mf.log.PerfMonReported ||
    new adf.mf.log.logger("oracle.maf.performance.monitor.observations.reported");
  //
  // JS representation of "oracle.maf.performance.monitor.captured" logger
  //
  var perfMonCapturedLogger = adf.mf.log.PerfMonCaptured = adf.mf.log.PerfMonCaptured ||
    new adf.mf.log.logger("oracle.maf.performance.monitor.captured");

  // ============================================================================================
  // Private methods and variables
  // Uncomment the following lines, in order to obtain performance numbers for start up.
  //perfMonReportedLogger.init(adf.mf.log.level.FINE,
  //  "[%LEVEL% - %LOGGER% - %CLASS% - %METHOD%] %MESSAGE%");
  //perfMonCapturedLogger.init(adf.mf.log.level.FINE,
  //  "[%LEVEL% - %LOGGER% - %CLASS% - %METHOD%] %MESSAGE%");
  //

  var FINEST = adf.mf.log.level.FINEST;
  var FINER = adf.mf.log.level.FINER;
  var FINE = adf.mf.log.level.FINE;
  var INFO = adf.mf.log.level.INFO;

  var noop = function() {};
  var noopTask = { "stop" : noop, "setInstanceName" : noop}; 
  var Assert = adf.mf.api.AdfAssert;

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Task object (base class)
  function Task(name)
  {
    this.Init(name);
  }

  adf.mf.api.AdfObject.createSubclass(Task, adf.mf.api.AdfObject, "Task");

  Task.InitClass = function()
  {
    // Used to keep a unique ID per task to identify it
    this._nextId = 1;
    // Tasks that are currently running
    this._activeTasks = [];
    this.VisitResult = { "ACCEPT": 0, "REJECT": 1, "COMPLETE": 2 };
  };

  /**
   * Get the most recent task that was started
   */
  Task.getActiveTask = function()
  {
    return (Task._activeTasks.length == 0) ?
      null : Task._activeTasks[Task._activeTasks.length - 1];
  };

  Task.prototype.Init = function(name)
  {
    this._id = Task._nextId++;
    this._name = name;
    this._parent = null;
    this._tasks = [];
    this._start = null;
    this._stop = null;
    this._tasksCompletedAt = null;
    this._activeTaskCount = 0;
    this._level = FINEST;
    this._description = null;
    this._instanceName = null;
  };

  Task.prototype.getIdentifier = function()
  {
    // Lazily create it for performance as we won't always need it
    if (this._identifier == null)
    {
      this._identifier = this.constructor.name + "[" + this._id + "/" + this._name + "]";
    }

    return this._identifier;
  };

  /**
   * Get the count of the tasks that are still running
   * @return {Number} the active count
   */
  Task.prototype.getActiveTaskCount = function()
  {
    return this._activeTaskCount;
  };

  /**
   * @return {Number} the unique ID of the task
   */
  Task.prototype.getId = function()
  {
    return this._id;
  };

  /**
   * @return {string} the friendly name of the task
   */
  Task.prototype.getName = function()
  {
    return this._name;
  };

  /**
   * @return {Task} the parent or null if a top level task
   */
  Task.prototype.getParent = function()
  {
    return this._parent;
  };
  
  Task.prototype.getLevel = function()
  {
    return this._level;
  };
  
  Task.prototype.setLevel = function(level)
  {
    this._level = level;
  };
  
  Task.prototype.getDescription = function()
  {
    return this._description;
  };
  
  Task.prototype.setDescription = function(description)
  {
    this._description = description;
  };
  
  Task.prototype.getInstanceName = function()
  {
    return this._instanceName;
  };
  
  Task.prototype.setInstanceName = function(instanceName)
  {
    this._instanceName = instanceName;
  };

  /**
   * @return {Operation} the closest parent operation or null if none
   */
  Task.prototype.getParentOperation = function()
  {
    for (var p = this._parent; p != null; p = p.getParent())
    {
      if (p instanceof Operation)
      {
        return p;
      }
    }

    return null;
  };

  /**
   * Add a child
   * @param {Task} task the child
   */
  Task.prototype.addChildTask = function(task)
  {
    if (this._stop != null)
    {
      Assert.assert(false,
        "addChildTask called on a stopped task: " + this.getIdentifier() +
        ", attempting to add " + task.getIdentifier());
    }
    this._tasks.push(task);
    ++this._activeTaskCount;
  };

  /**
   * Start the task running
   */
  Task.prototype.start = function()
  {
    if (this._start != null)
    {
      Assert.assert(
        false,
        "start called on a task that was already started: " + this.getIdentifier());
    }

    this._start = (new Date()).getTime();
    this._parent = Task.getActiveTask();

    if (this._parent != null)
    {
      this._parent.addChildTask(this);
    }

    Task._activeTasks.push(this);

    return this;
  };

  /**
   * Stop the task (may not be yet completed if there are children tasks still running)
   * @param {boolean} check if the task was already stopped, and if so, don't stop it again
   */
  Task.prototype.stop = function(checkStopped)
  {
    try
    {
      if (this._stop != null)
      {
        if (checkStopped)
        {
          return;
        }
        Assert.assert(
          false,
          "stop called on a task that was already stopped: " + this.getIdentifier());
      }
      
      
      this._stop = (new Date()).getTime();

      // Notify the sub-class
      this.Stopped();

      // See if this task is now complete
      this._checkComplete();
    }
    catch (e)
    {
      // Eat any exceptions in the performance code to prevent issues loading the page
      if (perfMonReportedLogger.isLoggable(FINEST))
      {
        perfMonReportedLogger.logp(FINEST,
          "adf.mf.internal.perf.Task", "stop",
          "Exception thrown " + e.message);
      }
      return { "stop": noop };
    }
  };
  

  /**
   * @return {Number} the start time (ms) of the task or null if not started
   */
  Task.prototype.getStart = function()
  {
    return this._start;
  };

  /**
   * @return {Number} the stop time (ms) of the task or null if not yet stopped.
   */
  Task.prototype.getStop = function()
  {
    return this._stop;
  };

  /**
   * @return {Number} the time (ms) between the start and stop times (may be null if not yet stopped)
   */
  Task.prototype.getElapsed = function()
  {
    return (this._start == null || this._stop == null) ?
      null : (this._stop - this._start);
  };

  /**
   * @return {Number} the time (ms) between the start and when the task was completed (all children
   * completed)
   */
  Task.prototype.getTotalElapsed = function()
  {
    return (this._start == null || this._tasksCompletedAt == null) ?
      null : (this._tasksCompletedAt - this._start);
  };

  /**
   * @return {Number} the time (ms) of the task completion or null if not yet stopped or children
   * tasks are still running
   */
  Task.prototype.getTasksCompletedAt = function()
  {
    return this._tasksCompletedAt;
  };

  /**
   * Visit interface. The callback accepts the task and returns a Task.VisitResult object.
   * @return {bool} true if visiting should continue
   */
  Task.prototype.visit = function(callback)
  {
    var result = callback(this);
    switch (result)
    {
      case Task.VisitResult["ACCEPT"]:
        for (var t = 0, numTasks = this._tasks.length; t < numTasks; ++t)
        {
          var task = this._tasks[t];
          if (!task.visit(callback))
          {
            return false;
          }
        }
        return true;
      case Task.VisitResult["REJECT"]:
        return true;
      case Task.VisitResult["COMPLETE"]:
      default:
        return false;
    }
  };

  /**
   * Check if the task was forced to complete (took too long)
   */
  Task.prototype.wasForcedToComplete = function()
  {
    return this._forceCompleted === true;
  };

  /**
   * Force a long running task to complete
   */
  Task.prototype.forceComplete = function()
  {
    if (this._tasksCompletedAt == null)
    {
      this._forceCompleted = true;
      for (var t = 0, numTasks = this._tasks.length; t < numTasks; ++t)
      {
        var task = this._tasks[t];

        if (task._tasksCompletedAt == null)
        {
          // Forcing the child to complete should result in the _childTaskComplete call
          // from the child and therefore the _activeTaskCount should be decremented
          // by the end of this function and the _checkComplete will run
          task.forceComplete();
        }

        if (this._tasksCompletedAt != null)
        {
          break;
        }
      }

      if (this._stop == null)
      {
        this.stop();
      }
    }

    Assert.assert(this._tasksCompletedAt != null,
      "Task was forced to complete, but is still active");
  };

  /**
   * Gets the monitor ID. This ID includes the path to indicate the correct nesting level.
   *
   * @return {string} the monitor ID of this task
   */
  Task.prototype.getMonitorId = function()
  {
    var monitorId = this.getName();
    return monitorId;
  };

  /**
   * Function for sub-classes
   */
  Task.prototype.Completed = function() {}

  /**
   * Function for sub-classes
   */
  Task.prototype.Stopped = function() {}

  Task.prototype._checkComplete = function()
  {
    if (this._stop != null && this._tasksCompletedAt == null)
    {
      if (this._activeTaskCount == 0)
      {
        this._tasksCompletedAt = (new Date()).getTime();

        var activeTask = Task.getActiveTask();
        if (activeTask != this)
        {
          Assert.assert(false,
            "Task that was not the active one was completed. Completed task: " +
            this.getIdentifier() + ". Active task: " + activeTask.getIdentifier());
        }

        Task._activeTasks.pop();

        // Notify the sub-class
        this.Completed();

        if (this._parent != null)
        {
          // Notify the parent
          this._parent._childTaskComplete(this);
        }
      }
    }
  };

  Task.prototype._childTaskComplete = function(task)
  {
    --this._activeTaskCount;
    this._checkComplete();
  };

  // Since Task has static methods, ensure that it is initialized before the first instance has
  // been created
  adf.mf.api.AdfObject.ensureClassInitialization(Task);

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Operation object

  /**
   * Function representing an operation to track performance. All method calls during the operation
   * are tracked as part of the operation.
   */
  function Operation(name, description, level)
  {
    this.Init(name, description, level);
  }

  adf.mf.api.AdfObject.createSubclass(Operation, Task, "Operation");

  Operation.InitClass = function()
  {
    this._activeOperation = null;
    this._completedOperations = [];
  };

  Operation.prototype.Init = function(name, description, level)
  {
    Operation.superclass.Init.call(this, name);
    this.setDescription(description);
    this.setLevel(level);
  };

  // Static members

  /**
   * Checks if there is a top level operation currently running
   * @return {boolean} true if there is an active operation
   */
  Operation.isOperationActive = function()
  {
    return Operation._activeOperation != null;
  };

  /**
   * Start the operation. Tracks the start time and either sets the operation as the top active
   * operation or adds it as a child to the last operation started.
   */
  Operation.prototype.start = function()
  {
    Operation.superclass.start.call(this);

    if (this.getParent() == null)
    {
      Operation._activeOperation = this;
    }
  };

  /**
   * Called when an operation is done. For the top level operation this will start the process
   * of sending the data to the embedded side for logging as a monitor observation.
   */
  Operation.prototype.Stopped = function()
  {
    if (Operation._activeOperation == this && this.getActiveTaskCount() > 0)
    {
      // This is the top level operation, but tasks are still active.
      // Wait up to 10 seconds for any active calls to complete
      if (this._waitingOnCompletionTimeout == null)
      {
        this._waitingOnTaskCompletion = window.setTimeout(
          this._activeTaskTimeout.bind(this), 10000);
      }
    }
  };

  Operation.prototype.Completed = function()
  {
    if (Operation._activeOperation == this)
    {
      Operation._activeOperation = null;
    }

    if (this.getParent() == null)
    {
      this._sendToEmbedded();
    }
  };

  /**
   * Called from the timeout set in the stop method if not all the children calls and operations
   * were complete at the time. If this method is called, the code will stop waiting for those to
   * complete, assuming them to be broken in some way.
   */
  Operation.prototype._activeTaskTimeout = function()
  {
    delete this._waitingOnTaskCompletion;

    if (this.getTasksCompletedAt() == null)
    {
      this.forceComplete();
    }
  };

  /**
   * Appends the monitor observations for this operation to the passed in array.
   * @param {Array.<Object>} monitorObservations the array to append to
   */
  Operation.prototype._appendMonitorObservations = function(monitorObservations)
  {
    this.visit(
      function (task)
      {
        var id = task.getMonitorId();
        var taskData =
        {
          "id": id,
          //
          // Stop time does not need to be sent, it can be calculated based on duration
          //
          "duration": task.getTotalElapsed(),
          "start": task.getStart(),
          "level" : task.getLevel().toString()
        };
        
        //
        // Description is optional. For common tasks, it is defined in MonitorFactory on the Embedded side
        //
        var description = task.getDescription();
        if (description)
        {
          taskData["description"] = description;
        }
        var instanceName = task.getInstanceName();
        if (instanceName)
        {
          taskData["instanceName"] = instanceName;
        }

        monitorObservations.push(taskData);
        return Task.VisitResult["ACCEPT"];
      });
  };

  /**
   * Sends the information to the embedded side to be logged as a monitor observation
   */
  Operation.prototype._sendToEmbedded = function()
  {
    this._active = null;

    // See if there is an active operation. If so, delay the sending of the data until no
    // operations are currently running. This allows the code to try to find a time that the UI is
    // not busy to send the data, reducing the hit on performance
    if (Operation._activeOperation != null)
    {
      Operation._completedOperations.push(this);

      if (perfMonReportedLogger.isLoggable(FINEST))
      {
        perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf.Operation", "_sendToEmbedded",
          "Another operation is currently running, waiting to send the data to the embedded side " +
          "until that operation completes");
      }

      return;
    }

    var numCompletedOperations = Operation._completedOperations.length;
    var monitorObservations = [];

    // If there are any operations that were delayed send their observations as well
    if (numCompletedOperations > 0)
    {
      for (var i = 0; i < numCompletedOperations; ++i)
      {
        var op = Operation._completedOperations[i];
        op._appendMonitorObservations(monitorObservations);
      }
      Operation._completedOperations = [];
    }

    this._appendMonitorObservations(monitorObservations);
    
    // If this send is a result of story ending, let Embedded side know
    if (this._storyEnding != null)
    {
      monitorObservations.push({"story" : this._storyEnding});
    }
    adf.mf.api.invokeMethod(
      "oracle.adfmf.framework.api.Model",
      "addMonitorObservations",
      monitorObservations, noop, noop);
  };

  // Since Operation has static methods, ensure that it is initialized before the first instance has
  // been created
  adf.mf.api.AdfObject.ensureClassInitialization(Operation);

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // Call object

  /**
   * Call object. Used for tracking start and stop calls on code functions.
   * @param {String} name the name of the call being made. Typically the fully qualified path
   *        to the function being executed
   */
  function Call(name, description, level)
  {
    this.Init(name);
    this.setDescription(description);
    this.setLevel(level);
  }

  adf.mf.api.AdfObject.createSubclass(Call, Task, "Call");

  Call.prototype.toString = function()
  {
    return this.getIdentifier();
  };

  // ============================================================================================
  // API methods

  /**
   * Notifies the framework of the start of an operation. An operation is a long running process to
   * be tracked for performance. Calls during the operation may be tracked to determine the
   * breakdown of the time spent in an operation. Operations may be nested but should only be used
   * to track major events (load page, navigation, handle data change event, etc.).
   *
   * @param {string} name the name of the operation
   * @param {Object} logging level for this operation
   * @param {string} description a description of the operation
   * @param {string} an optional instance name for this operation. For example, page name.
   * @return {{stop: function()}} an object with a stop function that must be called when the
   *         operation has completed
   */
  adf.mf.internal.perf.startMonitorOperation = function(name, level, description, instanceName)
  {
    //
    // Only start Operation if the captured logging level allows it
    //
    if (perfMonCapturedLogger.isLoggable(level))
    {
      try
      {
        var op = new Operation(name, description, level);
        if (instanceName != undefined)
        {
          op.setInstanceName(instanceName);
        }
        op.start();
        return op;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code to prevent issues loading the page
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "startMonitorOperation", "Exception thrown " +
            e.message);
        }
      }
    }
    return noopTask;
  }

  /**
   * Notifies the framework of a method call to be tracked as part of the time breakdown of an
   * operation. This should be used for methods that contribute to the overhead of an operation
   * and should therefore be tracked to determine performance changes.
   *
   * @param {string} name the name of the method
   * @param {Object} an optional logging level for this operation
   * @param {string} an optional description a description of the call
   * @param {string} an optional instance name forf this call. For example, component id.
   * @return {{stop: function()}} an object with a stop function that must be called when the
   *         call has completed. The stop function may be called asynchronously.
   */
  adf.mf.internal.perf.startMonitorCall = function(name, level, description, instanceName)
  {
    //
    // Only start Calls if the captured logging level allows it and Operation is active
    //
    if (Operation.isOperationActive() && perfMonCapturedLogger.isLoggable(level))
    {
      try
      {
        var call = new Call(name, description, level);
        if (instanceName != undefined)
        {
          call.setInstanceName(instanceName);
        }
        call.start();
        return call;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code to prevent issues loading the page
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "startMonitorCall", "Exception thrown " + e.message);
        }
        return noopTask;
      }
    }
    else
    {
      return noopTask;
    }
    return noopTask;
  };
  
  adf.mf.internal.perf.startOperation = function(name, description)
  {
    if (perfMonReportedLogger.isLoggable(FINE))
    {
      perfMonReportedLogger.logp(FINE, "adf.mf.internal.perf", "startOperation",
        "Use adf.mf.internal.perf.startMonitorOperation instead.");
    }
    return noopTask;
  }
  
  adf.mf.internal.perf.start = function(name)
  {
    if (perfMonReportedLogger.isLoggable(FINE))
    {
      perfMonReportedLogger.logp(FINE, "adf.mf.internal.perf", "start",
        "Use adf.mf.internal.perf.startMonitorCall instead.");
    }
    return noopTask;
  };
  
  
  /**
   * Forces all active Operations to stop.
   * @param {string} name the story that is ending
   * @return {bool} true if Operations were forced to stop
   */
  adf.mf.internal.perf.forceComplete = function(story)
  {
    if (Operation.isOperationActive())
    {
      try
      {
        Operation._activeOperation._storyEnding = story;
        Operation._activeOperation.forceComplete();
        return true;
      }
      catch (e)
      {
        // Eat any exceptions in the performance code
        if (perfMonReportedLogger.isLoggable(FINEST))
        {
          perfMonReportedLogger.logp(FINEST, "adf.mf.internal.perf", "forceComplete", "Exception thrown " + e.message);
        }
      }
    }
    return false;
  }

  /**
   * ADFc is still using this function, disable it instead of removing it so that the calling code
   * will not fail.
   * @deprecated Use adf.mf.internal.perf.start for method calls and
   *             adf.mf.internal.perf.startOperation for major operations (page loading, page
   *             navigation, etc.)
   */
  adf.mf.internal.perf.perfTimings = noop;
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfPerfTiming.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELParser.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- ELParser.js ---------------------- */
// @requires ELErrors
// @requires JavaScriptContext


var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.el.parser.cache  = adf.mf.internal.el.parser.cache  || {};
adf.mf.internal.el.parser.ops    = adf.mf.internal.el.parser.ops    || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

/**
 * Literals:
 *    Boolean: true and false
 *    Integer: as in Java
 *    Floating point: as in Java
 *    String: with single and double quotes; " is escaped as \", ' is escaped as \', and \ is escaped as \\.
 *    Null: null
 *
 * Operators:
 *    In addition to the . and [] operators discussed in Variables, there is the additional operators:
 *       Arithmetic: +, - (binary), *, / and div, % and mod, - (unary)
 *       Logical: and, &&, or, ||, not, !
 *       Relational: ==, eq, !=, ne, <, lt, >, gt, <=, ge, >=, le.
 *                  Comparisons can be made against other values, or against boolean,
 *                  string, integer, or floating point literals.
 *       Empty: The empty operator is a prefix operation that can be used to determine whether a value is null or empty.
 *       Conditional: A ? B : C. Evaluate B or C, depending on the result of the evaluation of A.
 *
 *   The precedence of operators highest to lowest, left to right is as follows:
 *      1. [] .
 *      2. () - Used to change the precedence of operators.
 *      3. - (unary) not ! empty
 *      4. * / div % mod
 *      5. + - (binary)
 *      6. < > <= >= lt gt le ge
 *      7. == != eq ne
 *      8. && and
 *      9. || or
 *     10. ? :
 *
 *  Reserved Words:
 *  The following words are reserved for the JSP expression language and should not be used as identifiers.
 *      and   eq   gt   true   instanceof
 *      or    ne   le   false  empty
 *      not   lt   ge   null   div   mod
 *  Note that many of these words are not in the language now, but they may be in the future,
 *  so you should avoid using them.
 *
 *  Examples:
 *  Here are some example EL expressions and the result of evaluating them.
 *
 *  EL Expression            Result
 *  ----------------------------------  --------------------------------------------------------------------
 *  ${1 > (4/2)}            false
 *  ${4.0 >= 3}              true
 *  ${100.0 == 100}            true
 *  ${(10*10) ne 100}          false
 *  ${'a' < 'b'}            true
 *  ${'hip' gt 'hit'}          false
 *  ${4 > 3}              true
 *  ${1.2E4 + 1.4}            12001.4
 *  ${3 div 4}              0.75
 *  ${10 mod 4}              2
 *  ${empty param.Add}          True if the request parameter named Add is null or an empty string
 *  ${pageContext.request.contextPath}  The context path
 *  ${sessionScope.cart.numberOfItems}  The value of the numberOfItems property of the session-scoped attribute
 *                    named cart
 *  ${param['mycom.productId']}      The value of the request parameter named mycom.productId
 *  ${header["host"]}          The host
 *  ${departments[deptName]}      The value of the entry named deptName in the departments map
 *
 *
 *  How to use the ELParser and ELExpression objects:
 *  - If you want to parse and evaluate an expression for a one time evaluation (i.e. will not be cached)
 *    do the following:
 *      adf.mf.internal.el.parser.evaluate(expression, context);
 *    i.e.
 *      adf.mf.internal.el.parser.evaluate("Hello", context);
 *      adf.mf.internal.el.parser.evaluate("${1.23E3}", context);
 *      adf.mf.internal.el.parser.evaluate("${applicationScope.loginRequired}", context);
 *      adf.mf.internal.el.parser.evaluate("${applicationScope.variableA < applicationScope.variableB}", context);
 *
 *  - If you want to parse an expression and use it over and over or simply let the "system" cached the expression
 *    for you, do the following:
 *      var expr      = adf.mf.internal.el.parser.parse(expression);
 *      ...
 *      var value     = expr.evaluate(context);  // can be called multiple times
 *
 *    i.e.
 *      var expr = adf.mf.internal.el.parser.evaluate("Hello");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate("${1.23E3}");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate(context, "${applicationScope.loginRequired}");
 *      expr.evaluate(context);  // can be called multiple times
 *
 *      var expr = adf.mf.internal.el.parser.evaluate(context, "${applicationScope.variableA < applicationScope.variableB}");
 *      expr.evaluate(context);  // can be called multiple times
 */
(function()
{
  adf.mf.internal.el.parser.ops =  {};

  var isStr = function(s) { return typeof(s) === 'string' || s instanceof String; };
  adf.mf.internal.el.parser.ops.isStr = isStr;

  adf.mf.internal.el.parser.ops.concat = function(a, b) { return "" + a + b; };

  // standard EL binary operations implementations
  //function add(a, b) { return (isStr(a) || isStr(b))? ("" + a + b) : (a + b); }
  adf.mf.internal.el.parser.ops.add = function(a, b)
  {
    // EL should not allow adding strings together, but this code re-writes EL like "#{null}#{null}"
    // to #{null + null}. In order to prevent a radical change at this point, support string
    // concatination despite being against the EL specification.
    if (a === null && b === null)
    {
      // JavaEL will use a blank string for nulls being concatinated
      return "";
    }
    else if (a === null && isStr(b))
    {
      return b;
    }
    else if (isStr(a) && b === null)
    {
      return a;
    }

    return a + b;
  };

  adf.mf.internal.el.parser.ops.subtract = function(a, b)           { return a - b;                        };
  adf.mf.internal.el.parser.ops.multiply = function(a, b)           { return a * b;                        };
  adf.mf.internal.el.parser.ops.divide = function(a, b)             { return a / b;                        };
  adf.mf.internal.el.parser.ops.modulo = function(a, b)             { return a % b;                        };
  adf.mf.internal.el.parser.ops.index = function(a, b)              { return a[b];                         };

  // standard EL unary operation implementations
  adf.mf.internal.el.parser.ops.negate = function(a)                { return -a;                           };
  adf.mf.internal.el.parser.ops.empty = function(a)
  {
    return ((a === null) || (a === '') || (a == []) ||
      (a === adf.mf.api.OptionalFragmentArgument));
  };

  adf.mf.internal.el.parser.ops.not = function(a)                   { return !adf.mf.internal.el.parser.ops.coerce(a);                   };

  // standard EL logical operations implementations
  adf.mf.internal.el.parser.ops.greaterThanOrEqual = function(a, b) { return a >= b;                       };
  adf.mf.internal.el.parser.ops.greaterThan = function(a, b)        { return a > b;                        };
  adf.mf.internal.el.parser.ops.lessThanOrEqual = function(a, b)    { return a <= b;                       };
  adf.mf.internal.el.parser.ops.lessThan = function(a, b)           { return a < b;                        };
  adf.mf.internal.el.parser.ops.equals = function(a, b)             { return adf.mf.internal.el.parser.ops.coerce(a) == adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.notEqual = function(a, b)           { return adf.mf.internal.el.parser.ops.coerce(a) != adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.or = function(a, b)                 { return adf.mf.internal.el.parser.ops.coerce(a) || adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.and = function(a, b)                { return adf.mf.internal.el.parser.ops.coerce(a) && adf.mf.internal.el.parser.ops.coerce(b);       };
  adf.mf.internal.el.parser.ops.ternary = function(a,b,c)           { return (adf.mf.internal.el.parser.ops.coerce(a))? b : c;           };

  // coerce the value to a boolean if so be it
  adf.mf.internal.el.parser.ops.coerce = function(a)                { return (a == "true") ? true : (a == "false") ? false : a; };

  // standard EL function implementations
  adf.mf.internal.el.parser.ops.unknown = function()                {                                      };
  adf.mf.internal.el.parser.ops.block = function()     {};

  adf.mf.internal.el.parser.ops.append = function(a, b)
  {
        if (Object.prototype.toString.call(a) != "[object Array]")
        {
          return [a, b];
        }
        a = a.slice();
        a.push(b);
        return a;
      };

      /*
       *  The precedence of operators highest to lowest, left to right is as follows:
       *      1. [] .
       *      2. () - Used to change the precedence of operators.
       *      3. - (unary) not ! empty
       *      4. * / div % mod
       *      5. + - (binary)
       *      6. < > <= >= lt gt le ge
       *      7. == != eq ne
       *      8. && and
       *      9. || or
       *     10. ? :
       */
  adf.mf.internal.el.parser.ops.unaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        "-"     : ["-",     adf.mf.internal.el.parser.ops.negate,          +1, +2, 3, false],
        "!"     : ["!",     adf.mf.internal.el.parser.ops.not,             +1, +2, 3, false],
        "not"   : ["not",   adf.mf.internal.el.parser.ops.not,             +3, +2, 3, true ],
        "empty" : ["empty", adf.mf.internal.el.parser.ops.empty,           +5, +2, 3, true ]
      };

  adf.mf.internal.el.parser.ops.binaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        // ",": [",",   adf.mf.internal.el.parser.ops.append,              +1, -1, -1, false], ---> not really a binary operator
        "#"   : ["#",   adf.mf.internal.el.parser.ops.concat,              +1, +2,  5, false],
        "+"   : ["+",   adf.mf.internal.el.parser.ops.add,                 +1, +2,  5, false],
        "-"   : ["-",   adf.mf.internal.el.parser.ops.subtract,            +1, +2,  5, false],
        "*"   : ["*",   adf.mf.internal.el.parser.ops.multiply,            +1, +1,  4, false],
        "/"   : ["/",   adf.mf.internal.el.parser.ops.divide,              +1, +1,  4, false],
        "div" : ["div", adf.mf.internal.el.parser.ops.divide,              +3, +2,  4, true ],
        "%"   : ["%",   adf.mf.internal.el.parser.ops.modulo,              +1, +2,  4, false],
        "mod" : ["mod", adf.mf.internal.el.parser.ops.modulo,              +3, +2,  4, true ],
        "and" : ["and", adf.mf.internal.el.parser.ops.and,                 +3, +2,  8, true ],
        "&&"  : ["&&",  adf.mf.internal.el.parser.ops.and,                 +2, +2,  8, false],
        "or"  : ["or",  adf.mf.internal.el.parser.ops.or,                  +2, +2,  9, true ],
        "||"  : ["||",  adf.mf.internal.el.parser.ops.or,                  +2, +2,  9, false],
        "<="  : ["<=",  adf.mf.internal.el.parser.ops.lessThanOrEqual,     +2, +2,  6, false],
        "le"  : ["le",  adf.mf.internal.el.parser.ops.lessThanOrEqual,     +2, +2,  6, true ],
        "<"   : ["<",   adf.mf.internal.el.parser.ops.lessThan,            +1, +1,  6, false],
        "lt"  : ["lt",  adf.mf.internal.el.parser.ops.lessThan,            +2, +1,  6, true ],
        ">="  : [">=",  adf.mf.internal.el.parser.ops.greaterThanOrEqual,  +2, +2,  6, false],
        "ge"  : ["ge",  adf.mf.internal.el.parser.ops.greaterThanOrEqual,  +2, +2,  6, true ],
        ">"   : [">",   adf.mf.internal.el.parser.ops.greaterThan,         +1, +2,  6, false],
        "gt"  : ["gt",  adf.mf.internal.el.parser.ops.greaterThan,         +2, +2,  6, true ],
        "=="  : ["==",  adf.mf.internal.el.parser.ops.equals,              +2, +2,  7, false],
        "eq"  : ["eq",  adf.mf.internal.el.parser.ops.equals,              +2, +2,  7, true ],
        "!="  : ["!=",  adf.mf.internal.el.parser.ops.notEqual,            +2, +2,  7, false],
        "ne"  : ["ne",  adf.mf.internal.el.parser.ops.notEqual,            +2, +2,  7, true ]
      };

  adf.mf.internal.el.parser.ops.ternaryOperations =
  {
        /* token : [ token, function_to_perform, increment_position_by, prior_token, precedence, requires_word_boundary ]*/
        "?"   : ["?",   adf.mf.internal.el.parser.ops.ternary,             +1, +2,  11, false]
      };

  adf.mf.internal.el.parser.ops.constants =
  {
        "true"  : true,
        "false" : false,
        "null"  : null
      };

  adf.mf.internal.el.parser.ops.functions =
  {
        "abs"             : Math.abs,
        "sign"            : adf.mf.internal.el.parser.ops.unknown,
        "pow"             : Math.pow,
        "exp"             : Math.exp,
        "ln"              : adf.mf.internal.el.parser.ops.unknown,
        "round"           : Math.round,
        "truncate"        : Math.floor,
        "len"             : adf.mf.internal.el.parser.ops.unknown,
        "strstr"          : adf.mf.internal.el.parser.ops.unknown,
        "leftstr"         : adf.mf.internal.el.parser.ops.unknown,
        "rightstr"        : adf.mf.internal.el.parser.ops.unknown,
        "substr"          : String.substr,
        "lower"           : String.toLowerCase,
        "upper"           : String.toUpperCase,
        "date"            : adf.mf.internal.el.parser.ops.unknown,
        "now"             : adf.mf.internal.el.parser.ops.unknown,
        "lookup"          : adf.mf.internal.el.parser.ops.unknown
      };

  var PRIMARY  = 1 <<  0;
  var OPERATOR = 1 <<  1;
  var FUNCTION = 1 <<  2;
  var LPAREN   = 1 <<  3;
  var RPAREN   = 1 <<  4;
  var COMMA    = 1 <<  5;
  var SIGN     = 1 <<  6;
  var CALL     = 1 <<  7;
  var OPENEXP  = 1 <<  8;
  var CLOSEEXP = 1 <<  9;
  var UNIOP    = 1 << 10;
  var HOOK     = 1 << 11;
  var COLON    = 1 << 12;
  var LBRACE   = 1 << 13;
  var NO_ARGS  = 1 << 14;

  /* types of tokens that will be encountered */
  var TOKEN_CONSTANT         =  0;
  var TOKEN_UNARY_OPERATOR   =  1;
  var TOKEN_BINARY_OPERATOR  =  2;
  var TOKEN_TERNARY_OPERATOR =  3;
  var TOKEN_VARIABLE         =  4;
  var TOKEN_FUNCTION         =  5;
  var TOKEN_INDEX            =  6;
  var TOKEN_DOT_OFFSET       =  7;
  var TOKEN_PROPERTY         =  8;
  var TOKEN_COLON            =  9;
  var TOKEN_COMMA            = 10;
  var TOKEN_NO_ARGS          = 11;


  function Token(type, index, prior, value)
  {
    this.type  = type;
    this.index = index || 0;
    this.prior = prior || 3;
    this.value = (value !== undefined) ? value : null;

    this.toString = function ()
    {
      switch (this.type)
      {
        case TOKEN_CONSTANT:         return escape(this.value);
        case TOKEN_UNARY_OPERATOR:   /* or */
        case TOKEN_BINARY_OPERATOR:  /* or */
        case TOKEN_TERNARY_OPERATOR: /* or */
        case TOKEN_NO_ARGS:          /* or */
        case TOKEN_INDEX:            /* or */
        case TOKEN_COLON:            /* or */
        case TOKEN_COMMA:            /* or */
        case TOKEN_DOT_OFFSET:       /* or */
        case TOKEN_VARIABLE:         return this.index;
        case TOKEN_FUNCTION:         return "INVOKE";
        default:                     return "Invalid Token";
      }
    };
  }

  // table used by table driven parser
  var parserRules = {};
  // default rule (function)
  var otherRule;

  /**
   * Adds several new rules to 'parserRules' table.
   *
   * @param {Object.<string, Object>} rules This is table of new rules like {"+": [...], "true": true}.
   *   This format is compatible with "adf.mf.internal.el.parser.ops.xxx" definition
   *   tables.
   * @param {function} f Function that will be called when some of registerred rules
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' is 'value'
   *   object from rules map.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function addParserRules(rules, f, caseInsensitive)
  {
    for (var k in rules)
    {
      addParserRule(k, f, rules [k], caseInsensitive);
    }
  }

  /**
   * Adds one rule to 'parserRules' table.
   *
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function addParserRule(text, f, param, caseInsensitive)
  {
    _addParserRulesForCharacter(0, text, parserRules, f, param, caseInsensitive);
  }

  /**
   * This method adds rules for one character from the given text. This method
   * is private.
   *
   * @private
   * @param {number} index Index to the text string. It points to the
   *   current character.
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {Object.<string, Object>} m Points to the current node in
   *   parserRules table.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   */
  function _addParserRulesForCharacter(index, text, m, f, param, caseInsensitive)
  {
    var ch = text.charAt(index);
    var last = index + 1 == text.length;
    if (caseInsensitive)
    {
      ch = ch.toLowerCase();
      _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last);
      var ch2 = ch.toUpperCase();
      if (ch !== ch2)
        _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch2, last);
    } else
      _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last);
  }

  /**
   * This method adds one rule for one character from the given text. This method
   * is private.
   *
   * @private
   * @param {number} index Index to the text string. It points to the
   *   current character.
   * @param {string} text Text specifies content of recognized token, like '==',
   *   'true' or '+'.
   * @param {Object.<string, Object>} m Points to the current node in
   *   parserRules table.
   * @param {function} f Function that will be called when registerred rule
   *   is recognized. This function will be called with two parameters. 'index'
   *   which is index to the ELParser.expression. Second parameter 'param' contains
   *   value of 'param'.
   * @param {Object} param Value that will be send to function 'f'.
   * @param {boolean} caseInsensitive Used for case insensitive tokens, like 'true'
   *   in EL Expression language.
   * @param {string} ch Character that should be added.
   * @param {boolean} last This parameter should be true for last character from
   *   text string.
   */
  function _addParserRuleForCharacter(index, text, m, f, param, caseInsensitive, ch, last)
  {
    var nm = m [ch];
    if (!nm)
    {
      nm = [{}];
      m [ch] = nm;
    }
    if (last)
    {
      nm [nm.length] = f;
      nm [nm.length] = param;
    } else
      _addParserRulesForCharacter(index + 1, text, nm [0], f, param, caseInsensitive);
  }

  /**
   * This function parses one token from ELParser.expression according to rules
   * stored in 'parserRules', and calls one of registerred callback method.
   *
   * @param {Object} elParser Instance of ELParser.
   * @returns {boolean} True, if some token was recognized.
   */
  function parseToken(elParser)
  {
    if (_parseTokenCharacter(elParser, elParser.pos, parserRules)) return true;
    if (otherRule) return otherRule.call(elParser, elParser.pos);
    return false;
  }

  /**
   * This function parses one character from the current token according to rules
   * stored in 'parserRules', and calls one of registerred callback method.
   *
   * @param {Object} elParser Instance of ELParser.
   * @param {number} index Index to elParser.expression.
   * @param {Object.<string, Object>} map Points to the current node in
   *   parserRules table.
   * @returns {boolean} True, if some token was recognized.
   */
  function _parseTokenCharacter(elParser, index, map)
  {
    var ch = elParser.expression.charAt(index);
    var r = map [ch];
    if (r)
    {
      if (_parseTokenCharacter(elParser, index + 1, r [0])) return true;
      for (var j = 1; j < r.length; j+=2)
      {
        if (r [j + 1] === 0 ? r [j].call(elParser, index + 1) : r [j].call(elParser, index + 1, r [j + 1]))
          return true;
      }
    }
    return false;
  }

  /*
   * Adds rule for parsing binary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.binaryOperations, function(index, param)
  {
    if (param[5] && !this.isOperatorBoundary(index))
      return false;

    this.finishTerm (this.pos);
    this.token = param[0];
    this.prior = param[4];
    this.pos   += param[2];
    if (this.isSign() && (this.expected & SIGN))
    {
      if (this.isNegativeSign())
      {
        this.token = adf.mf.internal.el.parser.ops.unaryOperations["-"][0];
        this.prior = adf.mf.internal.el.parser.ops.unaryOperations["-"][4];
        this.nooperands++;
        this.addfunc(TOKEN_UNARY_OPERATOR);
      }
      this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | CLOSEEXP);
    }
    else if (this.isComment())
    {
      /* do nothing */
    }
    else
    {
      if ((this.expected & OPERATOR) === 0)
      {
        var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_OPERATOR_FOUND");

        this.parsingError(this.pos, rmsg);
      }
      this.nooperands += 2;
      this.addfunc(TOKEN_BINARY_OPERATOR);
      this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
    }
    return true;
  });

  /*
   * Adds rule for parsing unary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.unaryOperations, function(index, param)
  {
    if (param[5] && !this.isOperatorBoundary(index))
      return false;
    this.token = param[0];
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & UNIOP) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_UNIARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_UNARY_OPERATOR);
    this.nooperands++;
    this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | CLOSEEXP);
    this.finishTerm (this.pos);
    this.pos  += param[0].length;
    return true;
  });

  /*
   * Adds rule for parsing '}'.
   */
  addParserRule("}", function()
  {
    while (this.operatorStack.length > 0)
    {
      this.tokenStack.push(this.operatorStack.pop());
    }
    this.finishTerm (this.pos);
    this.pos++;
    if ((this.expected & CLOSEEXP) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["}"]);

      this.parsingError(this.pos, rmsg);
    }
    if (this.expCount > 1)
    {
      this.token   = "+";   // should go to # if we should concat
      this.prior   = 30;    // 30 = 3 (for add) * 10 (to ensure it is always the last precedence)
      this.nooperands  += 2;
      this.addfunc(TOKEN_BINARY_OPERATOR);
    }
    this.text        = this.pos;
    this.expected    = (OPENEXP);
    return true;
  });

  /*
   * Adds rule for parsing ','.
   */
  addParserRule(",", function(index)
  {
    this.pos++;
    this.prior = -1;
    this.token = ",";
    if ((this.expected & COMMA) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [","]);

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_COMMA);
    this.nooperands    += 2;
    this.expected = (PRIMARY | LPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
    this.finishTerm (this.pos - 1);
    return true;
  });

  /*
   * Adds rule for parsing constant literals.
   */
  addParserRules(adf.mf.internal.el.parser.ops.constants, function(index, param)
  {
    // Verify that this is not part of a longer varible name that
    // just starts with a constant
    if (index < this.expression.length)
    {
      var nextChar = this.expression.charCodeAt(index);
      // Match a word character, [0-9A-Za-z_]
      if ((nextChar >= 48 /* 0 */ && nextChar <= 57 /* 9 */) ||
        (nextChar >= 65 /* A */ && nextChar <= 90 /* Z */) ||
        (nextChar >= 97 /* a */ && nextChar <= 122 /* z */) ||
        nextChar == 95 /* _ */)
        {
        // The string only begins with a constant, it is not a constant
        return false;
      }
    }
    this.value = param;
    this.pos  = index;

    if ((this.expected & PRIMARY) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_CONSTANT_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    var constant = new Token(TOKEN_CONSTANT, 0, 0, this.value);
    this.tokenStack.push(constant);
    this.expected = (OPERATOR | HOOK | LPAREN | RPAREN | COLON | COMMA | CLOSEEXP);
    return true;
  }, true);

  /*
   * Adds rule for parsing '#'.
   */
  addParserRule("#", function(index)
  {
    this.directive = this.pos;
    this.pos = index;
    return true;
  });

  /*
   * Adds rule for parsing '$'.
   */
  addParserRule("$", function(index)
  {
    this.directive = this.pos;
    this.finishTerm (this.pos);
    this.pos = index;
    return true;
  });

  /*
   * Adds rule for parsing '['.
   */
  addParserRule("[", function(index)
  {
    this.pos++;

    if ((this.expected & LBRACE) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["["]);

      this.parsingError(this.pos, rmsg);
    }
    else
    {
      this.nooperands  +=  2;
      this.prior   =  1;
      this.token   = '[';

      this.addfunc(TOKEN_INDEX);
      this.pmatch += 100;
    }

    this.expected = (PRIMARY | LPAREN | FUNCTION | UNIOP | SIGN);
    return true;
  });

  /*
   * Adds rule for parsing '('.
   */
  addParserRule("(", function(index)
  {
    this.pos++;
    this.pmatch += 100;

    if ((this.expected & LPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["("]);

      this.parsingError(this.pos, rmsg);
    }

    if (this.expected & CALL)
    {
      this.nooperands +=  2;
      this.prior  =  11;
      this.token  = '(';
      this.addfunc(TOKEN_FUNCTION);
      this.expected = (PRIMARY | LPAREN | RPAREN | FUNCTION | UNIOP | NO_ARGS | SIGN);
    }
    else
    {
      this.expected = (PRIMARY | LPAREN | RPAREN | UNIOP | SIGN);
    }
    return true;
  });

  /*
   * Adds rule for parsing numeric literals.
   */
  addParserRules({"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"+":0,"-":0,".":0},
  function(index)
  {
    var result   = false;
    var i        = this.pos;

    var exponent = false;
    var dot = false;
    var digit = false;

    while (i < this.expression.length)
    {
      var c = this.expression.charAt(i);
      if (c == '.')
      {
        if (dot || exponent)
        {
          result = false;
          break;
        }

        dot = true;
      }
      else if (c == '+' || c == '-')
      {
        if (i == this.pos) break;
        var previousChar = this.expression.charAt (i - 1);
        if (previousChar != 'e' && previousChar != 'E') break;
      }
      else if (c == 'e' || c == 'E')
      {
        if (!digit)
        {
          // A number must have a digit before the e or E (.e1 is not valid)
          result = false;
          break;
        }
        exponent = true;
      }
      else if (c >= '0' && c <= '9')
      {
        digit = true;
        result = true;
      }
      else
      {
        if ((c.toLowerCase() !== c.toUpperCase()) || (c === '_'))
          result = false;
        break;
      }
      i++;
    }

    if (result)
    {
      var str = this.expression.substr(this.pos, i - this.pos);
      this.value = parseFloat(str);
      if ((this.expected & PRIMARY) === 0)
      {
        var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_NUMBER_CONSTANT_FOUND");

        this.parsingError(this.pos, rmsg);
      }
      token = new Token(TOKEN_CONSTANT, 0, 0, this.value);
      this.tokenStack.push(token);

      this.expected = (OPERATOR | HOOK | RPAREN | COLON | COMMA | CLOSEEXP);
      this.pos = i;
    }

    return result;
  });

  /*
   * Adds rule for parsing binary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.binaryOperations, function(index, param)
  {
    // This code doesn't seem to be used, instead the block at line 450 is used.
    // Can this be removed?
    if (param[5] && !this.isOperatorBoundary(index))
      return false;
    this.token = this.expression.substr(this.pos, index - this.pos);
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & FUNCTION) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_BINARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_BINARY_OPERATOR);
    this.nooperands += 2;
    this.expected    = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos);
    this.pos   = index;
    return true;
  });

  /*
   * Adds rule for parsing ternary operators.
   */
  addParserRules(adf.mf.internal.el.parser.ops.ternaryOperations, function(index, param)
  {
    this.token = this.expression.substr(this.pos, index - this.pos);
    this.prior = param[4];  /* adding precedence support */
    if ((this.expected & HOOK) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_TERNARY_OP_FOUND");

      this.parsingError(this.pos, rmsg);
    }
    this.addfunc(TOKEN_TERNARY_OPERATOR);
    this.nooperands  += 2;
    this.expected     = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos);
    this.pos   = index;
    return true;
  });

  /*
   * Adds rule for parsing ')'.
   */
  addParserRule(")", function()
  {
    this.finishTerm (this.pos);
    this.pos++;
    this.pmatch -= 100;
    if ((this.expected & RPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [")"]);

      this.parsingError(this.pos, rmsg);
    }

    if ((this.expected & NO_ARGS) === NO_ARGS)
    {
      var vartoken = new Token(TOKEN_NO_ARGS, this.token, 0, 0);
      this.tokenStack.push(vartoken);
    }

    this.expected = (OPERATOR | HOOK | RPAREN | COMMA | LBRACE | LPAREN | COLON | CALL | CLOSEEXP);
    return true;
  });

  /*
   * Adds rule for parsing ']'.
   */
  addParserRule("]", function()
  {
    this.finishTerm (this.pos);
    this.pos++;
    this.pmatch -= 100;
    if ((this.expected & RPAREN) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", ["]"]);

      this.parsingError(this.pos, rmsg);
    }

    // Move the operation from the operation stack to the token stack
    if (this.operatorStack.length > 0 &&
      this.operatorStack[this.operatorStack.length - 1].type == TOKEN_INDEX)
    {
      this.tokenStack.push(this.operatorStack.pop());
    }

    this.expected = (OPERATOR | HOOK | LBRACE | RPAREN | CLOSEEXP | COLON);
    return true;
  });

  /*
   * Adds rule for parsing ':'.
   */
  addParserRule(":", function()
  {
    this.pos++;
    this.prior = 10;
    this.token = ":";
    if ((this.expected & COLON) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [":"]);

      this.parsingError(this.pos, rmsg);
    }

    this.addfunc(TOKEN_COLON);
    this.nooperands  += 2;
    this.expected     = (PRIMARY | LPAREN | UNIOP | SIGN);
    this.finishTerm (this.pos - 1);
    return true;
  });

  /*
   * Adds rule for parsing '.'.
   */
  addParserRule(".", function()
  {
    this.nooperands  +=  2;
    this.prior   = 1;
    this.token = '.';
    this.addfunc(TOKEN_DOT_OFFSET);
    this.pos++;
    this.expected = (PRIMARY);
    return true;
  });

  /**
   * This call adds rules for parsing identifiers to parserRules, and
   * registers callback function that is able to parse identifiers.
   *
   * @param {type} f Function that implements parsing identifiers.
   */
  function addIdentifierParserRule(f)
  {
    for (var ch in parserRules)
    {
      if ((ch.toLowerCase() !== ch.toUpperCase()) || (ch === '_'))
      {
        var nm = parserRules [ch];
        nm [nm.length] = f;
        nm [nm.length] = null;
        addIdentifierParserRuleForNode(nm [0], f);
      }
    }
    otherRule = f;
  }

  /**
   * This call adds rules for parsing identifiers to the concrete node of
   * parserRules table, and registers callback function that is able
   * to parse identifiers.
   *
   * @param {type} f Function that implements parsing identifiers.
   */
  function addIdentifierParserRuleForNode(m, f)
  {
    for (var ch in m)
    {
      if ((ch.toLowerCase() !== ch.toUpperCase()) || (ch === '_') ||
          ((ch >= '0') && (ch <= '9'))
      )
      {
        var nm = m [ch];
        nm [nm.length] = f;
        nm [nm.length] = null;
        addIdentifierParserRuleForNode(nm [0], f);
      }
    }
  }

  /*
   * Adds rule for parsing indentifiers.
   */
  addIdentifierParserRule(function(index)
  {
    var st = null;
    for (var i = index; i < this.expression.length; i++)
    {
      var ch = this.expression.charAt(i);
      if ((ch.toLowerCase() != ch.toUpperCase()) || (ch === '_'))
        continue;
      if ((this.pos < i) &&
          ((ch >= '0') && (ch <= '9'))
      )
        continue;
      break;
    } // for i
    if (this.pos === i) return false;
    if ((this.expected & PRIMARY) === 0)
    {
      var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_VARIABLE_FOUND");
      this.parsingError(this.pos, rmsg);
    }

    this.token = this.expression.substr(this.pos, i - this.pos);
    var vartoken = null;
    if (!this.currentTermStart [this.pmatch])
    {
      vartoken = new Token(TOKEN_VARIABLE, this.token, 0, 0);
      this.currentTermStart [this.pmatch] = this.pos;
      this.currentELTermStart [this.pmatch] = this.tokenStack.length;
    } else
      vartoken = new Token(TOKEN_PROPERTY, this.token, 0, 0);

    this.prior = 3;
    this.pos = i;
    this.tokenStack.push(vartoken);
    this.expected = (OPERATOR | HOOK | COLON | RPAREN | COMMA | LPAREN | LBRACE | CALL | CLOSEEXP);
    return true;
  });

  /*
   * Adds rule for parsing string literals.
   */
  addParserRules({"'":0,'"':0}, function(index)
  {
    var delim = this.expression.charAt(this.pos);
    var esc = false;
    for (var i = index; i < this.expression.length; i++)
    {
      var ch = this.expression.charAt(i);
      if (ch === '\\')
        esc = true;
      else
      {
        esc = false;
        if ((!esc) && ch === delim)
        {
          var str = this.expression.substr(this.pos + 1, i - this.pos - 1);
          this.value = this.unescape(str, this.pos);
          this.pos = i + 1;
          if ((this.expected & PRIMARY) === 0)
          {
            var  rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_UNEXPECTED_STRING_FOUND");

            this.parsingError(this.pos, rmsg);
          }
          var token = new Token(TOKEN_CONSTANT, 0, 0, this.value);
          this.tokenStack.push(token);

          this.expected = (OPERATOR | HOOK | COLON | RPAREN | COMMA | CLOSEEXP);
          return true;
        }
      }
    } // for i
    this.pos = i;
    return false;
  });

  /*
   * Adds rule for parsing whitespaces.
   */
  addParserRules({" ":0,'\n':0,'\r':0,'\t':0}, function(index)
  {
    this.pos++;
    return true;
  });

  adf.mf.internal.el.parser.cache.clear = function()
  {
    adf.mf.internal.el.parser.cache.map  = {};
    adf.mf.internal.el.parser.cache.hit  = 0;
    adf.mf.internal.el.parser.cache.miss = 0;
  };

  adf.mf.internal.el.parser.cache.count = function()
  {
    var count = 0;

    if (adf.mf.internal.el.parser.cache.map != null)
    {
      for (var key in adf.mf.internal.el.parser.cache.map)
      {
        ++count;
      }
    }
    return count;
  };

  adf.mf.internal.el.parser.cache.purge = function(expr)
  {
    if (adf.mf.internal.el.parser.cache.map == null)
    {
      return;
    }
    delete adf.mf.internal.el.parser.cache.map[expr];
  };

  adf.mf.internal.el.parser.cache.lookup = function(expr)
  {
    var pexp  = null;

    if (adf.mf.internal.el.parser.cache.map == null)
    {
      adf.mf.internal.el.parser.cache.map  = {};
      adf.mf.internal.el.parser.cache.hit  = 0;
      adf.mf.internal.el.parser.cache.miss = 0;
    }

    pexp = adf.mf.internal.el.parser.cache.map[expr];

    if ((pexp == undefined) || (pexp == null))
    {
      pexp = new ELParser().parse(expr);
      adf.mf.internal.el.parser.cache.map[expr] = pexp;
      ++adf.mf.internal.el.parser.cache.miss;
    }
    else
    {
      pexp.unflatten();
      ++adf.mf.internal.el.parser.cache.hit;
    }

    return pexp;
  };

  var ELParser = function ()
  {

    /**
     * This method calls parser given expression, and returns ELExpression.
     *
     * @param {string} expr
     * @returns {ELExpression}
     */
    adf.mf.internal.el.parser.parse = function (expr)
    {
      return adf.mf.internal.el.parser.cache.lookup(expr);
    };

    adf.mf.internal.el.parser.evaluate = function (context, expr)
    {
      var pexp  = adf.mf.internal.el.parser.cache.lookup(expr);
      return pexp.evaluate(context);
    };

    function ELExpression(tokens, expr, terms, elTerms)
    {
      this.tokens             = tokens;
      this.stringVersion      = null;
      this.readonly           = null;
      this._expr              = expr;
      this.elTerms            = elTerms;
    }

    adf.mf.internal.el.parser.ELParser = ELParser;
    adf.mf.internal.el.parser.ELExpression = ELExpression;

    /**
     * Expressions are also designed to be immutable so that only one instance needs to be created for
     * any given expression String / {@link FunctionMapper}. This allows a container to pre-create
     * expressions and not have to reparse them each time they are evaluated.
     */
    ELExpression.prototype =
    {
      ensureItIsNotTheNullObject: function(t)
      {
        return (t == null || t[".null"] === true) ? null : t;
      },

      evaluate: function (context)
      {
        var n1, n2, n3, fn, item;
        var nstack       = [];
        var tokenLength  = this.tokens.length;
        var val          = null;
        var ind          = null;
        var ignoreNull   = false;

        for (var i = 0; i < tokenLength; i++)
        {
          item = this.tokens[i];

          var type = item.type;
          switch (type)
          {
            case TOKEN_CONSTANT:
              nstack.push(item.value);
              break;

            case TOKEN_TERNARY_OPERATOR:
              n3 = this.ensureItIsNotTheNullObject(nstack.pop());
              n2 = this.ensureItIsNotTheNullObject(nstack.pop());
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.ternaryOperations[item.index])[1]; /* function to execute the operation */
              nstack.push(fn(n1, n2, n3));
              break;

            case TOKEN_BINARY_OPERATOR:
              n2 = this.ensureItIsNotTheNullObject(nstack.pop());
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.binaryOperations[item.index])[1]; /* function to execute the operation */
              nstack.push(fn(n1, n2));
              break;

            case TOKEN_DOT_OFFSET:
            case TOKEN_INDEX:
              var elResolver = context.getELResolver();

              n2 = nstack.pop();
              n1 = nstack.pop();

              try
              {
                var val = elResolver.getValue(context, n1, n2);

                nstack.push(val);

                if (type == TOKEN_INDEX)
                {
                  // Not sure why this is needed, but without this functionality,
                  // the control tests will hang on Android, going into an apparent
                  // infinite loop.
                  ignoreNull = true;
                }
              }
              catch (ex)
              {
                if (((typeof n1) !== 'object') && (n2 === "inputValue"))
                {
                  nstack.push(n1);
                }
                else
                {
                  if (type == TOKEN_INDEX || (ignoreNull && type == TOKEN_DOT_OFFSET))
                  {
                    // This is the old approach and preserving backwards compatibility. In Java,
                    // only a MapElResolver will not throw property not found exceptions. The issue
                    // is that in JavaScript, there is no knowledge of a java.util.Map. So, for now
                    // the indexed expression will work like a map evaluation, and the dot notation
                    // as a property lookup.
                    val = n1[n2];
                    nstack.push(val);

                    // Flag this expression as not having been resolved so that it can be added
                    // to the batch at the end (used by adf.mf.el.getLocalValue)
                    adf.mf.internal.el.indexedExpressionUnresolved = true;
                  }
                  else
                  {
                    throw new adf.mf.PropertyNotFoundException(this.getExpression());
                  }
                }
              }
              break;

            case TOKEN_COMMA:
            case TOKEN_COLON:
            case TOKEN_NO_ARGS:
              /* ignore */
              break;

            case TOKEN_PROPERTY:
              nstack.push(item.index);
              break;

            case TOKEN_VARIABLE:
              var elResolver = context.getELResolver();
              try
              {
                var value = elResolver.getValue(context, null, item.index);
                nstack.push(value);
                ignoreNull = false;
              }
              catch (ex)
              {
                throw new adf.mf.PropertyNotFoundException(this.getExpression());
              }
              break;

            case TOKEN_UNARY_OPERATOR:
              n1 = this.ensureItIsNotTheNullObject(nstack.pop());
              fn = (adf.mf.internal.el.parser.ops.unaryOperations[item.index])[1];
              nstack.push(fn(n1));
              break;

            case TOKEN_FUNCTION:
              n1 = nstack.pop();
              fn = nstack.pop();
              if (fn.apply && fn.call)
              {
                if (Object.prototype.toString.call(n1) == "[object Array]")
                {
                    n1.push(context);
                }
                else
                {
                  var x = this.ensureItIsNotTheNullObject(n1);

                  n1 = [x];
                  n1.push(context);
                }
                nstack.push(fn.apply(undefined, n1));
              }
              else
              {
                throw new adf.mf.ELException(fn + " is not a function");
              }
              break;
            default:
              throw new adf.mf.ELException("invalid ELExpression - " + type);
          }
        }
        if (nstack.length > 1)
        {
          throw new adf.mf.ELException("invalid ELExpression (mis-match tokens and operations)");
        }

        return nstack[0];
      },

      setValue: function (context, value)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "ValueExpression", "setValue",
            ("adfmf- setValue " + this.toString() + " = " + adf.mf.util.stringify(value)));
        }

        var tokens = this.tokens;
        var stack = [];
        var d = tokens.length;

        for (var i = 0; i < d; i++)
        {
          var token = tokens [i];
          switch (token.type)
          {
            case TOKEN_VARIABLE:
              // If the variable is the only token, use the EL resolver to set the value
              if (i == d - 1)
              {
                context.getELResolver().setValue(context, null, token.index, value);
                return;
              }

              var v = null;

              try
              {
                v = context.getELResolver().getValue(context, null, token.index);
              }
              catch (e)
              {
                // Use the .loaded to signify that the variable has not been loaded from the embedded side
                adf.mf.el.addVariable(token.index, v = { ".loaded": false });
              }

              stack.push(v);
              break;

            case TOKEN_PROPERTY:
              stack.push(token.index);
              break;

            case TOKEN_DOT_OFFSET:
            case TOKEN_INDEX:
              var n = stack.pop();
              var baseObject = stack.pop();
              var v = null;

              // If this is the last property of the object, use the EL resolver to
              // set the value
              if (i == d - 1)
              {
                context.getELResolver().setValue(context, baseObject, n, value);

                // Remove the .null if set
                if (baseObject != null)
                {
                  delete baseObject[".null"];
                }

                return;
              }

              try
              {
                v = context.getELResolver().getValue(context, baseObject, n);
              }
              catch (e)
              {
                // Set the base object to a new object, but mark it as not loaded so that we may be sure to generate
                // a cache miss if this object is requested and not a sub-property of the object from the
                // getLocalValue
                v = baseObject[n] = { ".loaded": false };

                // Remove the .null if set
                delete baseObject[".null"];
              }

              stack.push(v);
              break;

            case TOKEN_CONSTANT:
              stack.push(token.value);
              break;

            case TOKEN_TERNARY_OPERATOR:
              var n3 = this.ensureItIsNotTheNullObject(stack.pop());
              var n2 = this.ensureItIsNotTheNullObject(stack.pop());
              var n1 = this.ensureItIsNotTheNullObject(stack.pop());

              // function to execute the operation
              var fn = (adf.mf.internal.el.parser.ops.ternaryOperations[token.index])[1];

              stack.push(fn(n1, n2, n3));
              break;

            case TOKEN_BINARY_OPERATOR:
              var n2 = this.ensureItIsNotTheNullObject(stack.pop());
              var n1 = this.ensureItIsNotTheNullObject(stack.pop());

              // function to execute the operation
              var fn = (adf.mf.internal.el.parser.ops.binaryOperations[token.index])[1];

              stack.push(fn(n1, n2));
              break;

            default:
              break;
          } // switch
        } // for

        throw new adf.mf.PropertyNotWritableException(this.toString());
      },

      /**
       * Returns the original String used to create this ELExpression, unmodified. This is used for
       * debugging purposes but also for the purposes of comparison (e.g. to ensure the expression in
       * a configuration file has not changed). This method does not provide sufficient information to
       * re-create an expression. Two different expressions can have exactly the same expression
       * string but different function mappings. Serialization should be used to save and restore the
       * state of an ELExpression.
       *
       * @return The original expression String.
       */
      /* String */
      getExpressionString: function()
      {
        if (!this._expr)
          this.refresh();
        return this._expr;
      },

      /**
       * Get the expression using the EL indexed expression notation. This may be used to create
       * a common syntax to be able to compare two different EL expressions to see if they reference
       * the same object and property.
       * @return {string} the indexed representation as a string
       */
      getIndexedRepresentation: function()
      {
        if (this._indexedExpr == null)
        {
          var stack = [];

          for (var i = 0; i < this.tokens.length; i++)
          {
            var token = this.tokens[i];

            switch (token.type)
            {
              case TOKEN_CONSTANT:
                stack.push(escape(token.value));
                break;

              case TOKEN_TERNARY_OPERATOR:
                var n3 = stack.pop();

                // There may only be one here. This will occur during a dependencies call
                // for example where the EL expression is split into tokens.
                if (stack.length == 0)
                {
                  stack.push(n3);
                }
                else
                {
                  var n2 = stack.pop();
                  var n1 = stack.pop();
                  stack.push("((" + n1 + ")? " + n2 + " : " + n3 + ")");
                }

                break;

              case TOKEN_COMMA:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push("" + n1 + ", " + n2 + "");
                break;

              case TOKEN_COLON:
                break; // ignore

              case TOKEN_NO_ARGS:
                stack.push("");
                break;

              case TOKEN_BINARY_OPERATOR:
                var n2 = stack.pop();

                // There may only be one here. This will occur during a dependencies call
                // for example where the EL expression is split into tokens.
                if (stack.length == 0)
                {
                  stack.push(n2);
                }
                else
                {
                  var n1 = stack.pop();

                  stack.push("(" + n1 + " " + token.index + " " + n2 + ")");
                }

                break;

              case TOKEN_INDEX:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push(n1 + "[" + n2 + "]");
                break;

              case TOKEN_DOT_OFFSET:
                var n2 = stack.pop();
                var n1 = stack.pop();

                stack.push(n1 + '["' + n2 + '"]');
                break;

              case TOKEN_PROPERTY:
                stack.push(token.index);
                break;

              case TOKEN_VARIABLE:
                stack.push(token.index);
                break;

              case TOKEN_UNARY_OPERATOR:
                var n1 = stack.pop();

                switch (token.index)
                {
                  case "!":
                    stack.push("(!" + n1 + ")");
                    break;

                  case "-":
                    stack.push("(-" + n1 + ")");
                    break;

                  default:
                    stack.push(f + "(" + n1 + ")");
                    break;
                }

                break;

              case TOKEN_FUNCTION:
                var n1 = stack.pop();
                var fn = stack.pop();

                stack.push(fn + "(" + n1 + ")");
                break;

              default:
                throw new adf.mf.ELException("Invalid ELExpression");
            }
          }

          if (stack.length > 1)
          {
            console.log(stack);
            throw new adf.mf.ELException("Invalid ELExpression (incorrect number of operands)");
          }

          this._indexedExpr = stack[0];
        }

        return this._indexedExpr;
      },

      getExpression: function()
      {
        return "#{" + this.getExpressionString() + "}";
      },

      /**
       * Evaluates the expression as an lvalue and determines if {@link #setValue(ELContext, Object)}
       * will always fail.
       *
       * @param context used to resolve properties (<code>base.property</code> and <code>base[property]</code>)
       * and to determine the result from the last base/property pair
       * @return <code>true</code> if {@link #setValue(ELContext, Object)} always fails.
       * @throws ELException if evaluation fails (e.g. property not found, type conversion failed, ...)
       * @return {boolean}
       */
      isReadOnly: function()
      {
        if (this.readonly === null)
        {
          this.readonly = !((this.tokens.length > 0) && (this.tokens[0].type == TOKEN_VARIABLE));
        }
        return this.readonly;
      },

      /**
       * obtain all the variables this expression is dependent on.
       *
       * @returns {Array}
       */
      dependentObjects: function ()
      {
        var tokenLength = this.tokens.length;
        var vars        = [];

        for (var i = 0; i < tokenLength; i++)
        {
          var item = this.tokens[i];
          if ((item.type === TOKEN_VARIABLE) && (vars.indexOf(item.index) == -1))
          {
            vars.push(item.index);
          }
        }

        return vars;
      },

      /**
       * Convert the ELExpression to a context free expression.
       */
      dependencies: function ()
      {
        if (!this.terms)
        {
          this.terms = [];
          var elTerms = this.toContextFreeExpression ().getELTerms();
          for (var i = 0; i < elTerms.length; i++)
          {
            var t = elTerms [i].getExpressionString ();
            this.terms.push (t);
          }
        }
        return this.terms;
      },

      /**
       * Get an array of context free expressions for each dependency in
       * the indexed EL syntax
       * @returns {Array.<string>} array of dependencies in indexed syntax
       */
      getIndexedDependencies: function()
      {
        if (this._indexedDependencies == null)
        {
          // Get all the dependencies in context free form
          var elTerms = this.toContextFreeExpression().getELTerms();
          var deps = [];

          // Cache the value so it only has to be computed once
          this._indexedDependencies = deps;

          for (var i = 0; i < elTerms.length; ++i)
          {
            deps.push(elTerms[i].getIndexedRepresentation());
          }
        }

        return this._indexedDependencies;
      },

      /**
       * Obtain all the terms this expression is dependent on.
       *
       * @returns {Array} This method returns array of ELExpressions.
       */
      getELTerms: function ()
      {
        if (!this.elTerms)
          this.refresh ();
        return this.elTerms;
      },

      /**
       * Concatenates two ELExpressions.
       *
       * @param {Object} ELExpression to be concatenated to this ELExpression.
       */
      concat: function (elExpression)
      {
        var tokens = this.tokens.slice();
        var firstToken = elExpression.tokens [0];
        var newToken = new Token (TOKEN_PROPERTY, firstToken.index, firstToken.prior, firstToken.value);
        tokens.push(newToken);
        tokens.push(new Token (TOKEN_DOT_OFFSET, ".", -2, 0));
        adf.mf.internal.util.appendAll(tokens, elExpression.tokens, 1);
        var expression = this.getExpressionString() + '.' + elExpression.getExpressionString();
        return new ELExpression (tokens, expression, [expression], null);
      },

      /**
       * Appends array index access this ELExpression.
       *
       * @param {number} array index
       * @returns {Object} ELExpression.
       */
      appendIndex: function (index)
      {
        var tokens = this.tokens.slice();
        tokens.push (new Token (TOKEN_CONSTANT, 0, 3, index));
        tokens.push (new Token (TOKEN_INDEX, "[", -99, 0));
        var expression = this.getExpressionString() +
          (typeof index === "string" ? "['" + index + "']" :  "[" + index + "]");
        return new ELExpression (tokens, expression, [expression], null);
      },

      /**
       * @param {Array} arr
       * @param {Array} exclude
       */
      cleanup: function(arr, exclude)
      {
        var dfarr  = adf.mf.util.removeDuplicates(arr);
        var elen   = exclude.length;
        var dlen   = dfarr.length;

        for (var e = 0; e < elen; ++e)
        {
          for (var d = 0; d < dlen; ++d)
          {

            if (dfarr[d] == exclude[e])
            {
              dfarr.splice(d, 1);
            }
          }
        }

        return dfarr;
      },

      /**
       * This method computes this._expr, this.terms and this.elTerms variables
       * based on this.tokens value.
       */
      refresh: function ()
      {
        var stack = [];
        var termStart = [];
        var termsMap = {};
        var terms = [];
        var elTerms = [];

        function finishTerm (el, from, to, term)
        {
          if (!termsMap[term])
          {
            termsMap[term] = true;
            terms.push(term);

            var tokens = el.tokens.slice(from, to);

            elTerms.push(new ELExpression(tokens));
          }
        }

        function finishTerms (el, to)
        {
          for (var i = 2; i < arguments.length; i++)
          {
            var from = termStart.pop();

            if (from >= 0)
              finishTerm (el, from - 1, to - 1, arguments [i]);
            else
              from = -from;

            to = from;
          }

          termStart.push(-to);
        }

        for (var i = 0; i < this.tokens.length; i++)
        {
          var token = this.tokens[i];
          var type = token.type;

          if (type === TOKEN_CONSTANT)
          {
            stack.push(escape(token.value));
            termStart.push(-i-1);
          }
          else if (type === TOKEN_TERNARY_OPERATOR)
          {
            var n3 = stack.pop();
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("((" + n1 + ")? " + n2 + " : " + n3 + ")");
            finishTerms(this, i + 1, n3, n2, n1);
          }
          else if (type === TOKEN_COMMA)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("" + n1 + ", " + n2 + "");
            finishTerms(this, i + 1, n2, n1);
          }
          else if (type === TOKEN_COLON)
          {
            /* ignore */
          }
          else if (type === TOKEN_NO_ARGS)
          {
            stack.push("");
            termStart.push(-i-1);
          }
          else if (type === TOKEN_BINARY_OPERATOR)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();

            stack.push("(" + n1 + " " + token.index + " " + n2 + ")");
            finishTerms(this, i + 1, n2, n1);
          }
          else if (type === TOKEN_INDEX)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();
            var term = n1 + "[" + n2 + "]";

            stack.push(term);

            var from1 = termStart.pop();

            if (from1 >= 0)
              finishTerm(this, from1 - 1, i, n2);
          }
          else if (type === TOKEN_DOT_OFFSET)
          {
            var n2 = stack.pop();
            var n1 = stack.pop();
            var n3 = n1 + "." + n2;

            stack.push(n3);
          }
          else if (type === TOKEN_PROPERTY)
          {
            stack.push(token.index);
          }
          else if (type === TOKEN_VARIABLE)
          {
            stack.push(token.index);
            termStart.push(i + 1);
          }
          else if (type === TOKEN_UNARY_OPERATOR)
          {
            var n1 = stack.pop();
            var f = token.index;

            if (f === "!")
            {
              stack.push("(!" + n1 + ")");
            }
            else if (f === "-")
            {
              stack.push("(-" + n1 + ")");
            }
            else
            {
              stack.push(f + "(" + n1 + ")");
            }

            finishTerms(this, i + 1, n1);
          }
          else if (type === TOKEN_FUNCTION)
          {
            var n1 = stack.pop();
            var fn = stack.pop();
            var n2 = fn + "(" + n1 + ")";

            stack.push(n2);

            var from1 = termStart.pop();

            if (from1 >= 0)
              finishTerm(this, from1 - 1, i, n1);
          }
          else
          {
            throw new adf.mf.ELException("Invalid ELExpression");
          }
        }
        if (stack.length > 1)
        {
          throw new adf.mf.ELException("Invalid ELExpression (incorrect number of operands)");
        }
        if (termStart.length > 0)
        {
          var from = termStart.pop();

          if (from >= 0)
            finishTerm(this, from - 1, i, stack[0]);
        }

        this._expr = stack[0];
        this.elTerms = elTerms;
      },

      /**
       * This method clears cached values of local variables.
       */
      unflatten: function()
      {
        for (var i = 0; i < this.tokens.length; i++)
        {
          var token = this.tokens [i];

          if (token.flattened)
          {
            token.type = TOKEN_VARIABLE;
            token.value = 0;
            token.flattened = false;
          }
        }
      },

      /**
       * @returns {ELExpression}
       */
      toContextFreeExpression: function()
      {
        // for a context free version but not swapping out local variables.
        return this.stripLocalValues (true, undefined, false);
      },

      /**
       * Strips local values.
       *
       * @param {boolean} contextFree
       * @param {array} tokenReplacement
       * @param {boolean} replaceLocalVariables
       * @returns {ELExpression}
       */
      stripLocalValues: function(contextFree, tokenReplacement, replaceLocalVariables)
      {
        var result = null;

        for (var i = 0; i < this.tokens.length; i++)
        {
          var item = this.tokens[i];

          if (item.type === TOKEN_VARIABLE)
          {
            if (tokenReplacement != null)
            {
              var replacement = tokenReplacement[item.index];

              if (replacement)
              {
                if (!replacement.tokens)
                {
                  if (replacement.match(/[#$][{]/g) != null)
                  {
                    replacement = adf.mf.internal.el.parser.parse(replacement);
                  }
                  else
                  {
                    replacement = adf.mf.internal.el.parser.parse("#{" + replacement + "}");
                  }
                }

                result = replaceEL(result, this, i, replacement);
                continue;
              }
            }

            if (contextFree)
            {
              var elResolver = adf.mf.internal.context.getELResolver();

              try
              {
                var value = elResolver.getValue(adf.mf.internal.context, null, item.index);

                if ((value != null) && (value.getAlias !== undefined))
                {
                  // change the variable to be it's context free (alias) form
                  var expandedEL = value.getAlias();

                  result = replaceEL(result, this, i, expandedEL);
                  continue;
                }
                else if (replaceLocalVariables && (value != undefined) && ((typeof value) !== 'object'))
                {
                  result = replaceValue(result, this, i, value);
                  continue;
                }
              }
              catch (ex)
              {
              }
            }
          }

          if (result)
            result.tokens.push(item);
        } // for i

        if (result)
          return result.getEL();

        this._expr = null;

        return this;
      },

      toString: function()
      {
        // for a non-context free version and not swapping out local variables.
        return this.getExpressionString();
      }
    };

    function replaceValue (result, el, index, value)
    {
      if (!result)
        result = new Result(el, index);

      result.tokens.push(new Token(TOKEN_CONSTANT, 0, 0, value));

      return result;
    }

    function replaceEL(result, el, index, insertedEL)
    {
      if (!result)
        result = new Result(el, index);

      adf.mf.internal.util.appendAll(result.tokens, insertedEL.tokens);

      return result;
    }

    function Result(el, index)
    {
      this.tokens = el.tokens.slice (0, index);
    }

    Result.prototype.getEL = function()
    {
      return new ELExpression(this.tokens, null, null, null);
    };

    function ELParser()
    {
      this.success    = false;
      this.errormsg   = "";
      this.expression = "";
      this.pos        = 0;
      this.value      = 0;
      this.prior      = 3;
      this.token      = 0;
      this.pmatch     = 0;
    }

    /*
     * Expression Language BNF - taken from the JavaServer Pages 2.0 Specification (Section JSP.2.9 Collected Syntax)
     *
     * Expression           ::= Expression1 ExpressionRest?
     * ExpressionRest       ::= '?' Expression ':' Expression
     * Expression1          ::= Expression BinaryOp Expression | UnaryExpression
     * BinaryOp             ::= 'and' | '&&' | 'or' | '||' | '+' | '-' | '*' | '/' | 'div' | '%' | 'mod' |
     *                          '<' | 'gt' |'>' | 'lt' | '<=' | 'ge' |'>=' | 'le' | '==' | 'eq' | '=!' | 'ne'
     * UnaryExpression      ::= UnaryOp UnaryExpression |   Value
     * UnaryOp              ::= '-' | '!' | 'not' | 'empty'
     * Value                ::= ValuePrefix | Value ValueSuffix
     * ValuePrefix          ::= Literal | '(' Expression ')' | Identifier except for ImplicitObject |
     *                          ImplicitObject | FunctionInvocation
     * ValueSuffix          ::= '.' Identifier | '[' Expression ']'
     * Identifier           ::= Java language identifierCollected Syntax 1-83
     * ImplicitObject       ::= 'pageContext' | 'pageScope' | 'requestScope' | 'sessionScope' | 'applicationScope' |
     *                          'param' | 'paramValues' | 'header' | 'headerValues' | 'initParam' | 'cookie'
     * FunctionInvocation   ::= (Identifier ':')? Identifier '(' ( Expression ( ',' Expression )* )? ')'
     * Literal              ::= BooleanLiteral | IntegerLiteral | FloatingPointLiteral | StringLiteral | NullLiteral
     * BooleanLiteral       ::= 'true' | 'false'
     * StringLiteral        ::= '([^'\]|\'|\\)*' | "*(\\|"\|[\"^])"
     *                          i.e., a string of any characters enclosed by single or double quotes,
     *                                where \ is used to escape ', ", and \. It is possible to use single
     *                                quotes within double quotes, and vice versa, without escaping.
     * IntegerLiteral       ::= ['0'-'9']+
     * FloatingPointLiteral ::= (['0'-'9'])+ '.' (['0'-'9'])* Exponent? | '.' (['0'-'9'])+ Exponent? | (['0'-'9'])+ Exponent?
     * Exponent             ::= ['e','E'] (['+','-'])? (['0'-'9'])+
     * NullLiteral          ::= 'null'
     *
     * Notes
     * - An identifier is constrained to be a Java identifier - e.g., no -, no /, etc.
     * - A String only recognizes a limited set of escape sequences, and \ may not appear unescaped.
     * - The relational operator for equality is == (double equals).
     * - The value of an IntegerLiteral ranges from Long.MIN_VALUE to Long.MAX_VALUE
     * - The value of a FloatingPointLiteral ranges from Double.MIN_VALUE to Double.MAX_VALUE
     */
    ELParser.prototype =
    {
      parse: function (expr)
      {
        var insideExpression = false;
        var token            = null;

        this.operatorStack      = [];
        this.tokenStack         = [];
        this.expected           = (OPENEXP);
        this.nooperands         = 0;
        this.pmatch             = 0;
        this.errormsg           = "";
        this.success            = true;
        this.expression         = expr;
        this.pos                = 0;
        this.text               = 0;
        this.expCount           = 0;
        this.currentELTermStart = {};
        this.currentTermStart   = {};
        this.elTerms            = [];
        this.terms              = [];
        this.termsMap           = {};

        /* look for nested EL expressions */
        if (expr.match(new RegExp(".*[$#]{[^}]*[$#]{")))
        {
          this.parsingError(this.pos, "ERROR_EL_PARSER_NESTED_EL_NOT_SUPPORTED");
        }

        while (this.pos < this.expression.length)
        {
          if ((this.expected & OPENEXP) == OPENEXP)
          {
            if (this.isExpressionDirective())
            {
              /* we have a potential expression */
            }
            else
            {
              var txt = null;

              if (this.pos + 1 == this.expression.length)
              {
                txt = this.expression.substring(this.text, this.expression.length);

                if (this.text !== 0)
                {
                  this.expCount++;
                }
              }
              else if (this.isOpenExpression())
              {
                this.expCount++;
                txt           = this.expression.substring(this.text, this.pos - 1);
                this.expected = (PRIMARY | LPAREN | RPAREN | FUNCTION | SIGN | UNIOP | CLOSEEXP);
              }

              // in this case have something like: xxx#{...}
              // we want the xxx to be concatenated on the result of #{...}
              if ((txt !== null) && (txt.length > 0))
              {
                var t = new Token(TOKEN_CONSTANT, 0, 0, txt);

                if (this.expCount++ > 1)
                {
                  this.token = "+";   // should go to # if we should concat
                  this.prior = 30;    // 30 = 3 (for add) * 10 (to ensure it is always the last precedence)
                  this.nooperands  += 2;
                  this.addfunc(TOKEN_BINARY_OPERATOR);
                  this.text = this.pos;
                }

                this.tokenStack.push(t);
              }
            }

            this.pos++;
          }
          else if (parseToken(this))
          {
          }
          else
          {
            if (this.errormsg === "")
            {
              var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
                "ERROR_EL_PARSER_UNKNOWN_CHAR_FOUND", [this.expression.charAt(this.pos)]);

              this.parsingError(this.pos, rmsg);
            }
            else
            {
              this.parsingError(this.pos, this.errormsg);
            }
          }
        }

        if (insideExpression)
        {
          var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_MISSING_ENDING");

          this.parsingError(this.pos, rmsg);
        }

        if (this.pmatch != 0)
        {
          var rmsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle", "ERROR_EL_PARSER_MISMATCH");

          this.parsingError(this.pos, rmsg);
        }

        while (this.operatorStack.length > 0)
        {
          var tmp = this.operatorStack.pop();

          this.tokenStack.push(tmp);
        }

        if (this.tokenStack.length == 0)
        {
          token = new Token(TOKEN_CONSTANT, 0, 0, "");
          this.tokenStack.push(token);
        }

        if (this.nooperands + 1 !== this.tokenStack.length)
        {
          var msg = "{";

          for (var i=0; i < this.tokenStack.length; ++i)
          {
            msg += " token["+i+"] = '" + this.tokenStack[i].toString() + "' ";
          }

          msg += "}";

          var rmsg = adf.mf.internal.resource.getResourceStringImpl(
            "ADFErrorBundle", "ERROR_EL_PARSER_INCORRECT_OPERANDS",
            [("[" + (this.nooperands + 1) + ", " + this.tokenStack.length + "]"), msg]);

          this.parsingError(this.pos, rmsg);
        }

        return new ELExpression(this.tokenStack, null, null, this.elTerms);
      },

      finishTerm: function(endPosition)
      {
        this.finishTermTokens();

        var termStart = this.currentTermStart[this.pmatch];

        if (!termStart)
        {
          return;
        }

        var term = this.expression.substr(termStart, endPosition - termStart).trim();
        var elTermStart = this.currentELTermStart[this.pmatch];
        var newELTerm = null;

        if (!this.termsMap[term])
        {
          if (elTermStart === 0 &&
            endPosition === this.expression.length)
          {
            newELTerm = this;
          }
          else
          {
            var termExpression = this.tokenStack.slice(elTermStart);

            newELTerm = new ELExpression(termExpression, term, [term], null);
          }

          this.elTerms.push(newELTerm);
          this.termsMap[term] = true;
        }

        this.currentTermStart[this.pmatch] = null;
        this.currentELTermStart[this.pmatch] = null;
      },

      evaluate: function (expr, variables)
      {
        var /* ELExpression */ elExpr = this.parse(expr);
        var /* var array    */ vars   = [];
        var /* return value */ v;

        try
        {
          v = elExpr.evaluate(variables);
        }
        catch(e)
        {
          try
          {
            vars = elExpr.dependencies();
          }
          catch(e2)
          {
            vars = [];
          }

          vars.push(expr);

          throw e;
        }

        return v;
      },

      parsingError: function (column, msg)
      {
        this.success = false;
        this.errormsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
          "ERROR_IN_EL_PARSING");

        // This is a huge issue, log a message in case the caller is not catching exceptions
        adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal.el.parser", "EL Parser",
          this.errormsg);

        // For security purposes, only log the details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "ELParser", "parse",
            "EL Parsing Error: " + msg + " -- [column " + column + "] " + this.expression);
        }

        throw new adf.mf.ELException(this.errormsg);
      },

      finishTermTokens: function ()
      {
        while (this.operatorStack.length > 0)
        {
          if (this.operatorStack[this.operatorStack.length - 1].type == TOKEN_DOT_OFFSET)
          {
            this.tokenStack.push(this.operatorStack.pop());
          }
          else
          {
            break;
          }
        }
      },

      addfunc: function (type)
      {
        var operator = new Token(type, this.token, this.prior - this.pmatch, 0);
        while (this.operatorStack.length > 0)
        {
          if (operator.prior >= this.operatorStack[this.operatorStack.length - 1].prior)
          {
            this.tokenStack.push(this.operatorStack.pop());
          }
          else
          {
            break;
          }
        }
        this.operatorStack.push(operator);
      },

      /**
       * unescape an input string into a normal string
       *
       * @param input string to unescape
       * @param pos   in the overall expression we are unescaping
       *
       * @returns the unescaped string
       */
      unescape: function(input, pos)
      {
        var buf    = [];
        var escape = false;

        for (var i = 0; i < input.length; i++)
        {
          var c = input.charAt(i);

          if (! escape)
          {
            if (c == '\\') { /* turn on escaping */
              escape = true;
            } else {  /* non-escaped character, just add it to the buffer */
              buf.push(c);
            }
          } else { /* character following the escape character \\ */
            switch (c)
            {
            case '\\': buf.push('\\'); break;
            case '/':  buf.push('/');  break;
            case 'b':  buf.push('\b'); break;
            case 'f':  buf.push('\f'); break;
            case 'n':  buf.push('\n'); break;
            case 'r':  buf.push('\r'); break;
            case 't':  buf.push('\t'); break;
            case 'u':  /* following 4 chars make up the hex code for the character */
              var unicodeCode = parseInt(input.substring(i+1, i+5), 16);
              buf.push(String.fromCharCode(unicodeCode)); // add the string representation of the unicode char
              i += 4;
              break;
            default:
              throw this.parsingError(pos + i, "Illegal escape sequence: '\\" + c + "'");
            }
            escape = false;
          }
        }

        return buf.join('');  /* convert the array to a single string */
      },

      /**
       * Determine if the next token is a sign token (- or +)
       *
       * @returns {Boolean}
       */
      isSign: function ()
      {
        var code = this.expression.charCodeAt(this.pos - 1);
        return (code === 45 || code === 43); // - or +
      },

      /**
       * Determine if the next token is a negative sign token
       *
       * @returns {Boolean}
       */
      isNegativeSign: function ()
      {
        return (this.expression.charCodeAt(this.pos - 1) === 45); // -
      },

      /**
       * Determine if the next token is a dot token
       *
       * @returns {Boolean}
       */
      isDot: function ()
      {
        var code = this.expression.charCodeAt(this.pos);
        if (code === 46) { // .
          this.pos++;
          this.prior = 0;
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is the open expression token
       *
       * @returns {Boolean}
       */
      isOpenExpression: function ()
      {
        var code = this.expression.charCodeAt(this.pos);
        if ((code === 123) && (this.directive + 1 == this.pos)) // {
        {
          // this.pos++;
          return true;
        }
        return false;
      },

      /**
       * Determine if this is a expression directive.
       *
       * @returns {Boolean}
       */
      isExpressionDirective: function ()
      {
        var status = false;
        var code   = this.expression.charCodeAt(this.pos);

        if ((code === 35 /* # */) || (code === 36 /* $ */))
        {
          this.directive = this.pos;
          status         = true;
        }
        return status;
      },

      /**
       * Determine if the next token is ends the operator
       *
       * @returns {Boolean}
       */
      isOperatorBoundary: function (pos)
      {
        var code = this.expression.charCodeAt(pos);

        if (code === 40 /* (     */ ||
          code === 32 /* space */ ||
          code ===  9 /* tab   */ ||
          code === 10 /* LF    */ ||
          code === 13 /* CR    */)
          {
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is a variable token
       *
       * @returns {Boolean}
       */
      isVariable: function ()
      {
        var str       = "";
        var length    = 0;

        for (var i = this.pos; i < this.expression.length; i++)
        {
          var c           = this.expression.charAt(i);
          var includeChar = true;

          /* see if this character is not a valid character for a name */
          if (str === "")
          {
            /* first character must be alpha except for compressed keys
             * which will start with _ (and be in the form of _999)
             */
            if ((c.toLowerCase() == c.toUpperCase()) && (c !== '_'))
            {
              break;
            }
          }

          if (c.toLowerCase() == c.toUpperCase())
          {
            if (((c >= '0') && (c <= '9')) ||    /* numbers are validate             */
               ((c == '.') || (c == '_'))) {    /* dot and underscore are also okay */
              }else break;
          }

          length++;
          if (includeChar)
          {
            str += c;
          }
        }
        if (str.length > 0)
        {
          this.token  = str;
          this.prior  = 3;
          this.pos   += length; // str.length;
          return true;
        }
        return false;
      },

      /**
       * Determine if the next token is a comment token.
       *
       * @returns {Boolean}
       */
      isComment: function ()
      {
        /*
         * remember we need to look back one character for the slash since it might
         * have been picked up as a unary or binary operation token.
         */
        var code = this.expression.charCodeAt(this.pos - 1);

        if ((code === 47 /* slash */) && (this.expression.charCodeAt(this.pos) === 42 /* start */))
        {
          this.pos = this.expression.indexOf("*/", this.pos) + 2; /* eat all those characters */

          if (this.pos === 1)
          {
            this.pos = this.expression.length;
          }
          return true;
        }
        return false;
      }
    };

    function escape(v)
    {
      var quote     = "\""; // "'";
      var escapable = /[\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var meta      = { '\b': '\\b','\t': '\\t','\n': '\\n','\f': '\\f','\r': '\\r','\\': '\\\\' };
      if ((typeof v) === "string")
      {
        escapable.lastIndex = 0;
            return escapable.test(v) ?
                quote + v.replace(escapable, function (a)
                  {
                      var c = meta[a];
                      return ((typeof c === 'string')? c :
                          '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
                  }) + quote :
                  quote + v + quote;
      }
      return v;
    }

    return ELParser;
  }();
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/ELParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/TreeNode.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- TreeNode.js ---------------------- */
// @requires ELErrors
// @requires AdfPerfTiming

// @requires JavaScriptContext


var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};

(function() {

  var collectionModelExtensionELExpression = adf.mf.internal.el.parser.parse(
    "#{collectionModel.treeNodeBindings.providers}");

  function TreeNode(/* TreeBinding */ tb, /* index */ index, /* ELExpression */ treeBindingEL)
  {
    this.id       = tb.id;
    this.index    = index;
    this.modid    = adf.mf.internal.context.getModId();
    this.treeBindingEL = treeBindingEL;
    this.alias    = null;

    this.getAlias = function (/* boolean */ compressed)
    {
      if (compressed)
      {
        var ref = this.id + ".collectionModel.treeNodeBindings.providers['" + this.getKey() + "']";
        var alias = adf.mf.internal.api.addCompressedReference(ref);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNode", "getAlias",
            "alias=" + alias + " expanded=" + ref);
        }

        return alias;
      }
      if (!this.alias)
      {
        this.alias = this.treeBindingEL.concat(collectionModelExtensionELExpression)
          .appendIndex(this.getKey());
      }
      return this.alias;
    };

    /**
     * INTERNAL function to get the current collection
     * model stored for the given tree binding's id.
     */
    this.getTreeNodeBindings = function()
    {
      // check to see if we already have the latest tree node bindings
      if (this.modid == adf.mf.internal.context.getModId())
      {
        return tb.treeNodeBindings;
      }
      else
      {
        // looks like the cache has been updated, be safe re-fetch
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        if (cm != null && cm.treeNodeBindings != null)
        {
          return cm.treeNodeBindings;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
           adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "TreeNode.getTreeNodeBindings",
            "WARN_COLLECTION_MODEL_NOT_FOUND");

          // For security purposes, only log the details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "TreeNode", "getTreeNodeBindings",
              "Collection model is null or its tree node bindings: " + this.id);
          }
        }

        return {};
      }
    };
    this.tnb = this.getTreeNodeBindings();

    /**
     * getProvider will update the current provider
     * reference and return it's value to the caller.
     */
    this.getProvider = function()
    {
      var key = this.getKey();

      this.provider = (key != undefined)? this.tnb.providers[key] : undefined;

      return this.provider;
    };

    /**
     * getBindings will return the associated
     * column bindings to the caller.
     */
    this.getBindings = function()
    {
      return this.tnb.columnBindings;
    };

    /*
     * get the current key value
     */
    this.getKey = function()
    {
      this.key = ((index < 0) || (index >= this.tnb.keys.length)) ?
        undefined : this.tnb.keys[index];

      return this.key;
    };

    this.rowKey = function()
    {
      return this.getKey();
    };

    this.provider = this.getProvider();
    this.key      = this.getKey();
    this.note     = '' + (typeof this) + ' with EL variable id: ' + this.id + ' on index ' +
      this.index;
    this['.type'] = 'oracle.adfmf.bindings.dbf.TreeNode';

    // If an attribute is null or an empty array, the value is not being sent by the embedded side.
    // As a result, a request for that attribute will result in a cache miss (undefined value) and
    // cause a round trip to the embedded side. By checking the column attributes during
    // the creation of this object, we can avoid the undefined values by setting the properties to
    // null when not present
    if (this.provider != null)
    {
      for (var attributeName in tb.columnAttributes)
      {
        if (this.provider[attributeName] === undefined &&
          (this.provider.bindings == null || this.provider.bindings[attributeName] === undefined))
        {
          // We are not given the meta-data if this attribute is a true attribute or an accessor.
          // The accessors are stored directly on the provider, but the attributes are stored on
          // the bindings object of the provider. Since we do not know, store the value on the
          // provider directly.
          this.provider[attributeName] = null;
        }
      }
    }
  };

  /**
   *
   * Here are some things to note about using the iterator.
   *
   * Step  1. Resolve #{bindings.products.collectionModel}
   *          adf.mf.api.getValue("#{bindings.products.collectionModel}",
   *                          function(a,b) {value = b[0].value; success();}, failed);
   *
   * Step  2. Resolve #{bindings.products.collectionModel.iterator}
   *          adf.mf.api.getValue("#{bindings.products.collectionModel.iterator}",
   *                          function(a,b) {bpci = b[0].value; success();}, failed);
   *
   * Step 3.  Jumping around the rows with the iterator
   *          Resolve iterator.first():
   *          bpci.first(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   *          Resolve iterator.last():
   *          bpci.first(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }
   *                                function(a, b){ failed();});
   *
   *          Resolve iterator.previous():
   *          bpci.previous(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   *          Resolve iterator.next():
   *          bpci.next(function(a, b){ adf.mf.api.addVariable('row', b[0].value); success(); }, failed);
   *
   * Step  4. Accessing iterator bindings:
   *          Resolve #{row.bindings}:
   *          adf.mf.api.getValue("#{row.bindings}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Resolve #{row.bindings.name}:
   *          adf.mf.api.getValue("#{row.bindings.name}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve");});
   *
   *          Resolve #{row.bindings.name.inputValue}:"
   *                     adf.mf.api.getValue("#{row.bindings.name.inputValue}",
   *                                     function(a,b) {value = b[0].value; success();},
   *                                     function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Update #{row.bindings.name.inputValue}:"+ stringify(value) + "");
   *                     adf.mf.api.setValue({'name':"#{row.bindings.name.inputValue}", 'value':value},
   *                                      function() {showSuccess("Updated"); success();},
   *                                      function() {showFailure("Unable to updated");});
   *
   *          Resolve #{row.dataProvider}:
   *          adf.mf.api.getValue("#{row.dataProvider}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Resolve #{row.dataProvider}:
   *          adf.mf.api.getValue("#{row.dataProvider.name}",
   *                          function(a,b) {value = b[0].value; success();},
   *                          function(a,b) {showFailure("unable to resolve"); failure();});
   *
   *          Update #{row.dataProvider.name}:
   *          adf.mf.api.setLocalValue({'name':"#{row.dataProvider.name}", 'value':value},
   *                               function() {showSuccess("Updated"); success();},
   *                               function() {showFailure("Unable to updated"); failure();});
   *
   * Step 5: Register some data change listeners on #{bindings.products.collectionModel}:
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 1 of " + stringify(v));});
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 2 of " + stringify(v));});
   *         adf.mf.api.addDataChangeListeners("#{bindings.products.collectionModel}",
   *                                            function(v) {showChangeEvent("DCN 3 of " + stringify(v));});
   *
   * Step 6. Access the number of cached rows:
   *         var cr = bpci.getCachedRowCount(0);
   *
   * Step 7. Access the number of rows in a Range Size:
   *         var rs = bpci.getRangeSize();
   *
   * Step 8. Validating the data change event was processed correctly: ");
   *
   {
   *            bpci.first(loopBody, function(e){ console.log("Error: first failed: " + stringify(e));});
   *            ...
   *         }
   *         ...
   *
   *         // Easy way to loop thru the number of rows we have cached starting at 0
   *         function loopBody()
   *
   {
   *            if (++count < bpci.getCachedRowCount(0))
   *
   {
   *               var v1 = adf.mf.api.getLocalValue("id:#{row.bindings.id.inputValue}");
   *               var v2 = adf.mf.api.getLocalValue("name:#{row.bindings.name.inputValue}");
   *
   *               content += "checking provider[" + bpci.index + "] = [" + v1 + "]:" + v2 + "<br>";
   *
   *               bpci.next(function(a, b){ adf.mf.api.addVariable('row', b[0].value); loopBody(); },
   *                         function(a, b){ showSuccess("no more records to check"); showContent();});
   *             }
   *         }
   **/
  function TreeNodeIterator(/* TreeBinding */ tb, /* index */ idx)
  {
    this.id                         = tb.id;
    this.treeNodeBindings           = tb.treeNodeBindings  || {providers:{}, keys:[]};
    this.index                      = idx;
    this.currentKey                 = null;
    this[".type"]                   = "TreeNodeIterator";  /* needed for minimized version to obtain the type */
    this.modid                      = adf.mf.internal.context.getModId();
    this.treeBindingEL              = adf.mf.internal.el.parser.parse("#{" + tb.id + "}");


    /**
     * INTERNAL function to get the current collection
     * model stored for the given tree binding's id.
     */
    this.getTreeNodeBindings = function()
    {
      // check to see if we already have the latest tree node bindings
      if (this.modid == adf.mf.internal.context.getModId())
      {
        return tb.treeNodeBindings;
      }
      else
      {
        // looks like the cache has been updated, be safe re-fetch
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        if (cm != null && cm.treeNodeBindings != null)
        {
          return cm.treeNodeBindings;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "TreeNodeIterator.getTreeNodeBindings",
            "WARN_COLLECTION_MODEL_NOT_FOUND");

          // For security purposes, only log the request and response details at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "TreeNodeIterator", "getTreeNodeBindings",
              "Unable to find the collection model or tree node bindings for " + this.id);
          }
        }

        return { providers:{}, keys:[] };
      }
    };

    /**
     * create a new provider
     */
    this.createRow = function(provider, /* boolean */ insertFlag, success, failed)
    {
      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "create",
        this.id, this.currentKey, provider, insertFlag, success, failed);
    };

    /**
     * fetch the first row in the collection
     */
    this.first = function(success, failed)
    {
      this.fetch(0, success, failed);
    };

    /**
     * @returns the current row index
     */
    this.getCurrentIndex = function()
    {
      return this.index;
    };

    /**
     * @returns the current row key
     */
    this.getCurrentKey = function()
    {
      return this.currentKey;
    };

    /**
     * @returns the current provider (row)
     */
    this.getCurrentRow = function()
    {
      var tnb = this.getTreeNodeBindings();

      return (this.currentKey !== undefined)?
          tnb.providers[this.currentKey]: undefined;
    };

    /**
     * @returns true if their are more records buffered that can be read
     */
    this.hasNext = function()
    {
      var tnb = this.getTreeNodeBindings();

      return (this.index < (tnb.keys.length - 1));
    };

    /**
     * @returns true if their are more records buffered that can be read
     */
    this.hasPrevious = function()
    {
      return (this.index > 0);
    };

    /**
     * fetch the last row in the collection
     */
    this.last = function(success, failed)
    {
      var tnb = this.getTreeNodeBindings();

      this.fetch((tnb.keys.length - 1), success, failed);
    };

    /**
     * obtain the next record in the collection
     */
    this.next = function(success, failed)
    {
      // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "next",
          //           "Range Size: " + this.getRangeSize() + " where we have loaded " + this.getCachedRowCount(this.index) + " rows.");
      this.fetch((this.index + 1), success, failed);
    };

    /**
     * fetch the first row in the collection
     */
    /* provider */
    this.localFirst = function()
    {
      return this.localFetch(0);
    };

    /**
     * fetch the last row in the collection
     */
    /* provider */
    this.localLast = function()
    {
      var tnb = this.getTreeNodeBindings();

      return this.localFetch((tnb.keys.length - 1));
    };

    /**
     * get the next provider if you have it already cached, if not will return undefined
     */
    /* provider */
    this.localNext = function()
    {
      return this.localFetch((this.index + 1));
    };

    /**
     * get the previous provider if you have it already cached, if not will return undefined
     */
    /* provider */
    this.localPrevious = function()
    {
      return this.localFetch((this.index - 1));
    };

    /**
     * request the next set of records to be fetched
     */
    this.nextSet = function(success, failed)
    {
      this.fetchSet('next', this.index, success, failed);
    };

    /**
     * obtain the next record in the collection
     */
    this.previous = function(success, failed)
    {
      this.fetch((this.index - 1), success, failed);
    };

    /**
     * request the previous set of records to be fetched
     */
    this.previousSet = function(success, failed)
    {
      this.fetchSet('previous', this.index, success, failed);
    };

    /**
     * request the current record set to be re-fetched
     */
    this.refresh = function(success, failed)
    {
      this.fetchSet('next', this.index, success, failed);
    };

    /**
     * set the current index for the iterator
     *
     * @throws IllegalArgumentException if the index is out of range
     */
    this.setCurrentIndex = function(/* int */ index)
    {
      var tnb = this.getTreeNodeBindings();

      if ((index < 0) || (index > (tnb.keys.length - 1)))
      {
        this.index      = -1;
        this.currentKey = undefined;
      }

      this.index      = index;
      this.currentKey = tnb.keys[index];
    };


    /**
     * @return the number of contiguously loaded row starting at a given point.
     *
     * @param startingAtIndex
     */
    /* int */
    this.getCachedRowCount = function(/* int */ startingAtIndex)
    {
      var count = 0;
      var tnb   = this.getTreeNodeBindings();

      if ((startingAtIndex < 0) ||
         (startingAtIndex > (tnb.keys.length - 1)))
      {
        return 0;
      }

      // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "getCachedRowCount", "Passed the first test.");
      for (var i = startingAtIndex; i < tnb.keys.length; ++i)
      {
        var k = tnb.keys[i];

        // adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "getCachedRowCount", "index: " + i + "  key: " + k);

        if (tnb.providers[k] != undefined) ++count;
                else break;
      }

      return count;
    };


    /**
     * @return the number of rows in a given range
     */
    /* int */
    this.getRangeSize = function()
    {
      var sz = adf.mf.api.getLocalValue("#{" + this.id + ".IterBinding.RangeSize}");
      return (sz == undefined)? 0 : sz;
    };


    /***** internal methods *****/

    /**
     * fetch the first row in the collection
     */
    this.fetch = function(index, success, failed)
    {
      var tnb = this.getTreeNodeBindings();

      this.setCurrentIndex(index);

      if (this.currentKey !== undefined)
      {
        if (tnb.providers[this.currentKey] === undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("no provider present for the key " + this.currentKey +
                                    " need to fetch the value."));
          }
          this.fetchProviderByKey(this.currentKey, this.index, success, failed);
        }
        else
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("we have a provider for key " + this.currentKey +
                                   " = " + adf.mf.util.stringify(tnb.providers[this.currentKey])));
          }
          this.returnProvider(this.currentKey, new TreeNode(tb, this.index, this.treeBindingEL), success);
        }
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                 "no element found");
        }
        this.returnProvider(undefined, undefined, failed);
      }
    };

    /**
     * fetch a row in the collection
     */
    /* provider */
    this.localFetch = function(index)
    {
      var tnb      = this.getTreeNodeBindings();
      var  oldIndex = this.index;

      this.setCurrentIndex(index);

      if (this.currentKey !== undefined)
      {
        if (tnb.providers[this.currentKey] !== undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "fetch",
                                   ("we have a provider for key " + this.currentKey +
                                   " = " + adf.mf.util.stringify(tnb.providers[this.currentKey])));
          }
          var treeNode = new TreeNode(tb, this.index, this.treeBindingEL);
          var provider = treeNode.getProvider();
          if (provider['rowKey'] === undefined)
          {
            provider['rowKey'] = treeNode.rowKey();
          }
          return treeNode;
        }
      }

      this.setCurrentIndex(oldIndex);  /* move the cursor back to where it was first */
      return undefined;
    };


    this.getKeys = function(success, failed)
    {
      var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");;
      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "getKeys",
                                          this.id,
                                          [function(a,b) { cm.treeNodeBindings.keys = b; },
                                          success], failed);
    };

    /**
     * remove the current row (provider)
     */
    this.removeCurrentRow = function(success, failed)
    {
      var tnb       = this.getTreeNodeBindings();
      var removeKey = this.currentKey;
      var range     = 0;
      var newIndex  = this.index;

      /* first lets remove the key in the JavaScript cached collection model */
      for (var i = 0; i < tnb.keys.length; ++i)
      {
        if (tnb.keys[i] === this.currentKey)
        {
          tnb.keys.splice(i, 1);
          break;
        }
      }

      range = tnb.keys.length - 1;
      if (newIndex == range)
      {   /* we removed the last one, so move the index to the new last */
        newIndex = (range - 1);
      }
      if (range < 0)
      {  /* there are no elements in the collection any more */
        this.index      = -1;
        this.currentKey = undefined;
      }
      else
      {
        this.setCurrentIndex(newIndex);
      }

      return adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "removeRowWithKey",
                                 this.id, removeKey, success, failed);
    };

    this.setCurrentRowKey = function(key)
    {
      var i = this.getTreeNodeBindings().keys.indexOf(key);
      if (i != -1)
      {
        this.index = i;
        this.currentKey = key;
        return true;
      }
      return false;
    };

    this.setCurrentRowWithKey = function(key, success, failed)
    {
      var tnb      = this.getTreeNodeBindings();
      var newIndex = -1;

      for (var i = 0; i < tnb.keys.length; ++i)
      {
        if (tnb.keys[i] === key)
        {
          newIndex = i;
          break;
        }
      }
      if (newIndex != -1)
      {
        this.setCurrentIndex(newIndex);

        adf.mf.api.invokeMethod("oracle.adfmf.bindings.iterator.IteratorHandler", "setCurrentRowWithKey",
                                      this.id, key, success, failed);
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "TreeNodeIterator", "setCurrentRowWithKey",
                                 ("unable to find the key to set the current row to."));
        }
      }
    };


    /* ---------- internal callback functions ------------- */

    this.fetchSet = function(pcns, index, success, failed)
    {
      var cm    = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
      var scb   = [];
      var fcb   = [];
      var op    = "oracle.adfmf.bindings.iterator.IteratorHandler:fetchSetRelativeTo";
      var upf   = this.updateProviders;
      var start = adf.mf.internal.perf.startMonitorCall("Tree node iterator fetch set", adf.mf.log.level.FINER, op);


      scb = scb.concat(
        [
          function(a,b)
          {
            start.stop();
            start = adf.mf.internal.perf.startMonitorCall("Tree node iterator update providers", adf.mf.log.level.FINER,
              "adf.mf.api.TreeNodeIterator.updateProviders");
            try
            {
              upf(cm, b);
            }
            finally
            {
              start.stop();
            }
          }
        ]);
      scb = scb.concat(adf.mf.internal.util.is_array(success)? success : [success]);

      fcb = fcb.concat(
        [
          function(a,b)
          {
            start.stop();
            adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
              "TreeNodeIterator.fetchSet", "WARN_UNABLE_TO_FETCH_SET");

            // For security purposes, only log the request and response details at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "TreeNodeIterator", "fetchSet",
                "Faled to fetch set: " + adf.mf.util.stringify(arguments));
            }
          }
        ]);

      fcb = fcb.concat(adf.mf.internal.util.is_array(failed) ? failed : [ failed ]);

      /* pcns: previous, current, or next set */
      return adf.mf.api.invokeMethod(
        "oracle.adfmf.bindings.iterator.IteratorHandler", "fetchSetRelativeTo",
        this.id, pcns, cm.treeNodeBindings.keys[index], scb, fcb);
    };

    /* ---------- internal callback functions ------------- */
    this.fetchProviderByKey = function(key, index, success, failed)
    {
      var rpf = this.returnProvider;

      this.fetchSet("next", index,
        function(a,b) { rpf(key, new TreeNode(tb, index, this.treeBindingEL), success); },
        failed);
    };

    this.updateKeys = function(keys)
    {
      try
      {
        var cm = adf.mf.api.getLocalValue("#{" + this.id + ".collectionModel}");
        cm.treeNodeBindings.keys = keys;
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "TreeNodeIterator.updateKeys", "ERROR_TREENODEITERATOR_UPDATE_KEYS");

        // For security purposes, only log the request and response details at FINE level
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "TreeNodeIterator", "updateKeys",
            "Error updating the keys of " + this.id + " error: " + e);
        }
      }
    };

    this.updateProviders = function(cm, values)
    {
      var providers = values || {};
      var keys      = [];

      if (cm === undefined)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "TreeNodeIterator.updateProviders", "ERROR_TREENODEITERATOR_UPDATE_PROVIDERS");
      }
      else
      {
        for (var p in providers)
        {
          if (p !== undefined)
          {
            cm.treeNodeBindings.providers[p] = providers[p];
          }
        }
      }
    };

    this.returnProvider = function(name, provider, callback)
    {
      var request  = [{ 'name':name}];
      var response = [{ 'name':name, 'value': provider }];

      if (adf.mf.internal.util.is_array(callback))
      {
        var count = callback.length;

        for (var i = 0; i < count; ++i)
        {
          callback[i](request, response);
        }
      }
      else
      {
        callback(request, response);
      }
    };
  };

  adf.mf.internal.el.TreeNode   = TreeNode;
  adf.mf.el.TreeNodeIterator    = TreeNodeIterator;
})();




/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/TreeNode.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Utilities.js///////////////////////////////////////

/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Utilities.js ---------------------- */
// @requires AdfPerfTiming


var adf                                       = window.adf                                    || {};
adf.mf                                        = adf.mf                                        || {};
adf.mf.api                                    = adf.mf.api                                    || {};
adf.mf.el                                     = adf.mf.el                                     || {};
adf.mf.locale                                 = adf.mf.locale                                 || {};
adf.mf.log                                    = adf.mf.log                                    || {};
adf.mf.resource                               = adf.mf.resource                               || {};
adf.mf.util                                   = adf.mf.util                                   || {};

adf.mf.internal                               = adf.mf.internal                               || {};
adf.mf.internal.api                           = adf.mf.internal.api                           || {};
adf.mf.internal.converters                    = adf.mf.internal.converters                    || {};
adf.mf.internal.converters.dateParser         = adf.mf.internal.converters.dateParser         || {};
adf.mf.internal.converters.dateParser.iso8601 = adf.mf.internal.converters.dateParser.iso8601 || {};
adf.mf.internal.el                            = adf.mf.internal.el                            || {};
adf.mf.internal.el.parser                     = adf.mf.internal.el.parser                     || {};
adf.mf.internal.locale                        = adf.mf.internal.locale                        || {};
adf.mf.internal.log                           = adf.mf.internal.log                           || {};
adf.mf.internal.mb                            = adf.mf.internal.mb                            || {};
adf.mf.internal.perf                          = adf.mf.internal.perf                          || {};
adf.mf.internal.resource                      = adf.mf.internal.resource                      || {};
adf.mf.internal.util                          = adf.mf.internal.util                          || {};


/**
 * startBatchRequest marks the start of the batch request.  Once this function is called
 * all subsequent requests to the java layer will be deferred until the flushBatchRequest.
 * Between the start and flush batch request markers, all requests success callbacks will
 * be called with deferred object ({.deferred:true}) response object.
 *
 * @see adf.mf.util.flushBatchRequest
 */
/* void */
adf.mf.util.startBatchRequest = function()
{
  if(adf.mf.internal.batchRequest != undefined)
  {
    throw new adf.mf.ELException("Batch Request already started.");
  }
  adf.mf.internal.batchRequest = [];
};


/* boolean */
adf.mf.util.isException = function(/* exception object */ obj)
{
  var o       = ((obj != undefined) && ('object' == typeof obj))? obj : {};
  var e       = (o[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true);

  if(e)  return e;
  else { /* lets see if it ends with Exception */
    return adf.mf.util.isType(o, "Exception");
  }
};


/* boolean */
adf.mf.util.isType = function(/* object */ obj, /* type name */ tname)
{
  var o       = ((obj != undefined) && ('object' == typeof obj))? obj : {};
  var type    = o[adf.mf.internal.api.constants.TYPE_PROPERTY] || "unknown";

  return (type.length == tname.length)?
    (type == tname) :
    (type.indexOf(tname, type.length - tname.length) != -1);
};


/**
 * Where startBatchRequest marks the start of the batch request, flushBatchRequest marks
 * the end of the batch and flushes (processes) the requests.  The caller can determine
 * if the flush should abort of the first error or continue to completion by passing either
 * true or false in the abortOnError parameter.  Regardless, the success callbacks will
 * be called in order if the batch is deemed successful otherwise the failed callbacks
 * will be invoked.  The callbacks parameters will be a vector of requests/responses one
 * for each request that was batched.
 *
 * @see adf.mf.util.startBatchRequest
 */
/* void */
adf.mf.util.flushBatchRequest = function(/* boolean abortOnError, callback success, callback failed, [boolean ignoreErrorMessages]*/)
{
  var argv  = arguments;
  var argc  = arguments.length;
  var scb   = [];
  var fcb   = [];

  if (argc!=4 && argc!=3 && argc!=2)
  {
    throw new adf.mf.ELException("Wrong number of arguments");
  }

  var abortOnError   = argv[0] || false;
  var errorHandler   = ((argc == 4) && (argv[3] == true))?
    adf.mf.internal.api.nvpEatErrors :
    adf.mf.internal.api.arraySimulatedErrors;
  var perf = adf.mf.internal.perf.startMonitorCall("Sending batch request to embedded", adf.mf.log.level.FINEST, "adf.mf.util.flushBatchRequest");
  scb = scb.concat([errorHandler]);
  scb = scb.concat((adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]]);
  scb = scb.concat([function() { perf.stop(true); }]);

  fcb = fcb.concat((adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]]);
  fcb = fcb.concat([function() { perf.stop(true); }]);

  try
  {
    if((adf.mf.internal.batchRequest === undefined) || (adf.mf.internal.batchRequest === null))
    {  /* so we do not have a defined batch request */
      throw new adf.mf.IllegalStateException("batch request is not defined");
    }

    if(adf.mf.internal.batchRequest.length > 0)
    {  /* so we have pending requests */
      if(adf.mf.internal.isJavaAvailable())
      {
        var   requests = adf.mf.internal.batchRequest.slice(0);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "adf.mf.util", "flushBatchRequest",
            ("batch request contains " + requests.length + " requests."));
        }

        adf.mf.internal.batchRequest = undefined;
        adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model",
            "processBatchRequests", abortOnError, requests, scb, fcb);
      }
      else
      {
        throw new adf.mf.IllegalStateException("invalid environment defined for batch request");
      }
    }
    else
    {  /* this is okay, let the called know we are done */
      adf.mf.internal.batchRequest = undefined;
      for(var i = 0; i < scb.length; ++i) { try { scb[i](); }catch(e){}; }
    }
  }
  catch(e)
  {  /* this is not good, let the caller know */
    for(var i = 0; i < fcb.length; ++i) { try { fcb[i](); }catch(e){}; }
  }
  finally
  {
    perf.stop(true);
  }
};


/**
 * Get the context free version of the passed in EL expression.
 **/
/* String */
adf.mf.util.getContextFreeExpression = function(/* EL Expression */ el)
{
  return adf.mf.internal.el.parser.parse(el).toContextFreeExpression().getExpression();
};


/**
 * remove array entry
 */
/* array */
adf.mf.util.removeArrayEntry = function(/* Array */ arr, /* Object */ obj)
{
	var temp = [];

	if(adf.mf.internal.util.is_array(arr))
	{
		for(var i = 1; i < arr.length; ++i)
		{
			if(arr[i] !== obj)
			{
				temp.push(arr[i]);
			}
		}
	}
	else
	{
		throw new adf.mf.IllegalStateException("array was not passed");
	}
	return temp;
};

/**
 * remove duplicate entries from the array 'arr'.  If 'arr' is
 * not an array the 'arr' object is simply returned.
 */
/* array */
adf.mf.util.removeDuplicates = function(/* Array */ arr)
{
  if(adf.mf.internal.util.is_array(arr))
  {
    arr.sort();
    for(var i = 1; i < arr.length; )
    {
      if(arr[i-1] == arr[i])
      {
        arr.splice(i, 1);
      }
      else
      {
        i++;
      }
    }
  }
  return arr;
};

function elExpressionReplacer (key, value) {
	if (value && value._expr && value.tokens)
		return value._expr;
	return value;
}

/**
 * Convert the passed in object into a string representation for printing.
 *
 * @param   dat - data object to be converted
 * @returns string representation of the dat object
 */
/* String */
adf.mf.util.stringify = function(/* object */ dat)
{
  // Stringify is potentially costly, so profile it. The function call forwarding is made so
  // recursion does not spit out bunch of log timestamps
  var perf = adf.mf.internal.perf.startMonitorCall("Converting object to a string", adf.mf.log.level.FINEST, "adf.mf.util.stringify");
  try
  {
    // Forward the call so calee can recurse
    return JSON.stringify(dat, elExpressionReplacer);
  }
  finally
  {
    perf.stop();
  }

  return return_value;
};


/**
 * Return the number of milliseconds since 01 January, 1970 UTC that the provided
 * date string represents. Attempt to use the native Date.parse, and fall back to
 * adf.mf.internal.converters.dateParser.iso8601.parse if the native one returns
 * NaN. Returns NaN if a valid date cannot be parsed.
 *
 * @param   dateString - string containing a date in a format supported natively,
              or ISO-8601
 * @returns the number of ms since 01 January, 1970 UTC, or NaN if not parsable
 */
/* Number */
adf.mf.internal.converters.dateParser.parse = function(dateStr)
{
  var dateParse = Date.parse(dateStr);

  if (isNaN(dateParse))
  {
    dateParse = adf.mf.internal.converters.dateParser.iso8601.parse(dateStr);
  }

  return dateParse;
};


/**
 * Return the number of milliseconds since 01 January, 1970 UTC that the provided
 * ISO 8601 date string represents.
 *
 * @param   iso8601String - ISO 8601 formatted date string
 * @returns the number of ms since 01 January, 1970 UTC, or NaN if not parsable
 *
 * Most of the information for this standard to support was taken from:
 * http://en.wikipedia.org/wiki/ISO_8601
 *
 * The following ISO 8601 formats are supported by this parser. For now, the date string
 * must be of the format <date> or <date>T<time>, not just a <time>.
 *
 * Dates:
 * YYYY
 * YYYY-MM-DD
 * YYYY-MM
 * YYYYMMDD
 *
 * Times:
 * hh:mm:ss
 * hh:mm
 * hhmmss
 * hhmm
 * hh
 *
 * Decimal fractions may also be added to any of the three time elements. A decimal mark,
 * either a comma or a dot (without any preference as stated in resolution 10 of the 22nd
 * General Conference CGPM in 2003, but with a preference for a comma according to ISO
 * 8601:2004) is used as a separator between the time element and its fraction. A fraction
 * may only be added to the lowest order time element in the representation. To denote "14
 * hours, 30 and one half minutes", do not include a seconds figure. Represent it as
 * "14:30,5", "1430,5", "14:30.5", or "1430.5". There is no limit on the number of decimal
 * places for the decimal fraction.
 *
 * Time zone designators:
 * <time>Z
 * <time>hh:mm
 * <time>hhmm
 * <time>hh
 *
 * When the ISO 8601 string is applied against the regular expression, matches[] should contain
 * the following values. For MM/DD/mm/ss, only one of the corresponding array indicies for each
 * will contain data, the other remaining undefined. Which ones are populated depend on the use
 * of separator characters ('-', ':') in the ISO 8601 string.
 *
 * matches[1]   YYYY <- YYYY-MM-DDThh:mm:ss.fffZ        (the year)
 * matches[2]   MM   <- YYYYMMDDThh:mm:ss.fffZ          (the month when no hyphen separates year & month)
 * matches[3]   DD   <- YYYYMMDDThh:mm:ss.fffZ          (the day when no hyphen separates month & day)
 * matches[4]   MM   <- YYYY-MM-DDThh:mm:ss.fffZ        (the month when a hyphen separates year & month)
 * matches[5]   DD   <- YYYY-MM-DDThh:mm:ss.fffZ        (the day when a hyphen separates month & day)
 * matches[6]   hh   <- YYYY-MM-DDThh:mm:ss.fffZ        (the hours)
 * matches[7]   mm   <- YYYY-MM-DDThh:mm:ss.fffZ        (the minutes when no colon separates hours & minutes)
 * matches[8]   ss   <- YYYY-MM-DDThh:mm:ss.fffZ        (the seconds when no colon separates minutes & seconds)
 * matches[9]   mm   <- YYYY-MM-DDThhmmss.fffZ          (the minutes when a colon separates hours & minutes)
 * matches[10]  ss   <- YYYY-MM-DDThhmmss.fffZ          (the seconds when a colon separates minutes & seconds)
 * matches[11]  fff  <- YYYY-MM-DDThh.fffZ              (the fractional hours)
 *          or  fff  <- YYYY-MM-DDThhmm.fffZ            (the fractional minutes, with or without colon separator)
 *          or  fff  <- YYYY-MM-DDThhmmss.fffZ          (the fractional seconds, with or without colon separator)
 * matches[12]  Z    <- YYYY-MM-DDThh:mm:ss.fffZ        (Zulu time, aka +00:00)
 * matches[13]      <- YYYY-MM-DDThh:mm:ss.fffzh:zm   ('+' or '-'; the direction of the timezone offset)
 * matches[14]  zh   <- YYYY-MM-DDThh:mm:ss.fff-zh:zm   (the hours of the time zone offset)
 * matches[15]  zm   <- YYYY-MM-DDThh:mm:ss.fff-zh:zm   (the minutes of the time zone offset)
 */
/* Number */
adf.mf.internal.converters.dateParser.iso8601.parse = function(iso8601Str)
{
  var re = /^(\d{4})(?:(\d{2})(\d{2})|-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2})(?::(\d{2})(?::(\d{2}))?|(\d{2})(?:(\d{2}))?)?(?:[,\.](\d+))?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  var matches = re.exec(iso8601Str);

  if (!matches)
  {
    return NaN;
  }

  var pc = this.constants;

  // assign parsed values to correct units, initializing with default if unspecified
  var year     = matches[pc.YEAR];
  var month    = matches[pc.MONTH]    || matches[pc.MONTH_HYPHEN]  || "1";
  var day      = matches[pc.DAY]      || matches[pc.DAY_HYPHEN]    || "1";
  var hours    = matches[pc.HOURS]    || "0";
  var minutes  = matches[pc.MINUTES]  || matches[pc.MINUTES_COLON] || "0";
  var seconds  = matches[pc.SECONDS]  || matches[pc.SECONDS_COLON] || "0";
  var fraction = matches[pc.FRACTION] || "0";
  var zulu     = matches[pc.ZULU];

  year = parseInt(year, 10);
  month = parseInt(month, 10);
  day = parseInt(day, 10);

  hours = parseInt(hours, 10);
  minutes = parseInt(minutes, 10);
  seconds = parseInt(seconds, 10);

  var fractionMillis = 0;

  // if fraction specified, determine which time part it belongs to and compute additional ms
  if (matches[pc.FRACTION])
  {
    fraction = parseFloat("." + fraction);

    if (matches[pc.SECONDS] || matches[pc.SECONDS_COLON])
    {
      fractionMillis = Math.round(fraction * 1000);       // 1000 = ms / second
    }
    else if (matches[pc.MINUTES] || matches[pc.MINUTES_COLON])
    {
      fractionMillis = Math.round(fraction * 60000);      // 60 * 1000 = ms / minute
    }
    else
    {
      fractionMillis = Math.round(fraction * 3600000);    // 60 * 60 * 1000 = ms / hour
    }
  }

  // create date from time parts (month is zero-based)
  var dateMillis = Date.UTC(year, month - 1, day, hours, minutes, seconds);

  dateMillis += fractionMillis;

  // adjust for timezone
  if (!zulu)
  {
    var tzPlus    = matches[pc.TZ_PLUS];
    var tzHours   = matches[pc.TZ_HOURS]   || "0";
    var tzMinutes = matches[pc.TZ_MINUTES] || "0";

    var offsetMillis = parseInt(tzHours, 10) * 3600000;   // 60 * 60 * 1000
    offsetMillis += parseInt(tzMinutes, 10) * 60000;      // 60 * 1000;

    if (tzPlus == "+")
    {
      dateMillis += offsetMillis;
    }
    else
    {
      dateMillis -= offsetMillis;
    }
  }

  return dateMillis;
};


adf.mf.internal.converters.dateParser.iso8601.constants =
{
  YEAR:          1,
  MONTH:         2,
  DAY:           3,
  MONTH_HYPHEN:  4,
  DAY_HYPHEN:    5,
  HOURS:         6,
  MINUTES:       7,
  SECONDS:       8,
  MINUTES_COLON: 9,
  SECONDS_COLON: 10,
  FRACTION:      11,
  ZULU:          12,
  TZ_PLUS:       13,
  TZ_HOURS:      14,
  TZ_MINUTES:    15
};

/**
 * INTERNAL FUNCTION used to do token subsitution on the passed in expression
 * with the replacementStack of name/value objects.
 */
adf.mf.internal.util.tokenSubsitution = function(/* string */ expression, /* array */ replacementStack)
{
	var result = expression;

	for(var i = 0; i < replacementStack.length; ++i)
	{
		var  replaceMap = replacementStack[i];
		var  ele        = adf.mf.internal.el.parser.parse(result);

		result = ele.stripLocalValues(true, replaceMap, false).getExpression();
	}
	return result;
};

/**
 * INTERNAL FUNCTION used to do strip the local values and token subsitution in one step.
 */
adf.mf.internal.util.stripLocalValues = function(/* string */ expression, /* context free */ bContextFree, /* array */ replacementStack)
{
		if (!expression.tokens)
			expression = adf.mf.internal.el.parser.parse(expression);

	if(replacementStack != null)
	{
		for(var i = 0; i < replacementStack.length; ++i)
		{
			var replaceMap = replacementStack[i];
			expression = expression.stripLocalValues(bContextFree, replaceMap, true);
		}
	}
	else
	{
		expression  = expression.stripLocalValues(bContextFree, null, true);
	}
	return expression;
};


/**
 * Internal method to determine if the expression is valid as a
 * left hand expression for assignments.
 */
adf.mf.internal.util.isAssignable = function(/* string */ expression)
{
	var c1  = false;
	var c2  = false;
	var exp = expression;

	// since the term is allowed to have wrapping parenthesis we need to remove them if they exist
	exp = exp.replace(/^\(/g, " ").replace(/\)$/g, " ").trim();

	// since an array element is a valid LHS token, remove all characters in and including the brackets [.*]
	exp = exp.replace(/\[[^\]]*\]/g, "replace");

	// remove all the numbers from the expression to remove numeric constants
	exp = exp.replace(/[0-9]/g, "");

	// now look for any operators or parenthesis, denoting more than a single token remains
	c1  = (exp.search(/[!%&|\+\-\*\/\(]/i) == -1);

	// make sure we still have characters, i.e. letters for the variable
	c2  = (exp.length > 0);

	return (c1 && c2);
};


/**
 * INTERNAL FUNCTION used to determine if the input is an array or not
 */
adf.mf.internal.util.is_array = Array.isArray;

/**
 * INTERNAL FUNCTION appends array2, to array2. It does not create new array.
 */
adf.mf.internal.util.appendAll = function(array1, array2, array2From)
{
	if (!array2From) array2From = 0;
	for (var i = array2From; i < array2.length; i++)
		array1.push(array2[i]);
};

adf.mf.util.obfuscate = function(s) {
	return s.replace(/[a-zA-Z]/g, function(c) {
		return String.fromCharCode((c <= "Z"? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26);
	});
};

/**
 * Check if a string starts with another string
 *
 * @param {?string} findIn the string to check against
 * @param {?string} strToFind the string to look for
 * @return {boolean} true if findIn is a string and strToFind is a string and findIn starts with
 *         strToFind
 */
adf.mf.util.stringStartsWith = function(
	findIn,
	strToFind)
{
	return findIn != null &&
		strToFind != null &&
		strToFind.length > 0 &&
		findIn.length >= strToFind.length &&
		findIn.substring(0, strToFind.length) == strToFind;
};

/**
 * Check if a string ends with another string
 *
 * @param {?string} findIn the string to check against
 * @param {?string} strToFind the string to look for
 * @return {boolean} true if findIn is a string and strToFind is a string and findIn ends with
 *         strToFind
 */
adf.mf.util.stringEndsWith = function(
	findIn,
	strToFind)
{
	return findIn != null &&
		strToFind != null &&
		strToFind.length > 0 &&
		findIn.length >= strToFind.length &&
		findIn.substring(findIn.length - strToFind.length) == strToFind;
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Utilities.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adfel.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- Adfel.js ---------------------- */
// @requires ELErrors
//
// @requires JavaScriptContext

// @requires ELParser
// @requires TreeNode
// @requires Utilities
// @requires AdfPerfTiming
// @requires AdfResource
// @requires AdfLocale

var PERFMON    = true;

var adf                    = window.adf                 || {};
adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.el.parser.cache  = adf.mf.internal.el.parser.cache  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};



adf.mf.internal.api.constants = adf.mf.internal.api.constants || {
  'KEY_PROPERTY'            : '.key',
  'NULL_FLAG_PROPERTY'      : '.null',
  'TYPE_PROPERTY'           : '.type',
  'TRANSIENT_FLAG_PROPERTY' : '.transient',
  'EXCEPTION_FLAG_PROPERTY' : '.exception',
  'VALUE_REF_PROPERTY'      : '.valueref',
  'WEAK_REFERENCE_PROPERTY' : '.weakref',
  'DEFERRED_PROPERTY'       : '.deferred'
};

(function() {
  /**
   * The JavaScriptContext is basic the javascript model layer.  It is an EL
   * context for javascript.  So things like root level variables, functions,
   * .. as well as wrapping the VMChannel and other base platform items.
   */
  adf.mf.internal.context = new adf.mf.internal.el.JavaScriptContext();

  /**
   * Define a 'default' binding instance
   */
  var bindingInstances    = {};

  /**
   * Topic: Understanding_DataChangeListeners:
   *
   * There is one dataChangeListener for EACH individual variable we are monitoring for
   * changes.  So for the EL Expression #{a + b} there would be two dataChangeListeners
   * (one for 'a' and one for 'b').  Each of these dataChangeListers records are handled
   * independently, since we might actually be monitoring 'a' or 'b' already or as part
   * of another expression.  The dataChangeListeners record contains two arrays; one for
   * the all the unique IDs (EL Expressions) that we should be listening on, and one for
   * the callbacks to notify.
   *
   * Given that, when a data change listener (via addDataChangeListener) is registered,
   * the EL Expression is decomposed into all of it's individual variables where each
   * variable get their own dataChangeListner record.  So given the above EL Expression
   * (#{a + b}), there is an 'a' DCL and a 'b' DCL that would look something like this:
   *
   *   dataChangeListeners["a"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *   dataChangeListeners["b"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *
   * now if we then register the EL Expression #{a + c}, we would get something like this:
   *
   *   dataChangeListeners["a"] = { "id":["#{a + b}", "#{a + c}"]
   *                                "callback":[function() {...}, function() {...}] }
   *   dataChangeListeners["b"] = { "id":["#{a + b}"] "callback":[function() {...}] }
   *   dataChangeListeners["c"] = { "id":["#{a + c}"] "callback":[function() {...}] }
   *
   * Notice how the dataChangeListeners["a"]'s id and callback array grew and the
   * inclusion of the "c" dataChangeListener record.
   *
   * Now, when some data is changed in the CVM layer a data change event (DCE) is raised
   * and passed back on a VMChannel response message.  The native container framework then
   * pulls this DCE off the response and passes it to (javascript) processDataChangeEvent.
   * In this javascript function the DCE is disected and for each and every variable/provider
   * change in the DCE the following is done:
   *   1. data is updated in the JavaScriptContext
   *   2. determine if any registered data change listeners exists for that variable or provider.
   *      This is done by simply looking up the variable name in the dataChangeListeners map
   *      (i.e. name->dataChangeListeners records (described above)).
   *
   * Since the data change listener record contains all the registered ELs (id) and handlers
   * (callback), we simply send a notification to all the handlers with each of the registered
   * EL Expression (id in the code).
   *
   * So if we code that looked like this:
   *  adf.mf.api.addDataChangeListeners("#{a}",   fa);   // 1
   *  adf.mf.api.addDataChangeListeners("#{!a}",  fna);  // 2
   *  adf.mf.api.addDataChangeListeners("#{b}",   fb);   // 3
   *  adf.mf.api.addDataChangeListeners("#{a+b}", fab);  // 4
   *
   * Then we receive a data change event for a, then following notifications would
   * be emitted:
   *   fa(#{a})    // registered by line 1
   *   fna(#{!a})  // registered by line 2
   *   fab(#{a+b}) // registered by line 4
   * If we then recieve a data change event fo b, these notifications would be emitted:
   *   fb(#{b})    // registered by line 3
   *   fab(#{a+b}) // registered by line 4
   *
   * To unregister a data change listener simply call adf.mf.api.removeDataChangeListeners
   * i.e.
   *   adf.mf.api.removeDataChangeListeners("#{a+b}") // remove the line 4 listener
   *
   *
   * In addition to the data change listeners for individual EL expressions, one can register for
   * a bulk notification mechanism.  In this case, the framework will not attempt to map individual
   * ELs to specific callback, instead the registered callback(s) will be invoked with the list of
   * ELs that where changed.  This 'bulk' mechanism has some PROs and CONs.  It provides a single
   * notification with all the changed ELs allowing the handler to process all the changes in a single
   * call (allowing a single update event for multiple changes in components like a table).  However,
   * it does place the work of filtering/routing EL changes to the proper sub-component.
   *
   * NOTE: The providers detail will only contain itemized changes provided the 'itemized'
   *       property exists and is true.  Otherwise the entire collection model should be
   *       updated since no detailed information is known.  This detailed information is
   *       delivered as a map with the collection model id being the key.  The value of the
   *       property will be a provider change record in the following format:
   *
   *       {
   *         bindings.notes.collectionModel: {
   *           itemized: true;
   *           created: [0: {key: UID-3464; }];
   *           updated: [];
   *           deleted: [];
   *           dirtied: [];
   *         };
   *       }
   *
   *       where:
   *         itemized: true | false,  // true if created,updated, and deleted information is provided
   *         created:[ c-record ],    // right now only contains a single key property
   *         updated:[ ids ],         // list of IDs that have been updated
   *         deleted:[ ids ]          // list of IDs that have been deleted
   *         dirtied:[ ids ]          // list of IDs that have been updated
   *
   * To register a bulk data change listener the following should be done:
   *   adf.mf.api.addBatchDataChangeListener(variables, providers);
   *
   * Then we you will received data change events as follows:
   *   fa(["#{a}", "{#!a}", "#{a + b}"],
   *      {myCollectionModel:{itemized:true, created:[0: {key: UID-3464; }], updated:[], deleted:[], dirtied:[]})
   *
   */
  var dataChangeListeners                    = {};

  /**
   * INTERNAL: the array of global batch data change listeners
   */
  adf.mf.internal.batchDataChangeListeners   = [];

  /**
   * INTERNAL: the array of pending requests
   */
  adf.mf.internal.batchRequest               = undefined;

  /**
   * INTERNAL: storage for batching missing get local values.
   *
   *   @see adf.mf.api.startGetValueBatchRequest
   *  @see adf.mf.api.flushGetValueBatchRequest
   */
  adf.mf.internal.el.getValueBatch           = undefined;

  /**
   * INTERNAL FUNCTION used to log all errors coming back from the JVM.
   */
  adf.mf.internal.logError = function(req, resp)
  {
    var msg = adf.mf.resource.getInfoString("ADFErrorBundle", "ERROR_IN_REQUEST");
    adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "adf.mf.internal", "logError", msg);

    // For security, only log the error at a FINE level
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal", "logError",
        "Error in request: " + adf.mf.util.stringify(req) + ". Response: " +
        adf.mf.util.stringify(resp));
    }
  };
  adf.mf.internal.errorHandlers = [adf.mf.internal.logError];

  /**
   * PUBLIC FUNCTION used to add a new data change listener (callback) for a given el expression (variable)
   *
   * e.g.
   *   adf.mf.api.addDataChangeListeners("#{bindings.apple}",                   appleChangedCallback);
   *   adf.mf.api.addDataChangeListeners("#{bindgins.apple + bindings.orange}", appleOrOrangeChangedCallback);
   *
   *    adf.mf.api.addDataChangeListeners("#{!bindings.foo}",                    bindingsFooChangedCallback);
   *
   *   where the callback would looks something like this:
   *   bindingsFooChangedCallback = function(id)
   *   {
   *      document.write("DataChangeNotification 1 notification for ID: " + id);
   *   }
   *
   * If the same expression/listener combination is registered several times, duplicates are discarded.
   *
   * For more details see @Understanding_DataChangeListeners
   *
   * @export
   */
  adf.mf.api.addDataChangeListeners = function(expression, callback)
  {
    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);
    var variables  = expression.dependencies();
    var id         = expression;

    var perf = adf.mf.internal.perf.startMonitorCall("Add a new data change listener", adf.mf.log.level.FINE,
      "adf.mf.api.addDataChangeListeners");
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addDataChangeListeners",
          ("addDataChangeListeners " + expression + " ==> " + variables.length + " ==> " + variables.join()));
    }

    for (var v = 0; v < variables.length; ++v)
    {
      var alreadyRegistered = false;
      var variable          = variables[v];
      var dcl               = (variable.slice(0, "bindings".length) == "bindings")?
          currentBindingInstance.dataChangeListeners : dataChangeListeners;

      if (dcl[variable] === undefined)
      {   /* if currently we don't have a DCL record for this variable, create it */
        dcl[variable] = {"id":[], "callback":[]};
      };

      /* add the expression id to the dataChangeListeners */
      alreadyRegistered = false;
      for (var i = 0; i < dcl[variable]["id"].length; ++i)
      {
        if (dcl[variable]["id"][i] == id)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.api", "addDataChangeListeners",
                ("addDataChangeListener " + variable + " id=" + id + " was already registered."));
          }
          alreadyRegistered = true;
          break;  /* you only need to find one match */
        }
      }
      if (!alreadyRegistered)
      {
        dcl[variable]["id"].push(id);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
              ("there are now " + dcl[variable]["id"].length + " different listener's IDs."));
        }
      }

      alreadyRegistered = false;
      for (var i = 0; i < dcl[variable]["callback"].length; ++i)
      {
        if (dcl[variable]["callback"][i].toString() == callback.toString())
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
                ("variable " + variable + " already has this callback registered."));
          }

          alreadyRegistered = true;
          break;  /* you only need to find one match */
        }
      }
      if (!alreadyRegistered)
      {
        dcl[variable]["callback"].push(callback);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "addDataChangeListeners",
              ("there are now " + dcl[variable]["callback"].length + " different callbacks registered."));
        }
      }

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addDataChangeListeners",
            ("adding the " + variable + " " +  adf.mf.util.stringify(dcl[variable]) + " listener."));
      }
    }
    perf.stop();
  };

  /**
   * PUBLIC FUNCTION used to add a new bulk data change listener (callback)
   *
   * e.g.
   *   adf.mf.api.addBatchDataChangeListener(printBatchDataChangeEvent);
   *
   *   where the callback would looks something like this:
   *
   *   printBatchDataChangeEvent = function(variables, providers) {
   *     if(variables != undefined) {
   *       document.write("Batch DCE -- <br> variables = " + adf.mf.util.stringify(variables)+ "<br>");
   *     }
   *     if(providers!= undefined) {
   *       document.write(" providers =" + adf.mf.util.stringify(providers) + "<br>");
   *     }
   *   };
   *
   * If the same listener is registered several times, duplicates are discarded.
   *
   * NOTE: if the providers detail will only contain itemized changes provided the 'itemized'
   *       property exists and is true.  Otherwise the entire collection model should be updated
   *       since no detailed information is known.
   *
   * For more details see @Understanding_DataChangeListeners
   *
   * @export
   */
  adf.mf.api.addBatchDataChangeListener = function(callback)
  {
    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      if (adf.mf.internal.batchDataChangeListeners[i] == callback) return
    }
    adf.mf.internal.batchDataChangeListeners.push(callback);
  };

  /**
   * PUBLIC FUNCTION used to add a new error handler (callback)
   *
   * e.g.
   *   adf.mf.api.addErrorHandler(myErrorHandler);
   *
   *   where the callback would looks something like this:
   *   myErrorHandler = function(adfexception)
   *   {
   *      document.write("Error Handler 1 notification for: " + adfexception);
   *   }
   *
   * If the same handler is registered several times, duplicates are discarded.
   *
   * For more details see @Understanding_ErrorHandlers
   *
   * @export
   */
  adf.mf.api.addErrorHandler = function(callback)
  {
    for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
    {
      if (adf.mf.internal.errorHandlers[i] == callback) return
    }
    adf.mf.internal.errorHandlers.push(callback);
  };


  /**
   * PUBLIC FUNCTION used to get the current context ID.
   *
   * e.g. adf.mf.api.getContextId(successCallback, failedCallback);
   *
   * @deprecated
   * @export
   */
  /* void */
  adf.mf.api.getContextId = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextId", success, failed);
  };


  /**
   * PUBLIC FUNCTION used to get the current context's pagedef.
   *
   * e.g. adf.mf.api.getContextId(success, failed);
   *
   * @export
   */
  /* void */
  adf.mf.api.getContextPageDef = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextPageDef", success, failed);
  };


  /**
   * PUBLIC FINCTION used to get the current context's instance ID
   *
   * @export
   */
  /* void */
  adf.mf.api.getContextInstanceId = function(success, failed)
  {
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getContextInstanceId", success, failed);
  };



  /**
   * PUBLIC FUNCTION used to invoke method in any class in classpath.
   *
   * e.g. adf.mf.api.invokeMethod(classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
   *
   * @param {string}                               classname  - name of the class
   * @param {string}                               methodname - name of the method
   * @param {Array.<string>}                       params     - parameters
   * @param {Array.<function(Object,Object):void>} success    - invoked when the method is successful invoked
   *                                                            (signature: success(request, response))
   * @param {Array.<function(Object,Object):void>} failed     - invoked when an error is encountered
   *                                                            (signature: failed(request, response))
   *
   * Examples:
   *      adf.mf.api.invokeMethod("TestBean", "setStringProp", "foo", success, failed);
   *      adf.mf.api.invokeMethod("TestBean", "getStringProp", success, failed);
   *      adf.mf.api.invokeMethod("TestBean", "testSimpleIntMethod", "101", success, failed); // Integer parameter
   *      adf.mf.api.invokeMethod("TestBean", "testComplexMethod",
   *              {"foo":"newfoo","baz":"newbaz",".type":"TestBeanComplexSubType"}, success, failed); // Comples parameter
   *      adf.mf.api.invokeMethod("TestBean", "getComplexColl", success, failed); // No parameter
   *      adf.mf.api.invokeMethod("TestBean", "testMethodStringStringString", "Hello ", "World", success, failed); // 2 string parameter
   */
  adf.mf.api.invokeMethod = function()
  {
    var args = [].splice.call(arguments,0);   // convert arguments into a real array

    var updatedArgs = [null];  // adding the default communication id

    adf.mf.internal.api.invokeMethod.apply(this, updatedArgs.concat(args));
  };

  /**
   * PUBLIC FUNCTION used to invoke Security Methods
   */
  adf.mf.api.invokeSecurityMethod = function(command, username, password, tenantname, success, failed)
  {
    adf.mf.internal.context.invokeSecurityMethod(command, username, password, tenantname, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to remove all data change listeners associated with the variable
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.removeDataChangeListeners = function(expression)
  {
    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);
    var variables  = expression.dependencies();
    var id         = expression;

    for (var i = 0; i < variables.length; ++i)
    {
      var v   = variables[i];
      var dcl = ((v.slice(0, "bindings".length) == "bindings")?
          currentBindingInstance.dataChangeListeners : dataChangeListeners);

      try
      {
        var ida = dcl[v]["id"];
        for (var j = 0; j < ida.length; ++j)
        {
          if (ida[j] === id)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf", "removeDataChangeListeners",
                  ("removing the " + adf.mf.util.stringify(ida[j]) + " listener."));
            }
            ida.splice(j,1);
          }
        }
        if (ida.length == 0)
        {
          // clean up the dataChangeListener all together
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf", "removeDataChangeListeners",
              ("removing the " + ida + " listener all together."));
          }
          delete dcl[v];
        }
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf", "removeDataChangeListeners",
              ("All the current data change listeners in the system:<br> " +
                  adf.mf.util.stringify(dcl)));
        }
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.SEVERE))
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.api.removeDataChangeListeners", "ERROR_EXCEPTION");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.api", "removeDataChangeListeners",
              "Exception: " + e);
          }
        }
      }
    }
  };


  /**
   * PUBLIC FUNCTION used to remove a bulk data change listener
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.removeBatchDataChangeListener = function(callback)
  {
    var temp = [];

    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      if (adf.mf.internal.batchDataChangeListeners[i] != callback)
      {
        temp.push(adf.mf.internal.batchDataChangeListeners[i]);
      }
    }
    adf.mf.internal.batchDataChangeListeners = temp;
  };


  /**
   * PUBLIC FUNCTION used to remove an error handler
   *
   * For more details see @Understanding_ErrorHandlers
   */
  adf.mf.api.removeErrorHandler = function(callback)
  {
    var temp = [];

    for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
    {
      if (adf.mf.internal.errorHandlers[i] != callback)
      {
        temp.push(adf.mf.internal.errorHandlers[i]);
      }
    }
    adf.mf.internal.errorHandlers = temp;
  };


  /**
   * PUBLIC FUNCTION used to reset context. Call this before setting new context.
   * This is exactly the same as calling adf.mf.api.setContext with an empty context name.
   *
   * e.g. adf.mf.api.removeContextInstance(successCallback, failedCallback);
   */
  adf.mf.api.removeContextInstance = function(pageDef, instanceId, success, failed)
  {
    adf.mf.internal.el.resetBindingContext();
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model",
        "removeContextInstance", pageDef, instanceId, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to reset context. Call this before setting new context.
   * This is exactly the same as calling adf.mf.api.setContext with an empty context name.
   *
   * e.g. adf.mf.api.resetContext(successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.resetContext = function(success, failed)
  {
    adf.mf.api.setContext("", success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set context for the specified name
   *
   * e.g. adf.mf.api.setContext("MyPage", "MyPage-1", true, true, successCallback, failedCallback);
   *
   * pageDef    - name of the page definition
   * instanceId - unique id for the instance
   * resetState - reset the bindings associated with this instance
   * reSync     - re-send the initial bindings structure to the container
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  adf.mf.api.setContextInstance = function(pageDef, instanceId, resetState, /* boolean */reSync, success, failed)
  {
    adf.mf.api.setCurrentContext(pageDef, resetState, reSync, true, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set the current context.
   *
   * e.g. adf.mf.api.setCurrentContext("MyPage", true, true, true, successCallback, failedCallback);
   *
   * pageDef      - name of the page definition
   * resetState   - reset the bindings associated with this instance
   * reSync       - re-send the initial bindings structure to the container
   * newViewScope - should a new viewScope also be initialized, releasing the previous one?
   */
  adf.mf.api.setCurrentContext = function(pageDef, resetState, reSync, newViewScope, success, failed)
  {
    try
    {
      if ((pageDef === undefined) || (pageDef === null) || (pageDef.length < 1))
      {
        //
        // clear all the bindings and listeners associated with this context.
        //
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf", "setCurrentContext",
            ("\n\n*******\nBindings = " +
            adf.mf.util.stringify(adf.mf.api.getLocalValue("#{bindings}")) + "\n*******\n\n"));
        }
        adf.mf.api.removeContextInstance(pageDef, null, success, failed);
      }
      else
      {
        adf.mf.internal.el.switchBindingInstance(pageDef);
        adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setCurrentContext",
            pageDef, resetState, reSync, newViewScope, success, failed);
      }
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setCurrentContext", "ERROR_SET_CONTEXT_EXCEPTION");

      // For security, only log the error at a FINE level
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setCurrentContext", ge);
    }
  };


  /**
   * PUBLIC FUNCTION used to clear and then set context for the specified name
   *
   * @param name    - name of the context
   * @param success - call on success
   * @param failed  - call on failed
   *
   * this is the same as calling adf.mf.internal.api.setContext(name, true, success, failed);
   *
   * e.g. adf.mf.api.setContext("myContextName", successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.clearAndSetContext = function(/* context name */ name, success, failed)
  {
    adf.mf.internal.api.setContext(name, true, success, failed);
  };

  /**
   * PUBLIC FUNCTION used to set context for the specified name
   *
   * @param name    - name of the context
   * @param success - call on success
   * @param failed  - call on failed
   *
   * this is the same as calling adf.mf.internal.api.setContext(name, false, success, failed);
   *
   * e.g. adf.mf.api.setContext("myContextName", successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.api.setContext = function(/* context name */ name, success, failed)
  {
    adf.mf.internal.api.setContext(name, false, success, failed);
  };

  /**
   * INTERNAL FUNCTION used to set context for the specified name
   *
   * @param name       - name of the context
   * @param clearPrior - true for clear the current context
   * @param success    - call on success
   * @param failed     - call on failed
   *
   * e.g. adf.mf.api.setContext("myContextName", true, successCallback, failedCallback);
   *
   * @deprecated use adf.mf.api.setCurrentContext instead.
   */
  /* void */
  adf.mf.internal.api.setContext = function(/* String */ name, /* boolean */clearPrior, success, failed)
  {
    adf.mf.api.setCurrentContext(name, true, true, true, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as adding
   * a variable to the root namespace for variables.
   *
   * i.e. adf.mf.api.addVariable("name", some_object);
   *
   * addVariable/removeVariable are used to add and then remove
   * temporary variables, like loop iterator variables along with
   * longer lasting variables.
   */
  /* void */
  adf.mf.el.addVariable = function(/* variable name */ name, /* new value */ value)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "addVariable", name);
    adf.mf.internal.context.setVariable(name, value);
  };
  adf.mf.api.addVariable = adf.mf.el.addVariable;


  /**
   * PUBLIC FUNCTION will evaluate the passed in expression against
   * the local cache ONLY.  If there are terms that are currently
   * not cached or any function calls then undefined will be returned.
   * If the adf.mf.api.startGetValueBatchRequest has been called any
   * EL expression cache misses will be queued to fetched on the
   * adf.mf.api.flushGetValueBatchRequest call.
   *
   * @see adf.mf.api.addVariable
   * @see adf.mf.api.removeVariable
   *
   * @see adf.mf.api.getValue
   * @see adf.mf.api.setValue
   * @see adf.mf.api.setLocalValue
   *
   * @see adf.mf.api.startGetValueBatchRequest
   * @see adf.mf.api.flushGetValueBatchRequest
   */
  adf.mf.el.getLocalValue = function(/* expression */ expression)
  {
    var val = undefined;

    if (!expression.tokens)
      expression = adf.mf.internal.el.parser.parse(expression);

    var addToBatch = false;
    var context = adf.mf.internal.context;

    try
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "getLocalValue", expression.getExpression());
      adf.mf.internal.el.indexedExpressionUnresolved = false;
      val = expression.evaluate(context);

      // Check if the and indexed expression was unable to get its value. If so
      // no error is thrown, so add the term to the batch
      if (adf.mf.internal.el.indexedExpressionUnresolved)
      {
        addToBatch = true;
      }

      // If the return value of a local value is an object that has yet to be loaded from the embedded side, force
      // it to undefined and treat it as a cache miss to go and fetch the value
      if (val instanceof Object && val[".loaded"] === false)
      {
        addToBatch = true;
        val = undefined;
      }
    }
    catch(e1)
    {
      addToBatch = true;
    }
    finally
    {
      delete adf.mf.internal.el.indexedExpressionUnresolved;
    }

    if (addToBatch)
    {
      // expression was not found
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getLocalValue",
          ("unable to resolve '" + expression.getExpression() + "' locally."));
      }

      // NOTE: only if the internal batch is defined will we batch the
      // expression to fetch when adf.mf.api.flushGetValueBatchRequest.
      if (adf.mf.internal.el.getValueBatch !== undefined)
      {
        var batch = adf.mf.internal.el.getValueBatch;

        try
        {
          var exp   = expression.stripLocalValues(true, undefined, true);
          var terms = exp.getELTerms();

          for (var t = 0; t < terms.length; ++t)
          {
            var term = terms[t];

            addToBatch = false;

            try
            {
              // Detect when properties were not found in indexed expressions
              // (no exceptions thrown for those)
              adf.mf.internal.el.indexedExpressionUnresolved = false;

              var result = term.evaluate(context);

              if (adf.mf.internal.el.indexedExpressionUnresolved ||
                (result instanceof Object && result[".loaded"] === false))
              {
                addToBatch = true
              }
            }
            catch(e3)
            {
              addToBatch = true;
            }
            finally
            {
              delete adf.mf.internal.el.indexedExpressionUnresolved;
            }

            if (addToBatch)
            {
              batch.push(term.getExpression());

              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.api", "getLocalValue",
                    "we currently do not have term: " + term + " cached, adding to the batch.");
              }
            }
          }
        }
        catch(e2)
        {
          // the only way you would get here is if the EL Expression can not be parsed

          // Look to see if there is any registered error handlers and call them.
          adf.mf.internal.api.notifyErrorHandlers(expression.getExpression (), e2);


          // Since the bulk of the callers do not handle exceptions well we are going
          // to simply return the exception as the value.  This is similar to what we
          // do in getValues so there is no difference here.  The UI should look at
          // the value and handle it correctly.
          val = e2;
        }
      }
    }

    return val;
  };

  adf.mf.api.getLocalValue = adf.mf.el.getLocalValue;

  /**
   * startGetValueBatchRequest is responsible for starting a new get value
   * batch so theproper "behind the scene" call to get the values can be
   * called at the flushGetValueBatchRequest call.
   *
   * @see adf.mf.api.startGetValueBatchRequest
   */
  /* void */
  adf.mf.el.startGetValueBatchRequest = function()
  {
    if (adf.mf.internal.el.getValueBatch !== undefined)
    {
      throw new adf.mf.ELException("GetValueBatchRequest already started");
    }
    else
    {
      adf.mf.internal.el.getValueBatch = [];
    }
  };
  adf.mf.api.startGetValueBatchRequest = adf.mf.el.startGetValueBatchRequest;

  /**
   * @returns the list of all terms used in any of the ELs
   */
  /* String[] */
  adf.mf.internal.el.getListOfTerms = function(/* array */ els)
  {
    var variables = els || [];
    var terms     = [];
    var length    = 0;

    variables = adf.mf.internal.util.is_array(variables)? variables : [variables];
    length    = variables.length;

    for (var i = 0; i < length; ++i)
    {
      var ele   = adf.mf.internal.el.parser.parse(variables[i]);

      if ((ele !== undefined) || (ele !== null))
      {
        terms  = terms.concat(ele.dependencies());
      }
    }
    return terms;
  };


  /**
   * flushGetValueBatchRequest is responsible for closing off the current
   * batch and make the proper "behind the scene" call to get the values.
   *
   * @see adf.mf.api.startGetValueBatchRequest
   */
  /* void */
  adf.mf.el.flushGetValueBatchRequest = function()
  {
    if (adf.mf.internal.el.getValueBatch !== undefined)
    {
      if (adf.mf.internal.el.getValueBatch.length > 0)
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Close current batch request", adf.mf.log.level.FINER,
          "adf.mf.api.flushGetValueBatchRequest");

        adf.mf.api.getValue(adf.mf.util.removeDuplicates(adf.mf.internal.el.getValueBatch),
          function(a,b)
          {
            try
            {
              var terms = adf.mf.internal.el.getListOfTerms(a.params[0]);

              adf.mf.internal.api.notifyDataChangeListeners(terms);
              perf.stop();
            }
            catch(e)
            {
              perf.stop();
            }
          },
          function(a, b)
          {
            perf.stop();
          });
      }

      adf.mf.internal.el.getValueBatch = undefined;
    }
    else
    {
      throw new adf.mf.IllegalStateException("No get value batch started.");
    }
  };
  adf.mf.api.flushGetValueBatchRequest = adf.mf.el.flushGetValueBatchRequest;



  /**
   * PUBLIC FUNCTION used to evaluate the expression(s) passed in and return the associated
   * value(s) via the success callback.  Since not all variables may not be resolved only the
   * resolved expressions will be returned in the 'response' property of the success callback.
   *
   * Given that you can use this method to get the value for:
   *
   * Evaluation of a single EL expression:
   * e.g. adf.mf.api.getValue("#{100+2*20/3}", success, failed);
   * e.g. adf.mf.api.getValue("#{bindings.userName.inputValue}", success, failed);
   *
   * Evaluation of an array of EL expressions:
   * e.g. adf.mf.api.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
   * e.g. adf.mf.api.getValue(["#{bindings.foo}", "#{applicationScope.username}"], success, failed);
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.getValue("#{100+2*20/3}", success, failed);
   *        success(["#{100+2*20/3}"], [ {name:"#{100+2*20/3}", value:"113.33"} ] )
   *
   *   e.g. adf.mf.api.getValue("#{bindings.userName.inputValue}", success, failed);
   *        success(["#{bindings.userName.inputValue}"], [ {name:"#{bindings.userName.inputValue}", value:"me"} ] )
   *
   *   e.g. adf.mf.api.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
   *        success(["#{100+2*20/3}", "#{500/2}"],
   *                [ {name:"#{100+2*20/3}", value:"113.33"}, {name:"#{500/2}", value:"250"} ] )
   *
   * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
   * e.g. adf.mf.api.getValue( ["#{bindings.foo}", "#{bindings.bar}"], success, failed);
   *        success(["#{bindings.foo}", "#{bindings.bar}"],
   *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
   *          *** notice: binding.bar was not part of the result array
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   *
   * There also exists another way to invoke the getValue used to resolve a property from an already
   * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
   * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
   * the "right thing to do" based on the 'base' and 'property' variables:
   *
   * e.g. adf.mf.api.getValue(base, property);
   *   where the value returned is value of the property or nil if it does not exists.
   **/
  adf.mf.el.getValue = function()
  {
    var argv  = arguments;
    var argc  = arguments.length;

    if (argc!=4 && argc!=3 && argc!=2)
    {
      throw new adf.mf.ELException("Wrong number of arguments");
    }

    try
    {
      if (typeof(argv[1])!='object' && (argv[1] instanceof Function))
      {
        /*
         * Note: in order to make [gs]etValue individual errors show up in the error view
         *       we will inject a nvpSimulatedErrors callback into the success callback vector.
         *       We only need to include it in the success because the failed will automatically
         *       be routed to the error handlers (see JavaScriptContext.nonBlockingCall)
         */
        var expression     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
        var success        = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
        var failed         = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];
        var errorHandler   = ((argc == 4) && (argv[3] == true))?
            adf.mf.internal.api.nvpEatErrors :
              adf.mf.internal.api.nvpSimulatedErrors;
        var perf           = adf.mf.internal.perf.startMonitorCall("Evaluate EL expression", adf.mf.log.level.FINER,
          "adf.mf.api.getValue");
        var scb            = [errorHandler,
                              function() { perf.stop(); }];
        var fcb            = [function() { perf.stop(); }];

        expression = arrayToEL (expression);
        try
        {
          var count = expression.length;
          var nvpa  = [];

          for (var i = 0; i < count; i++)
          {
            var temp = undefined;

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.el","getValue", "evaluating locally" + expression[i].getExpression());
            }

            if ((temp = expression[i].evaluate(adf.mf.internal.context)) === undefined)
            {
              throw new adf.mf.PropertyNotFoundException(expression[i].getExpression());
            }
            else
            {
              nvpa.push({"name":expression[i].getExpression(), "expression":expression[i], "value":temp});
            }
          }

          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
                ("adfmf- did not call the server for " + expression.join(", ")));
          }

          // Found everything locally
          perf.stop();
          for (var i = 0; i < success.length; ++i)
          {
            try
            {
              success[i](expression, nvpa);
            }
            catch(fe)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.api.getValue", "ERROR_GETVALUE_SUCCESS_CB_ERROR", i);

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue", fe);
            }
          }
        }
        catch (e)
        {
          var terms = getTerms (expression);

          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
                ("adfmf- needs to call the server for " + terms.join(", ")));
          }
          /* inject the addtional callbacks for: caching and peformance */
          scb     = scb.concat(adf.mf.internal.el.cacheResult, success);
          fcb     = fcb.concat(failed);
          adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "getValue", terms, scb, fcb);
        }
      }
      else
      {
        var base = argv[0];
        var property = argv[1];
        value = adf.mf.internal.context.getELResolver().getValue(adf.mf.internal.context, base,
          property);
      }
    }
    catch(ge)
    {
      var expression = (adf.mf.internal.util.is_array(argv[0])) ? argv[0] : [argv[0]];
      var failed = (adf.mf.internal.util.is_array(argv[2])) ? argv[2] : [argv[2]];

      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.getValue", "ERROR_EXCEPTION_RESOLVING");

      // For security, only log the EL expression and exception at a FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue",
          "Error evaluting EL expression: " + expression.join(", ") + " exception: " + ge);
      }

      perf.stop();
      for (var i = 0; i < failed.length; ++i)
      {
        try
        {
          failed[i](expression, ge);
        }
        catch(fe)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.api.getValue", "ERROR_GETVALUE_FAILED_CB_ERROR", i);

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "getValue", fe);
        }
      }
    }
  };
  adf.mf.api.getValue = adf.mf.el.getValue;

  /**
   * Returns array of terms for given array of expressions.
   *
   * @param {Array} expressions
   * @returns {Array}
   */
  function getTerms(expressions)
  {
    var map = {};
    for (var i = 0; i < expressions.length; i++)
    {
      var exp = expressions[i];
      var terms = exp.getELTerms();

      for (var j = 0; j < terms.length; j++)
      {
        var term = adf.mf.internal.context.uncompressReference(terms[j]);

        //  If the term is the same as the original expression then we don't want
        //  add it to the result collection a second time.
        if (term.getExpression() != exp.getExpression())
        {
          map[term.getExpression()] = true;
        }
      }
    }
    var result = [];
    for (var i = 0; i < expressions.length; i++)
    {
      result.push(expressions[i].getExpression());
    }
    for (var t in map)
    {
      result.push (t);
    }

    return result;
  }

  /**
   * Converts array of strings to array of ELExpressions.
   *
   * @param {type} expressions
   * @returns {Array}
   */
  function arrayToEL(expressions)
  {
    if (expressions[0].tokens)
      return expressions;
    var elExpressions = [];
    for (var i = 0; i < expressions.length; i++)
    {
      elExpressions.push (adf.mf.internal.el.parser.parse (expressions[i]));
    }
    return elExpressions;
  }

  /**
   * PUBLIC FUNCTION used to used to invoke a method expression in the java environment.
   *
   * expression: is the method expression itself
   *             i.e. #{bean.method}  #{applicationScope.bean.method}
   * params    : is an array of zero or more values that should be passed as the method parameters
   *             i.e. []                      - to invoke bean.method()
   *             or ["Hello"]                 - to invoke bean.method(String)
   *             or [[false, false], "Hello"] - to invoke bean.method(boolean[], String)
   * returnType: is the return type
   *             i.e. void                    -
   *             i.e. String                  - return type is a string
   * types     : i.e. []                      - no parameters
   *             i.e. [java.lang.String]      - one parameter of type String
   *             i.e. [java.lang.String, int] - parameter-1 of type String, parameter-2 of type int
   *
   * Given this information the correct method will be looked up and invoked from the given method.
   *
   * Evaluation of a single EL expression:
   * e.g. invoke("#{Bean.foobar}", [parameters], [parameter-types], success, failed);
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.invoke("#{Bean.foobar}", [], "java.lang.String", [], success, failed);
   *        success({method:"#{Bean.foobar}" arguments:[]}, {result:....} )
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   **/
  adf.mf.el.invoke = function(expression, params, returnType, types, success, failed)
  {
    if (expression && expression.getExpression)
      expression = expression.getExpression ();
    adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "evaluateMethodExpression",
        expression, params, returnType, types, success, failed);
  };


  /**
   * PUBLIC FUNCTION used to update a value for a given variable expression.
   * Since variable expressions are the only type of expressions that can be LHS
   * (left-hand-side) expressions we can rule out all literal, complex, and method
   * expressions from the possible input.
   *
   * A simple name-value-pair object is used to denote the variable expression (name)
   * with it's desired value (value).  An example of this would be:
   *       { "name":"#{applicationScope.foo}", value:"foobar" }
   *
   * Similar to the getValue function, the setValue can take a single name-value-pair
   * or an array of them for doing batch sets.  The following examples will highlight
   * these cases:
   *
   * Passing only a single name-value-pair
   * e.g. adf.mf.api.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
   *      resulting in the bindings.foo variable being assigned foo
   *
   * Passing an array of name-value-pairs
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *      resulting in the bindings.foo variable being assigned foo and
   *                       bindings.bar variable being assigned bar
   *
   *
   * Success Callback:
   * success(request, response)
   *   where the request echos the first argument passed in
   *     and the response is an array of name-value-pairs, one for each resolved expression.
   * so if we take our examples above:
   *   e.g. adf.mf.api.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
   *        success(["{ "name": "#{bindings.foo}", "value": "foo" }"], [ { "name": "#{bindings.foo}", "value": "foo" } ] )
   *
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *        success([{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }],
   *                [{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }] )
   *
   * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
   * e.g. adf.mf.api.setValue( [{ "name": "#{bindings.foo}", "value": "foo" },
   *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
   *        success([{ "name": "#{bindings.foo}", "value": "foo" },
   *                 { "name": "#{bindings.bar}", "value": "bar" }],
   *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
   *          *** notice: binding.bar was not part of the result array
   *
   * Failed Callback:
   * failed(request, exception)
   *   where the request echos the first argument passed in
   *     and the exception encountered resulting in all of the expressions failing to be resolved
   *
   * There also exists another way to invoke the setValue used to set a property from an already
   * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
   * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
   * the "right thing to do" based on the 'base' and 'property' variables:
   *
   * e.g. adf.mf.api.setValue(base, property, value);
   *   where the base.property is assigned the value of 'value'
   *
   **/
  adf.mf.el.setValue = function()
  {
    var argv  = arguments;
    var argc  = arguments.length;

    if (argc != 3)
    {
      throw new adf.mf.ELException("Wrong number of arguments");
    }

    try
    {
      /*
       * Note: in order to make [gs]etValue individual errors show up in the error view
       *       we will inject a nvpSimulatedErrors callback into the success callback vector.
       *       We only need to include it in the success because the failed will automatically
       *       be routed to the error handlers (see JavaScriptContext.nonBlockingCall)
       */
      var nvp     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
      var success = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
      var failed  = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];
      var scb     = [];
      var fcb     = [];
      var perf    = adf.mf.internal.perf.startMonitorCall("Set EL value", adf.mf.log.level.FINER, "adf.mf.api.setValue");

      if (success[0] instanceof Function)
      {
        if (adf.mf.internal.isJavaAvailable())
        {  /* since java is available we need to also do the remote write */
          var nvp1 = [];
          for (var i = 0; i < nvp.length; ++i)
          {
            if (!nvp[i].expression)
              nvp[i].expression = adf.mf.internal.el.parser.parse(nvp[i].name);
            var uncompressedEL = adf.mf.internal.context.uncompressReference(nvp[i].expression);
            nvp[i].expression = uncompressedEL;
            var uncompressedELString = uncompressedEL.getExpression ();
            var v = {name: uncompressedELString, value: nvp[i].value};
            if (nvp[i][adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]])
            {
              v[adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]] = true;
            }
            nvp1.push (v);
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
            "We now have the uncompressed terms.");

          var rscb = [];

          rscb = rscb.concat([adf.mf.internal.api.nvpSimulatedErrors]);
          rscb = rscb.concat([function() { perf.stop(); }]);
          rscb = rscb.concat(success);

          scb = scb.concat(function()
          {
            adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "setValue", nvp1, rscb, failed);
          });
          fcb = scb.concat(failed);
        }
        else
        {
          // since java is _NOT_ available store the value locally and notify the data change
          // listeners (ndcl)
          for (var i = 0; i < nvp.length; ++i)
          {
            if (!nvp[i].expression)
              nvp[i].expression = adf.mf.internal.el.parser.parse(nvp[i].name);
            var uncompressedEL = adf.mf.internal.context.uncompressReference(nvp[i].expression);
            nvp[i].expression = uncompressedEL;
            nvp[i].name = uncompressedEL.getExpression();
          }

          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
            "We now have the uncompressed terms.");

          var  ndcl = undefined;

          ndcl = [
            function()
            {
              for (var v = 0; v < nvp.length; ++v)
              {
                var terms = nvp[v].expression.dependencies();
                adf.mf.internal.api.notifyDataChangeListeners(terms);
              }
            }];

          scb = ndcl.concat(function() { perf.stop(); });
          scb = scb.concat(success);

          fcb = ndcl.concat(function() { perf.stop(); });
          fcb = fcb.concat(failed);
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "adf.mf.api.setValue", "WARN_SKIP_REMOTE_WRITE");
        }

        adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "setValue",
          "now calling setLocalValue");

        adf.mf.api.setLocalValue(nvp, scb, fcb);
      }
      else
      {
        var base     = argv[0];
        var property = argv[1];
        var value    = argv[2];

        adf.mf.internal.context.getELResolver().setValue(adf.mf.internal.context, base, property,
          value);
        perf.stop();
      }
    }
    catch(ge)
    {
      perf.stop();
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setValue", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setValue", fe);
    }
    finally
    {
      // nothing more that needs to be done here.
    }
  };
  adf.mf.api.setValue = adf.mf.el.setValue;

  /**
   * PUBLIC FUNCTION used to set the value only on the javascript side.
   *
   * @see adf.mf.api.setValue
   */
  adf.mf.el.setLocalValue = function()
  {
    // no-value

    try
    {
      if (arguments.length != 3)
      {
        var errMsg = adf.mf.internal.resource.getResourceStringImpl("ADFErrorBundle",
          "ERROR_INCORRECT_NUM_ARGS_PASSED");
        throw new adf.mf.ELException(errMsg);
      }

      var argv    = arguments;
      var nvp     = (adf.mf.internal.util.is_array(argv[0]))? argv[0] : [argv[0]];
      var success = (adf.mf.internal.util.is_array(argv[1]))? argv[1] : [argv[1]];
      var failed  = (adf.mf.internal.util.is_array(argv[2]))? argv[2] : [argv[2]];

      if (success[0] instanceof Function)
      {
        try
        {
          var count = nvp.length;
          for (var i = 0; i < count; i++)
          {
            var nvpi = nvp[i];
            var n = nvpi.name;
            if (!nvpi.expression)
              nvpi.expression = adf.mf.internal.el.parser.parse(nvpi.name);
            var v = nvpi.value;

            if (nvpi != null &&
              nvpi[adf.mf.internal.api.constants.VALUE_REF_PROPERTY] !== undefined)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                  ("adfmf- not caching '" + n + "' because it is value reference."));
              }
            }
            else
              if (nvpi != null &&
                nvpi[adf.mf.internal.api.constants.TRANSIENT_FLAG_PROPERTY] !== undefined)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                    ("adfmf- not caching '" + n + "' because it is transient."));
                }
              }
              else
              {
                nvpi.expression.setValue(adf.mf.internal.context, v);

                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                    ("adfmf- setting local value : " + n));
                }
              }
          }
        }
        catch(e1)
        {
          try
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_FAILED");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", e1);

            for (var i = 0; i < failed.length; ++i)
            {
              failed[i](nvp, e1);
            }

            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
                ("set local value failed callback has been executed."));
            }
          }
          catch(e2)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_FAILED_CB");

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", fe);
          }
          return;
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
            "set local value is now complete and now calling the success callback(s)");
        }

        for (var i = 0; i < success.length; ++i)
        {
          try
          {
            success[i](nvp, nvp);
          }
          catch(fe)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.setLocalValue", "ERROR_SET_LOCAL_VALUE_SUCCESS_CB_FAILED", i);

            // Only log the exception at a fine level for security reasons
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", fe);
          }
        }

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue",
            "set local value is now complete and " + success.length +
            " success callback has been executed.");
        }
      }
      else
      {
        var base     = argv[0];
        var property = argv[1];
        var value    = argv[2];

        adf.mf.internal.context.getELResolver().setValue(adf.mf.internal.context, base, property,
          value);

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
            "adf.mf.api", "setLocalValue",
            "context.getELResolver().setValue" + base + "." + property);
        }
      }
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.setLocalValue", "ERROR_EXCEPTION");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "setLocalValue", ge);
    }
    finally
    {
      // no-value
    }
  };
  adf.mf.api.setLocalValue = adf.mf.el.setLocalValue;


  /**
   * PUBLIC FUNCTION used to remove a top-level variable
   * from the context.  This should be thought of as removing
   * a variable from the root namespace for variables.
   *
   * i.e. adf.mf.api.removeVariable("name");
   */
  /* void */
  adf.mf.el.removeVariable = function(/* variable name */ name)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST, "adf.mf.api", "removeVariable", name);
    adf.mf.internal.context.removeVariable(name);
    // no-value
  };
  adf.mf.api.removeVariable = adf.mf.el.removeVariable;

  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as adding
   * a variable to the root namespace for variables.
   *
   * i.e. adf.mf.api.setVariable("name", some_object);
   *
   * Most of the time the 'some_object' will be a property
   * map.  So we can do things like:
   *   adf.mf.api.getValue("${name.property}");
   */
  /* void */
  adf.mf.el.setVariable = function(/* variable name */ name, /* new value */ value)
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Add a top-level variable", adf.mf.log.level.FINEST,
      "adf.mf.api.setVariable");
    try
    {
      adf.mf.internal.context.setVariable(name, value);
      adf.mf.internal.api.notifyDataChangeListeners(name);
    }
    finally
    {
      perf.stop();
    }
  };
  adf.mf.api.setVariable = adf.mf.el.setVariable;

  /**
   * PUBLIC FUNCTION used to create a top-level variable
   * into the context.  This should be thought of as pushing
   * a variable onto the root namespace for variables.
   *
   * i.e. adf.mf.api.pushVariable("name", some_object);
   *
   * Most of the time the 'some_object' will be a property
   * map.  So we can do things like:
   *   adf.mf.api.getValue("${name.property}");
   *
   * NOTE: This call will _NOT_ generate a data change event.
   */
  /* void */
  adf.mf.el.pushVariable = function(/* variable name */ name, /* new value */ value)
  {
    adf.mf.internal.context.pushVariable(name, value);
  };
  adf.mf.api.pushVariable = adf.mf.el.pushVariable;

  /**
   * PUBLIC FUNCTION used to pop a top-level variable
   * from the context.  This should be thought of as poping
   * a variable off the root namespace for variables.
   *
   * i.e. adf.mf.api.popVariable("name");
   *
   * NOTE: This call will _NOT_ generate a data change event.
   */
  /* void */
  adf.mf.el.popVariable = function(/* variable name */ name)
  {
    adf.mf.internal.context.popVariable(name);
  };
  adf.mf.api.popVariable = adf.mf.el.popVariable;

  /**
   * PUBLIC FUNCTION used to process the data change event associated with response messages.
   *
   * DataChangeEvents can be sent as their own request message or as part of _any_ response
   * message.  This event is sent to inform the javascript side that some data was side-effected
   * in the CVM layer and should be propagated into the javascript cache as well as notify the
   * user interface of the change.  This event has the following JSON represention:
   *
   * DataChangeEvent
   * {
   *    variableChanges: {
   *         elExpression:value
   *         ...
   *    }
   *    providerChanges: {
   *      providerId: {
   *         <operation>:{
   *            current_row_key: { properties filtered by node }
   *            ...
   *         }
   *             ...
   *      }
   *      ...
   *    }
   * }
   *
   * Given that, we need to do the following for each data change event:
   * Variable Changes:
   *    set the value in the local cache
   *    notify anyone interested in that variable, that it has changed.
   *
   * Provider Changes:
   *    on Create:
   *      set the value in the local cache
   *    on Update:
   *      set the value in the local cache
   *      notify anyone interested in that variable, that it has changed.
   *    on Create:
   *      remove the value from the local cache
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.api.processDataChangeEvent = function(/* DataChangeEvent */ dce)
  {
    var dcevs  = [];  /* data change event variables  */
    var pdces  = {};  /* provider data change details */

    var perfOp = adf.mf.internal.perf.startMonitorOperation("Process data change event", adf.mf.log.level.FINER,
      "adf.mf.api.processDataChangeEvent");

    try
    {
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent",
            ("processing a data change event with " + adf.mf.util.stringify(dce)));
      }

      try
      {
        var hasMoreKeysVariableChanges = {};
        var va;
        // Due to the way the API was created, the embedded side will always fire hasMoreKeys
        // data change events even when the value does not change (the API has no concept of the
        // current value, so has nothing to compare against). The problem with this is that
        // data change events may be expensive to process (like an AMX node tree visit). It
        // should be faster to check these values and ensure that these are broadcast as
        // changes when the value is actually changed.
        for (va in dce.variableChanges)
        {
          if (adf.mf.util.stringEndsWith(va, ".collectionModel.treeNodeBindings.hasMoreKeys"))
          {
            hasMoreKeysVariableChanges[va] = (true == adf.mf.el.getLocalValue("#{" + va + "}"));
          }
        }

        adf.mf.internal.api.updateGenericCacheElement(dce.variableChanges, false); // only update the cache

        /* add to the batch data change events */
        for (va in dce.variableChanges)
        {
          dcevs.push(va);

          if ((weakref = adf.mf.internal.context.getWeakReference(va)) !== undefined)
          {
            dcevs.push(weakref);
          }

          // Look to see if the variable is of type TreeBindings and if so, add it to the provider
          // change list
          var variableChange = dce.variableChanges[va];

          // Check to see if the variable change is for the hasMoreKeys property of a collection
          // model's tree node bindings property. If so, treat it as an itemized provider change
          var hasMoreKeysOldValue = hasMoreKeysVariableChanges[va];
          if (hasMoreKeysOldValue != null)
          {
            // EL including the ".collectionModel":
            var collectionModelEl = va.substring(0, va.length - 29);

            // If another property has not changed on the tree bindings, then we can handle a
            // hasMoreKeys change in an optimized fashion.
            if (pdces[collectionModelEl] == null)
            {
              var hasMoreKeysNewValue = (true == adf.mf.el.getLocalValue("#{" + va + "}"));

              if (hasMoreKeysOldValue != hasMoreKeysNewValue)
              {
              // Notify the listeners that the hasMoreKeys property has changed
              pdces[collectionModelEl] = { itemized:true, hasMoreKeysChanged:true };
              dcevs.push(collectionModelEl); // for individual dce notifications
            }
          }
          }
          else if (adf.mf.util.isType(variableChange, "TreeBindings"))
          {
            pdces[va] = { itemized:false };
            dcevs.push(va); // for individual dce notifications
          }
          else if (adf.mf.util.stringEndsWith(va, ".collectionModel.treeNodeBindings.keys"))
          {
            // If the keys array has changed and there are no itemized set of changes in the
            // provider changes, then the entire collection model has changed and a
            // non-itemized change set should be recorded.
            var providerEl = va.substring(0, va.length - 38);
            if (dce.providerChanges[providerEl] == null)
            {
              pdces[collectionModelEl] = { itemized:false };
              dcevs.push(collectionModelEl); // for individual dce notifications
            }
          }
        }
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
          "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_VAR_CHANGES");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent", e);
      }

      var perf = adf.mf.internal.perf.startMonitorCall("Process provider changes",
        adf.mf.log.level.FINER, "adf.mf.api.processDataChangeEvent:providerChanges");
      try
      {
        if (dce.providerChanges !== undefined)
        {
          for (var p in dce.providerChanges)
          {
            // each property key is the name of the provider that has a change
            var pdce = dce.providerChanges[p];

            adf.mf.internal.api.updateGenericCacheElement(pdce.columnAttributes, true);

            if (pdce.providers)
            {
              // these are changes to the column attributes
              var cmpn   = p + ".collectionModel";
              var cmn    = "#{" + cmpn + "}";
              var cm     = adf.mf.api.getLocalValue(cmn);
              var create = pdce.providers.create || {};
              var update = pdce.providers.update || {};
              var dirty  = pdce.providers.dirty  || {};
              var remove = pdce.providers.remove || {};

              if (cm === undefined)
              {
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                    "processDataChangeEvent",
                    ("Warning: received a data change event before " + cmn +
                      " has been cached.  Ignoring the change."));
                }
                break;
              }

              // See if the record was already added by a variable change
              var pd = pdces[cmpn];

              if (pd == null)
              {
                pd = { itemized:true };
                pdces[cmpn] = pd;
                dcevs.push(cmpn); // for individual dce notifications
              }

              pd.created = []; // Objects with "key" property
              pd.updated = []; // Key strings
              pd.deleted = []; // Key strings
              pd.dirtied = []; // Key strings

              // Ensure there is a providers object to access
              var tnb = cm.treeNodeBindings;
              tnb.providers = tnb.providers || {};

              for (var k in create)
              {
                try
                {
                  // Make sure we got the keys so we can actually see this new provider :-)
                  pd.created.push({key:k});
                  tnb.providers[k] = create[k];
                }
                catch(e)
                {
                  adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                    "adf.mf.api.processDataChangeEvent",
                    "WARN_PROCESSING_CREATE_DATA_CHANGE");

                  // For security, only log the EL and exception at a FINE level
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                  {
                    adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                      "processDataChangeEvent", "Error with create data change event. EL: " + p +
                      " Error: " + e);
                  }
                }
              }

              for (var k in update)
              {
                try
                {
                  // Please note, this will add the provider if it is currently not in the cache
                  pd.updated.push(k);
                  tnb.providers[k] = update[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent",
                      "WARN_PROCESSING_UPDATED_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with update data change event. EL: " + p +
                         " Error: " + e);
                    }
                  }
                }
              }

              for (var k in dirty)
              {
                try
                {
                  // Actually removed the provider, if it is still there
                  pd.dirtied.push(k);
                  delete tnb.providers[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_REMOVE_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with dirty data change event. EL: " + p +
                        " Error: " + e);
                    }
                  }
                }
              }

              for (var k in remove)
              {
                try
                {
                  // Actually removed the provider, if it is still there
                  pd.deleted.push(k);
                  delete tnb.providers[k];
                }
                catch(e)
                {
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
                  {
                    adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
                      "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_REMOVE_DATA_CHANGE");

                    // For security, only log the details at a FINE level
                    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                    {
                      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api",
                        "processDataChangeEvent", "Error with remove data change event. EL: " + p +
                        " Error: " + e);
                    }
                  }
                }
              }
            }
          }
        }
      }
      catch(e)
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
            "adf.mf.api.processDataChangeEvent", "WARN_PROCESSING_PROVIDER_CHANGES");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.api", "processDataChangeEvent", e);
        }
      }
      finally
      {
        perf.stop();
      }

      /* notify all the data change listeners (registered either individually or batch wise) */
      adf.mf.internal.api.notifyDataChangeListeners(dcevs, pdces);
    }
    catch(ge)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.processDataChangeEvent", "ERROR_PROCESSING_DATA_CHANGE_EVENT");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent", ge);
    }
    finally
    {
      perfOp.stop();
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.api", "processDataChangeEvent",
        "process data change event done");
    }
  };

  /* String */
  adf.mf.internal.api.getWeakReference = function(/* String */ fqn)
  {
    return adf.mf.internal.context.getWeakReference(fqn);
  };

  /* String */
  adf.mf.internal.api.addCompressedReference = function(/* String */ reference)
  {
    return adf.mf.internal.context.addCompressedReference(reference);
  };

  /**
   * INTERNAL FUNCTION used to determine if Java is available or not.
   */
  adf.mf.internal.isJavaAvailable = function()
  {
    return window !== undefined &&
      window.container !== undefined &&
      window.container.internal !== undefined &&
      window.container.internal.device !== undefined &&
      window.container.internal.device.integration !== undefined &&
      window.container.internal.device.integration.vmchannel !== undefined;
  };


  /**
   * INTERNAL FUNCTION used to determine if we are or not in design time mode.
   */
  adf.mf.internal.isDesignTime = function()
  {
    return false;  /* TBD: add the ajax call to determine if this should be true or false */
  };


  /**
   * INTERNAL FUNCTION used to caches value for an expression
   */
  adf.mf.internal.el.cacheResult = function (request, response)
  {
    if (adf.mf.internal.util.is_array(response))
    {
      // we have an array of name value pairs
      for (var i = 0; i < response.length; ++i)
      {
        var nvp = response[i];

        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "cacheResult",
              ("adfmf- caching " + response.length + " values."));
        }

        /* we need to make sure we only try to cache individual terms */
                // old way: if (! adf.mf.internal.el.parser.parse(nvp.name).isComplexExpression())
        if (adf.mf.internal.util.isAssignable(nvp.name))
        {
          if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true)
          {
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.el", "cacheResult",
                "Caching [" + nvp.name + "] as an exception - " + adf.mf.util.stringify(nvp));
            }
          }
          adf.mf.api.setLocalValue(nvp, function() {}, function() {});
        }
        else
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "cacheResult",
                ("not caching complex expression [" + nvp.name + "]."));
          }
        }
      }
    }
  };


  /**
   * INTERNAL FUNCTION used by the processDataChangeEvent handler to update generic
   * properties in the cache.
   *
   * @param values
   *
   * For more details see @Understanding_DataChangeListeners
   */
  adf.mf.internal.api.updateGenericCacheElement = function(/* arguments */)
  {
    var values = (arguments.length > 0)? arguments[0] : null;
    var notify = (arguments.length > 1)? arguments[1] : true;

    /* update the cache's modification id */
    adf.mf.internal.context.updateModId();
    if (values !== undefined)
    {   /* each variable change property is an scalar property that was changed */
      var nvp    = [];

      for (var va in values)
      {
        var vk = '#{' + va + '}';
        var pvk = adf.mf.internal.el.parser.parse(vk);
        nvp.push({'name':vk, 'expression':pvk, 'value':values[va]});
      }

      if (nvp.length > 0)
      {
        try
        {
          adf.mf.api.setLocalValue(nvp,
            function(a, b)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
                  "updateGenericCacheElement",
                  ("updated the java script cache variables " + adf.mf.util.stringify(b)));
              }
            },
            function(a, b)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.SEVERE))
              {
                adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                  "adf.mf.internal.api.updateGenericCacheElement",
                  "ERROR_UNABLE_TO_SET_DATA_CHANGE_VALS");

                // For security, only log the EL at a FINE level
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api",
                    "updateGenericCacheElement", "Return value: " + df.mf.util.stringify(b));
                }
              }
            });

          if (notify) adf.mf.internal.api.notifyDataChangeListeners(values, null);
        }
        catch(e)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
          {
            adf.mf.log.logInfoResource("ADFInfoBundle", adf.mf.log.level.WARNING,
              "adf.mf.internal.api.updateGenericCacheElement", "WARN_UPDATING_CACHE");
          }
        }
      }
    };
  };


  /**
   * INTERNAL FUNCTION used to notify all the registered batch listeners
   * that the given variables have changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyBatchDataChangeListeners = function(variables, details)
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Notify registered batch data change listeners", adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyBatchDataChangeListeners");

    for (var i = 0; i < adf.mf.internal.batchDataChangeListeners.length; ++i)
    {
      try
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER,
            "adf.mf.internal.api",
            "notifyBatchDataChangeListeners",
            "notify listener " + i + "th bulk data change callback");
        }
        adf.mf.internal.batchDataChangeListeners[i](variables, details);
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "adf.mf.internal.api.notifyBatchDataChangeListeners",
          "ERROR_IN_BULK_NOTIFICATION_CALLBACK");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.internal.api", "notifyBatchDataChangeListeners", e);
      }
    }

    perf.stop();
  };


  /**
   * INTERNAL FUNCTION used to notify all the registered listeners
   * that the given variable has changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyIndividualDataChangeListeners = function(variable)
  {
    /* ensure values is an array */
    var values = (adf.mf.internal.util.is_array(variable))? variable : [ variable ];

    var perf = adf.mf.internal.perf.startMonitorCall("Notify individual data change listeners",
      adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyIndividualDataChangeListeners");

    for (var i = 0; i < values.length; ++i)
    {
      var  v  = values[i];
      var  la = (v.slice(0, "bindings".length) == "bindings")?
      currentBindingInstance.dataChangeListeners[v] : dataChangeListeners[v];

      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "adf.mf.internal.api",
          "notifyIndividualDataChangeListeners",
          ("**NDCL** Variable " + i + ": " + v + " has changed (" +
            adf.mf.api.getLocalValue(v)  + ") "));
      }
      if (la !== undefined)
      {
        for (var j = 0; j < la["callback"].length; ++j)
        {
          var k = 0;  /* declared out here so we can use it in the exception log message */

          try
          {
            for (k = 0; k < la["id"].length; ++k)
            {
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
                  "notifyDataChangeListeners",
                  ("notify listener " + j + "th callback in " + adf.mf.util.stringify(la) +
                    " listeners"));
              }
              la["callback"][j](la["id"][k]);
            }
          }
          catch(e)
          {
            adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
              "adf.mf.internal.api.notifyIndividualDataChangeListeners",
              "ERROR_IN_INDIVIDUAL_NOTIFICATION_CALLBACK");

            // For security, only log the details at a FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.internal.api",
                "notifyIndividualDataChangeListeners",
                "Error in notifying callback with data: " + la["id"][k] +
                " Error: " + e);
            }
          }
        }
      }
      else
      {
        if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.FINER,
            "adf.mf.internal.api",
            "notifyIndividualDataChangeListeners",
            ("no listener set is defined for " + values[i]));
        }
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to notify all the registered listeners
   * that the given variable has changed.
   *
   * #see Understanding_DataChangeListeners
   */
  adf.mf.internal.api.notifyDataChangeListeners = function(vars, pdces)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.api", "notifyDataChangeListeners",
        "with variables " + adf.mf.util.stringify(vars));
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.api", "notifyDataChangeListeners",
        "with provider details" + adf.mf.util.stringify(pdces));
    }

    /* notify the individual listeners */
    adf.mf.internal.api.notifyIndividualDataChangeListeners(vars);

    /* notify the batched listeners */
    adf.mf.internal.api.notifyBatchDataChangeListeners(vars, pdces);
  };

  /**
   * PRIVATE FUNCTION used to eat standard errors for any name-value exceptions values
   */
  adf.mf.internal.api.nvpEatErrors = function(request, response)
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api", "nvpEatErrors", "eat standard errors");
  };


  /**
   * PRIVATE FUNCTION used to simulate standard errors for any batch or array values
   */
  adf.mf.internal.api.arraySimulatedErrors = function(request, response)
  {
    /* ensure response is an array */
    var requests  = (adf.mf.internal.util.is_array(request ))? request  : [request ];
    var responses = (adf.mf.internal.util.is_array(response))? response : [response];
    var length    = responses.length;

    var perf = adf.mf.internal.perf.startMonitorCall(
      "Simulate standard errors for any batch or array values",
      adf.mf.log.level.FINER, "adf.mf.internal.api.arraySimulatedErrors");

    for (var i = 0; i < length; ++i)
    {
      var rv = (adf.mf.internal.util.is_array(responses[i]))? responses[i][0] : responses[i];
      if (adf.mf.util.isType(rv, "NameValuePair"))
      {
        /*
         * if the response type is a NVP or and array of them simply forward
         * that request/response to nvpSimulatedErrors handler to do the work
         */
        adf.mf.internal.api.nvpSimulatedErrors(requests[0], responses[i]);
      }
      else if (adf.mf.util.isException(responses[i]))
      {
        try
        {
          /* notify the error handlers */
          adf.mf.internal.api.notifyErrorHandlers(requests[0], responses[i]);
        }
        catch(e)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.arraySimulatedErrors", "ERROR_IN_ERROR_CALLBACK");
        }
      }
    }
    perf.stop();
  };

  /**
   * PRIVATE FUNCTION used to simulate standard errors for any name-value exceptions values
   */
  adf.mf.internal.api.nvpSimulatedErrors = function(request, response)
  {
    /* ensure response is an array */
    var responses = (adf.mf.internal.util.is_array(response))? response : [response];

    var perf = adf.mf.internal.perf.startMonitorCall(
      "Simulate standard errors for any name-value exceptions values",
      adf.mf.log.level.FINER, "adf.mf.internal.api.nvpSimulatedErrors");

    for (var i = 0; i < responses.length; ++i)
    {
      var nvp = responses[i];

      if (adf.mf.util.isType(nvp, "NameValuePair"))
      {
        if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] !== undefined)
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINEST))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.api", "nvpSimulatedErrors",
              "this is an exception: " + adf.mf.util.stringify(nvp));
          }

          /* lets be sure and make sure the value is true */
          if (nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] == true)
          {
            try
            {
              /* notify the error handlers */
              adf.mf.internal.api.notifyErrorHandlers(nvp.name, nvp.value);
            }
            catch(e)
            {
              adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
                "adf.mf.internal.api.nvpSimulatedErrors", "ERROR_IN_ERROR_CALLBACK");
            }
          }
        }
      }
      else
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
          "nvpSimulatedErrors",
          "response element " + i + " was not of type NameValuePair - " +
          adf.mf.util.stringify(nvp));
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to notify all the registered error handlers
   */
  adf.mf.internal.api.notifyErrorHandlers = function(req, resp)
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Notify all registered error handlers",
      adf.mf.log.level.FINER,
      "adf.mf.internal.api.notifyErrorHandlers.callback");

    if ((resp != undefined) && (resp != null) &&
      (resp[adf.mf.internal.api.constants.DEFERRED_PROPERTY] != true))
    {
      for (var i = 0; i < adf.mf.internal.errorHandlers.length; ++i)
      {
        try
        {
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.api",
              "notifyErrorHandlers", "notify error handler " + i + " of the error");
          }
          adf.mf.internal.errorHandlers[i](req, resp);
        }
        catch(e)
        {
          adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
            "adf.mf.internal.api.notifyErrorHandlers", "ERROR_CALLING_ERROR_HANDLERS");

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "adf.mf.internal.api", "notifyErrorHandlers", e);
        }
      }
    }

    perf.stop();
  };

  /**
   * INTERNAL FUNCTION used to clear all the binding variables
   * currently registered.
   */
  adf.mf.internal.el.resetBindingContext = function()
  {
    var perf = adf.mf.internal.perf.startMonitorCall(
      "Reset binding context",
      adf.mf.log.level.FINER,
      "adf.mf.internal.el.resetBindingContext");

    try
    {
      adf.mf.api.removeVariable('bindings');
      adf.mf.api.addVariable('bindings', {});
      adf.mf.internal.el.clearWeakReferences();
      adf.mf.internal.el.parser.cache.clear();

      // now clean up all the bindings data change listeners
      currentBindingInstance.dataChangeListeners = {};
    }
    catch(e)
    {
      adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.el.resetBindingContext", "ERROR_RESETTING_BINDING_CONTEXT");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "adf.mf.internal.el", "resetBindingContext", e);
    }
    finally
    {
      perf.stop();
    }
  };

  /**
   * INTERNAL FUNCTION used to clear all weak references in the system.
   */
  /* void */
  adf.mf.internal.el.clearWeakReferences = function()
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.el", "clearWeakReferences", name);
    adf.mf.internal.context.clearWeakReferences();
  };


  adf.mf.el.removeCache = function(keys)
  {
    count = keys.length;
    for (var i = 0; i < count; i++)
    {
      elCache.kill(keys[i]);
    }
  };


  adf.mf.internal.el.getBindingInstance = function(/* String */ id)
  {
    var  bi = bindingInstances[id];

    if (bi == null)
    {
      bi = {"bindings": {}, "dataChangeListeners": {}};
      bindingInstances[id] = bi;
    }

    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "purgeCache",
          ("getBindingInstance for '" + id + "' = " + adf.mf.util.stringify(bi)));
    }

    return bi;
  };

  adf.mf.internal.el.switchBindingInstance = function(id)
  {
    if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
    {
      adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "adf.mf.internal.el", "switchBindingInstance",
          ("switchBindingInstance to '" + id + "'"));
    }

    currentBindingInstance = adf.mf.internal.el.getBindingInstance(id);

    adf.mf.api.removeVariable('bindings');
    adf.mf.api.addVariable('bindings',   currentBindingInstance.bindings);
    // adf.mf.internal.el.clearWeakReferences();
    adf.mf.internal.el.parser.cache.clear();
  };

  /**
   * PUBLIC FUNCTION used to add a performance monitor observation.  Can be called with or without the description parameter.
   * @param monitorId      - monitor ID
   * @param description    - description for the given monitor (optional)
   * @param duration       - observation duration.  This is the quantity value that is observed.
   * @param successCB      - success callback
   * @param failureCB      - failure callback
   *
   * e.g. adf.mf.api.addMonitorObservation("MyCategory.methodFoo", 123, successCB, failureCB);
   * e.g. adf.mf.api.addMonitorObservation("MyCategory.methodFoo", "Measures time spent in method Foo", 123, successCB, failureCB);
   *
   */
  /* void */
  adf.mf.api.addMonitorObservation = function()
  {
    var args = [].splice.call(arguments,0);   // convert arguments into a real array
    var updatedArgs = ["oracle.adfmf.framework.api.Model", "addMonitorObservation"];
    adf.mf.api.invokeMethod.apply(this, updatedArgs.concat(args));
  };

  /*
   * Initialize the default binding instance for HTML base interactions
   */
  var currentBindingInstance = adf.mf.internal.el.getBindingInstance("default");
})();



/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/Adfel.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfelBridge.js///////////////////////////////////////

/* Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------- AdfelBridge.js ---------------------- */
// @requires Adfel


var adf                    = window.adf                 || {};
adf.el                     = adf.el                     || {};
adf.log                    = adf.log                    || {};

adf.mf                     = adf.mf                     || {};
adf.mf.api                 = adf.mf.api                 || {};
adf.mf.api.adf             = adf.mf.api.adf             || {};
adf.mf.el                  = adf.mf.el                  || {};
adf.mf.locale              = adf.mf.locale              || {};
adf.mf.log                 = adf.mf.log                 || {};
adf.mf.resource            = adf.mf.resource            || {};
adf.mf.util                = adf.mf.util                || {};

adf.mf.internal            = adf.mf.internal            || {};
adf.mf.internal.api        = adf.mf.internal.api        || {};
adf.mf.internal.el         = adf.mf.internal.el         || {};
adf.mf.internal.el.parser  = adf.mf.internal.el.parser  || {};
adf.mf.internal.locale     = adf.mf.internal.locale     || {};
adf.mf.internal.log        = adf.mf.internal.log        || {};
adf.mf.internal.mb         = adf.mf.internal.mb         || {};
adf.mf.internal.perf       = adf.mf.internal.perf       || {};
adf.mf.internal.perf.story = adf.mf.internal.perf.story || {};
adf.mf.internal.resource   = adf.mf.internal.resource   || {};
adf.mf.internal.util       = adf.mf.internal.util       || {};


/**
 * PUBLIC FUNCTION used to add a new data change listener (callback) for a given el expression (variable)
 * 
 * e.g.
 *   adf.addDataChangeListeners("#{bindings.apple}",                   appleChangedCallback); 
 *   adf.addDataChangeListeners("#{bindgins.apple + bindings.orange}", appleOrOrangeChangedCallback);
 *                              
 * 	 adf.addDataChangeListeners("#{!bindings.foo}",                    bindingsFooChangedCallback);
 * 
 *   where the callback would looks something like this:
 *   bindingsFooChangedCallback = function(id)
 *   {
 *      document.write("DataChangeNotification 1 notification for ID: " + id);
 *   }
 *   
 * If the same expression/listener combination is registered several times, duplicates are discarded.
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.addDataChangeListeners = function(expression, callback) 
{
	adf.mf.api.addDataChangeListeners.apply(this, arguments);
};

adf.mf.api.adf.loadADFMessageBundles = function(baseUrl, loadMessageBundleCallback)
{
	adf.mf.resource.loadADFMessageBundles.apply(this, arguments);
};

adf.mf.api.adf.getInfoString = function(bundleName, key)
{
	adf.mf.resource.getInfoString.apply(this, arguments);
};

adf.mf.api.adf.getErrorId = function(bundleName, key)
{
	adf.mf.resource.adf.getErrorId.apply(this, arguments);
};

adf.mf.api.adf.getErrorCause = function(bundleName, key)
{
	adf.mf.resource.getErrorCause.apply(this, arguments);
};

adf.mf.api.adf.getErrorAction = function(bundleName, key)
{
	adf.mf.resource.getErrorAction.apply(this, arguments);
};

adf.mf.api.adf.logAndThrowErrorResource = function(bundleName, methodName, key)
{
	adf.mf.log.logAndThrowErrorResource.apply(this, arguments);
};

adf.mf.api.adf.logInfoResource = function(bundleName, level, methodName, key)
{
	  adf.mf.log.logInfoResource.apply(this, arguments);
};




/**
 * PUBLIC FUNCTION used to get the current context ID. 
 *
 * e.g. adf.getContextId(success, failed);
 * 
 * @deprecated
 */
/* void */
adf.getContextId = function(success, failed) 
{ 
	adf.mf.api.getContextId.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to get the current context's pagedef. 
 *
 * e.g. adf.getContextId(success, failed);
 * 
 */
adf.getContextPageDef = function(success, failed)
{
	adf.mf.api.getContextPageDef.apply(this, arguments);
};

/**
 * PUBLIC FINCTION used to get the current context's instance ID
 */
adf.getContextInstanceId = function(success, failed)
{
	adf.mf.api.getContextInstanceId.apply(this, arguments);
};


/**
 * setContext
 * pageDef    - name of the page definition
 * instanceId - unique id for the instance
 * resetState - reset the bindings associated with this instance
 * reSync     - resend the initial bindings structure to the container
 */
adf.setContextInstance = function(pageDef, instancedId, resetState, /* boolean */reSync, success, failed)
{
	adf.mf.api.setContextInstance.apply(this, arguments);
};

adf.removeContextInstance = function(pageDef, instanceId, success, failed)
{
	adf.mf.api.removeContextInstance.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to invoke method in any class in classpath.
 * 
 * e.g. adf.invokeMethod(classname, methodname, param1, param2, ... , paramN ,successCallback, failedCallback);
 *
 * Examples:
 *      adf.invokeMethod("TestBean", "setStringProp", "foo", success, failed);                  
 *      adf.invokeMethod("TestBean", "getStringProp", success, failed);                  
 *      adf.invokeMethod("TestBean", "testSimpleIntMethod", "101", success, failed); // Integer parameter              
 *      adf.invokeMethod("TestBean", "testComplexMethod", 
 *              {"foo":"newfoo","baz":"newbaz",".type":"TestBeanComplexSubType"}, success, failed); // Comples parameter
 *      adf.invokeMethod("TestBean", "getComplexColl", success, failed); // No parameter
 *      adf.invokeMethod("TestBean", "testMethodStringStringString", "Hello ", "World", success, failed); // 2 string parameter
 *
 * @param classname  - name of the class
 * @param methodname - name of the method
 * @param params     - parameters
 * @param success    - invoked when the method is successfull invoked
 *                     (signature: success(request, response))
 * @param failed     - invoked when an error is encountered 
 *                     (signature: failed(request, response))
 */
adf.invokeMethod = function() 
{ 
	adf.mf.api.invokeMethod.apply(this, arguments);
};

/**
 * PUBLIC FUNCTION used to invoke IDM Mobile SDK methods
 */
adf.invokeSecurityMethod = function(command, username, password, tenantname)  
{ 
	adf.mf.security.invokeSecurityMethod.apply(this, arguments); 
};

/**
 * PUBLIC FUNCTION used to remove all data change listeners associated with the variable
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.removeDataChangeListeners = function(expression) 
{
	adf.mf.api.removeDataChangeListeners.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to reset context. Call this before setting new context.
 * This is exactly the same as calling adf.setContext with an empty context name.
 *
 * e.g. adf.resetContext(successCallback, failedCallback);
 */
/* void */
adf.resetContext = function(success, failed) 
{ 
	adf.mf.api.resetContext.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to set context for the specified name
 * 
 * e.g. adf.setContext("myContextName", successCallback, failedCallback);
 */
/* void */
adf.setContext = function(/* context name */ name, success, failed) 
{
	adf.mf.api.setContext.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION used to create a top-level variable
 * into the context.  This should be thought of as adding
 * a variable to the root namespace for variables.
 * 
 * i.e. adf.el.addVariable("name", some_object);
 * 
 * addVariable/removeVariable are used to add and then remove
 * temporary variables, like loop iterator variables along with
 * longer lasting variables.
 */
/* void */
adf.el.addVariable = function(/* variable name */ name, /* new value */ value) 
{ 
	adf.mf.api.addVariable.apply(this, arguments); 
};


/**
 * PUBLIC FUNCTION will evaluate the passed in expression against
 * the local cache ONLY.  If there are terms that are currently
 * not cached or any function calls then undefined will be returned.
 * 
 * @see adf.el.addVariable
 * @see adf.el.removeVariable
 * 
 * @see adf.el.getValue
 * @see adf.el.setValue
 * @see adf.el.setLocalValue
 */
adf.el.getLocalValue = function(/* expression */ expression) 
{
	return adf.mf.api.getLocalValue.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to evaluate the expression(s) passed in and return the associated 
 * value(s) via the success callback.  Since not all variables may not be resolved only the
 * resolved expressions will be returned in the 'response' property of the success callback.
 *  
 * Given that you can use this method to get the value for:
 * 
 * Evaluation of a single EL expression:
 * e.g. adf.el.getValue("#{100+2*20/3}", success, failed);
 * e.g. adf.el.getValue("#{bindings.userName.inputValue}", success, failed);
 * 
 * Evaluation of an array of EL expressions:
 * e.g. adf.el.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
 * e.g. adf.el.getValue(["#{bindings.foo}", "#{applicationScope.username}"], success, failed);
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.getValue("#{100+2*20/3}", success, failed);
 *        success(["#{100+2*20/3}"], [ {name:"#{100+2*20/3}", value:"113.33"} ] )
 *        
 *   e.g. adf.el.getValue("#{bindings.userName.inputValue}", success, failed);
 *        success(["#{bindings.userName.inputValue}"], [ {name:"#{bindings.userName.inputValue}", value:"me"} ] )
 * 
 *   e.g. adf.el.getValue(["#{100+2*20/3}", "#{500/2}"], success, failed);
 *        success(["#{100+2*20/3}", "#{500/2}"], 
 *                [ {name:"#{100+2*20/3}", value:"113.33"}, {name:"#{500/2}", value:"250"} ] )
 * 
 * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
 * e.g. adf.el.getValue( ["#{bindings.foo}", "#{bindings.bar}"], success, failed);
 *        success(["#{bindings.foo}", "#{bindings.bar}"], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
 *          *** notice: binding.bar was not part of the result array
 *          
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 *   
 * There also exists another way to invoke the getValue used to resolve a property from an already 
 * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
 * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
 * the "right thing to do" based on the 'base' and 'property' variables:
 * 
 * e.g. adf.el.getValue(base, property);
 *   where the value returned is value of the property or nil if it does not exists.
 **/
adf.el.getValue = function() 
{
	adf.mf.api.getValue.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to used to invoke a method expression in the java environment.
 * 
 * expression: is the method expression itself
 *             i.e. #{bean.method}  #{applicationScope.bean.method}
 * params    : is an array of zero or more values that should be passed as the method parameters
 *             i.e. []                      - to invoke bean.method()
 *             or ["Hello"]                 - to invoke bean.method(String)
 *             or [[false, false], "Hello"] - to invoke bean.method(boolean[], String)
 * returnType: is the return type
 *             i.e. void                    - 
 *             i.e. String                  - return type is a string
 * types     : i.e. []                      - no parameters
 *             i.e. [java.lang.String]      - one parameter of type String
 *             i.e. [java.lang.String, int] - parameter-1 of type String, parameter-2 of type int
 *               
 * Given this information the correct method will be looked up and invoked from the given method.
 * 
 * Evaluation of a single EL expression:
 * e.g. invoke("#{Bean.foobar}", [parameters], [parameter-types], success, failed);
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.invoke("#{Bean.foobar}", [], "java.lang.String", [], success, failed);
 *        success({method:"#{Bean.foobar}" arguments:[]}, {result:....} )
 *          
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 **/
adf.el.invoke = function(expression, params, returnType, types, success, failed) 
{
	adf.mf.api.invoke.apply(this, arguments);
};


/** 
 * PUBLIC FUNCTION used to update a value for a given variable expression.
 * Since variable expressions are the only type of expressions that can be LHS
 * (left-hand-side) expressions we can rule out all literal, complex, and method 
 * expressions from the possible input.
 * 
 * A simple name-value-pair object is used to denote the variable expression (name)
 * with it's desired value (value).  An example of this would be: 
 *       { "name":"#{applicationScope.foo}", value:"foobar" } 
 * 
 * Similar to the getValue function, the setValue can take a single name-value-pair
 * or an array of them for doing batch sets.  The following examples will highlight
 * these cases:
 * 
 * Passing only a single name-value-pair
 * e.g. adf.el.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
 *      resulting in the bindings.foo variable being assigned foo
 *      
 * Passing an array of name-value-pairs
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *      resulting in the bindings.foo variable being assigned foo and 
 *                       bindings.bar variable being assigned bar
 *      
 * 
 * Success Callback:
 * success(request, response)
 *   where the request echos the first argument passed in
 *     and the response is an array of name-value-pairs, one for each resolved expression.
 * so if we take our examples above:
 *   e.g. adf.el.setValue( { "name": "#{bindings.foo}", "value": "foo" }, success, failed);
 *        success(["{ "name": "#{bindings.foo}", "value": "foo" }"], [ { "name": "#{bindings.foo}", "value": "foo" } ] )
 *        
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *        success([{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }] )
 * 
 * Now let suppose that bindings.foo exists but not bindings.bar.  In this case would see:
 * e.g. adf.el.setValue( [{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                        { "name": "#{bindings.bar}", "value": "bar" }], success, failed);
 *        success([{ "name": "#{bindings.foo}", "value": "foo" }, 
 *                 { "name": "#{bindings.bar}", "value": "bar" }], 
 *                [{ "name": "#{bindings.foo}", "value": "foo" }] )
 *          *** notice: binding.bar was not part of the result array
 * 
 * Failed Callback:
 * failed(request, exception)
 *   where the request echos the first argument passed in
 *     and the exception encountered resulting in all of the expressions failing to be resolved
 *   
 * There also exists another way to invoke the setValue used to set a property from an already 
 * retrieved base object.  This version is used by the AMX layer to do things like iterator variables
 * when doing collection/lists/tables.  In this version, we simply let the EL resolvers determine
 * the "right thing to do" based on the 'base' and 'property' variables:
 * 
 * e.g. adf.el.setValue(base, property, value);
 *   where the base.property is assigned the value of 'value'
 **/
adf.el.setValue = function(nvp, success, failed) 
{
	adf.mf.api.setValue.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to set the value only on the javascript side.
 * 
 * @see adf.el.setValue
 */
adf.el.setLocalValue = function() 
{
	adf.mf.api.setLocalValue.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to remove a top-level variable
 * from the context.  This should be thought of as removing
 * a variable from the root namespace for variables.
 * 
 * i.e. adf.el.removeVariable("name");
 */
/* void */
adf.el.removeVariable = function(/* variable name */ name) 
{
	adf.mf.api.removeVariable.apply(this, arguments);
};


/**
 * PUBLIC FUNCTION used to create a top-level variable
 * into the context.  This should be thought of as adding
 * a variable to the root namespace for variables.
 * 
 * i.e. adf.el.setVariable("name", some_object);
 * 
 * Most of the time the 'some_object' will be a property
 * map.  So we can do things like:
 *   adf.el.getValue("${name.property}");
 */
/* void */
adf.el.setVariable = function(/* variable name */ name, /* new value */ value) 
{
	adf.mf.api.setVariable.apply(this, arguments);
};

 /**
 * PUBLIC FUNCTION used to process the data change event associated with response messages.
 * 
 * DataChangeEvents can be sent as their own request message or as part of _any_ response
 * message.  This event is sent to inform the javascript side that some data was side-effected
 * in the CVM layer and should be propagated into the javascript cache as well as notify the 
 * user interface of the change.  This event has the following JSON represention:
 *   
 * DataChangeEvent
 * {
 *  	variableChanges: {
 * 	    	elExpression:value
 * 	    	...
 *  	}
 *  	providerChanges: {
 *  		providerId: {
 *  		   <operation>:{ 
 *  		      current_row_key: { properties filtered by node }
 *  		      ...
 *  		   }
 *             ...
 *  		}
 *  		...
 *  	}
 * }
 * 
 * Given that, we need to do the following for each data change event:
 * Variable Changes:
 *    set the value in the local cache
 *    notify anyone interested in that variable, that it has changed.
 *    
 * Provider Changes:
 *    on Create:
 *      set the value in the local cache
 *    on Update:
 *      set the value in the local cache
 *      notify anyone interested in that variable, that it has changed.
 *    on Create:
 *      remove the value from the local cache
 * 
 * For more details see @Understanding_DataChangeListeners
 */
adf.processDataChangeEvent = function(/* DataChangeEvent */ dce)
{
	adf.mf.api.processDataChangeEvent.apply(this, arguments);
};


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/ADF/js/AdfelBridge.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-resource.js ------------------ */
/* ------------------------------------------------------ */

// base-adfel.js defines all of the other namespaces
if (!window.adf) window.adf = {};
                  adf.mf              = adf.mf              || {};
                  adf.mf.api          = adf.mf.api          || {};
/** @namespace */ adf.mf.api.amx      = adf.mf.api.amx      || {};
                  adf.mf.internal     = adf.mf.internal     || {};
/** @namespace */ adf.mf.internal.amx = adf.mf.internal.amx || {};
                  adf.mf.resource     = adf.mf.resource     || {};
if (!window.amx) window.amx = {}; /* deprecated */

// --------- Config Initialization --------- //
(function()
{
  // define the names of the 2 known message bundles here
  adf.mf.resource.AMXErrorBundleName = "AMXErrorBundle";
  adf.mf.resource.AMXInfoBundleName  = "AMXInfoBundle";
})();
// --------- /Config Initialization --------- //

// --------- Utilities --------- //
(function()
{
  function loadTrinidadLocaleElements(baseUrl, localeList, callback)
  {
    var getLocaleElementsUrl = function(locale)
    {
      return baseUrl + "/resource/LocaleElements_" + adf.mf.locale.getJavaLanguage(locale) + ".js";
    };

    var isLocaleElementsLoaded = function(locale)
    {
      var suffix = "_" + adf.mf.locale.getJavaLanguage(locale);
      if (typeof window["LocaleSymbols" + suffix] !== "undefined")
      {
        return true;
      }
      return false;
    };

    adf.mf.api.amx.loadJavaScriptByLocale(
      localeList,
      getLocaleElementsUrl,
      isLocaleElementsLoaded,
      callback,
      true);
  }

  function loadTrinidadMessageBundle(baseUrl, languageList, callback)
  {
    var getMessageBundleUrl = function(language)
    {
      var url = baseUrl + "/resource/MessageBundle";
      if (language.indexOf("en") == 0)
      {
        return url + ".js";
      }
      return url + "_" + adf.mf.locale.getJavaLanguage(language) + ".js";
    };

    var isMessageBundleLoaded = function(locale)
    {
      return typeof TrMessageFactory._TRANSLATIONS !== "undefined";
    };

    adf.mf.api.amx.loadJavaScriptByLocale(
      languageList,
      getMessageBundleUrl,
      isMessageBundleLoaded,
      callback,
      true);
  }

  function loadOtherMessageBundles(baseUrl, languageList)
  {
    /* first load the ADF message bundles */
    adf.mf.resource.loadADFMessageBundles(
      baseUrl,
      languageList.slice(0),
      true);

    /* now load the AMX message bundles */
    adf.mf.resource.loadMessageBundle(
      adf.mf.resource.AMXErrorBundleName,
      baseUrl,
      languageList.slice(0),
      true);
    adf.mf.resource.loadMessageBundle(
      adf.mf.resource.AMXInfoBundleName,
      baseUrl,
      languageList.slice(0),
      true);
  }

  // --------- /Private helper methods --------- //

  // --------- Public methods --------- //

  adf.mf.api.amx.loadJavaScriptByLocale = function(localeList, constructor, predicate, callback, async)
  {
    // clone the array before calling the load method since it will actually
    // modify the array as it searches
    var clonedList = [].concat(localeList);

    var loadedResolve = null;
    var loadedPromise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        loadedResolve = resolve;
      });
    var wrappedCallback = function(result)
    {
      loadedResolve();
      callback(result);
    };
    adf.mf.internal.resource.loadJavaScriptByLocale(clonedList, constructor, predicate,
      wrappedCallback, async);
    return loadedPromise;
  };

  adf.mf.api.amx.loadTrinidadResources = function(baseUrl) /* used by base-controller.js */
  {
    // before doing anything, we need to register the error handler
    adf.mf.api.addErrorHandler(adf.mf.internal.amx.errorHandlerImpl);

    // Bootstrap the Trinidad locale globals
    _df2DYS = null;

    // Return global variable _locale if it is non-null; otherwise return the browser language
    _locale = adf.mf.locale.getUserLocale();
    var language = adf.mf.locale.getUserLanguage();

    var localeList = adf.mf.locale.generateLocaleList(_locale, true);
    var languageList = adf.mf.locale.generateLocaleList(language, false);

    loadTrinidadLocaleElements(baseUrl, localeList,
      function(locale)
      {
        if (locale === null)
        {
          // for this low-level method, always send in the english string (do not translate)
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "amx", "loadTrinidadResources",
              "MSG_FAILED_TO_LOAD_LOCALE",
              "Failed to load LocaleElements");
          }
        }
        else
        {
          // Reassign global locale (necessary since Trinidad does not fallback to en-US).
          _locale = locale;
        }
      });

    loadTrinidadMessageBundle(baseUrl, languageList, function(language)
    {
      if (language === null)
      {
        // for this low-level method, always send in the english string (do not translate)
        if(adf.mf.log.Framework.isLoggable(adf.mf.log.level.WARNING))
        {
          adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "amx", "loadTrinidadResources",
            "Failed to load MessageBundle");
        }
      }
    });

    // load any other message bundles that the js system depends on
    loadOtherMessageBundles(baseUrl, languageList);
  };
  // --------- /Public methods --------- //

}) ();
//--------- /Utilities --------- //
/* Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* --------------- amx-elDependencies.js ---------------- */
/* ------------------------------------------------------ */

(function()
{
  /**
   * Object to parse the EL dependencies for attributes and maintain a map for what EL
   * dependencies are used by certain attributes. Internal object used by AmxTag and
   * AmxNode.
   * @constructor adf.mf.internal.amx.AmxElDependencies
   * @augments adf.mf.api.AdfObject
   */
  function AmxElDependencies(
    attributes)
  {
    this.Init(attributes);
  }

  adf.mf.internal.amx.AmxElDependencies = AmxElDependencies;
  adf.mf.api.AdfObject.createSubclass(
    adf.mf.internal.amx.AmxElDependencies,
    adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxElDependencies");

  /**
   * Initialization method. Using adf.mf.internal.amx.acceptAttributeForElProcessing, this function
   * will gather all the EL dependencies of the attributes so that they may be hooked into the
   * data change event framework.
   *
   * @param {Object.<string, string>} a map of the attribute names as keys and the raw value from
   *                                  the amx or amxf file for the attribute.
   * @protected
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.Init = function(attributes)
  {
    AmxElDependencies.superclass.Init.call(this);

    this._attributeElDependencies = {};
    this._elTokens = [];

    for (var attrName in attributes)
    {
      var attrVal = attributes[attrName];
      if (typeof attrVal == "string" || attrVal instanceof String)
      {
        attrVal = adf.mf.internal.el.parser.parse(attrVal);
      }

      if (adf.mf.internal.amx.acceptAttributeForElProcessing(attrName, attrVal))
      {
        var dependencies = attrVal.getIndexedDependencies();
        for (var i = 0, size = dependencies.length; i < size; ++i)
        {
          var dependency = dependencies[i];
          var attrDependencies = this._attributeElDependencies[dependency];
          if (attrDependencies == null)
          {
            this._attributeElDependencies[dependency] = [ attrName ];
          }
          else
          {
            attrDependencies.push(attrName);
          }

          // Avoid duplicates:
          if (this._elTokens.indexOf(dependency) == -1)
          {
            this._elTokens.push(dependency);
          }
        }
      }
    }
  };

  /**
   * Get the names of the attributes that are affected by a change
   * to the given EL dependency.
   *
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   *        containing one term
   * @return {Array.<string>} array of attribute names.
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.getAttributesForElDependency = function(
    valueExpression)
  {
    var attrs = this._attributeElDependencies[valueExpression.getIndexedRepresentation()];
    return attrs == null ? [] : attrs;
  };

  /**
   * Get the EL tokens that all the attributes are dependent on.
   *
   * @return {Array.<string>} the EL tokens
   */
  adf.mf.internal.amx.AmxElDependencies.prototype.getElTokens = function()
  {
    return this._elTokens;
  };

})();
/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* -------------------- amx-tag.js ---------------------- */
/* ------------------------------------------------------ */

(function()
{
  // ------ AMX Tag ------ //
  /**
   * AMX tag object. JS object representation of the AMX node definition from the AMX page.
   * Constructor should only be by the framework.
   *
   * @param {(adf.mf.api.amx.AmxTag|null)} parentTag the parent tag or null for the root.
   * @param {Node} xmlNode the XML DOM node from the AMX page
   * @param {Array.<number>} nextAutoGeneratedId an array with a single integer (to be able
   *        to change the value) for tags without IDs, the next auto-generated
   *        one to use.
   * @constructor adf.mf.api.amx.AmxTag
   * @augments adf.mf.api.AdfObject
   */
  function AmxTag(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    this.Init(parentTag, xmlNode, nextAutoGeneratedId);
  }

  adf.mf.api.amx.AmxTag = AmxTag;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.AmxTag, adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxTag");

  adf.mf.api.amx.AmxTag.prototype.Init = function(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    AmxTag.superclass.Init.call(this);

    // TODO assert that xmlNode != null and xmlNode.nodeType == 1
    this._parent = parentTag;
    // The native xml parser in UWP has namespaceUri vs namespaceURI
    this._ns = xmlNode.namespaceURI || xmlNode.namespaceUri;
    this._prefixedName = xmlNode.tagName;
    this._name = xmlNode.localName;
    this._nsPrefixedName = this._ns + ":" + this._name;
    this._textContent = "";
    this._elDependencies = null;
    this._attr = {};
    this._uiTag = null;

    if (this._name == "parsererror")
    {
      // The native xml parser in UWP has innerText vs textContent
      var errorText = xmlNode.textContent || xmlNode.innerText;
      if (adf.mf.environment.profile.mockData)
        console.log("*** " + errorText); // make more obvious error for mock mode
      throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
        "ERROR_XML_PARSING_ERROR", errorText));
    }

    var attrs = xmlNode.attributes;
    var i, size;
    var idFound = false;

    for (i = 0, size = attrs.length; i < size; ++i)
    {
      var a = attrs[i];
      this._attr[a.name] = a.value;
      if (idFound == false && a.name == "id")
      {
        idFound = true;
      }
    }

    if (!idFound)
    {
      // Assign a unique ID to the tag
      if (nextAutoGeneratedId == null)
      {
        nextAutoGeneratedId = [ 0 ];
      }

      this._attr["id"] = "_auto" + (nextAutoGeneratedId[0]++);
    }

    this._children = [];
    var children = xmlNode.childNodes;
    for (i = 0, size = children.length; i < size; ++i)
    {
      var child = children[i];

      switch (child.nodeType)
      {
        case 1: // element
          var tag = new adf.mf.api.amx.AmxTag(this, child, nextAutoGeneratedId);
          this._children.push(tag);
          break;
        case 3: // text node
        case 4: // CDATA node
          if (this._textContent == null)
          {
            // First text or CDATA node encountered. Note: innerText is for UWP
            this._textContent = child.textContent || child.innerText;
          }
          else
          {
            // Subsequent text or CDATA nodes. Note: innerText is for UWP
            this._textContent += child.textContent || child.innerText;
          }
          break;
      }
    }
  };

  AmxTag.NAMESPACE_AMX = "http://xmlns.oracle.com/adf/mf/amx";
  AmxTag.NAMESPACE_DVTM = AmxTag.NAMESPACE_AMX + "/dvt";

  /**
   * Get the XML namespace URI for the tag.
   * @return {string} the namespace URI
   */
  adf.mf.api.amx.AmxTag.prototype.getNamespace = function()
  {
    return this._ns;
  };

  /**
   * @deprecated
   */
  adf.mf.api.amx.AmxTag.prototype.getPrefixedName = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "AmxTag.getPrefixedName", "MSG_DEPRECATED", "amxTag.getPrefixedName",
      "Use amxTag.getNsPrefixedName instead.");
    return this._prefixedName;
  };

  /**
   * Return the tag name including the namespace prefix (not the local xmlns prefix).
   * This is the full XML name like "http://xmlns.example.com/custom:custom".
   * @return {string} the tag name with the prefix
   */
  adf.mf.api.amx.AmxTag.prototype.getNsPrefixedName = function()
  {
    return this._nsPrefixedName;
  };

  /**
   * Get the tag name. This is the local XML tag name without the prefix.
   * @return {string} the tag name
   */
  adf.mf.api.amx.AmxTag.prototype.getName = function()
  {
    return this._name;
  };

  /**
   * Get the parent tag.
   * @return {(adf.mf.api.amx.AmxTag|null)} the parent tag or null for the top level
   *         tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getParent = function()
  {
    return this._parent;
  };

  /**
   * Returns the text content of the tag.
   * @return {string} the text content, or an empty string.
   */
  adf.mf.api.amx.AmxTag.prototype.getTextContent = function()
  {
    return this._textContent;
  };

  /**
   * Recursively search the tag hierarchy for tags with the given
   * namespace and tag name. Returns the current tag if a match as well.
   *
   * @param {string} namespace the namespace of the children to retrieve.
   * @param {string} tagName the name of the tags to return.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching tags.
   */
  adf.mf.api.amx.AmxTag.prototype.findTags = function(
    namespace,
    tagName)
  {
    var tags = [];
    if (tagName == this.getName() && this.getNamespace() == namespace)
    {
      tags.push(this);
    }

    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      var result = child.findTags(namespace, tagName);
      if (result.length > 0)
      {
        tags = tags.concat(result);
      }
    }

    return tags;
  };

  /**
   * Get the children of the tag. Provides for optional filtering of the children
   * namespaces and tag names.
   * @param {(string|null)} namespace the namespace to filter the children by. If
   *        null all the children will be returned.
   * @param {(string|null)} tagName the name of the tag to filter the children by.
   *        Only considered if the namespace parameter is non-null. If null, the
   *        children will not be filtered by tag name.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching children tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildren = function(
    namespace,
    tagName)
  {
    var result = [];
    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      if ((namespace == null || namespace == child.getNamespace()) &&
        (tagName == null || tagName == child.getName()))
      {
        result.push(child);
      }
    }

    return result;
  };

  /**
   * Convenience function to get all of the children facet tags. Meant to assist
   * the creation of the AMX node process.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the facet tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenFacetTags = function()
  {
    return this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
  };

  /**
   * Convenience function to get the facet tag with the given name. Meant to assist
   * the code if the presence of a facet changes the behavior of a type handler.
   * @param {string} name the name of the facet to find.
   * @return {(adf.mf.api.amx.AmxTag|null)} the child facet tag or null if none has been
   *         provided with the given name.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildFacetTag = function(name)
  {
    var facetTags = this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
    for (var i = 0, size = facetTags.length; i < size; ++i)
    {
      var tag = facetTags[i];
      if (tag.getAttribute("name") == name)
      {
        return tag;
      }
    }

    return null;
  };

  /**
   * Convenience function to get all children tags that are UI tags. Meant to assist
   * the creation of the AMX node process. Does not return any facet tags.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the children UI tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenUITags = function()
  {
    var children = this.getChildren();
    var result = children.filter(
      function(tag, index, array)
      {
        return tag.isUITag();
      });

    return result;
  };

  /**
   * Get all of the defined attribute names for the tag.
   * @return {Array.<string>} all of the attribute names for the attributes that were
   *         specified on the tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributeNames = function()
  {
    var names = [];
    for (var name in this._attr)
    {
      names.push(name);
    }

    return names;
  };

  /**
   * Get if the given attribute is bound to an EL expression.
   * @param {string} name the name of the attribute to check.
   * @return {boolean} true if there is EL in the attribute value or false if the value
   *         is static or if the attribute was not defined.
   */
  adf.mf.api.amx.AmxTag.prototype.isAttributeElBound = function(name)
  {
    return AmxTag.__isELExpression(this.getAttribute(name));
  };

  /**
   * Get the attribute value (may be an EL string) for the attribute of the given name.
   * @param {string} name the name of the attribute
   * @return {string|undefined} the attribute value or undefined if the attribute was not specified.
   *         Returns the expression string for EL attributes.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttribute = function(name)
  {
    return this._attr[name];
  };

  /**
   * Get a k/v pair map of the attributes and their values.
   * @return {Object.<string, value>} map of name to value pairs.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributes = function()
  {
    return this._attr;
  };

  /**
   * Get if the node is a UI tag with a type handler and renders content.
   * @return {boolean} true if a UI tag
   */
  adf.mf.api.amx.AmxTag.prototype.isUITag = function()
  {
    if (this._uiTag == null)
    {
      // Lazily load the value. This ensures that the tag resources are loaded before we check
      // for a tag handler in case the tag handler is registered inside of a resource.
      var hasTagHandler = adf.mf.internal.amx.AmxTagHandler.__hasTagHandler(this._nsPrefixedName);
      this._uiTag = !hasTagHandler;
    }

    return this._uiTag;
  };

  /**
   * Get the tags for the children of this facet and the name of the facet if this tag
   * is a facet tag. Convenience function for building the AMX node tree.
   * @return {({name:string, children:Array.<adf.mf.api.amx.AmxTag>}|null)} an object with the
   *         name of the facet and the children tags of the facet. Returns null if the tag
   *         is not an AMX facet tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getFacet = function()
  {
    if (this._nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":facet")
    {
      var children = this.getChildren();
      var facetName = this.getAttribute("name");

      return { "name": facetName, "children": children };
    }

    return null;
  };

  /**
   * Create a new instance of an AMX node for this tag given the stamp ID. If the tag
   * is a facet tag, the tag will create the node for the child tag. This function does
   * not initialize the node.
   *
   * @param {(adf.mf.api.amx.AmxNode|null)} parentNode the parent AMX node or null if the
   *        tag/node is the root
   * @param {(Object|null)} key the stamp key to identify the node with the given key. May
   *        be null for non-iterating parent tags.
   * @return {(adf.mf.api.amx.AmxNode|null)} an un-initialized AMX node object or null
   *         for non-UI tags
   */
  adf.mf.api.amx.AmxTag.prototype.buildAmxNode = function(
    parentNode,
    key)
  {
    if (!this.isUITag())
    {
      // Currently do nothing for other non-UI tags, but we should consider adding
      // behaviors and other types of tags in the future to remove the hard-coded nature
      // of processing tags like the AMX setPropertyListener tag.
      return null;
    }

    return new adf.mf.api.amx.AmxNode(parentNode, this, key);
  };

  /**
   * Get the type handler for this tag.
   * @return {Object} the type handler
   */
  adf.mf.api.amx.AmxTag.prototype.getTypeHandler = function()
  {
    if (this._typeHandler === undefined)
    {
      var typeHandler = null;
      if (this._nsPrefixedName)
      {
        typeHandler = adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName];
        if (typeHandler == null)
        {
          var typeHandlerClass = adf.mf.api.amx.TypeHandler._classDictionary[this._nsPrefixedName];
          if (typeHandlerClass != null)
          {
            typeHandler = new typeHandlerClass();
            adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName] = typeHandler;
          }
        }
      }

      if (typeHandler === undefined && adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        // Could not find an associated TypeHandler.
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.api.amx.AmxTag", "getTypeHandler",
          "Unable to find TypeHandler for namespace = " + this._ns + ", ns prefixed name = " +
          this._nsPrefixedName + ", local name = " + this._name);
      }

      this._typeHandler = typeHandler;
    }

    return this._typeHandler;
  };

  /**
   * Internal function to check if the given value is an EL expression.
   * @param {(string|null)} value the value to check
   * @return {boolean} true if there is EL in the value or false if the value
   *         is static or if the value is null.
   * @ignore
   */
  adf.mf.api.amx.AmxTag.__isELExpression = function(value)
  {
    return value != null && value.indexOf("#{") >= 0;
  };

  /**
   * Get a type handler function (JavaScript class) for the given namespace and name.
   * Primarily used by the test JavaScript files to extend an existing type handler prototype.
   *
   * @param {string} tagNs the tag namespace
   * @param {string} tagName the tag name
   * @return {function} the type handler function if found, otherwise null
   */
  AmxTag.getTypeHandlerFunction = function(tagNs, tagName)
  {
    // Internal usage is for the first param to be the prefixed name
    var nsPrefixedName = arguments.length == 1 ? tagNs : tagNs + ":" + tagName;

    return adf.mf.api.amx.TypeHandler._classDictionary[nsPrefixedName];
  };

})();
/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ---------------- amx-tagInstance.js ------------------ */
/* ------------------------------------------------------ */

(function()
{
  /**
   * @namespace
   */
  adf.mf.internal.amx.AmxTagInstanceStates =
  {
    /** EL based attributes needed for rendering have not been fully loaded yet */
    "WAITING_ON_EL_EVALUATION": 0,
    /** EL attributes have been loaded, the node has not yet been rendered */
    "LOADED": 1
  };

  /**
   * Constructor for a tag instance. The tag instance represents a non-UI tag of an AMX
   * node and store node specific information. In the case of fragments, the tag instance
   * holds onto replaced EL strings that are specific to each individual node.
   *
   * @param {adf.mf.api.amx.AmxNode} parentAmxNode the AMX node that this tag instance
   *        belongs to
   * @param {adf.mf.internal.amx.AmxTagInstance} parentTagInstance the parent tag instance if
   *        nested
   * @param {adf.mf.api.amx.AmxTag} tag the refence to the tag for this instance
   * @constructor adf.mf.internal.amx.AmxTagInstance
   * @augments adf.mf.api.AdfObject
   */
  function AmxTagInstance(
    parentAmxNode,
    parentTagInstance,
    tag)
  {
    this.Init(parentAmxNode, parentTagInstance, tag);
  }

  adf.mf.internal.amx.AmxTagInstance = AmxTagInstance;
  adf.mf.api.AdfObject.createSubclass(adf.mf.internal.amx.AmxTagInstance, adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxTagInstance");

  /**
   * Initialize the tag instance. This function will evaluate the EL expressions, storing the
   * cached values into the object so that the values may be retrieved later without EL
   * evaluation. It also sets up the EL dependencies that will be used for data change events
   * to ensure the cached values are kept up to date.
   *
   * @param {adf.mf.api.amx.AmxNode} parentAmxNode the AMX node that this tag instance
   *        belongs to
   * @param {adf.mf.internal.amx.AmxTagInstance} parentTagInstance the parent tag instance if
   *        nested
   * @param {adf.mf.api.amx.AmxTag} tag the refence to the tag for this instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.Init = function(
    parentAmxNode,
    parentTagInstance,
    tag)
  {
    AmxTagInstance.superclass.Init.call(this);

    this._parentAmxNode = parentAmxNode;
    this._parentTagInstance = parentTagInstance;
    this._tag = tag;
    this._elAttributeMap = {}; // maps string (attribute name) to ELExpression (attribute value)
    this._tagHandler = adf.mf.internal.amx.AmxTagHandler.__getHandler(
      tag.getNsPrefixedName());

    this._attributesWaitingOnEl = 0;
    this._attributeNamesWaitingOnEl = {};
    this._state = adf.mf.internal.amx.AmxTagInstanceStates["LOADED"];

    // Create a set of the attributes that have their values stored on the tag instance
    this._cachedAttributes = {};

    // A map of the local (cached) attribute values
    this._attrs = {};

    var attrs = tag.getAttributes();
    for (var attrName in attrs)
    {
      var value = attrs[attrName];

      if (attrName != "id" && adf.mf.api.amx.AmxTag.__isELExpression(value))
      {
        var elExpression = adf.mf.internal.el.parser.parse(value);
        var expr = adf.mf.api.amx.AmxNode.__performElSubstitutions(elExpression);
        this._elAttributeMap[attrName] = expr;

        if (this._tagHandler.shouldPrefetchAttribute(attrName, expr))
        {
          var value = adf.mf.internal.amx.evaluateExpression(expr);
          this._attrs[attrName] = value;
          this._cachedAttributes[attrName] = true;
          if (value === undefined)
          {
            this._state = adf.mf.internal.amx.AmxTagInstanceStates["WAITING_ON_EL_EVALUATION"];
            ++this._attributesWaitingOnEl;
            this._attributeNamesWaitingOnEl[attrName] = true;
          }
        }
      }
    }

    this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(this._elAttributeMap);

    this._tagHandler.initializeTagInstance(this);

    this._children = [];

    if (parentTagInstance != null)
    {
      parentTagInstance._children.push(this);
    }
  };

  /**
   * @return {adf.mf.api.amx.AmxNode} get the AMX node that this tag instance belongs to
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getParentAmxNode = function()
  {
    return this._parentAmxNode;
  };

  /**
   * @return {(adf.mf.internal.amx.AmxTagInstance|null)} get the parent tag instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getParentTagInstance = function()
  {
    return this._parentTagInstance;
  };

  /**
   * @return {adf.mf.api.amx.AmxTag} get the tag for this instance
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getTag = function()
  {
    return this._tag;
  };

  /**
   * @param {(string|null)} namespace the namespace to filter the children by
   * @param {(string|null)} tagName the tag name to filter the children by (requires namespace to be
   *        provided)
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} the children tag instances
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getChildren = function(
    namespace,
    tagName)
  {
    var children = [];
    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      if (namespace != null)
      {
        var tag = child.getTag();
        if ((tagName != null && tagName != tag.getName()) ||
          namespace != tag.getNamespace())
        {
          continue;
        }
      }

      children.push(child);
    }
    return children;
  };

  /**
   * Get an EL expression for an attribute. For fragments, the EL expression will be already
   * replaced.
   *
   * @return {(ELExpression|null)} for EL bound attributes, returns the ELExpression of an attribute.
   *         Returns undefined for attributes that are not EL bound.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getAttributeExpression = function(name)
  {
    return this._elAttributeMap[name];
  };

  /**
   * Get an attribute value
   *
   * @param {string} name the name of the attribute to get the value
   * @param {boolean=} evaluateEl if not given, or true EL based attributes will be evaluated. If
   *        false, the EL string will be returned for EL based attributes.
   * @return {(Object|string)} returns the attribute value or the EL expression for the attribute.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getAttribute = function(
    name,
    evaluateEl)
  {
    // Default evaluateEl not being passed to a true value
    if (evaluateEl === undefined)
    {
      evaluateEl = true;
    }

    // Check to see if this is an attribute that has its value cached
    if (evaluateEl && this._cachedAttributes[name] == true)
    {
      return this._attrs[name];
    }

    var expr = this.getAttributeExpression(name);
    if (expr == null)
    {
      return this.getTag().getAttribute(name);
    }

    // If not evaluating the EL, return the expression
    return evaluateEl ? adf.mf.internal.amx.evaluateExpression(expr) : expr.getExpression ();
  };

  /**
   * Called from the node when a markNodeForUpdate call is being processed. This is
   * usually called as a result of a data change event.
   *
   * @param {Array.<string>} attributeNames the names of the attributes that should be
   *        updated. Any cached attributes in this array will re-evaluate their EL
   *        values to get the current values.
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.updateAttributes = function(
    attributeNames)
  {
    var oldValues = {};

    for (var a = 0, numAttrs = attributeNames.length; a < numAttrs; ++a)
    {
      var attrName = attributeNames[a];

      if (this._cachedAttributes[attrName] == true)
      {
        var expr = this.getAttributeExpression(attrName);
        var val = adf.mf.internal.amx.evaluateExpression(expr);

        var oldValue = this._attrs[attrName];
        oldValues[attrName] = oldValue;

        this._attrs[attrName] = val;

        // Notify the tag handler that a cached attribute's value has been changed
        this._tagHandler.attributeUpdated(this, attrName, oldValue, val);

        if (val !== undefined && this._attributeNamesWaitingOnEl[attrName])
        {
          delete this._attributeNamesWaitingOnEl[attrName];
          if (--this._attributesWaitingOnEl == 0)
          {
            this._state = adf.mf.internal.amx.AmxTagInstanceStates["LOADED"];
          }
        }
      }
    }
  };

  /**
   * Set a local value for an attribute on a tag instance. Allows type handlers and
   * tag instance handlers to store attributes on a tag instance
   *
   * @param {string} attributeName the name of the attribute
   * @param {Object} value the value to store. If undefined is passed, the attribute
   *        is removed from the cache
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.setAttribute = function(
    attributeName,
    value)
  {
    if (value === undefined)
    {
      delete this._cachedAttributes[attributeName];
      delete this._attrs[attributeName];
    }
    else
    {
      this._cachedAttributes[attributeName] = true;
      this._attrs[attributeName] = value;
    }
  };

  /**
   * Get the EL dependencies of this tag instance
   *
   * @return {adf.mf.internal.amx.AmxElDependencies} EL dependencies object
   */
  adf.mf.internal.amx.AmxTagInstance.prototype.getElDependencies = function()
  {
    return this._elDependencies;
  };

  adf.mf.internal.amx.AmxTagInstance.prototype.getState = function()
  {
    return this._state;
  };
})();
/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ----------------- amx-tagHandler.js ------------------ */
/* ------------------------------------------------------ */

(function()
{

  var handlerClassMap = {};
  var handlerInstanceMap = {};
  /**
   * The base class for handlers of non-UI tags.
   * This class is currently internal and the API is very rudimentary at the moment.
   * @constructor adf.mf.internal.amx.AmxTagHandler
   * @augments adf.mf.api.AdfObject
   */
  function AmxTagHandler()
  {
    this.Init();
  }

  // Make this internal as the API should not be exposed at this time until a full and
  // stable API can be designed.
  adf.mf.internal.amx.AmxTagHandler = AmxTagHandler;
  adf.mf.api.AdfObject.createSubclass(adf.mf.internal.amx.AmxTagHandler, adf.mf.api.AdfObject,
    "adf.mf.internal.amx.AmxTagHandler");

  /**
   * Register a tag handler with a namespace and name.
   * @param {string} namespace the xmlns for the tag
   * @param {string} tagName the name of the tag (no namespace)
   * @param {(adf.mf.internal.amx.AmxTagHandler|null)} precreatedClass optional pre-created class to
   *        register
   * @return {Function} the registered adf.mf.internal.amx.AmxTagHandler subclass
   */
  adf.mf.internal.amx.AmxTagHandler.register = function(
    namespace,
    tagName,
    precreatedClass)
  {
    // make sure that our class is initialized, since we are using a Factory Method
    adf.mf.api.AdfObject.ensureClassInitialization(AmxTagHandler);
    var registeredClass = precreatedClass;

    if (namespace != null && tagName != null)
    {
      if (registeredClass == null)
      {
        // Create the new class and make it inherit from adf.mf.internal.amx.AmxTagHandler:
        registeredClass =
          function RegisteredTagHandler()
          {
            this.Init();
          };

        adf.mf.api.AdfObject.createSubclass(
          registeredClass,
          adf.mf.internal.amx.AmxTagHandler,
          "TagHandler[" + namespace + ":" + tagName + "]");
      }

      // Make the association so we can find the class:
      var id = namespace + ":" + tagName;
      handlerClassMap[id] = registeredClass;
    }
    else // invalid registration, do not register the TagHandler class
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.internal.amx.AmxTagHandler.register", "MSG_INVALID_TYPE_HANDLER_REGISTRATION",
        namespace, tagName);
    }

    return registeredClass;
  };

  /**
   * Function used by the tag instances to retrieve a tag handler instance.
   *
   * @param {string} nsPrefixedTagName the namespace and tag name separated by a colon
   * @return {(adf.mf.internal.amx.AmxTagHandler|null)} an instance of a tag handler if one
   *         is registered for the given name, otherwise null is returned.
   * @ignore
   */
  adf.mf.internal.amx.AmxTagHandler.__getHandler = function(
    nsPrefixedTagName)
  {
    var instance = handlerInstanceMap[nsPrefixedTagName];

    if (instance == null)
    {
      var cls = handlerClassMap[nsPrefixedTagName];

      if (cls != null)
      {
        instance = new cls();
        handlerInstanceMap[nsPrefixedTagName] = instance;
      }
    }

    return instance;
  };

  /**
   * Check if a tag handler has been specified for the prefixed name. If
   * there is no tag handler, the tag is a UI tag.
   *
   * @param {string} nsPrefixedTagName the namespace then a colon then the tag name
   * @return {boolean} true if there is a registered tag handler
   * @ignore
   */
  adf.mf.internal.amx.AmxTagHandler.__hasTagHandler = function(
    nsPrefixedTagName)
  {
    return AmxTagHandler.__getHandler(nsPrefixedTagName) != null;
  };

  adf.mf.internal.amx.AmxTagHandler.prototype.Init = function()
  {
    AmxTagHandler.superclass.Init.call(this);
  };

  /**
   * Check if the tag attribute with the given EL expression should
   * be pre-fetched during the construction of the tag instance.
   * This ensures that the value is present in the cache when the
   * value should be retrieved. It also ensures that no EL values will
   * be evaluated during rendering.
   *
   * @param {string} attrName the name of the tag attribute
   * @param {string} elExpression the EL expression for the attribute.
   *        In the case of fragments, it will already have been resolved
   *        of any fragment attribute names.
   * @return {boolean} true if the attribute should be evaluated during
   *         tag instance construction
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.shouldPrefetchAttribute = function(
    attrName,
    elExpression)
  {
    // By default pre-fetch all EL bound attribute values
    return true;
  };

  /**
   * Callback after all of the attributes for the tag instance have been
   * fetched. Allows the tag handler to perform any initialization. The base
   * implementation will mark the parent AMX node as waiting on EL evaluation
   * if any of the attributes were not in the EL cache.
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the tag instance
   *        being initialized
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.initializeTagInstance = function(
    tagInstance)
  {
  };

  /**
   * Callback to notify the tag handler that an attribute has been updated on
   * the tag instance. Typically called as a result of a data change event.
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the tag instance
   *        that was updated
   * @param {string} attributeName the name of the attribute that was updated
   * @param {Object} oldValue the old value of the attribute
   * @param {Object} newValue the new value of the attribute
   */
  adf.mf.internal.amx.AmxTagHandler.prototype.attributeUpdated = function(
    tagInstance,
    attributeName,
    oldValue,
    newValue)
  {
    var amxNode = tagInstance.getParentAmxNode();
    if (newValue == undefined && tagInstance.getAttributeExpression(attributeName) != null &&
      amxNode.isReadyToRender())
    {
      amxNode.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
  };

})();
/* Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ---------------- amx-tagHandlers.js ------------------ */
/* ------------------------------------------------------ */

(function()
{
  // This file houses the built in tag (non-UI) handlers. The tag handlers are currently mostly
  // place holders until a full tag API can be designed.

  var AmxTagHandler = adf.mf.internal.amx.AmxTagHandler;

  // --------- Temporary handlers --------- //
  // Register tag handlers for tags that have no behavior in this file (other tags
  // handle the logic)
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attributeList",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attributeSet",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "transition", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "loadingIndicatorBehavior",
    AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationBehavior",
    AmxTagHandler);

  // TODO: introduce a special API for converters. For now, just let them use the default handler
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "convertNumber", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "convertDateTime", AmxTagHandler);

  // TODO: introduce an action/behavior tag to process events. For now, use the default
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "showPopupBehavior", AmxTagHandler);
  AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "closePopupBehavior", AmxTagHandler);
  // --------- /Temporary handlers --------- //

  // --------- attribute --------- //
  // Tag handler for AMX fragment attributes. Prevent the fetching of the value attribute by default
  // in case the EL points to a method and not a value expression.
  var attributeTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "attribute",
    AmxTagHandler);
  attributeTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "value";
  };
  // --------- /attribute --------- //


  // --------- actionListener --------- //
  // Use a custom tag handler for the actionListener tag to prevent the EL evaluation of the binding
  // attribute during tag instance construction
  var actionListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "actionListener");

  actionListenerTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "binding";
  };
  // --------- /actionListener --------- //

  // --------- clientListener --------- //
  var clientListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "clientListener");

  clientListenerTagHandler._NON_DOM_EVENT_TYPES = {
    "move": true,
    "rangeChange": true,
    "selection": true,
    "valueChange": true
  };

  clientListenerTagHandler.prototype.initializeTagInstance = function(tagInstance)
  {
    // Get the attribute type. If none is specified assume an action attribute.
    var attrType;
    var type = tagInstance.getAttribute("type");
    if (type != null)
      attrType = adf.mf.internal._getEventTypeResolvedForBidi(type);
    else // use default type
      attrType = "action";

    // Only add types that are DOM events (non-DOM events are already handled):
    if (!clientListenerTagHandler._NON_DOM_EVENT_TYPES[attrType])
    {
      // The parent AMX node will have a list without duplication (map with dummy keys) that indicate
      // which clientListener events the app developer wants the TypeHandler to support.
      var parentAmxNode = tagInstance.getParentAmxNode();
      var clientListenerTypesKey = "data-clientListenerTypes";
      var clientListenerTypes = parentAmxNode.getAttribute(clientListenerTypesKey);
      if (clientListenerTypes == null)
      {
        clientListenerTypes = {};
        parentAmxNode.setAttributeResolvedValue(clientListenerTypesKey, clientListenerTypes);
      }

      clientListenerTypes[attrType] = true;
    }
  };
  // --------- /clientListener --------- //

  // --------- navigationDragBehavior --------- //
  // Use a custom tag handler for the navigationDragBehavior tag to prevent the EL evaluation of the action
  // attribute during tag instance construction
  var navigationDragBehaviorTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "navigationDragBehavior");

  navigationDragBehaviorTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "action";
  };
  // --------- /navigationDragBehavior --------- //
  
  // --------- setPropertyListener --------- //
  // Use a custom tag handler for the setPropertyListener tag to prevent the EL evaluation of the
  // attributes during tag instance construction
  var setPropertyListenerTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "setPropertyListener");

  setPropertyListenerTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return false;
  };
  // --------- /setPropertyListener --------- //

  // --------- loadBundle --------- //
  // Use a custom tag handler for the loadBundle tag to prevent the EL evaluation of the
  // basename attribute during tag instance construction
  var loadBundleTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "loadBundle");

  loadBundleTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return name != "basename";
  };
  // --------- /loadBundle --------- //
  
  // --------- systemActionBehavior --------- //
  // Use a custom tag handler for the systemActionBehavior tag to prevent the EL evaluation of the actionListener
  // and action attributes during tag instance construction
  var systemActionBehaviorTagHandler = AmxTagHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
    "systemActionBehavior");

  systemActionBehaviorTagHandler.prototype.shouldPrefetchAttribute = function(name)
  {
    return (name != "actionListener" && name != "action");
  };
  // --------- /systemActionBehavior --------- //
})();
/* Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------ amx-nodeUpdateArguments.js -------------- */
/* ------------------------------------------------------ */

(function()
{
  /**
   * Internal object for the arguments to the markNodeForUpdate function
   * @constructor adf.mf.api.amx.AmxNodeUpdateArguments
   * @augments adf.mf.api.AdfObject
   */
  function AmxNodeUpdateArguments()
  {
    this.Init();
  }

  /**
   * @deprecated
   */
  adf.mf.internal.amx.AmxNodeUpdateArguments = AmxNodeUpdateArguments;

  /*
   * Object for the arguments passed into the adf.mf.api.amx.markNodeForUpdate function.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments = AmxNodeUpdateArguments;

  adf.mf.api.AdfObject.createSubclass(
    adf.mf.api.amx.AmxNodeUpdateArguments,
    adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxNodeUpdateArguments");

  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.Init = function()
  {
    AmxNodeUpdateArguments.superclass.Init.call(this);
    this._amxNodes = [];
    this._affectedAttributes = {};
    this._collectionChanges = {};
    this._affectedTagInstances = {};
    this._affectedTagInstanceAttributes = {};
    this._canceled = false;
  };

  /**
   * Check if the update has been canceled
   * @return {boolean} true if canceled
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.isCanceled = function()
  {
    return this._canceled;
  };

  /**
   * Request that the update be canceled. If the update has been queued, calling this function
   * will prevent the update from being executed. This may be used if an asynchronous event has
   * occurred while the update has been queued that makes the update undesirable. If the update
   * has already run or is in progress this function will not have an effect.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.cancel = function()
  {
    this._canceled = true;
  };

  /**
   * Get an array of affected AmxNodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getAffectedNodes = function()
  {
    return this._amxNodes;
  };

  /**
   * Get an object representing the affected attributes for a given AmxNode ID
   * @param {string} amxNodeId the AmxNode ID
   * @return {Object<string, boolean>} an object with the changed
   *         attributes as keys and "true" as the value.
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getAffectedAttributes = function(amxNodeId)
  {
    var affected = this._affectedAttributes[amxNodeId];
    return affected == null ? {} : affected;
  };

  /**
   * Get the collection changes for a given AmxNode and property
   * @param {string} amxNodeId the AmxNode ID
   * @return {(Object<string, adf.mf.api.amx.AmxCollectionChange>|undefined)} an object with the
   *         attributes as keys and the collection change objects for the values. May
   *         be undefined if there are no changes for a given AmxNode
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.getCollectionChanges = function(amxNodeId)
  {
    return this._collectionChanges[amxNodeId];
  };

  /**
   * Mark an attribute of an AmxNode as affected
   * @param {adf.mf.api.amx.AmxNode} amxNode the affected AmxNode
   * @param {string} attributeName the name of the affected attribute
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.setAffectedAttribute = function(
    amxNode,
    attributeName)
  {
    var amxNodeId = amxNode.getId();
    var affected = this._affectedAttributes[amxNodeId];
    if (affected == null)
    {
      affected = {};
      this._affectedAttributes[amxNodeId] = affected;

      // Mark the node dirty if it hasn't already
      if (this._affectedTagInstances[amxNode] == null)
      {
        this._amxNodes.push(amxNode);
      }
    }

    affected[attributeName] = true;
  };

  /**
   * Set the collection changes for a given AmxNode's attribute
   * @param {string} amxNodeId the AMX node ID
   * @param {string} attributeName the name of the attribute that the collection had changes
   * @param {adf.mf.api.amx.AmxCollectionChange} collectionChanges the changes for the collection
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.setCollectionChanges = function(
    amxNodeId,
    attributeName,
    collectionChanges)
  {
    var obj = this._collectionChanges[amxNodeId];
    if (obj == null)
    {
      obj = {};
      this._collectionChanges[amxNodeId] = obj;
    }

    obj[attributeName] = collectionChanges;
  };

  /**
   * Internal function to get a list of affected tag instance IDs for a given AMX node.
   *
   * @param {string} amxNodeId the AMX node ID
   * @return {Array.<string>} IDs of the affected tag instances. Will return an empty array if
   *         there are not IDs.
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__getAffectedTagInstanceIds = function(
    amxNodeId)
  {
    var affected = this._affectedTagInstances[amxNodeId];
    return affected == null ? [] : affected;
  };

  /**
   * Internal function to get the affected attribute names for an AMX node and its tag instance ID
   *
   * @param {string} amxNodeId the ID of the affected AMX node
   * @param {string} amxTagId the ID of the affected AMX tag ID
   * @return {Array.<string>} array of affected attributes. Will return an empty array if there are
   *         none.
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__getAffectedAttributesForTagInstance = function(
    amxNodeId,
    amxTagId)
  {
    var key = amxNodeId + "/" + amxTagId;
    var affected = this._affectedTagInstanceAttributes[key];
    return affected == null ? [] : affected;
  };

  /**
   * Internal function to mark a tag's attribute as dirty
   *
   * @param {adf.mf.internal.amx.AmxTagInstance} tagInstance the affected tag instance
   * @param {string} attributeName the name of the affected attribute
   * @ignore
   */
  adf.mf.api.amx.AmxNodeUpdateArguments.prototype.__setAffectedAttributeForTagInstance = function(
    tagInstance,
    attributeName)
  {
    var amxNode = tagInstance.getParentAmxNode();
    var amxTagId = tagInstance.getTag().getAttribute("id");
    var amxNodeId = amxNode.getId();
    var affectedTagInstanceIds = this._affectedTagInstances[amxNodeId];

    // Mark the instance dirty
    if (affectedTagInstanceIds == null)
    {
      affectedTagInstanceIds = [ amxTagId ];
      this._affectedTagInstances[amxNodeId] = affectedTagInstanceIds;

      // Mark the node dirty if it has not already
      if (this._affectedAttributes[amxNodeId] == null)
      {
        this._amxNodes.push(amxNode);
      }
    }
    else if (affectedTagInstanceIds.indexOf(amxTagId) == -1)
    {
      // Mark the instance as dirty
      affectedTagInstanceIds.push(amxTagId);
    }

    // Mark the attribute dirty
    var key = amxNodeId + "/" + amxTagId;

    var affectedAttributes = this._affectedTagInstanceAttributes[key];

    if (affectedAttributes == null)
    {
      this._affectedTagInstanceAttributes[key] = [ attributeName ];
    }
    else if (affectedAttributes.indexOf(attributeName) == -1)
    {
      affectedAttributes.push(attributeName);
    }
  };

})();
/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-node.js ---------------------- */
/* ------------------------------------------------------ */

(function()
{
  var nodeToElMap = {};

  // ------ AMX Node ------ //
  /**
   * AMX node definition. The AMX node constructor is private and only the framework
   * may create new node objects.
   * (parameters TBD)
   * @constructor adf.mf.api.amx.AmxNode
   * @augments adf.mf.api.AdfObject
   */
  function AmxNode(
    parentNode,
    tag,
    key)
  {
    this.Init(parentNode, tag, key);
  }

  adf.mf.api.amx.AmxNode = AmxNode;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.AmxNode, adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxNode");

  AmxNode.prototype.Init = function(
    parentNode,
    tag,
    key)
  {
    AmxNode.superclass.Init.call(this);

    this._tag = tag;
    this._parent = parentNode;
    this._children = {};
    this._facets = {};
    this._attr = {};
    this._modifiableEl = {};
    this._key = key === undefined ? null : key;
    this._state = adf.mf.api.amx.AmxNodeStates["INITIAL"];
    this._childrenCreated = false;
    this._id = null;
    this._converterTag = null;
    this._converter = null;
    this._elDependencies = null;
    this._elAttributeMap = null;

    // Store the tag instances for all children non-UI tags
    this._tagInstances = null;

    // Variables to track what EL is not yet cached that is required
    this._tagInstancesWaitingOnEl = 0;
    this._tagInstanceIdsWaitingOnEl = {};
    this._attributesWaitingOnEl = 0;
    this._attributeNamesWaitingOnEl = {};

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "Init",
        "Created AMX node for tag " + tag.getNsPrefixedName() + " and ID attribute " +
        tag.getAttribute("id"));
    }

    // Increment the number of nodes waiting
    adf.mf.internal.amx._pageBusyTracker.increment();
  };

  /**
   * Get the unique identifier for this node. This is used as the ID on the root HTML element
   * rendered by this node.
   */
  AmxNode.prototype.getId = function()
  {
    return this._id;
  };

  /**
   * Get the AMX tag that created this node.
   * @return {adf.mf.api.amx.AmxTag} the tag that created the node
   */
  AmxNode.prototype.getTag = function()
  {
    return this._tag;
  };

  /**
   * Get the type handler for this node.
   * @return {Object} the type handler
   */
  AmxNode.prototype.getTypeHandler = function()
  {
    return this.getTag().getTypeHandler();
  };

  /**
   * Fetches the client state for this AMX node based on its ID that was previously stored.
   * TypeHandlers would call this to retrieve old state in render(), refresh(), or postDisplay().
   * @return {Object} undefined or the client state data that was previously stored in this view instance
   */
  AmxNode.prototype.getClientState = function()
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      // The client side state map may not be available if this call is performed on a view that
      // is being destroyed. For example, when a task flow return has been executed, the map will
      // be set to null until the new page context has been setup
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx.AmxNode", "getClientState",
          "State not able to be retrieved, client state map is not available for AmxNode " +
          amxNodeId);
      }
      return undefined;
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * Stores/replaces the client state for this AMX node based on its ID (if the ID changes, you won't
   * get the same data).
   * Preferrably, TypeHandler functions would call this whenever a state change happens (i.e. something
   * you want to cache so that when the user navigates to a new page and later comes back, you will be
   * able to restore it like a scroll position).
   * However, it is not always feasible to detect when a state change happens so you may need
   * to update the state for your component just before the view is going to be
   * discarded. There are 2 possible scenarios that you will need to account for:
   * - Renderer refresh() (for navigating to the same view again)
   * - Renderer preDestroy() (for navigating to a new view and navigating back at a later time)
   * @param {String} amxNodeId the amxNode.id that uniquely identifies the stored data
   * @param {Object} payloadJsonObject the client state data to store for the lifetime of this view instance
   */
  AmxNode.prototype.setClientState = function(payloadJsonObject)
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      // The client side state map may not be available if this call is performed on a view that
      // is being destroyed. For example, when a task flow return has been executed, the map will
      // be set to null until the new page context has been setup
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx.AmxNode", "setClientState",
          "State not being saved, client state map is not available for AmxNode " + amxNodeId);
      }
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Fetches the volatile state for this AMX node based on its ID that was previously stored.
   * TypeHandlers would call this to retrieve old state in render(), refresh(), or postDisplay().
   * @return {Object} undefined or the volatile state data that was previously stored since the last navigation
   */
  AmxNode.prototype.getVolatileState = function()
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getVolatileStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
	  			stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * Stores/replaces the AMX volatile state for the specified AMX node ID.
   * Preferrably, renderers would call this whenever a volatile state change happens (i.e. something you want
   * to forget when navigating to a new AMX page but might want to keep around in case a component gets redrawn.
   * @param {Object} payloadJsonObject the volatile state data to store until navigation
   */
  AmxNode.prototype.setVolatileState = function(payloadJsonObject)
  {
    var amxNodeId = this.getId();
    var stateValue = adf.mf.internal.amx._getVolatileStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
	  			amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
	  			stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Get the converter, if set, for this node.
   */
  AmxNode.prototype.getConverter = function()
  {
    return this._converter;
  };

  /**
   * Set the converter for this node.
   */
  AmxNode.prototype.setConverter = function(converter)
  {
    this._converter = converter;
  };

  /**
   * For an attribute, create and store an EL expression that may be used to set EL values
   * into the model. The value is context insensitive and may be used to set a value at any
   * time. Common use is to set a value based on user interaction. May be called by type
   * handlers.
   *
   * @param {string} name the name of the attribute
   * @return {(string|null)} the modifyable EL. Also stored on the node. Returns null if the
   *         attribute in question is not bound to an EL value.
   */
  AmxNode.prototype.storeModifyableEl = function(name)
  {
    var tag = this.getTag();
    if (tag.isAttributeElBound(name))
    {
      var el = this.getAttributeExpression(name, false, true);
      el = el.toContextFreeExpression();
      this._modifiableEl[name] = el;
      return el;
    }
    else
    {
      return null;
    }
  };

  /**
   * Initializes the node, performing any EL evaluation and any other pre-render logic.
   * Called by the framework. It is expected for the state to be WAITING_ON_EL_EVALUATION,
   * ABLE_TO_RENDER or UNRENDERED after invoking this function. This function also creates
   * the children AMX nodes once the status is WAITING_ON_EL_EVALUATION, but does not
   * initialize them.
   */
  AmxNode.prototype.init = function()
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Initialize AMX node", adf.mf.log.level.FINEST, null);
    var state = this.getState();
    var tag = this.getTag();
    var attr = tag.getAttributes();
    var name = null;

    try
    {
      // Create a unique ID that is based on the stamped key, if present.
      this._createUniqueId();

      // Set Call instance name after unique id has been created
      var instanceName = tag.getName() + ":" + this.getId();
      perf.setInstanceName(instanceName);

      // TODO: although no types currently need to customize how attributes
      // are loaded, we really need a method to allow the type handlers to
      // control what attributes are processed and how they are processed.
      // Due to time constraints and the desire to make sure the API is solid,
      // it is not being added at this time.

      // Process the rendered attribute if we haven't already
      var cacheMiss = this._processAttribute("rendered");

      if (cacheMiss)
      {
        // Ensure the state is still INITIAL so that the building
        // of the node hierarchy does not continue
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);

        // At this time, only setup the data change events for the rendered attribute
        this._registerRenderedAttributeForDataChange();

        return;
      }

      if (!this.getAttribute("rendered"))
      {
        if (this.getAttributeExpression("rendered") != null)
        {
          // Hookup data change events on the rendered attribute when EL bound
          this._registerRenderedAttributeForDataChange();
        }

        // Update the state
        this.setState(adf.mf.api.amx.AmxNodeStates["UNRENDERED"]);
        return;
      }

      for (name in attr)
      {
        // ID and rendered attributes have already been processed
        if (name == "rendered" || name == "id")
        {
          continue;
        }

        this._processAttribute(name);
      }

      // Now, look for a converter tag
      this._processConverterTag();

      // Update the state to reflect if all the EL is available
      this.setState(this._tagInstancesWaitingOnEl == 0 &&
        this._attributesWaitingOnEl == 0 ?
        adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"] :
        adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);

      state = this.getState();
      if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
        state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
      {
        // Once all the necessary EL has been loaded, create the children nodes,
        // but do not initialize them
        this._createChildren();

        state = this.getState();
        if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
          state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
        {
          if (this._processConverter())
          {
            this._convertValue();
          }
        }
      }

      // Setup validation of the input value of this node if there is one
      this._setupInputValueValidation();

      // Finally hook up the data change events
      this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(
        this._getAttributesExpressionMap());
      this._postProcessForDataChangeNotification(true);
    }
    finally
    {
      perf.stop();
    }
  };

  /**
   * Get the stamp key for the AMX node. The stamp key identifies AMX nodes that are produced inside of
   * iterating containers. This is provided by the parent node. An example tag that uses stamp keys is
   * the AMX iterator tag.
   * @return {(Object|null)} the key or null if the node was not stamped
   */
  AmxNode.prototype.getStampKey = function()
  {
    return this._key;
  };

  /**
   * Get a list of the attribute names that have been defined for this node.
   * @return {Array.<string>} array of the attribute names
   */
  AmxNode.prototype.getDefinedAttributeNames = function()
  {
    var names = [];
    for (var name in this._attr)
    {
      names.push(name);
    }
    return names;
  };

  /**
   * Gets an attribute value for the attribute of the given name.
   * @param {string} name the name of the attribute
   * @return {(Object|null|undefined)} returns the value (may be null) or
   *         undefined if the attribute is not set or is not yet loaded.
   */
  AmxNode.prototype.getAttribute = function(name)
  {
    return this._attr[name];
  };

  /**
   * Given the name of an attribute, get the EL expression.
   *
   * @param {string} name the name of the attribute
   * @param {boolean=} returnStaticValue if true and the attribute is not EL bound, the string
   *        value of the attribute from the tag will be returned or undefined if the attribute is
   *        not defined on the tag
   * @param {boolean} returnEL if true, the ELExpression value of the attribute from the tag
   *        will be returned or undefined if the attribute is not defined on the tag.
   *        If false, it will return String representation of EL Expression.
   * @return {(string|null)} the EL expression if the attribute is EL bound, otherwise null.
   */
  AmxNode.prototype.getAttributeExpression = function(
    name,
    returnStaticValue,
    returnEL)
  {
    var tag = this.getTag();

    // See if this attribute is an EL expression
    if (!tag.isAttributeElBound(name))
    {
      return (returnStaticValue === true) ? tag.getAttribute(name) : null;
    }

    var expr;
    if (this._elAttributeMap != null)
    {
      expr = this._elAttributeMap[name];
      if (expr != null)
      {
        return returnEL ? expr: expr.getExpression();
      }
    }

    var value = tag.getAttribute(name);

    var expr = adf.mf.internal.el.parser.parse(value);
    expr = AmxNode.__performElSubstitutions(expr);

    if (expr != null)
    {
      if (this._elAttributeMap == null)
      {
        this._elAttributeMap = {};
      }

      this._elAttributeMap[name] = expr;
    }

    return returnEL ? expr : expr.getExpression();
  };

  /**
   * Used by the type handler or the framework to store the attribute value for an attribute onto
   * the node. This function does not update the model.
   * @param {string} name the name of the attribute
   * @param {object} value the value of the attribute
   */
  AmxNode.prototype.setAttributeResolvedValue = function(name, value)
  {
    this._attr[name] = value;
  };

  /**
   * For use by type handlers to set the value of an attribute on the model. This value will be sent
   * to the Java side to update the EL value. The value on the AMX node will not be updated by this
   * call, it is expected that a data change event will result to update the AMX node.
   * @param {string} name the name of the attribute
   * @param {object} value the new value of the attribute
   */
  AmxNode.prototype.setAttribute = function(name, value)
  {
    var that = this;
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        var el = that._modifiableEl[name];

        if (el == null)
        {
          var tag = that.getTag();

          // If the EL is null, then this will not work if the node is
          // not in context. Try to set the EL using the raw EL from the tag
          //
          // First, ensure the attribute is EL bound
          if (tag.isAttributeElBound(name))
          {
            el = that.getTag().getAttribute(name);
          }
        }

        that.setAttributeResolvedValue(name, value);

        if (el == null)
        {
          // If this attribute was not EL based, just resolve the promise
          resolve();
        }
        else
        {
          var oldValue = that.getAttribute(name);
          var p = {"name": el, "value": value};
          if (!el.indexOf) {
              p["name"] = el.getExpression();
              p["expression"] = el;
          }
          amx.setElValue(p)
            .then(
              function()
              {
                resolve();
              },
              function()
              {
                that.setAttributeResolvedValue(name, oldValue);
              });
        }
      }); // TODO We do not want to support/document that this returns a promise object resolved once the
          //      value has been set. Instead, we ought to provide success/failed callbacks as parameters.
  };

  /**
   * Check if the attribute has been specified.
   * @param {string} name the name of the attribute
   * @return {boolean} true if the attribute was defined by the user
   */
  AmxNode.prototype.isAttributeDefined = function(name)
  {
    return this._tag.getAttribute(name) !== undefined;
  };

  /**
   * Get the parent AMX node.
   * @return {(adf.mf.api.amx.AmxNode|null)} the parent node or null for the top level
   *         node.
   */
  AmxNode.prototype.getParent = function()
  {
    return this._parent;
  };

  /**
   * Adds a child AMX node to this node. Should only be called by the framework or the type handler.
   * @param {adf.mf.api.amx.AmxNode} child the child to add
   * @param {(string|null)} facetName the name of the facet or null if the child does not belong in a
   *        facet.
   */
  AmxNode.prototype.addChild = function(child, facetName)
  {
    var key = child.getStampKey();
    var children;
    if (facetName == null)
    {
      children = this._children[key];
      if (children == null)
      {
        this._children[key] = children = [];
      }
    }
    else
    {
      var facets = this._facets[key];
      if (facets == null)
      {
        facets = this._facets[key] = {};
      }
      children = facets[facetName];
      if (children == null)
      {
        facets[facetName] = children = [];
      }
    }

    children.push(child);
  };

  /**
   * Remove a child node from this node. Note that the AMX node will be removed from the hierarchy,
   * but not the DOM for that node. It is up to the caller to remove the DOM. This is to allow
   * type handlers to handle animation and other transitions when DOM is replaced.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode the node to remove
   * @return {boolean} true if the node was found and removed.
   */
  AmxNode.prototype.removeChild = function(amxNode)
  {
    var key = amxNode.getStampKey();
    var nodeId = amxNode.getId();
    var state = amxNode.getState();
    var result = this._findChildIndexAndFacetName(key, nodeId);

    if (result == null)
    {
      return false;
    }

    amxNode._removeFromDataChangeNotification(true);

    var facetName = result["facetName"];
    var childrenArray = null;
    var index = result["index"];

    if (facetName == null)
    {
      childrenArray = this._children[key];
    }
    else
    {
      childrenArray = this._facets[key][facetName];
    }

    // Splice updates the array in place
    childrenArray.splice(index, 1);

    return true;
  };

  /**
   * Removes any children that are present with the given stamp key
   * @param {object} stampKey the key to use to find the nodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of the nodes removed
   */
  AmxNode.prototype.removeChildrenByKey = function(
    stampKey)
  {
    var removed = [];

    // Note, slice used to create a copy so it will not be modified during changes
    var children = this.getChildren(null, stampKey).slice();

    for (var c = 0, numChildren = children.length; c < numChildren; ++c)
    {
      var child = children[c];
      if (this.removeChild(child))
      {
        removed.push(child);
      }
    }

    return removed;
  };

  /**
   * Replace a child node with a new node.
   * @param {adf.mf.api.amx.AmxNode} oldNode the node to replace
   * @param {adf.mf.api.amx.AmxNode} newNode the replacement node
   * @return {boolean} true if the old node was found and replaced.
   */
  AmxNode.prototype.replaceChild = function(
    oldNode,
    newNode)
  {
    var key = oldNode.getStampKey();
    var nodeId = oldNode.getId();
    var result = this._findChildIndexAndFacetName(key, nodeId);
    if (result == null)
    {
      return false;
    }

    oldNode._removeFromDataChangeNotification(true);

    var facetName = result["facetName"];
    if (facetName == null)
    {
      this._children[key][result["index"]] = newNode;
    }
    else
    {
      var facetChildren = this._facets[key][facetName];
      facetChildren[result["index"]] = newNode;
    }

    return true;
  };

  /**
   * Get the children AMX nodes.
   * @param {(string|null|undefined)} facetName the name of the facet to retrieve the children
   *        or null to get the non-facet children.
   * @param {(Object|null|undefined)} key An optional key to specify for stamping. If provided, it will retrieve
   *        the children AMX nodes for a given stamping key.
   * @return {Array.<adf.mf.api.amx.AmxNode>} an array of the children AMX nodes. Returns an empty array
   *         if no children exist or if there are no children for the given stamp key.
   */
  AmxNode.prototype.getChildren = function(facetName, key)
  {
    if (key === undefined)
    {
      key = null;
    }

    var children;
    if (facetName == null)
    {
      children = this._children[key];
    }
    else
    {
      var facets = this._facets[key];
      if (facets == null)
      {
        return [];
      }

      children = facets[facetName];
    }

    return children == null ? [] : children;
  };

  /**
   * Get all of the facets of the AMX node.
   * @param {(Object|null|undefined)} key An optional key to specify for stamping. If provided, it will retrieve
   *        the facet AMX nodes for a given stamping key.
   * @return {Object.<string, Array.<adf.mf.api.amx.AmxNode>>} map of facets defined for the node
   */
  AmxNode.prototype.getFacets = function(key)
  {
    if (key === undefined)
    {
      key = null;
    }

    var facets = this._facets[key];
    return facets == null ? {} : facets;
  };

  /**
   * Perform a tree visitation starting from this node.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visit = function(
    context,
    callback)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "visit"))
    {
      return th.visit(this, context, callback);
    }

    if (context.isVisitAll() || context.getNodesToVisit().indexOf(this) >= 0)
    {
      var result = callback(context, this);
      switch (result)
      {
        case adf.mf.api.amx.VisitResult["ACCEPT"]:
          return this.visitChildren(context, callback);

        case adf.mf.api.amx.VisitResult["REJECT"]:
          return false;

        case adf.mf.api.amx.VisitResult["COMPLETE"]:
        default:
          return true;
      }
    }

    return this.visitChildren(context, callback);
  };

  /**
   * Perform a tree visitation of the children of the node.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visitChildren = function(
    context,
    callback)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "visitChildren"))
    {
      return th.visitChildren(this, context, callback);
    }

    return this.visitStampedChildren(null, null, null,
      context, callback);
  };

  /**
   * Convenience function for type handlers that stamp their children to
   * visit the children AMX nodes from inside of a custom visitChildren
   * function.
   *
   * @param {object} key the stamp key of the children to visit.
   * @param {(Array.<string>|null)} facetNamesToInclude list of facet names to visit.
   *        If empty the facets will not be processed for this
   *        stamp. If null, all the facets will be processed. To visit the children of
   *        non-facets, include null in the array.
   * @param {(function|null)} filterCallback an optional function to filter the children
   *        to visit. The function will be invoked with this node,
   *        the stamp key, and the child node.
   *        Function must return a boolean. If true, the tag will be used to create
   *        children, if false the tag will not be processed.
   * @param {adf.mf.api.amx.VisitContext} context the visit context
   * @param {Function} callback the callback function to invoke when visiting. Should accept
   *        the context and the node as arguments
   * @return {boolean} true if the visitation is complete and should not continue.
   */
  AmxNode.prototype.visitStampedChildren = function(
    key,
    facetNamesToInclude,
    filterCallback,
    visitContext,
    visitCallback)
  {
    var visitAll = visitContext.isVisitAll();
    var nodesToWalk = visitContext.getNodesToWalk();

    var facetNames;
    if (facetNamesToInclude == null)
    {
      facetNames = [];
      var facets = this.getFacets(key);
      for (var name in facets)
      {
        facetNames.push(name);
      }
      facetNames.push(null);
    }
    else
    {
      facetNames = facetNamesToInclude;
    }

    for (var f = 0, numFacets = facetNames.length; f < numFacets; ++f)
    {
      var facetName = facetNames[f];
      var children = this.getChildren(facetName, key);
      // Loop through all the children, note if the facet name is null
      // then we are visiting the direct (non-facet) children.
      for (var i = 0, size = children.length; i < size; ++i)
      {
        var child = children[i];
        // See if we are visiting all or if the node is one to be visited
        if (visitAll || nodesToWalk.indexOf(child) >= 0)
        {
          // If there is a filter function, call it to see if this node
          // should be visited
          if (filterCallback == null ||
            filterCallback(this, key, child))
          {
            if (child.visit(visitContext, visitCallback))
            {
              return true;
            }
          }
        }
      }
    }

    return false;
  };

  /**
   * Get the rendered children of the AMX node.
   * @param {(string|null)} facetName the name of the facet to retrieve the rendered children for
   *        or null to get the rendered children outside of the facets.
   * @param {(Object|null)} key An optional key to specify for stamping. If provided, it will
   *        retrieve the children AMX nodes for a given stamping key.
   * @return {Array.<adf.mf.api.amx.AmxNode>} the children that should be rendered for the given
   *         stamp key. This function will flatten any flattenable components and will not return
   *         any non-rendered nodes.
   */
  AmxNode.prototype.getRenderedChildren = function(facetName, key)
  {
    var result = [];
    var children = this.getChildren(facetName, key);

    for (var i = 0, size = children.length; i < size; ++i)
    {
      var vc = new adf.mf.api.amx.VisitContext();
      var child = children[i];

      child.visit(vc,
        function (context, node)
        {
          if (!node.isReadyToRender())
          {
            return adf.mf.api.amx.VisitResult["REJECT"];
          }

          // Skip over any flattened nodes. Note that this means that the type handler
          // will never be called for preDestroy and destroy as those functions are currently
          // based on DOM nodes, not AMX nodes.
          if (node.isFlattenable())
          {
            // To support the functionality of amx:facetRef, use a "__getRenderedChildren" method
            // to allow the facet reference to resolve the children to be rendered as the children
            // of the fragment facet tag. The "__" prefix is used as this should not be consumed
            // by 3rd party type handlers, it is specifically for internal use only.
            var th = node.getTypeHandler();
            if (adf.mf.internal.amx.implementsFunction(th, "__getRenderedChildren"))
            {
              var nodes = th.__getRenderedChildren(node);
              result.push.apply(result, nodes);
              return adf.mf.api.amx.VisitResult["REJECT"];
            }

            return adf.mf.api.amx.VisitResult["ACCEPT"];
          }

          result.push(node);
          return adf.mf.api.amx.VisitResult["REJECT"];
        });
    }

    return result;
  };

  /**
   * Get if the node is flattenable. A flattened node produces no HTML but instead provides
   * information to the parent or about how the children should be handled. Allows for customizing
   * the creation of children nodes as well.
   *
   * @return {boolean} true if the node is flattenable
   */
  AmxNode.prototype.isFlattenable = function()
  {
    var th = this.getTypeHandler();
    return adf.mf.internal.amx.implementsFunction(th, "isFlattenable") && th.isFlattenable(this);
  };

  /**
   * Get the current state of the node.
   * @return {int} the current state, as a constant value from adf.mf.api.amx.AmxNodeStates.
   */
  AmxNode.prototype.getState = function()
  {
    return this._state;
  };

  /**
   * Moves the state of the node. Should only be called by the framework or the node's type handler.
   * @param {int} state the new state of the node
   */
  AmxNode.prototype.setState = function(state)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "setState",
        "Setting state of AmxNode " + this.getId() + " to " +
        adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
    }

    // Check the new state and see if the page busy tracker needs to
    // be updated
    switch (state)
    {
      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
      case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
      {
        switch (this._state)
        {
          case adf.mf.api.amx.AmxNodeStates["UNRENDERED"]:
          case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
          case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
          {
            // The node was "resolved" but now will be waiting on a condition. Mark the node as
            // being in a pending state
            adf.mf.internal.amx._pageBusyTracker.increment();
            break;
          }
        }
        break;
      }
      // ABLE_TO_RENDER, RENDERED, UNRENDERED
      default:
      {
        switch (this._state)
        {
          case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
          case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
          case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
          {
            // The node was waiting on a condition but now is "resolved"
            adf.mf.internal.amx._pageBusyTracker.decrement();
            break;
          }
        }
        break;
      }
    }
    this._state = state;
  };

  /**
   * @deprecated use render instead
   */
  AmxNode.prototype.renderNode = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderNode", "MSG_DEPRECATED", "amxNode.renderNode", "amxNode.render");

    var renderResult = this.render();
    return renderResult;
  };

  /**
   * Render the AmxNode.
   *
   * @return {(HTMLElement|null)} the root HTML element for this AmxNode or null if there is no type
   *   handler for this node
   */
  AmxNode.prototype.render = function()
  {
    var domNode = null;

    // facet are not rendered as they should be handled by the parent
    var tag = this.getTag();
    if (tag.isUITag())
    {
      // if there are a "rendered" property set to false, then, we do not render
      if (this.getAttribute("rendered") === false)
      {
        // domNode will be null
      }
      else
      {
        var nodeTypeHandler = this.getTypeHandler();

        // if renderer found
        if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "render"))
        {
          var id = this.getId();
          if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.api.amx.AmxNode", "renderNode",
              "Rendering AmxNode " + id);
          }

          domNode = nodeTypeHandler.render(this, id);

          // render the AmxNode
          try
          {
            domNode.setAttribute("id", id);
          }
          catch (ex)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle",
              adf.mf.log.level.SEVERE, "renderNode", "MSG_AMX_NODE_RENDER_FAILED",
              this.getTag().getNsPrefixedName());

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx.AmxNode", "render",
                "Setting the ID attribute failed for tag " +
                this.getTag().getNsPrefixedName() + " with ID " + id + " error: " + ex);
            }

            return null;
          }

          try
          {
            // Add this AmxNode to init and post display queues
            if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "init"))
            {
              amx.queueForInit(this);
            }
            if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, "postDisplay"))
            {
              amx.queueForPostDisplay(this);
            }

            adf.mf.internal.amx._setNonPrimitiveElementData(domNode, "amxNode", this);

            // add the amx classes
            domNode.classList.add("amx-node");
            if (tag._rootClassName == null)
            {
              var theNamespace = tag.getNamespace();
              if (theNamespace == adf.mf.api.amx.AmxTag.NAMESPACE_AMX)
              {
                tag._rootClassName = "amx-" + tag.getName();
              }
              else if (theNamespace == adf.mf.api.amx.AmxTag.NAMESPACE_DVTM)
              {
                tag._rootClassName = "dvtm-" + tag.getName();
              }
              else
              {
                tag._rootClassName = ""; // custom components should add their own class names
              }
            }
            if (tag._rootClassName != "")
            {
              domNode.classList.add(tag._rootClassName);
            }
            var styleClass = this.getAttribute("styleClass");
            if (styleClass != null && styleClass != "")
            {
              if (adf.mf.environment.profile.dtMode)
              {
                // if adf.mf.environment.profile.dtMode, remove el
                styleClass = styleClass.replace(/#\{(.*?)\}/ig, ' ');
              }
              var splits = styleClass.split(" ");
              for (var i=0, count=splits.length; i<count; ++i)
              {
                var split = splits[i];
                if ("" != split)
                  domNode.classList.add(split);
              }
            }
            if (adf.mf.api.amx.isValueTrue(this.getAttribute("readOnly")))
            {
              domNode.classList.add("amx-readOnly");
            }
            if (adf.mf.api.amx.isValueTrue(this.getAttribute("disabled")))
            {
              domNode.classList.add("amx-disabled");
            }
            if (typeof nodeTypeHandler.destroy === "function")
            {
              domNode.classList.add("amx-has-destroy");
            }
            if (typeof nodeTypeHandler.preDestroy === "function")
            {
              domNode.classList.add("amx-has-predestroy");
            }

            // add the eventual inlineStyle
            var inlineStyle = this.getAttribute("inlineStyle");
            if (inlineStyle)
            {
              if (adf.mf.environment.profile.dtMode)
              {
                // if adf.mf.environment.profile.dtMode, remove el
                inlineStyle = inlineStyle.replace(/#\{(.*?)\}/ig, ' ');
              }
              var existingStyle = domNode.getAttribute("style");
              if (existingStyle == null)
                domNode.setAttribute("style", inlineStyle);
              else
                domNode.setAttribute("style", existingStyle + ";" + inlineStyle);
            }

            this._applyClientListenerAssociations(domNode);
          }
          catch (ex)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
              "adf.mf.api.amx.AmxNode.render", "MSG_AMX_NODE_RENDER_FAILED",
              this.getTag().getNsPrefixedName());

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx.AmxNode", "render",
                "Error rendering tag " +
                this.getTag().getNsPrefixedName() + " with ID " + this.getId() + " error: " + ex);
            }
          }
        }
        else
        {
          adf.mf.log.logInfoResource("AMXInfoBundle",
            adf.mf.log.level.WARNING, "render", "MSG_NO_RENDERER",
            this.getTag().getNsPrefixedName());
        }
      }
    }

    if (this.getState() != adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"])
    {
      this.setState(adf.mf.api.amx.AmxNodeStates["RENDERED"]);
    }

    return domNode;
  };

  /**
   * Apply clientListener event type associations.
   * @param {HTMLElement} rootElement the root element of this component
   */
  AmxNode.prototype._applyClientListenerAssociations = function(rootElement)
  {
    var clientListenerTypes = this.getAttribute("data-clientListenerTypes");
    if (clientListenerTypes)
    {
      var amxNodeId = this.getId();
      var th = this.getTypeHandler();
      for (var eventType in clientListenerTypes)
        th.__experimentalCLAssociation(
          this,
          amxNodeId,
          eventType,
          rootElement); // TODO what if the type or method changes due to DCEs?
    }
  };

  /**
   * @deprecated
   */
  AmxNode.prototype.renderSubNodes = function(facetName, key)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amxNode.renderSubNodes", "MSG_DEPRECATED",
      "amxNode.renderSubNodes", "amxNode.renderDescendants");

    var arrayOfHtmlElements = this.renderDescendants(facetName, key);
    var subNodes = [];
    for (var i=0, size=arrayOfHtmlElements.length; i<size; ++i)
    {
      var elementToAdd = arrayOfHtmlElements[i];
      subNodes.push(elementToAdd);
    }
    return subNodes;
  };

  /**
   * Renders the sub-AmxNodes of this AmxNode.
   * @param {(string|null)} facetName the name of the facet to render the children for or null
   *        to render the non-facet children.
   * @param {(Object|null)} key An optional key to specify for stamping. If provided, it will render
   *        the children AMX nodes for a given stamping key.
   * @return {Array<HtmlElement>} array of all of the rendered HTML nodes
   */
  AmxNode.prototype.renderDescendants = function(facetName, key)
  {
    var arrayOfHtmlElements = [];
    var children = this.getRenderedChildren(facetName, key);
    for (var i=0, size=children.length; i<size; ++i)
    {
      var childAmxNode = children[i];
      var subElement = childAmxNode.render();
      if (subElement)
      {
        arrayOfHtmlElements.push(subElement);
      }
    }

    return arrayOfHtmlElements;
  };

  /**
   * @deprecated
   */
  AmxNode.prototype.rerenderNode = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amxNode.rerenderNode", "MSG_DEPRECATED", "amxNode.rerenderNode", "amxNode.rerender");

    this.rerender();
  };

  /**
   * Re-renders the AmxNode.
   */
  AmxNode.prototype.rerender = function()
  {
    var oldDomNode = document.getElementById(this.getId());
    if (oldDomNode == null)
    {
      var amxNode = this.__getRenderingParent().__getClosestRenderedNode();
      if (amxNode != null)
      {
        amxNode.rerender();
      }
      return;
    }

    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "rerenderNode",
        "Re-rendering AmxNode " + this.getId());
    }

    var newDomNode = this.render();
    if (newDomNode)
    {
      oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
    }
    adf.mf.api.amx.removeDomNode(oldDomNode);
    // rerender function is called independently from outside of the amx core so
    // init and postDisplay have to be invoked now to ensure that the node
    // will be fully initialized
    if (amx.mustProcessQueues === true)
    {
      amx.processAndCleanInitQueue();
      amx.processAndCleanPostDisplayQueue();
    }
  };

  /**
   * Checks the state of the node to see if the node was rendered or is able to be be rendered.
   * The node is considered to be renderable if it is in the ABLE_TO_RENDER,
   * RENDERED or PARTIALLY_RENDERED state.
   *
   * @return {boolean} true if the node was rendered or should be rendered.
   */
  AmxNode.prototype.isReadyToRender = function()
  {
    switch (this.getState())
    {
      case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
      case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        return true;
      default:
        return false;
    }
  };

  /**
   * Checks if a node was rendered and the DOM is still present on the page.
   *
   * @return {boolean} true if the node was rendered and it's DOM node is present on the page
   */
  AmxNode.prototype.isRendered = function()
  {
    switch (this.getState())
    {
      // Note that WAITING_ON_EL_EVALUATION may be the state if updateAttributes set it to that
      // value after the state was previously PARTIALLY_RENDERED
      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
      case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
      case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        return document.getElementById(this.getId()) != null;
      default:
        return false;
    }
  };

  /**
   * Called to refresh the HTML of a node. This method is called after the updateChildren
   * method and should be implemented by type handlers that wish to update their DOM in
   * response to a change.
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {(adf.mf.api.amx.AmxDescendentChanges|null)} descendentChanges the changes for any
   *        descendent nodes that need to be refreshed.
   */
  AmxNode.prototype.refresh = function(attributeChanges, descendentChanges)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "refresh"))
    {
      th.refresh(this, attributeChanges, descendentChanges);
    }
  };

  /**
   * Applies any attribute changes. Usually called as a result of the data change
   * framework.
   *
   * @param {Object.<string, boolean>} affectedAttributes object with keys of the
   *        attribute names that have changed and a value of true.
   * @param {Object.<string, adf.mf.api.amx.AmxCollectionChange>} collectionChanges the change
   *        details for collection attributes that have changed
   * @return {adf.mf.api.amx.AmxAttributeChange} returns the changed properties and their old
   *         values.
   */
  AmxNode.prototype.updateAttributes = function(affectedAttributes, collectionChanges)
  {
    // First, update the attributes that have changed
    var changes = new adf.mf.api.amx.AmxAttributeChange();
    var cacheMiss = false;

    // See if one of the affected attributes is the rendered attribute
    if (affectedAttributes["rendered"])
    {
      var oldValue = this.getAttribute("rendered");
      var cacheMiss = this._processAttribute("rendered");

      if (cacheMiss)
      {
        // The new value is not in the EL cache
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);
        changes.__addChangedAttribute("rendered", oldValue);
        return changes;
      }

      // Ensure a boolean type
      var newValue = this.getAttribute("rendered");
      if (oldValue != newValue)
      {
        changes.__addChangedAttribute("rendered", oldValue, null);

        if (!newValue)
        {
          // The node is no longer rendered. Remove any children and any other
          // properties that do not need to be kept anymore
          this._removeFromDataChangeNotification(false);
          this._facets = {};
          this._children = {};
          this._modifiableEl = {};
          this._childrenCreated = false;
          this._converter = null;
          this._tagInstances = null;
          this._elDependencies = null;
          this._tagInstanceIdsWaitingOnEl = {};
          this._tagInstancesWaitingOnEl = 0;

          // Update the state
          this.setState(adf.mf.api.amx.AmxNodeStates["UNRENDERED"]);

          // Register for data change events only on the rendered attribute
          this._registerRenderedAttributeForDataChange();

          // Don't process any more attribute changes on unrendered nodes.
          return changes;
        }

        // The node was not rendered but now is. Allow the rest of the attributes
        // to be process. First, change the state to INITIAL so that the children
        // may be built. This will result in the init method being called again for this
        // node.
        this.setState(adf.mf.api.amx.AmxNodeStates["INITIAL"]);

        // Return the old values to the caller
        return changes;
      }
    }

    // If the node is not rendered, then do not process any other attributes
    if (this.getState() == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
    {
      return changes;
    }

    // At this point, the rendered attribute has not changed, just process the changed
    // attributes
    for (var attrName in affectedAttributes)
    {
      if (attrName == "rendered")
      {
        continue;
      }

      var oldValue = this.getAttribute(attrName);
      cacheMiss = this._processAttribute(attrName) || cacheMiss;

      var collectionChange = collectionChanges == null ? null : collectionChanges[attrName];
      changes.__addChangedAttribute(attrName, oldValue, collectionChange);
    }

    // Update the state to reflect if all the EL is available
    if (cacheMiss && this.isReadyToRender())
    {
      // Update the state, if necessary, to reflect that the node does not have all
      // the required attributes.
      this.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
    else if (this._tagInstancesWaitingOnEl == 0 && this._attributesWaitingOnEl == 0 &&
      this.getState() == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"])
    {
      this.setState(adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]);
    }

    return changes;
  };

  /**
   * Process any necessary updates to the children AMX nodes during an attribute
   * change. This is called after the updateAttributes function and before the refresh
   * function. Type handlers may implement a function updateChildren with the amx node and
   * the old attribute values as the parameters. The implementation of the function should
   * remove any old children and create and add any new children to the AMX node. The
   * framework will initialize the children and call the refresh function on the nodes
   * once they are ready to render.
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  AmxNode.prototype.updateChildren = function(attributeChanges)
  {
    // See if the node ever created children
    if (this._childrenCreated)
    {
      var th = this.getTypeHandler();

      // Do not call the type handler if no attributes have changed. This will happen if the
      // tag instances have changed and not any attributes
      if (attributeChanges.getSize() > 0)
      {
        if (adf.mf.internal.amx.implementsFunction(th, "updateChildren"))
        {
          // Note that the type handler should check for styleClass and
          // inlineStyle and return REFRESH for those if implementing a custom
          // updateChildren or use the result from defaultUpdateChildren
          return th.updateChildren(this, attributeChanges);
        }

        return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
      }
      else
      {
        // Do not rerender nodes if only the tag instances have been updated
        return adf.mf.api.amx.AmxNodeChangeResult["NONE"];
      }
    }
    else
    {
      // The node never created its children, so use the _createChildren
      // method instead of the updateChildren
      state = this.getState();
      if (state == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"] ||
        this.isReadyToRender())
      {
        this._createChildren();
      }

      return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
    }
  };

  /**
   * Convenience function for type handlers that stamp their children to
   * create the children AMX nodes from inside of a custom createChildrenNodes
   * function. It will create children for any UI tags.
   *
   * @param {object} key the stamp key to use
   * @param {(Array.<string>|null)} facetNamesToInclude list of facet names to create
   *        children for. If empty the facets will not be processed for this
   *        stamp. If null, all the facets will be processed. Include a null value
   *        inside the array to create children for non-facet tags.
   * @param {(function|null)} filterCallback an optional function to filter the children
   *        to create the children for. The function will be invoked with the node,
   *        the stamp key, the child tag and the facet name (or null for non-facets).
   *        Function must return a boolean. If true, the tag will be used to create
   *        children, if false the tag will not be processed.
   * @return {Array.<adf.mf.api.amx.AmxNode>} the children that were created
   */
  AmxNode.prototype.createStampedChildren = function(
    key,
    facetNamesToInclude,
    filterCallback)
  {
    var tag = this.getTag();
    var node, i, size;
    var created = [];

    // First create the AMX nodes for the facets
    if (facetNamesToInclude == null || facetNamesToInclude.length > 0)
    {
      var facetTags = tag.getChildrenFacetTags();
      for (i = 0, size = facetTags.length; i < size; ++i)
      {
        var facetData = facetTags[i].getFacet();
        var facetName = facetData["name"];

        if (facetNamesToInclude != null &&
          facetNamesToInclude.length > 0 &&
          facetNamesToInclude.indexOf(facetName) == -1)
        {
          continue;
        }

        var facetTagChildren = facetData["children"];

        for (var j = 0, facetChildrenSize = facetTagChildren.length;
          j < facetChildrenSize; ++j)
        {
          var facetTag = facetTagChildren[j];
          if (!facetTag.isUITag())
          {
            continue;
          }

          if (filterCallback == null ||
            filterCallback(this, key, facetTag, facetName))
          {
            node = facetTag.buildAmxNode(this, key);
            created.push(node);
            this.addChild(node, facetName);
          }
        }
      }
    }

    // Create the nodes for the children
    if (facetNamesToInclude == null ||
      facetNamesToInclude.indexOf(null) >= 0)
    {
      var childrenUiTags = tag.getChildrenUITags();
      for (i = 0, size = childrenUiTags.length; i < size; ++i)
      {
        var childTag = childrenUiTags[i];

        if (filterCallback == null ||
          filterCallback(this, key, childTag, null))
        {
          node = childTag.buildAmxNode(this, key);
          created.push(node);
          this.addChild(node);
        }
      }
    }

    return created;
  };

  /**
   * Attempts to find a parent AMX node by its tag's namespace and tag name
   *
   * @param {string} ns the namespace
   * @param {string} tagName the tag name
   * @return {(adf.mf.api.amx.AmxNode|null)} the ancestor AMX node or null if not found
   */
  AmxNode.prototype.findAncestorByTag = function(
    ns,
    tagName)
  {
    for (var amxNode = this.getParent(); amxNode != null; amxNode = amxNode.getParent())
    {
      var tag = amxNode.getTag();
      if (tag.getName() == tagName && tag.getNamespace() == ns)
      {
        return amxNode;
      }
    }

    return null;
  };

  /**
   * Attempts to find an AMX node relative to the current node by its XML ID. This will search in
   * the current naming container for the given node. If not found, it will look in the parent
   * naming container. By providing colons in the string, the code will search for children of
   * found parent nodes.
   *
   * @param {string} xmlIdSearchExpression the XML ID optionally separated by colons for a hierarchy of nodes.
   * @param {boolean} if true the code will search in parent files. If false, it will only check
   *        the current file
   * @return {(adf.mf.api.amx.AmxNode|null)} the node if found
   */
  AmxNode.prototype.findRelativeAmxNode = function(
    xmlIdSearchExpression,
    searchAcrossMultiplePages)
  {
    var namingContainerInfo = this._findNamingContainerAndStampKey();
    var idsToFind = xmlIdSearchExpression.split(":");
    var ncAmxNode = namingContainerInfo["amxNode"];
    var amxNode = ncAmxNode;

    for (var i = 0, numIds = idsToFind.length; i < numIds && amxNode != null; ++i)
    {
      amxNode = amxNode._findAmxNode(idsToFind[0], i == 0 ? namingContainerInfo["stampKey"] : null);
    }

    if (amxNode == null)
    {
      var tag = ncAmxNode.getTag();
      var parent = ncAmxNode.getParent();

      if (parent == null ||
        (tag.getName() == "fragment" && tag.getNamespace() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX &&
          searchAcrossMultiplePages != true))
      {
        return null;
      }

      // Search the naming container above the current one
      return parent.findRelativeAmxNode(xmlIdSearchExpression, searchAcrossMultiplePages);
    }

    return amxNode;
  };

  /**
   * Update the tag instance attributes. This is usually called as a result of a data change
   * event. Currently internal until a formal API can be fully designed
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the arguments to the
   *                                                markNodeForUpdate call.
   * @ignore
   */
  AmxNode.prototype.__updateTagInstanceAttributes = function(nodeUpdateArguments)
  {
    var amxNodeId = this.getId();
    var affectedInstanceIds = nodeUpdateArguments.__getAffectedTagInstanceIds(amxNodeId);
    var numInstances = affectedInstanceIds.length;

    if (numInstances > 0)
    {
      var th = this.getTypeHandler();
      // Delegate to the type handler if the custom function has been provided
      var typeHandlerHasNotifyMethod = adf.mf.internal.amx.implementsFunction(
        th, "__tagInstanceUpdated");

      for (var i = 0; i < numInstances; ++i)
      {
        var tagInstanceId = affectedInstanceIds[i];
        var affectedAttributes = nodeUpdateArguments.__getAffectedAttributesForTagInstance(
          amxNodeId, tagInstanceId);

        var tagInstance = this._tagInstances[tagInstanceId];
        tagInstance.updateAttributes(affectedAttributes);

        if (this._tagInstanceIdsWaitingOnEl[tagInstanceId] &&
          tagInstance.getState() == adf.mf.internal.amx.AmxTagInstanceStates["LOADED"])
        {
          delete this._tagInstanceIdsWaitingOnEl[tagInstanceId];
          --this._tagInstancesWaitingOnEl;
        }

        if (typeHandlerHasNotifyMethod)
        {
          // Use a temporary API to notify the type handler that a tag instance has been updated.
          // This API needs to be improved before making public (same with the entire tag instance
          // API)
          th.__tagInstanceUpdated(this, tagInstance);
        }
      }

      // See if the node is now ready to render (if all the EL is now loaded)
      if (this._tagInstancesWaitingOnEl == 0 && this._attributesWaitingOnEl == 0 &&
        this.getState() == adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"])
      {
        this.setState(adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]);
      }
    }
  };

  /**
   * Checks to see if the converter needs to be re-created and the value re-converted as a result
   * of a change.
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the arguments to the
   *                                                markNodeForUpdate call
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the attribute changes created by
   *                                            the updateAttributes call
   */
  AmxNode.prototype.__processConverterChanges = function(
    nodeUpdateArguments,
    attributeChanges)
  {
    if (this._converterTag == null)
    {
      // There is no converter
      return;
    }

    var id = this.getId();
    var converterTagId = this._converterTag.getAttribute("id");
    var affectedTagInstanceIds = nodeUpdateArguments.__getAffectedTagInstanceIds(id);
    var converterAffected = affectedTagInstanceIds.indexOf(converterTagId) >= 0;
    var valueAffected = nodeUpdateArguments.getAffectedAttributes(id)["value"];

    var hasConverter = this.getConverter() != null;

    if (converterAffected || hasConverter == false)
    {
      // Force the re-creation of the converter, if necessary
      this._converter = null;

      if (this._processConverter())
      {
        // Check if the the node has a "value" attribute. This is a work-around for bug 17055533
        // where DVT is using converters on AMX nodes that do not have value attributes.
        if (this.getTag().getAttribute("value") !== undefined)
        {
          var oldValue = this.getAttribute("value");

          // If the value was not changed in this update and the converter was set
          // before, then we need a clean copy of the value
          if (hasConverter && valueAffected != true && !adf.mf.environment.profile.dtMode)
          {
            var valueEl = this.getAttributeExpression("value");
            this.setAttributeResolvedValue("value",
              adf.mf.internal.amx.evaluateExpression(valueEl));
          }

          this._convertValue();
          attributeChanges.__addChangedAttribute("value", oldValue, null);
        }
      }
    }
    else if (valueAffected)
    {
      this._convertValue();
    }
  };

  /**
   * The AMX facetRef allows facets to be relocated for purposes of rendering (rendered in a
   * location that they are not defined in). In these cases, the framework must be able to
   * determine the parent AMX node responsible for rendering a node instead of the one that
   * is used to define it. This function normally returns the parent, but for facets used by
   * amx:facetRef, this function will return the facetRef.
   *
   * @return {adf.mf.api.amx.AmxNode} the parent node for rendering purposes.
   */
  AmxNode.prototype.__getRenderingParent = function()
  {
    return this._renderingParent == null ? this.getParent() : this._renderingParent;
  };

  /**
   * See __getRenderingParent
   */
  AmxNode.prototype.__setRenderingParent = function(renderingParent)
  {
    this._renderingParent = renderingParent;
  };

  /**
   * Function to push a map of EL tokens that should be replaced and their replacement
   * values onto a stack. Allows EL aliasing. Used internally for amx:fragmentDef to perform
   * attribute aliasing.
   *
   * @param {Object.<string, string>} map a map with the name to replace as a key and the
   *        token replacement as a value.
   */
  AmxNode.prototype.__pushElReplacements = function(map)
  {
    AmxNode._pushElReplacements(map);
  };

  /**
   * Function to push a map of EL tokens that should be replaced and their replacement
   * values onto a stack. Allows EL aliasing. Used internally for amx:fragmentDef to perform
   * attribute aliasing.
   *
   * @param {Object.<string, string>} map a map with the name to replace as a key and the
   *        token replacement as a value.
   */
  AmxNode.prototype.__popElReplacements = function()
  {
    AmxNode._popElReplacements();
  };

  AmxNode.prototype.__getConverterTag = function()
  {
    return this._converterTag;
  };

  /**
   * Returns the node closest to the this node, which may
   * be the current node, that is rendered and returns it.
   * @param {(boolean|null)} checkAbleToRenderNodes if true nodes in the ABLE_TO_RENDER state
   *        will be checked if rendered. This is useful during the data change event processing
   *        where a node's state may have been altered
   * @return {(adf.mf.api.amx.AmxNode|null)} the closest rendered node or null if no
   *         nodes are rendered.
   */
  AmxNode.prototype.__getClosestRenderedNode = function(checkAbleToRenderNodes)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    var targetNodeId = null;
    if (isFinestLoggingEnabled)
    {
      targetNodeId = this.getId();
    }

    for (var amxTargetNode = this; amxTargetNode != null;
      amxTargetNode = amxTargetNode.__getRenderingParent())
    {
      var state = amxTargetNode.getState();
      switch (state)
      {
        case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
        case adf.mf.api.amx.AmxNodeStates["RENDERED"]:
        case adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"]:
          // If in the ABLE_TO_RENDER, only use if checkAbleToRenderNodes is true
          if (checkAbleToRenderNodes !== true &&
            state == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"])
          {
            continue;
          }

          // Verify that the DOM node still exists (state is consistent)
          if (document.getElementById(amxTargetNode.getId()) != null)
          {
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.api.amx.AmxNode", "__getClosestRenderedNode",
                "Closest rendered ancestor node of node " + targetNodeId +
                " was found to be " + amxTargetNode.getId());
            }
            return amxTargetNode;
          }
          break;
      }
    }

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.api.amx.AmxNode", "__getClosestRenderedNode",
        "No rendered ancestor node could be found for node " + targetNodeId);
    }

    return null;
  };

  AmxNode.prototype.__getDescendentChangeAction = function(changes)
  {
    var th = this.getTypeHandler();
    // Delegate to the type handler if the custom function has been provided
    if (adf.mf.internal.amx.implementsFunction(th, "getDescendentChangeAction"))
    {
      return th.getDescendentChangeAction(this, changes);
    }

    // If a custom handler function has not been provided, the default behavior is
    // to re-render the closest rendered ancestor AMX node if any of the children
    // have had their rendered state changed.
    var changedAmxNodes = changes.getAffectedNodes();
    for (var i = 0, size = changedAmxNodes.length; i < size; ++i)
    {
      var descendentAmxNode = changedAmxNodes[i];
      var oldState = changes.getPreviousNodeState(descendentAmxNode);
      var rendered = descendentAmxNode.isReadyToRender();
      var wasRendered = (
          oldState == adf.mf.api.amx.AmxNodeStates["ABLE_TO_RENDER"] ||
          oldState == adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"] ||
          oldState == adf.mf.api.amx.AmxNodeStates["RENDERED"]
        ) && document.getElementById(descendentAmxNode.getId()) != null;

      if ((rendered == false && wasRendered) ||
       (rendered && wasRendered == false))
      {
        // The descendent AMX node's rendered state has changed.
        // We need to re-render the ancestor to reflect the change in the UI
        // since the ancestor is not configured to handle the change itself
        return adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
      }
    }

    // If none of the changes result in a rendered state change, by default
    // we do not need to take any action.
    return adf.mf.api.amx.AmxNodeChangeResult["NONE"];
  };

  /**
   * Get the names of the attributes that are affected by a change
   * to the given EL dependency.
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   * @return {Array.<string>} array of attribute names.
   */
  AmxNode.prototype.__getAttributesForElDependency = function(valueExpression)
  {
    var attrs = null;
    if (this._elDependencies != null)
    {
      attrs = this._elDependencies.getAttributesForElDependency(valueExpression);
    }
    else
    {
      attrs = [];
    }

    return attrs;
  };

  /**
   * Populates the AMX node update arguments for the tag instances
   *
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} nodeUpdateArguments the object
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression the value expression
   */
  AmxNode.prototype.__processTagInstancesForElDependency = function(
    nodeUpdateArguments,
    valueExpression)
  {
    var tagInstances = this.__getAllTagInstances();
    for (var i = 0, numInstances = tagInstances.length; i < numInstances; ++i)
    {
      var tagInstance = tagInstances[i];
      var elDependencies = tagInstance.getElDependencies();
      var affectedAttributes = elDependencies.getAttributesForElDependency(valueExpression);

      for (var a = 0, numAttrbitues = affectedAttributes.length; a < numAttrbitues; ++a)
      {
        nodeUpdateArguments.__setAffectedAttributeForTagInstance(
          tagInstance, affectedAttributes[a]);
      }
    }
  };

  /**
   * Internal function to retrieve the tag instances that are present under this node for
   * a specific namespace and tag name.
   *
   * @param {string} namespace the XML namespace of the tag
   * @param {string} tagName the tag name
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} array of all the tag instances for
   *         the given namespace and tag name
   */
  AmxNode.prototype.__getTagInstances = function(
    namespace,
    tagName)
  {
    var result = [];
    for (var id in this._tagInstances)
    {
      var instance = this._tagInstances[id];

      // Skip instances underneath another instance
      if (instance.getParentTagInstance() == null)
      {
        var tag = instance.getTag();
        if (tag.getName() == tagName &&
          tag.getNamespace() == namespace)
        {
          result.push(instance);
        }
      }
    }

    return result;
  };

  /**
   * Internal function to get an array of all the tag instances for this AMX node. Includes
   * tag instances that are nested under other tag instances as well (flattens the hierarchy).
   * Not meant to be used outside of amx-core.js.
   *
   * @return {Array.<adf.mf.internal.amx.AmxTagInstance>} array of all the tag instances
   *         for the node
   */
  AmxNode.prototype.__getAllTagInstances = function()
  {
    var result = [];
    for (var id in this._tagInstances)
    {
      result.push(this._tagInstances[id]);
    }

    return result;
  };

  AmxNode.prototype.__findPopup = function(
    popupId)
  {
    if (popupId == null)
    {
      return null;
    }

    // See if the pop-up points to a child of a fragment
    var index = popupId.indexOf(":");
    var th;

    if (index == -1)
    {
      for (var amxNode = this; amxNode != null; amxNode = amxNode.getParent())
      {
        th = amxNode.getTypeHandler();

        if (adf.mf.internal.amx.implementsFunction(th, "findPopup"))
        {
          return th.findPopup(amxNode, popupId, true);
        }
      }

      return null;
    }

    var fragmentId = popupId.substring(0, index);
    var fragmentAmxNode = this.findRelativeAmxNode(fragmentId, false);

    if (fragmentAmxNode != null)
    {
      var children = fragmentAmxNode.getChildren();
      if (children.length > 0)
      {
        var fragmentDefAmxNode = children[0];

        th = fragmentDefAmxNode.getTypeHandler();

        if (adf.mf.internal.amx.implementsFunction(th, "findPopup"))
        {
          return th.findPopup(fragmentDefAmxNode, popupId.substring(index + 1), false);
        }
      }
    }

    return null;
  };

  /**
   * Internal function to get the attribute that should be validated
   *
   * @return {string} the name of the attribute to validate or null if the node has no input
   *         value to validate.
   */
  AmxNode.prototype.__getAttributeToValidate = function()
  {
    return this._attributeToValidate;
  };

  /**
   * Find the naming container node and the stamp key for the current node.
   *
   * @return {{amxNode: adf.mf.api.amx.AmxNode, stampKey: object}} the naming container for the
   *         current node
   */
  AmxNode.prototype._findNamingContainerAndStampKey = function()
  {
    for (var amxNode = this; true; amxNode = amxNode.getParent())
    {
      var stampKey = amxNode.getStampKey();
      if (stampKey != null)
      {
        return { "amxNode": amxNode.getParent(), "stampKey": stampKey };
      }
      else if (amxNode._isNamingContainer() || amxNode.getParent() == null)
      {
        return { "amxNode": amxNode, "stampKey": null };
      }
    }

    // This code will not be reached
    return null;
  };

  AmxNode.prototype._findAmxNode = function(
    xmlId,
    stampKey)
  {
    var childrenToSearch = this.getChildren(null, stampKey);
    var facets = this.getFacets(stampKey);

    for (var facetName in facets)
    {
      childrenToSearch = childrenToSearch.concat(facets[facetName]);
    }

    var numChildren = childrenToSearch.length;
    var c;

    // Look to see if it is one of the children
    for (c = 0; c < numChildren; ++c)
    {
      var child = childrenToSearch[c];
      var tagId = child.getTag().getAttribute("id");

      if (tagId == xmlId)
      {
        return child;
      }
    }

    // Search the decedents of the children
    for (c = 0; c < numChildren; ++c)
    {
      var child = childrenToSearch[c];

      // Do not search into child naming containers
      if (child._isNamingContainer())
      {
        continue;
      }

      var amxNode = child._findAmxNode(xmlId, null);
      if (amxNode != null)
      {
        return amxNode;
      }
    }

    return null;
  };

  /**
   * Function called when there is a cache miss on the rendered attribute or the EL expression
   * for the rendered attribute resolves to false. Only wires the rendered attribute for data change
   * events and ignores other attributes.
   */
  AmxNode.prototype._registerRenderedAttributeForDataChange = function()
  {
    if (this._elDependencies == null)
    {
      var el = this.getAttributeExpression("rendered", false, true);
      this._elDependencies = new adf.mf.internal.amx.AmxElDependencies(
        { "rendered": el });
      this._postProcessForDataChangeNotification(false);
    }
  };

  var iteratorEL = adf.mf.internal.el.parser.parse ("#{iterator}");
  var nullEL = adf.mf.internal.el.parser.parse("#{null}");

  /**
   * Handles the evaluation and conversion of an attribute. Called by both the initialization
   * code as well as the update code.
   *
   * @param {string} attrName the name of the attribute to be processed
   * @return {boolean} whether an EL bound attribute had a cache miss
   */
  AmxNode.prototype._processAttribute = function(attrName)
  {
    var cacheMiss = false;

    var tag = this.getTag();
    if (!tag.isAttributeElBound(attrName))
    {
      // Do not process non-EL attributes if they have already been loaded
      if (this.getAttribute(attrName) !== undefined)
      {
        return cacheMiss;
      }

      var value = tag.getAttribute(attrName);

      // Convert the rendered to a boolean
      if (attrName == "rendered")
      {
        value = value === undefined || adf.mf.api.amx.isValueTrue(value);
      }

      // Do not process attributes not on the tag
      if (value == undefined)
      {
        return cacheMiss;
      }

      this.setAttributeResolvedValue(attrName, value);
      return cacheMiss;
    }

    var el = this.getAttributeExpression(attrName, false, true);

    if (adf.mf.environment.profile.dtMode)
    {
      this.setAttributeResolvedValue(attrName, attrName == "rendered" ? true : el.getExpression());
      return cacheMiss;
    }

    // TODO: move the acceptAttributeForElProcessing into the AmxNode class
    // instead of a global function
    //
    if (!acceptAttributeForElProcessing(attrName, el))
    {
      return cacheMiss;
    }

    var value = adf.mf.internal.amx.evaluateExpression(el);
    if (value === undefined)
    {
      cacheMiss = true;
      if (this._attributeNamesWaitingOnEl[attrName])
      {
        // If this is the second time that we had a cache miss on the same attribute,
        // check to make sure that the EL is valid. For example, a complex EL statement
        // cannot be cached within the JS EL cache and therefore the value would
        // never come back as having a value.
        var unassignableDependency = this._checkForUnassignableEl(el);
        if (unassignableDependency != null)
        {
          // First, replace the EL on the node so that we do not try to evaluate it again:
          this._elAttributeMap[attrName] = nullEL;
          // Second, throw an error to let the user/developer know that the EL is not valid
          throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
            "ERROR_UNASSIGNABLE_ATTRIBUTE", this.getId(), attrName, unassignableDependency));
        }
      }
      else
      {
        // Record that at least one EL was not available so that we update
        // the state appropriately
        this._attributeNamesWaitingOnEl[attrName] = true;
        ++this._attributesWaitingOnEl;
      }
    }
    else
    {
      if (this._attributeNamesWaitingOnEl[attrName])
      {
        delete this._attributeNamesWaitingOnEl[attrName];
        --this._attributesWaitingOnEl;
      }

      // Convert the rendered to a boolean
      if (attrName == "rendered")
      {
        value = adf.mf.api.amx.isValueTrue(value);
      }
      // Temporary hack for backwards compatibility is needed here. The old code, when getting
      // a collection model, would first look up the collection model via EL but then use the
      // javascript iterator as the returned attribute value. As a result, we first need to
      // get the collection model (ensuring the value is not an array), and only if that is
      // not undefined, get the iterator and store that.
      else if (attrName == "value" && tag.getAttribute("var") != null &&
         value != null && !Array.isArray(value))
      {
        // If this code is reached, then the value variable is the collection model, but we
        // need the JavaScript iterator for the type handlers. Temporarily "hack" the code so that
        // we now get the iterator from EL
        var iteratorEl = el.concat(iteratorEL);
        value = adf.mf.internal.amx.evaluateExpression(iteratorEl);
        if (value === undefined)
        {
          cacheMiss = true;
        }
      }

      // Store on the node
      this.setAttributeResolvedValue(attrName, value);
    }

    return cacheMiss;
  };

  AmxNode.prototype._checkForUnassignableEl = function(el)
  {
    var elDependencies = el.dependencies();
    for (var i = 0, numDeps = elDependencies.length; i < numDeps; ++i)
    {
      var dependency = elDependencies[i];
      if (!adf.mf.internal.util.isAssignable(dependency))
      {
        return dependency;
      }
    }

    return null;
  };

  AmxNode.prototype._createChildren = function()
  {
    // By default only create the children once
    if (this._childrenCreated)
    {
      return;
    }

    this._childrenCreated = true;

    // Create the non-UI tag instances
    this._createNonUITagInstances();

    var th = this.getTypeHandler();
    // Delegate to the type handler if the custom function has been provided
    if (adf.mf.internal.amx.implementsFunction(th, "createChildrenNodes"))
    {
      var createChildrenNodesResult = th.createChildrenNodes(this);
      if (this.getState() == adf.mf.api.amx.AmxNodeStates["INITIAL"] ||
        createChildrenNodesResult == adf.mf.api.amx.AmxNodeCreateChildrenNodesResult["DEFERRED"])
      {
        // If the type handler moves the state to INITIAL, call the createChildrenNodes
        // again.
        // Similarly, also if the display is deferred (to display a temporary placeholder).
        this._childrenCreated = false;
        return;
      }

      if (createChildrenNodesResult == adf.mf.api.amx.AmxNodeCreateChildrenNodesResult["HANDLED"])
      {
        return;
      }
    }

    // Create the non-facet children (non-stamped)
    this.createStampedChildren(null, null, null);
  };

  AmxNode.prototype._processConverterTag = function()
  {
    var tags = this.getTag().getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX);
    for (var i = 0, size = tags.length; i < size; ++i)
    {
      var tag = tags[i];
      var tagName = tag.getName();
      if (tagName == "convertNumber" || tagName == "convertDateTime")
      {
        this._converterTag = tag;

        // TODO: make this into an official API for registering converters
        break;
      }
    }
  };

  /**
   * Create the converter if it has not already been created
   *
   * @return {boolean} true if a converter was created during this call, otherwise false
   */
  AmxNode.prototype._processConverter = function()
  {
    if (this._converter != null || this._converterTag == null ||
      adf.mf.environment.profile.dtMode == true)
    {
      return false;
    }

    var convTag = this._converterTag;
    var convTagName = convTag.getName();
    var dirty = false;

    // Only process the converter if the node is in a state ready to be rendered
    if (this.isReadyToRender())
    {
      var converterTagInstance = this._tagInstances[convTag.getAttribute("id")];

      if (convTagName == "convertNumber" && amx.createNumberConverter)
      {
        var label = this.isAttributeDefined("label") ? this.getAttribute("label") : null;
        this.setConverter(amx.createNumberConverter(converterTagInstance, label));
        dirty = true;
      }
      else if (convTagName == "convertDateTime" && amx.createDateTimeConverter)
      {
        var label = this.isAttributeDefined("label") ? this.getAttribute("label") : null;
        this.setConverter(amx.createDateTimeConverter(converterTagInstance, label));
        dirty = true;
      }

      // Notify the type handler that the converter has been changed if desired.
      // This is currently only present for DVT and not a publicly supported API at this
      // time.
      var th = this.getTypeHandler();
      if (adf.mf.internal.amx.implementsFunction(th, "__converterCreated"))
      {
        th.__converterCreated(this, this._converter);
      }
    }

    return dirty;
  };

  AmxNode.prototype._convertValue = function()
  {
    if (this._converter != null)
    {
      this.setAttributeResolvedValue("value",
        this._converter.getAsString(this.getAttribute("value")));
    }
  };

  AmxNode.prototype._isNamingContainer = function()
  {
    var tag = this.getTag();
    var ns = tag.getNamespace();
    var name = tag.getName();

    // This function only needs to return true for tags that do not stamp but need
    // to have unique name containers. So list view and the itertor tags are not needed
    // here since they are stamping nodes.
    return (name == "fragment" || name == "facetRef") &&
      ns == adf.mf.api.amx.AmxTag.NAMESPACE_AMX;
  };

  /**
   * Creates the tag instances for the node. Only creates them once, may be called
   * multiple times. Called from the _createChildren method before the AMX children nodes
   * are created.
   * @param {adf.mf.internal.amx.AmxTagInstance=} parentTagInstance the parent tag instance or null
   */
  AmxNode.prototype._createNonUITagInstances = function(parentTagInstance)
  {
    if (parentTagInstance == null)
    {
      // Only execute once per AMX node
      if (this._tagInstances != null)
      {
        return;
      }

      this._tagInstances = {};
    }

    // No need to create non-UI AmxTagInstance if in DT mode.
    if (adf.mf.environment.profile.dtMode)
    {
      return;
    }

    var tag = parentTagInstance == null ? this.getTag() : parentTagInstance.getTag();

    var children = tag.getChildren();
    for (var i = 0, size = children.length; i < size; ++i)
    {
      var childTag = children[i];
      if (childTag.isUITag() == false)
      {
        // Skip amx:facet as there is no need for that tag to have instances
        if (!(childTag.getName() == "facet" &&
          childTag.getNamespace() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX))
        {
          var id = childTag.getAttribute("id");
          var instance = new adf.mf.internal.amx.AmxTagInstance(this, parentTagInstance, childTag);

          this._tagInstances[id] = instance;

          if (instance.getState() ==
            adf.mf.internal.amx.AmxTagInstanceStates["WAITING_ON_EL_EVALUATION"])
          {
            ++this._tagInstancesWaitingOnEl;
            this._tagInstanceIdsWaitingOnEl[id] = true;
          }

          // Process any nested tag instances
          this._createNonUITagInstances(instance);
        }
      }
    }

    if (this._tagInstancesWaitingOnEl > 0 && this.isReadyToRender())
    {
      // Make the node wait to render until the needed EL is loaded for all tag
      // instances
      this.setState(adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]);
    }
  };

  AmxNode.prototype._createUniqueId = function()
  {
    var id = this.getAttribute("id");
    if (id === undefined)
    {
      id = this.getTag().getAttribute("id");
      this.setAttributeResolvedValue("id", id);
    }

    var parent = this.__getRenderingParent();

    if (parent == null)
    {
      this._id = id;
    }
    else
    {
      var parentId = parent.getId();
      var stampKey = this.getStampKey();
      var parentIsNamingContainer = parent._isNamingContainer();

      if (stampKey == null || parentIsNamingContainer)
      {
        if (parentIsNamingContainer)
        {
          this._id = parentId + ":" + id;
        }
        else
        {
          // Find the portion af the parent with a colon in the ID
          var idx = parentId == null ? -1 : parentId.lastIndexOf(":");
          if (idx == -1)
          {
            // The parent is not "namespaced"
            this._id = id;
          }
          else
          {
            // Get the parent's "namespace" from the ID and use that as this node's prefix
            var prefix = parentId.substring(0, idx + 1);
            this._id = prefix + id;
          }
        }
      }
      else
      {
        var re = /[^\w\.\-]/g;
        var strVal = stampKey.toString();
        // Replace any non-ID friendly values with a sequence of characters unlikely to appear in the
        // value. This assumes that most characters
        // of the iterationKey will be valid and will therefore produce a unique key. Using a token
        // cache would address this if this assumption becomes an issue. If we end up with duplicate
        // IDs due to escaping, we'll have to create a token cache approach.
        strVal = strVal.replace(re, "._.");

        this._id = parentId + ":" + strVal + ":" + id;
      }
    }
  };

  AmxNode.prototype._findChildIndex = function(
    stampKey,
    nodeId,
    facetName)
  {
    var children = this.getChildren(facetName, stampKey);

    for (var i = 0, size = children.length; i < size; ++i)
    {
      var node = children[i];
      if (node.getId() == nodeId)
      {
        return i;
      }
    }

    return -1;
  };

  AmxNode.prototype._findChildIndexAndFacetName = function(
    stampKey,
    nodeId)
  {
    var foundFacetName = null;
    // First search for the child in the children
    var index = this._findChildIndex(stampKey, nodeId, null);
    if (index == -1)
    {
      // If it was not found as a child, look for it as a facet child
      var facets = this.getFacets(stampKey);
      for (var facetName in facets)
      {
        index = this._findChildIndex(stampKey, nodeId, facetName);
        if (index >= 0)
        {
          foundFacetName = facetName;
          break;
        }
      }
    }

    return index == -1 ? null :
      {
        "index": index,
        "facetName": foundFacetName
      };
  };

  /**
   * Function to handle any necessary code to properly notify the node of changes from the model.
   *
   * @param {boolean} includeTagInstances if true the EL in the tag instances will also be
   *        registered.
   */
  AmxNode.prototype._postProcessForDataChangeNotification = function(
    includeTagInstances)
  {
    var elTokens = this._elDependencies.getElTokens();

    if (includeTagInstances)
    {
      var tagInstances = this.__getAllTagInstances();
      for (var i = 0, numInstances = tagInstances.length; i < numInstances; ++i)
      {
        var tagInstance = tagInstances[i];
        elTokens = elTokens.concat(tagInstance.getElDependencies().getElTokens());
      }
    }

    for (var t = 0, numTokens = elTokens.length; t < numTokens; ++t)
    {
      var token = elTokens[t];
      var nodes = nodeToElMap[token];

      if (nodes == null)
      {
        nodes = [ this ];
        nodeToElMap[token] = nodes;
      }
      else
      {
        if (nodes.indexOf(this) == -1)
        {
          nodes.push(this);
        }
      }
    }

    // Cache the value for the removal code
    this._registeredElTokens = elTokens;
  };

  /**
   * Removes the node and descendents from listening to data change events.
   *
   * @param {boolean} nodeWillBeRemoved if true, the a notification will be fired
   *        to the type handler to be notified that the AMX node is going to be removed
   *        from the hierarchy.
   */
  AmxNode.prototype._removeFromDataChangeNotification = function(nodeWillBeRemoved)
  {
    // Notify the type handler this node will be removed or is now unrendered
    this._fireNotification(adf.mf.api.amx.AmxNodeNotifications[
      nodeWillBeRemoved ? "PRE_REMOVAL" : "UNRENDERED"]);

    if (nodeWillBeRemoved)
    {
      // If the state of the node is not "resolved", decrement the node waiting count
      // so that we are not waiting on a removed node
      switch (this.getState())
      {
        case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
        case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
        case adf.mf.api.amx.AmxNodeStates["PARTIALLY_RENDERED"]:
          adf.mf.internal.amx._pageBusyTracker.decrement();
          break;
      }
    }

    // Remove this node from notifications
    var tokens = this._registeredElTokens;

    if (tokens != null)
    {
      for (var i = 0, size = tokens.length; i < size; ++i)
      {
        var token = tokens[i];
        var nodes = nodeToElMap[token];
        if (nodes != null)
        {
          var index = nodes.indexOf(this);
          if (index >= 0)
          {
            nodes.splice(index, 1);
          }
        }
      }
    }

    this._registeredElTokens = null;

    this._removeChildrenFromDataChangeNotification();
  };

  /**
   * Removes this node's children from being notified of any data changes. Typically this is called
   * when the node is being set to an un-rendered state or when the node is being removed from the
   * node hierarchy.
   */
  AmxNode.prototype._removeChildrenFromDataChangeNotification = function()
  {
    var i, size, children, stampKey = null;

    for (stampKey in this._children)
    {
      children = this._children[stampKey];
      for (i = 0, size = children.length; i < size; ++i)
      {
        children[i]._removeFromDataChangeNotification(true);
      }
    }

    for (stampKey in this._facets)
    {
      var facets = this._facets[stampKey];
      for (var facetName in facets)
      {
        children = facets[facetName];
        for (i = 0, size = children.length; i < size; ++i)
        {
          children[i]._removeFromDataChangeNotification(true);
        }
      }
    }
  };

  /**
   * Fires a notification of an AMX node event to the type handler
   *
   * @param {string} one of the adf.mf.api.amx.AmxNodeNotifications constants
   */
  AmxNode.prototype._fireNotification = function(
    notificationType)
  {
    var th = this.getTypeHandler();
    if (adf.mf.internal.amx.implementsFunction(th, "handleNotification"))
    {
      th.handleNotification(this, notificationType);
    }
  };

  /**
   * Get the EL expression map for the node. This will get all the EL expressions with
   * replacement for any EL bound attributes.
   *
   * @return {Object.<string, string>} map of the attribute name to the replaced EL expression
   */
  AmxNode.prototype._getAttributesExpressionMap = function()
  {
    var tag = this.getTag();
    var attrs = tag.getAttributes();
    var replacedAttrs = {};
    for (var name in attrs)
    {
      var expr = this.getAttributeExpression(name, false, true);

      if (expr != null)
      {
        replacedAttrs[name] = expr;
      }
    }

    return replacedAttrs;
  };

  /**
   * Called during initialization to set the input value attribute of the node, allowing validation
   * of that parameter to take place and sets up the EL to permit context free usage during the
   * posting of the changes back to the model.
   */
  AmxNode.prototype._setupInputValueValidation = function()
  {
    // Note, if this function is changed at all, the amx-core.js function amx.registerInputValue
    // must also be changed as it has the deprecated version of this code.
    var th = this.getTypeHandler();

    if (this._attributeToValidate === undefined)
    {
      var attr = adf.mf.internal.amx.implementsFunction(th, "getInputValueAttribute") ?
        th.getInputValueAttribute() :
        null;
      this._attributeToValidate = attr;

      if (attr != null)
      {
        // Convert the EL to a context free EL string to be able to safely call back into the model
        // without any local javascript variables
        this.storeModifyableEl(attr);
      }
    }
  };

  /**
   * Given an HTML element, find the closest AMX node
   * @param {HTMLElement} element the DOM element
   * @return {adf.mf.api.amx.AmxNode|null} the node if found or null
   */
  AmxNode.getAmxNodeForElement = function(element)
  {
    for (var e = element; e != null && e.classList != null; e = e.parentNode)
    {
      if (e.classList.contains("amx-node"))
      {
        return adf.mf.internal.amx._getNonPrimitiveElementData(e, "amxNode");
      }
    }

    return null;
  };

  /**
   * Performs any EL substitutions for the given EL expression. Must be called in-context so that
   * EL variables are correctly recognized and substituted.
   *
   * @param {string} expr the EL expression
   * @return {string} the EL expression with any EL replacements made
   */
  AmxNode.__performElSubstitutions = function(expr)
  {
    if (!expr.tokens)
        expr = adf.mf.internal.el.parser.parse(expr);

    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    var replacementStack = AmxNode._elReplacementsStack;
    var origExpr = expr;

    try
    {
        expr = adf.mf.internal.util.stripLocalValues(expr, true, replacementStack);
    }
    catch (e)
    {
        // If the replacement fails, log the error and fall back to using the non-replaced EL.
        // This will make it easier to track down the EL expression that had caused the error.
        amx.log.error(e.message);
        return origExpr;
    }

    if (isFinestLoggingEnabled)
    {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.api.amx.AmxNode", "__performElSubstitutions",
            "Original expression: " + origExpr + ". Replacement: " + expr);
    }

    return expr;
  };

  /**
   * Pushes a new map of EL expressions onto the EL replacement stack.
   *
   * @param {Object.<string, string>} map of the EL variable name to
   *        the EL string replacement to be made.
   */
  AmxNode._pushElReplacements = function(map)
  {
    var stack = AmxNode._elReplacementsStack;
    if (stack == null)
    {
      AmxNode._elReplacementsStack = [ map ];
    }
    else
    {
      stack.unshift(map);
    }
  };

  /**
   * Removes the last EL replacement map from the stack
   *
   * @return {Object.<string, string>} the map that was removed
   */
  AmxNode._popElReplacements = function()
  {
    var stack = AmxNode._elReplacementsStack;
    var item = stack.shift();

    if (stack.length == 0)
    {
      delete AmxNode._elReplacementsStack;
    }

    return item;
  };

  /**
   * Sort nodes of in an array so that parents appear first
   * and descendents later.
   */
  AmxNode.__sortNodesByDepth = function(nodes)
  {
    function getNodeDepth(node)
    {
      var depth = 0;
      for (var n = node; n != null; n = n.getParent())
      {
        ++depth;
      }

      return depth;
    }

    function nodeCompare(n1, n2)
    {
      if (n1 == n2)
      {
        return 0;
      }

      var n1p = n1.getParent();
      var n2p = n2.getParent();

      if (n1p == n2p)
      {
        // If in the same parent, first compare the stamp keys
        var s1 = n1.getStampKey();
        var s2 = n2.getStampKey();

        if (s1 == s2)
        {
          // The nodes are in the same parent with the same stamp key,
          // return the order of the nodes in the children array
          var n1data = n1p._findChildIndexAndFacetName(s1, n1.getId());
          var n2data = n2p._findChildIndexAndFacetName(s2, n2.getId());

          var n1f = n1data["facetName"];
          var n2f = n2data["facetName"];


          if (n1f == n2f)
          {
            // They have the same facet (may be null), so just compare the
            // indexes
            return n1data["index"] - n2data["index"] < 0 ? -1 : 1;
          }
          else
          {
            if (n1f == null)
            {
              return 1;
            }
            else if (n2f == null)
            {
              return -1;
            }

            return n1f < n2f ? -1 : 1;
          }
        }
        else // The stamp keys are not the same
        {
          // Use a string comparisson of the keys
          return (("" + s1) < ("" + s2)) ? -1 : 1;
        }
      }
      else // The parents are not the same
      {
        var d1 = getNodeDepth(n1);
        var d2 = getNodeDepth(n2);

        var tmp1 = n1;
        var tmp2 = n2;
        var origD1 = d1;
        var origD2 = d2;

        // Ensure that they are the same depth
        if (d1 != d2)
        {
          while (d1 > d2)
          {
            tmp1 = tmp1.getParent();
            --d1;
          }

          while (d2 > d1)
          {
            tmp2 = tmp2.getParent();
            --d2;
          }

          if (tmp1 == tmp2)
          {
            // The nodes are the same, return the one that was more shallow
            return origD1 < origD2 ? -1 : 1;
          }

          if (tmp1.getParent() == tmp2.getParent())
          {
            // If they have the same parent at this level, then recursively
            // use this function
            return nodeCompare(tmp1, tmp2);
          }
        }

        // At this point, we have nodes at the same depth, but the parents are not the same.
        // We need to walk up the parent hierarchy until we find nodes that share the same parent.
        for (var depth = d1; depth > 0; --depth)
        {
          var tmp1p = tmp1.getParent();
          var tmp2p = tmp2.getParent();

          if (tmp1p == tmp2p)
          {
            // We found the parents that are the same, use a recursive call
            return nodeCompare(tmp1, tmp2);
          }

          // Keep looking up the ancestory chain
          tmp1 = tmp1p;
          tmp2 = tmp2p;
        }

        // We should not have reached here as there is only one root node. This would only
        // happen if the nodes are from different hierarchies, which is not valid.
        // Throw an error so that we know it failed.
        throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
          "ERROR_FAILED_TO_SORT_AMX_NODES"));
      }
    }

    nodes.sort(nodeCompare);
  };

  /**
   * Internal function called from amx-core.js in the handling of data change events
   * @param {adf.mf.internal.el.parser.ELExpression} valueExpression
   *        the value expression to get the nodes
   * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that are registered for the EL token
   */
  AmxNode.__getNodesDependentOnElToken = function(valueExpression)
  {
    var token = valueExpression.getIndexedRepresentation();

    // Now get the nodes
    var nodes = nodeToElMap[token];
    return nodes == null ? [] : nodes;
  };

  AmxNode.__clearBindings = function()
  {
    nodeToElMap = {};
  };

  // ------ /AMX Node ------ //

  // return true if this attribute/value needs to be EL resolved
  acceptAttributeForElProcessing.noProcessAttributes =
  {
    valueChangeListener:true,
    from:true,
    to:true,
    selectionChangeListener:true,
    actionListener:true,
    action:true,
    binding:true,
    rangeChangeListener:true
  };

  function acceptAttributeForElProcessing(attrName, attrValue)
  {
    var accept = (!acceptAttributeForElProcessing.noProcessAttributes[attrName] &&
      attrValue);
    accept = accept && (attrName.indexOf("Listener") === -1);
    return accept;
  }

  adf.mf.internal.amx.acceptAttributeForElProcessing = acceptAttributeForElProcessing;

})();
/*
** Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
** Important:
** - This file is designed to be shared verbatim among the ADFui products.
** - Do not add framework-specific dependencies in this file (it must be self-contained).
** - Do not change this file without testing it in other ADFui products (ADF Faces, ADF Mobile, etc.).
*/
if (!window.adf) {
  /**
   * @expose
   * @namespace adf
   */
  window.adf = {}
};

/** @namespace */
adf.shared = adf.shared || {};

/** @namespace */
adf.shared.impl = adf.shared.impl || {}; // ONLY IMPL FOR NOW, CONSIDER PROMOTING TO API IN FUTURE

/** @namespace */
adf.shared.impl.animationUtils = new Object(); // must be explicitly assigned to the window.adf.shared.impl object for cross-framework sharing

/** @private */
adf.shared.impl.animationUtils._browserSpecificNames = {};

// ======================= AnimationUtils Internal APIs =======================

/**
 * Perform a transition animation between 2 elements.
 * - Requirements and prerequisites for calling this function:
 * <ul>
 * <li>The 2 elements must be siblings,
 * <li>Your finishedFunction is responsible for firing trigger resize notifications if applicable,
 * <li>Your finishedFunction is responsible for cleaning up objects associated with and removing the old currentElement,
 * <li>The provided elements must not be using display:none.
 * </ul>
 * When this animation is complete, the currentElement will get display:none and there may be other styles added.
 * If desirable, you may want to save off the styles for restoration if you are not discarding the element in your
 * finished function.
 * @param {string} transitionType the type of transition desired (fade, flipUp, flipDown, flipStart, flipEnd,
 *                                slideUp, slideDown, slideStart, slideEnd, or none)
 * @param {HTMLElement} currentElement the DOM element to be replaced or null if not applicable
 * @param {HTMLElement} newElement the DOM element that will remain or null if not applicable
 * @param {Object} properties a map of properties for the animation:
 * <ul>
 * <li>"dimensionsFromParent" boolean whether dimensions are from the parent (stretching layout structure)
 * <li>"finishedFunction" an optional function to invoke once the animation is completed
 * <li>"callbackParams" an object that will be passed into the finishedFunction or returned from the cancel function
 * <li>"animationEnabled" boolean whether animation should be disabled
 * <li>"isRtl" boolean whether the reading direction is right-to-left
 * <li>"fineLogger" a logger function that will be used for fine-level messages
 * <li>"parentFlipAllowed" boolean whether the parent of the new/current elements can be flipped for an inset effect (gives a flip effect without worry about truncation); In order to do the inset flip, we have to be able to flip the parent element. We need special permission for that because:
 *   <ul>
 *   <li>There might be other elements inside of that parent that (if visible to the user)
 *       would be flipped which may not be desirable.
 *   <li>We cannot create a new temporary parent element on the fly either because we would
 *       then lose scroll positions on all scrollable containers within the subtrees of those
 *       flipped elements.
 *   <li>The parent and grandparent elements must have the same dimensions;
 *       if we applied the perspective to the grandparent (parent of the common ancestor),
 *       then the dimensions of the parent element would not be respected when the rotations
 *       are applied; you'd see the elements flip outside of the dimensions of the parent element.
 *   </ul>
 * </ul>
 * @return {function} function to invoke if you want to cancel an animation that is currently in progress
 */
adf.shared.impl.animationUtils.transition = function(
  transitionType,
  currentElement,
  newElement,
  properties)
{
  var dimensionsFromParent = properties["dimensionsFromParent"];
  var finishedFunction = properties["finishedFunction"];
  var callbackParams = properties["callbackParams"];
  var animationEnabled = properties["animationEnabled"];
  var isRtl = properties["isRtl"];
  var fineLogger = properties["fineLogger"];
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var animationUtils    = adf.shared.impl.animationUtils;
  var animationContext  = new animationUtils.AnimationContext(finishedFunction, callbackParams);
  var cancelFunction    = function() {};
  animationUtils._isRtl = isRtl;
  animationUtils._fineLogger = fineLogger;

  if (animationUtils._agentTypeAndVersion == null)
  {
    // Do a 1-time agent initialization
    animationUtils._agentTypeAndVersion = animationUtils._getAgentTypeAndVersion(navigator.userAgent);
  }

  try
  {
    // If any of the prerequisities are violated, do not attempt a transition:
    var nothingToAnimate = false;
    if (!hasCurrent && !hasNew)
      nothingToAnimate = true; // no elements to animate
    else if (hasCurrent && hasNew && currentElement.parentNode != newElement.parentNode)
    {
      nothingToAnimate = true; // common parent prerequisite was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition common parent prerequisite was violated");
    }
    if (hasCurrent && currentElement.style.display == "none")
    {
      nothingToAnimate = true; // display != none was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition currentElement display != none prerequisite was violated");
    }
    if (hasNew && newElement.style.display == "none")
    {
      nothingToAnimate = true; // display != none was violated
      animationUtils._fineLogger("AdfAnimationUtils: transition newElement display != none prerequisite was violated");
    }
    if (nothingToAnimate)
    {
      if (finishedFunction != null)
        adf.shared.impl.animationUtils._requestAnimationFrame(
          animationUtils.getProxyFunction(animationContext, animationContext._performFinish));

      return cancelFunction; // do not attempt a transition
    }

    if (!animationEnabled)
    {
      transitionType = "none";
    }

    var transitionFunction = null;
    var direction = null;
    var sendCurrent = true;
    var sendNew = true;

    if (transitionType != null) // default to "none"
    {
      var agentType = animationUtils._agentTypeAndVersion[0];
      var agentVersion = animationUtils._agentTypeAndVersion[1];

      if (transitionType.indexOf("slide") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(5).toLowerCase();
        transitionFunction = animationUtils._slide;
      }
      else if (transitionType.indexOf("flip") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 19, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 19, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(4).toLowerCase();
        transitionFunction = animationUtils._flip;
      }
      else if (transitionType == "fade" &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        transitionFunction = animationUtils._fade;
      }
      else if (transitionType.indexOf("cover") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(5).toLowerCase();
        // reuse slide animation to animate cover eff
        transitionFunction = animationUtils._slide;
        if (hasNew)
        {
          // only slide new incomming div
          sendCurrent = false;
        }
      }
      else if (transitionType.indexOf("reveal") == 0 &&
        animationUtils._isMinimumAgentMet(agentType, agentVersion, "gecko", 16, "trident", 6, "webkit", 533.1))
      {
        // Requires: Firefox 16, IE 10, Safari 5/Chrome 5/Android 2.3
        direction = transitionType.substring(6).toLowerCase();
        transitionFunction = animationUtils._slide;
        if (hasCurrent)
        {
          // only slide old div out
          sendNew = false;
          // keep current element always on top
          properties["currentOnTop"] = true;
        }
      }
    }

    if (direction == "")
      direction = "start";

    if (transitionFunction == null ||
      ((hasCurrent && !currentElement.addEventListener) || (hasNew && !newElement.addEventListener)))
    {
      // There was no transition specified or this browser doesn't support it, just hide the currentElement:
      animationUtils._restoreStyles(currentElement);
      animationUtils._restoreStyles(newElement);
      if (hasCurrent)
        currentElement.style.display = "none";

      // let the control proceed and immediately after invoke finish since there was nothing to animate
      adf.shared.impl.animationUtils._requestAnimationFrame(
        animationUtils.getProxyFunction(animationContext, animationContext._performFinish));
    }
    else // we can do an animation
    {
      if (hasCurrent && hasNew && !dimensionsFromParent)
      {
        // Add some styles to compensate for it so currentElement won't be pushed down by the newElement when dimensionsFrom == "children":
        var currentElementStyle = currentElement.style;
        var currentWidth = currentElement.offsetWidth;
        var currentHeight = currentElement.offsetHeight;
        currentElementStyle.position = "absolute";
        currentElementStyle.top = "0px";
        currentElementStyle.width = currentWidth + "px";
        currentElementStyle.height = currentHeight + "px";
      }

      if (sendCurrent === false)
      {
        currentElement = null;
      }

      if (sendNew === false)
      {
        newElement = null;
      }

      cancelFunction = transitionFunction(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction);
    }
  }
  catch (problem)
  {
    // Should not get here but in case we do, log the problem:
    animationUtils._fineLogger("AdfAnimationUtils: unable to perform transition due to problem:");
    animationUtils._fineLogger(problem);
  }

  return cancelFunction;
};

/**
 * Creates a function instance that will call back the passed in function with the specified owner as the "this" variable.
 * @param {Object} owner the proxy owner of the proxied function (exposed via the "this" variable inside the function)
 * @param {function} func the function to proxy
 * @return {function} the proxied function
 */
adf.shared.impl.animationUtils.getProxyFunction = function(owner, func)
{
  // create a function that sets up "this" and delegates all of the parameters
  // to the passed in function
  var proxyFunction = new Function(
    "var f=arguments.callee; return f._func.apply(f._owner, arguments);");

  // attach ourselves as "this" to the created function
  proxyFunction["_owner"] = owner;

  // attach function to delegate to
  proxyFunction["_func"] = func;

  return proxyFunction;
};

/**
 * Since a transition end event will not be triggered when an element is
 * hidden, use this API to add the one-time listener with a fallback
 * invocation if the event doesn't happen within a set time.
 * @param {HTMLElement} transitioningElement the DOM element that is transitioning
 * @param {function} callback the function (zero parameters) to invoke
 */
adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe = function(
  transitioningElement,
  callback)
{
  if (transitioningElement != null && callback != null)
  {
    var transitionEndEventName =
      adf.shared.impl.animationUtils._getTransitionEndEventName();
    var context = {
      "timerId": null,
      "handler": null,
      "handled": false
    };

    // Define the handler for either the transitionend or failsafe:
    context["handler"] =
      function()
      {
        try
        {
          if (!context["handled"])
          {
            // This was the first time the handler was invoked so mark it as
            // handled and then invoke the callback:
            context["handled"] = true;
            callback();
          }
        }
        finally
        {
          // Unregister the listener and clear the timeout:
          transitioningElement.removeEventListener(
            transitionEndEventName,
            context["handler"],
            true);
          window.clearTimeout(context["handler"]);
        }
      };

    // Register the listener and add the timeout:
    transitioningElement.addEventListener(
      transitionEndEventName,
      context["handler"],
      true);
    context["timerId"] = window.setTimeout(context["handler"], 1000);
  }
};

// ======================= priavte transition functions =======================

/**
 * Perform a fade animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._fade = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  if (hasCurrent)
  {
    animationUtils._setOpacity(currentElement, "1");
  }
  if (hasNew)
  {
    animationUtils._saveStyles(newElement);
    animationUtils._setOpacity(newElement, "0");
    newElement.style.zIndex = "1";
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, "opacity", 1);
  }

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all .2s ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all .2s ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        currentElement.style.display = "none";
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
      });
    }

    if (hasCurrent)
      animationUtils._setOpacity(currentElement, "0");
    if (hasNew)
      animationUtils._setOpacity(newElement, "1");
  });

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Perform a slide animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._slide = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var parentElement = null;
  if (hasCurrent)
  {
    parentElement = currentElement.parentNode;
  }
  else if (hasNew)
  {
    parentElement = newElement.parentNode;
  }
  if (hasNew)
  {
    animationUtils._saveStyles(newElement);
  }
  if (hasCurrent)
  {
    animationUtils._saveStyles(currentElement);
  }

  var vertical = false; // whether we move along the y-axis (true) or x-axis (false)
  var back = false; // the code below is written in one direction, this toggles whether we reverse the direction

  if (direction == "up" || direction == "down")
  {
    vertical = true;
  }

  if (direction == "right" || direction == "down")
  {
    back = true;
  }

  if (animationUtils._isRtl)
  {
    if (direction == "start")
    {
      back = true;
    }
  }
  else // ltr
  {
    if (direction == "end")
    {
      back = true;
    }
  }

  // Use fading of the current element if in flowing mode for a better effect.
  // When stretching, this fading effect is not as desirable so don't use it in that case.
  var fadeCurrent = !dimensionsFromParent;

  // We have to also apply opacity in case the viewport does not truncate:
  if (hasCurrent && fadeCurrent)
  {
    animationUtils._setOpacity(currentElement, "1");
  }
  // set z-index to the currentElement to keep it always on above the new element
  // this properties will be erased on the animation end
  if (hasCurrent && properties["currentOnTop"])
  {
    currentElement.style.zIndex = 10;
  }
  var translateDistance, size, offsetShift;
  var offsetProperty = vertical ? "offsetHeight" : "offsetWidth";
  if (back) // down or right
  {
    // We want to move down the distance of the new element if present
    if (hasNew)
      size = newElement[offsetProperty];
    else // must hasCurrent
      size = currentElement[offsetProperty];
  }
  else // up or left
  {
    // We want to move up the distance of the old element if present
    if (hasCurrent)
      size = currentElement[offsetProperty];
    else // must hasNew
      size = newElement[offsetProperty];
  }
  offsetShift = back ? (-1) * size : size;
  translateDistance = offsetShift * -1;
  if (hasNew)
  {
    if (vertical)
      animationUtils._setTransformTranslate(newElement, "0," + offsetShift + "px");
    else
      animationUtils._setTransformTranslate(newElement, offsetShift + "px,0");
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all 125ms ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all 125ms ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        animationUtils._restoreStyles(currentElement);
        currentElement.style.display = "none";
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
      });
    }

    // Animate the translated distance:
    if (vertical)
    {
      if (hasCurrent)
        animationUtils._setTransformTranslate(currentElement, "0," + translateDistance + "px");
      if (hasNew)
        animationUtils._setTransformTranslate(newElement, "0,0");
    }
    else
    {
      if (hasCurrent)
        animationUtils._setTransformTranslate(currentElement, translateDistance + "px,0");
      if (hasNew)
        animationUtils._setTransformTranslate(newElement, "0,0");
    }

    // Animate the opacity:
    if (hasCurrent && fadeCurrent)
      animationUtils._setOpacity(currentElement, "0");
  });

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Perform a flip animation between 2 sibling elements.
 * @param {Object} animationContext the animation context
 * @param {HTMLElement} currentElement the DOM element to be replaced
 * @param {HTMLElement} newElement the DOM element that will remain
 * @param {Object} properties a map of properties for the animation
 * @param {boolean} dimensionsFromParent whether dimensions are from the parent (stretching layout structure)
 * @param {string} direction the direction of the animation
 * @private
 */
adf.shared.impl.animationUtils._flip = function(animationContext, currentElement, newElement, properties, dimensionsFromParent, direction)
{
  var animationUtils = adf.shared.impl.animationUtils;
  var hasCurrent = currentElement != null;
  var hasNew = newElement != null;
  var parentElement = null;
  if (hasCurrent)
    parentElement = currentElement.parentNode;
  else if (hasNew)
    parentElement = newElement.parentNode;
  if (hasCurrent)
    animationUtils._saveStyles(currentElement);
  if (hasNew)
    animationUtils._saveStyles(newElement);
  animationUtils._saveStyles(parentElement);
  var vertical = false; // whether we flip up/down about the x-axis (true) or left/right about the y-axis (false)
  var back = false; // the code below is written in one direction, this toggles whether we reverse the direction

  if (direction == "up" || direction == "down")
    vertical = true;

  if (direction == "right" || direction == "up")
    back = true;

  if (animationUtils._isRtl)
  {
    if (direction == "start")
      back = true;
  }
  else // ltr
  {
    if (direction == "end")
      back = true;
  }

  // Ideally we want to perform an inset flip rather than a flip on the plane of the page so that
  // there wouldn't be any potential for undesirable truncation when the content flips toward the
  // user
  // There are several considerations that may prevent an inset flip from being used:
  // 1.) Internet Explorer 10 doesn't support nested 3D transforms so it will have to use the
  //     less-than ideal flipping on the plane of the page implementation.
  // 2.) In order to do the inset flip, we have to be able to flip the parent element. We need
  //     special permission for that because:
  //     a.) There might be other elements inside of that parent that (if visible to the user)
  //         would be flipped which may not be desirable.
  //     b.) We cannot create a new temporary parent element on the fly either because we would
  //         then lose scroll positions on all scrollable containers within the subtrees of those
  //         flipped elements.
  //     c.) The parent and grandparent elements must have the same dimensions:
  //         If we applied the perspective to the grandparent (parent of the common ancestor),
  //         then the dimensions of the parent element would not be respected when the rotations
  //         are applied; you'd see the elements flip outside of the dimensions of the parent element.
  var agentType = animationUtils._agentTypeAndVersion[0];
  var doInsetFlip = (true == properties["parentFlipAllowed"] && "trident" != agentType);
  if ("webkit" == agentType && 534.3 > animationUtils._agentTypeAndVersion[1]) // Android 4.1.1 == 534.3
    doInsetFlip = false; // old versions of WebKit cannot handle it

  if (doInsetFlip)
    animationUtils._flipInset(
      animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back, dimensionsFromParent);
  else // fallback to safest flip
    animationUtils._flipOnPageLayer(
      animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back);

  return animationUtils.getProxyFunction(animationContext, animationContext.cancelFunction);
};

/**
 * Helper for the _flip transition that performs the less-than ideal (but simpler) flip transition.
 * @private
 */
adf.shared.impl.animationUtils._flipOnPageLayer = function(
  animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back)
{
  // We want matching dimensions for a smooth flip:
  var offsetWidth = 0;
  var offsetHeight = 0;
  if (hasNew)
  {
    offsetWidth = newElement.offsetWidth;
    offsetHeight = newElement.offsetHeight;
  }
  if (hasCurrent)
  {
    offsetWidth = Math.max(offsetWidth, currentElement.offsetWidth);
    offsetHeight = Math.max(offsetHeight, currentElement.offsetHeight);
  }
  if (hasNew)
  {
    animationUtils._setBackfaceVisibility(newElement, "hidden");
    animationUtils._setTransformStyle(newElement, "preserve-3d");
    newElement.style.width = offsetWidth + "px";
    newElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformRotateX(newElement, (back?"-180deg":"180deg"));
    else
      animationUtils._setTransformRotateY(newElement, (back?"-180deg":"180deg"));
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }
  if (hasCurrent)
  {
    animationUtils._setBackfaceVisibility(currentElement, "hidden");
    animationUtils._setTransformStyle(currentElement, "preserve-3d");
    currentElement.style.width = offsetWidth + "px";
    currentElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformRotateX(currentElement, "0deg");
    else
      animationUtils._setTransformRotateY(currentElement, "0deg");
  }

  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  var agentVersion = adf.shared.impl.animationUtils._agentTypeAndVersion[1];
  if ("webkit" == agentType)
  {
    // Older versions of the Android browser cannot handle perspective flipping
    if ("webkit" == agentType && 534.3 <= agentVersion) // Android 4.1.1 == 534.3
    {
      var perspectiveProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("perspective");
      parentElement.style[perspectiveProperty] = "2000px";
    }
  }
  else if ("trident" != agentType) // inhibit for IE since IE10 doesn't support it properly
    parentElement.style.perspective = "2000px";

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    if (hasCurrent)
      animationUtils._setTransition(currentElement, "all .2s ease-in-out");
    if (hasNew)
      animationUtils._setTransition(newElement, "all .2s ease-in-out");

    if (hasCurrent)
    {
      animationContext.addTransitionEndA(currentElement, function()
      {
        currentElement.style.display = "none";
        animationUtils._restoreStyles(currentElement);
        animationUtils._restoreStyles(parentElement);
      });
    }

    if (hasNew)
    {
      animationContext.addTransitionEndB(newElement, function()
      {
        animationUtils._restoreStyles(newElement);
        animationUtils._restoreStyles(parentElement);
      });
    }

    if (vertical)
    {
      if (hasCurrent)
        animationUtils._setTransformRotateX(currentElement, (back?"180deg":"-180deg"));
      if (hasNew)
        animationUtils._setTransformRotateX(newElement, "0deg");
    }
    else
    {
      if (hasCurrent)
        animationUtils._setTransformRotateY(currentElement, (back?"180deg":"-180deg"));
      if (hasNew)
        animationUtils._setTransformRotateY(newElement, "0deg");
    }
  });
};

/**
 * Helper for the _flip transition that performs the more desirable (but more complicated) flip transition.
 * @private
 */
adf.shared.impl.animationUtils._flipInset = function(
  animationContext, animationUtils, currentElement, hasCurrent, newElement, hasNew, parentElement, vertical, back, dimensionsFromParent)
{
  // This kind of flip requires an extra layer of DOM elements:
  // - the parent will be flipping so no other siblings should be present
  // - the parent flips within perspective of the grandparent so parent and grandparent should share equal dimensions
  var grandparentElement = parentElement.parentNode;
  animationContext.addExtraCancelFunction(function()
  {
    // Restore the 2 children back into the "grandparent" and purge the "parent"
    animationUtils._flipInsetExtraCancel(currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement);
  });

  animationUtils._saveStyles(grandparentElement);
  var perspectiveProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("perspective");
  grandparentElement.style[perspectiveProperty] = "2000px";

  // The parent needs preserve-3d because we are nesting rotations:
  animationUtils._setTransformStyle(parentElement, "preserve-3d");

  // We want matching dimensions among the children for a smooth flip.
  // The new element starts on the reverse side so we need to rotate it.
  var offsetWidth = 0;
  var offsetHeight = 0;
  if (hasNew)
  {
    offsetWidth = newElement.offsetWidth;
    offsetHeight = newElement.offsetHeight;
  }
  if (hasCurrent)
  {
    offsetWidth = Math.max(offsetWidth, currentElement.offsetWidth);
    offsetHeight = Math.max(offsetHeight, currentElement.offsetHeight);
  }
  if (hasNew)
  {
    animationUtils._setBackfaceVisibility(newElement, "hidden");
    newElement.style.width = offsetWidth + "px";
    newElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformValue(newElement, "perspective(2000px) rotateX(" + (back?"180deg":"-180deg") + ")");
    else
      animationUtils._setTransformValue(newElement, "perspective(2000px) rotateY(" + (back?"-180deg":"180deg") + ")");
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    adf.shared.impl.animationUtils._ensureAppliedStyle(newElement, transformProperty, "none");
  }
  if (hasCurrent)
  {
    animationUtils._setBackfaceVisibility(currentElement, "hidden");
    currentElement.style.width = offsetWidth + "px";
    currentElement.style.height = offsetHeight + "px";
    if (vertical)
      animationUtils._setTransformValue(currentElement, "perspective(2000px) rotateX(0deg)");
    else
      animationUtils._setTransformValue(currentElement, "perspective(2000px) rotateY(0deg)");
  }

  // In order to produce an inset flip, we need to change the transform origin, later we will also translate
  if (vertical)
    animationUtils._setTransformOrigin(parentElement, (back?"center bottom":"center top"));
  else
    animationUtils._setTransformOrigin(parentElement, (back?"left center":"right center"));

  // let the screen paint the initial state, then animate to the new state
  adf.shared.impl.animationUtils._requestAnimationFrame(function()
  {
    animationUtils._setTransition(parentElement, "all .2s ease-in-out");

    animationContext.addTransitionEndA(parentElement, function()
    {
      if (hasCurrent)
      {
        animationUtils._restoreStyles(currentElement);
        currentElement.style.display = "none";
      }
      if (hasNew)
        animationUtils._restoreStyles(newElement);

      // Restore the 2 children back into the "grandparent" and purge the "parent"
      animationUtils._flipInsetExtraCancel(currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement);
    });

    if (vertical)
      animationUtils._setTransformValue(
        parentElement,
        "perspective(2000px) " + (back?"translateY(-100%) rotateX(180deg)":"translateY(100%) rotateX(-180deg)"));
    else
      animationUtils._setTransformValue(
        parentElement,
        "perspective(2000px) " + (back?"translateX(100%) rotateY(180deg)":"translateX(-100%) rotateY(-180deg)"));
  });
};

/**
 * Restore the styles of the "grandparent" and "parent" elements.
 * @private
 */
adf.shared.impl.animationUtils._flipInsetExtraCancel = function(
  currentElement, hasCurrent, newElement, hasNew, parentElement, grandparentElement)
{
  var animationUtils = adf.shared.impl.animationUtils;
  animationUtils._restoreStyles(parentElement);
  animationUtils._restoreStyles(grandparentElement);
};

// ======================= private agent helpers =======================

/**
 * Ensures that the specified style has a computed style that is different
 * than the one passed in.
 * @param {HTMLElement} element the DOM element whose style we are computing
 * @param {string} propertyName the browser-specific style property name
 * @param {string} valueItShouldNotBe the value the property should not be
 * @private
 */
adf.shared.impl.animationUtils._ensureAppliedStyle = function(
  element,
  propertyName,
  valueItShouldNotBe)
{
  if (element.ownerDocument.defaultView.getComputedStyle != null) // not IE8
  {
    // Chrome 37, 40 and Safari 8 have a bug where intermittently a style
    // property assignment does not always get applied which means it is not
    // possible for a CSS transition animation to occur.
    // By asking for a computed style, we are able to work around this issue and
    // force the browser to recognize the need for a transition.
    var actualValue =
      element.ownerDocument.defaultView.getComputedStyle(element)[propertyName];
    if (actualValue == valueItShouldNotBe)
      adf.shared.impl.animationUtils._fineLogger(
        "AdfAnimationUtils: computed style had unexpected value: " +
        actualValue);
  }
};

/**
 * Gets the name of the event used by this browser when a CSS transition ends.
 * @return {string} the transition-end event name
 * @private
 */
adf.shared.impl.animationUtils._getTransitionEndEventName = function()
{
  if (adf.shared.impl.animationUtils._transitionEndEventName == null)
  {
    var eventName = "transitionend";
    var element = document.createElement("div");
    var possibleEventNames = {
      "WebkitTransition": "webkitTransitionEnd",
      "transition":       "transitionend",
      "OTransition":      "oTransitionEnd",
      "MozTransition":    "transitionend"
    };

    for (var stylePropertyName in possibleEventNames)
    {
      if (element.style[stylePropertyName] !== undefined)
      {
        eventName = possibleEventNames[stylePropertyName];
        break;
      }
    }
    adf.shared.impl.animationUtils._transitionEndEventName = eventName;
  }
  return adf.shared.impl.animationUtils._transitionEndEventName;
};

/**
 * Gets the name of the style property used by this browser for a CSS transform.
 * @param {string} baseName the non-browser-specific style property name
 * @return {string} the transform style property name
 * @private
 */
adf.shared.impl.animationUtils._getBrowserSpecificName = function(baseName)
{
  if (adf.shared.impl.animationUtils._browserSpecificNames[baseName] == null)
  {
    var name = baseName;
    var capitalizedName = baseName.charAt(0).toUpperCase() + baseName.substring(1);
    var element = document.createElement("div");
    var possibleNames = {};
    possibleNames["Webkit" + capitalizedName] = "webkit" + capitalizedName;
    possibleNames[name] = name;
    possibleNames["O" + capitalizedName] = "o" + capitalizedName;
    possibleNames["Moz" + capitalizedName] = "moz" + capitalizedName;

    for (var stylePropertyName in possibleNames)
    {
      if (element.style[stylePropertyName] !== undefined)
      {
        //name = possibleNames[stylePropertyName];
        name = stylePropertyName;
        break;
      }
    }
    adf.shared.impl.animationUtils._browserSpecificNames[baseName] = name;
  }
  return adf.shared.impl.animationUtils._browserSpecificNames[baseName];
};

/**
 * Allow the browser to paint before invoking the given callback.
 * @param {function} callback the function to invoke after painting
 * @private
 */
adf.shared.impl.animationUtils._requestAnimationFrame = function(callback)
{
  var lastTime = 0;
  var vendors = ['webkit', 'ms', 'moz', 'o'];
  for (var x=0; x<vendors.length && !window.requestAnimationFrame; ++x)
  {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame =
      window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame)
  {
    window.requestAnimationFrame =
      function(callback)
      {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16-(currTime-lastTime));
        var id = window.setTimeout(
          function()
          {
            callback(currTime+timeToCall);
          },
          timeToCall);
        lastTime = currTime+timeToCall;
        return id;
      };
  }

  if (!window.cancelAnimationFrame)
  {
    window.cancelAnimationFrame =
      function(id)
      {
        clearTimeout(id);
      };
  }

  window.requestAnimationFrame(callback);
};

/**
 * Gets whether the specified agent minimum requirements are met or exceeded.
 * Every 2 arguments past actualAgentType and actualAgentVersion must correspond
 * to a minimum required agent type and floating point version number.
 * @param {string} actualAgentType the actual agent type ("trident", "webkit", "gecko")
 * @param {number} actualAgentVersion the actual agent version number as a floating point number
 * @return {boolean} whether the specified agent minimums are met
 * @private
 */
adf.shared.impl.animationUtils._isMinimumAgentMet = function(actualAgentType, actualAgentVersion)
{
  var argCount = arguments.length;
  if (argCount % 2 == 1) // odd number
  {
    adf.shared.impl.animationUtils._fineLogger("AdfAnimationUtils: invalid number of minimum agent requirement arguments: " + argCount);
    return false;
  }

  // Loop through each requirement pair to see if we match one
  for (var i=2; i<=argCount-2; i+=2)
  {
    var requriementType = arguments[i];
    if (actualAgentType == requriementType)
    {
      // We found an agent type match so now see if the actual version is greater than or equal
      // to the requirement version number:
      var requirementVersion = arguments[1+i];
      if (actualAgentVersion >= requirementVersion)
        return true; // met requirement
      else
        return false; // failed requirement
    }
  }
  return false; // no agent type match found; failed requirement
};

/**
 * Gets the agent type and version.
 * @param {string} givenUserAgentString the navigator's userAgent property
 * @return {Array.<Object>} with 2 members, a String for the agent type ("trident", "webkit", "gecko") and a Float for the agent version
 * @private
 */
adf.shared.impl.animationUtils._getAgentTypeAndVersion = function(givenUserAgentString)
{
  var versionParser = adf.shared.impl.animationUtils._parseFloatVersion;
  var agentType = null;
  var agentVersion = -1;
  var userAgent = givenUserAgentString.toLowerCase();
  if (userAgent.indexOf("msie") != -1 || userAgent.indexOf("trident") != -1)
  {
    agentType = "trident";
    var possibleVersion = versionParser(userAgent, /trident\/(\d+[.]\d+)/);
    if (possibleVersion != -1)
    {
      // 6.0 = IE10
      // 5.0 = IE9
      // 4.0 = IE8
      agentVersion = possibleVersion;
    }
    else
    {
      possibleVersion = versionParser(userAgent, /msie (\d+\.\d+);/);
      if (possibleVersion == -1)
        possibleVersion = versionParser(userAgent, /msie (\d+\.\d+)b;/); // expression for betas
      agentVersion = possibleVersion - 4; // Trident versions are 4 behind IE numbers
    }
    if (document.documentMode != null)
    {
      // If a documentMode is provided, it would be an IE number and Trident versions are 4 behind IE numbers.
      // The actual Trident version in use would be the smaller of the 2 numbers:
      agentVersion = Math.min(agentVersion, document.documentMode - 4);
    }
  }
  else if (userAgent.indexOf("applewebkit") != -1)
  {
    agentType = "webkit";
    // 536.26.17 = Mac Desktop Safari 6.0.2
    // 535.1 = Chrome 13.0.782.1
    // 534.46 = Safari 5.1 or iOS 5
    // 525.18 = Mac/Windows Desktop Safari 3.1.1
    // 420.1 = iOS 3
    agentVersion = versionParser(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
  }
  else if (userAgent.indexOf("gecko/")!=-1)
  {
    agentType = "gecko";
    // rv:5 = Firefox 5
    // rv:2 = Firefox 4
    // rv:1.9 = Firefox 3
    // rv:1.8.1 = Firefox 2
    // rv:1.8 = Firefox 1.5
    agentVersion = versionParser(userAgent, /rv:(\d+[.]\d+)/);
  }
  return [ agentType, agentVersion ];
};

/**
 * Parses the float version out of of the specified agent string using
 * a regular expression to identify the version portion of the string.
 * @param {string} userAgent the lowercase navigator user agent string
 * @param {RegExp} versionNumberPattern the regular expression pattern used to extract a number that will be parsed into a float
 * @private
 */
adf.shared.impl.animationUtils._parseFloatVersion = function(userAgent, versionNumberPattern)
{
  var matches = userAgent.match(versionNumberPattern);
  if (matches)
  {
    var versionString = matches[1];
    if (versionString)
      return parseFloat(versionString);
  }
  return -1;
};

/**
 * Save the current styles to be later restored via _restoreStyles.
 * @param {HTMLElement} element the DOM element whose style attribute is to be cached in a data attribute
 * @private
 */
adf.shared.impl.animationUtils._saveStyles = function(element)
{
  if (element != null && element.getAttribute && element.setAttribute)
  {
    // It is invalid to save styles if there was a pending restoreStyle call
    var styles = element.getAttribute("data-adf-original-style");
    if (styles != null)
    {
      adf.shared.impl.animationUtils._fineLogger("AdfAnimationUtils: save while pending restore");
      adf.shared.impl.animationUtils._restoreStyles(element); // restore just in case as a last resort
    }

    styles = element.getAttribute("style");
    if (styles == null)
      styles = "";
    element.setAttribute("data-adf-original-style", styles);
  }
};

/**
 * Restore the original styles that were saved via _saveStyles.
 * @param {HTMLElement} element the DOM element whose style attribute is to be restored from a data attribute
 * @private
 */
adf.shared.impl.animationUtils._restoreStyles = function(element)
{
  if (element != null && element.getAttribute && element.setAttribute)
  {
    var styles = element.getAttribute("data-adf-original-style");
    if (styles != null)
    {
      element.setAttribute("style", styles);
      if (element.removeAttribute)
        element.removeAttribute("data-adf-original-style");
    }
  }
};

/**
 * Opacity was not supported in old browsers.
 * @param {HTMLElement} element the opacity will be applied to
 * @param {string} opacityValue the opacity value
 * @private
 */
adf.shared.impl.animationUtils._setOpacity = function(element, opacityValue)
{
  element.style.opacity = opacityValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transition will be applied to
 * @param {string} transitionValue the transition value
 * @private
 */
adf.shared.impl.animationUtils._setTransition = function(element, transitionValue)
{
  var transitionProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transition");
  element.style[transitionProperty] = transitionValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform will be applied to
 * @param {string} transformValue the transform value
 * @private
 */
adf.shared.impl.animationUtils._setTransformValue = function(element, transformValue)
{
  var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
  element.style[transformProperty] = transformValue;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the translate will be applied to
 * @param {string} translateValues the translate value
 * @private
 */
adf.shared.impl.animationUtils._setTransformTranslate = function(element, translateValues)
{
  var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
  element.style[transformProperty] = "translate(" + translateValues + ")";
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the rotateX will be applied to
 * @param {string} rotateXValues the rotateX value
 * @private
 */
adf.shared.impl.animationUtils._setTransformRotateX = function(element, rotateXValues)
{
  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  if ("trident" == agentType)
  {
    // At least IE10 requires this hack plus removal of the ancestor perspective
    // to support hidden backface-visibility:
    element.style.transform = "perspective(2000px) rotateX(" + rotateXValues + ")";
  }
  else
  {
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    element.style[transformProperty] = "rotateX(" + rotateXValues + ")";
  }
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the rotateY will be applied to
 * @param {string} rotateYValues the rotateY value
 * @private
 */
adf.shared.impl.animationUtils._setTransformRotateY = function(element, rotateYValues)
{
  var agentType = adf.shared.impl.animationUtils._agentTypeAndVersion[0];
  if ("trident" == agentType)
  {
    // At least IE10 requires this hack plus removal of the ancestor perspective
    // to support hidden backface-visibility:
    element.style.transform = "perspective(2000px) rotateY(" + rotateYValues + ")";
  }
  else
  {
    var transformProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transform");
    element.style[transformProperty] = "rotateY(" + rotateYValues + ")";
  }
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the backface visibility will be applied to
 * @param {string} backfaceVisibility the backface visibility value
 * @private
 */
adf.shared.impl.animationUtils._setBackfaceVisibility = function(element, backfaceVisibility)
{
  var backfaceVisibilityProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("backfaceVisibility");
  element.style[backfaceVisibilityProperty] = backfaceVisibility;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform-style will be applied to
 * @param {string} transformStyle the transform-style value
 * @private
 */
adf.shared.impl.animationUtils._setTransformStyle = function(element, transformStyle)
{
  var transformStyleProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transformStyle");
  element.style[transformStyleProperty] = transformStyle;
};

/**
 * Only works in a subset of browsers.
 * @param {HTMLElement} element the transform-origin will be applied to
 * @param {string} transformOrigin the transform-origin value
 * @private
 */
adf.shared.impl.animationUtils._setTransformOrigin = function(element, transformOrigin)
{
  var transformOriginProperty = adf.shared.impl.animationUtils._getBrowserSpecificName("transformOrigin");
  element.style[transformOriginProperty] = transformOrigin;
};

// ======================= private context object =======================

/**
 * This context object allows us to:<ul>
 * <li> maintain flags for whether each animation has finished
 * <li> when both listeners have finished, invoke the finishedFunction (if non-null)
 * <li> when each listener is called, unregister it to prevent re-invocation
 * <li> provide a cancel function that will prevent the finishedFunction from being called</ul>
 * @param {function} finishedFunction the function to invoke if the registered transition end events are invoked (and not cancelled)
 * @param {Object} callbackParams an object that will be passed to the finishedFunction when invoked
 * @constructor
 */
adf.shared.impl.animationUtils.AnimationContext = function(finishedFunction, callbackParams)
{
  this.Init(finishedFunction, callbackParams);
};

adf.shared.impl.animationUtils.AnimationContext.prototype = new Object();
if (window.AdfObject != null)
  adf.shared.impl.animationUtils.AnimationContext.prototype.constructor = window.AdfObject; // this will not work in ADF Mobile (no AdfObject exists)

/**
 * Object instance initializer.
 * @param {function} finishedFunction the function to invoke if the registered transition end events are invoked (and not cancelled)
 * @param {Object} callbackParams an object that will be passed to the finishedFunction when invoked
 * @protected
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.Init = function(finishedFunction, callbackParams)
{
  this._finishedFunction = finishedFunction;
  this._callbackParams = callbackParams;
  this._handledA = true; // initialize to true in case no "A" element is involved
  this._handledB = true; // initialize to true in case no "B" element is involved
};

/**
 * When implementing a custom transition, you are given an animationContext object.
 * Your transition function must return a proxied version of this function in the scope of the animationContext object.
 * This method will unregister the transition end handlers and restore the styles of the elements involved in the transition.
 * The ADF Faces deck component will invoke this method if a new transition comes in while another is processing.
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.cancelFunction = function()
{
  // Remove the finishedFunction so it won't be called and remove the listeners:
  this._finishedFunction = null;
  var callbackParams = this._callbackParams;
  this._callbackParams = null;
  var animationUtils = adf.shared.impl.animationUtils;
  animationUtils._restoreStyles(this._elementA);
  animationUtils._restoreStyles(this._elementB);
  var parentElement;
  if (this._elementA != null)
  {
    parentElement = this._elementA.parentNode;
    animationUtils._restoreStyles(parentElement);
    if (parentElement != null)
      animationUtils._restoreStyles(parentElement.parentNode);
    
  }
  else if (this._elementB != null)
  {
    parentElement = this._elementB.parentNode;
    animationUtils._restoreStyles(parentElement);
    if (parentElement != null)
      animationUtils._restoreStyles(parentElement.parentNode);
  }
  this._removeTransitionEndA();
  this._removeTransitionEndB();
  if (this._extraCancelFunction)
  {
    try
    {
      this._extraCancelFunction();
    }
    catch (problem)
    {
      // Should only get here if there is a problem in the transition implementation:
      animationUtils._fineLogger("AdfAnimationUtils: unable to complete extra cancel function due to problem:");
      animationUtils._fineLogger(problem);
    }
    this._extraCancelFunction = null;
  }
  return callbackParams;
};

/**
 * This method cleans up the context and performs the finished function given at context creation time.
 * @private
 */
adf.shared.impl.animationUtils.AnimationContext.prototype._performFinish = function()
{
  // invode the finish function and perform cleanup
  var finishedFunction      = this._finishedFunction;
  var callbackParams        = this._callbackParams;
  this._finishedFunction    = null;
  this._extraCancelFunction = null;
  this._callbackParams      = null;
  if (finishedFunction != null)
    finishedFunction(callbackParams);
};

/**
 * Adds a function that will be called if this animation gets cancelled.
 * This allows extra cleanup to be performed if necessary.
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addExtraCancelFunction = function(extraCancelFunction)
{
  this._extraCancelFunction = extraCancelFunction;
};

/**
 * When implementing a custom transition, you need to register transition end events for any element
 * transitioning so that the finished function is properly invoked after the transition ends.
 * See also the addTransitionEndB function if you have a second element involved.
 * @param {HTMLElement} element the element whose transition end event you want to listen for
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addTransitionEndA = function(element, extraHandler)
{
  // Add the event listeners and save a reference to the element:
  this._elementA = element;
  this._handleProxyA = adf.shared.impl.animationUtils.getProxyFunction(this, this._handleTransitionEndA);
  this._handledA = false; // an "A" element is involved so re-initialize this to false
  var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
  if (extraHandler != null)
  {
    this._extraHandlerA = extraHandler;
    element.addEventListener(transitionEndEventName, extraHandler, true);
  }
  element.addEventListener(transitionEndEventName, this._handleProxyA, true);
};
adf.shared.impl.animationUtils.AnimationContext.prototype._removeTransitionEndA = function()
{
  // Remove the event listeners and remove the reference to the element:
  var element = this._elementA;
  if (element != null)
  {
    var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
    if (this._extraHandlerA != null)
    {
      element.removeEventListener(transitionEndEventName, this._extraHandlerA, true);
      this._extraHandlerA = null;
    }
    element.removeEventListener(transitionEndEventName, this._handleProxyA, true);
    this._elementA = null;
  }
  this._handleProxyA = null;
};
adf.shared.impl.animationUtils.AnimationContext.prototype._handleTransitionEndA = function()
{
  if (!this._handledA)
  {
    // Mark this element's event as being handled, remove the listeners:
    this._handledA = true;
    this._removeTransitionEndA();

    // If both elements' events were handled, invoke the finishFunction:
    if (this._handledB)
      this._performFinish(); // both events were handled
  }
};

/**
 * When implementing a custom transition, you need to register transition end events for any element
 * transitioning so that the finished function is properly invoked after the transition ends.
 * See also the addTransitionEndA function if you have a second element involved.
 * @param {HTMLElement} element the element whose transition end event you want to listen for
 * @param {function} extraHandler an optional extra function that will be invoked when this element gets a transition end event
 * @export
 */
adf.shared.impl.animationUtils.AnimationContext.prototype.addTransitionEndB = function(element, extraHandler)
{
  // Add the event listeners and save a reference to the element:
  this._elementB = element;
  this._handleProxyB = adf.shared.impl.animationUtils.getProxyFunction(this, this._handleTransitionEndB);
  this._handledB = false; // a "B" element is involved so re-initialize this to false
  var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
  if (extraHandler != null)
  {
    this._extraHandlerB = extraHandler;
    element.addEventListener(transitionEndEventName, extraHandler, true);
  }
  element.addEventListener(transitionEndEventName, this._handleProxyB, true);
};
/** @private */
adf.shared.impl.animationUtils.AnimationContext.prototype._removeTransitionEndB = function()
{
  // Remove the event listeners and remove the reference to the element:
  var element = this._elementB;
  if (element != null)
  {
    var transitionEndEventName = adf.shared.impl.animationUtils._getTransitionEndEventName();
    if (this._extraHandlerB != null)
    {
      element.removeEventListener(transitionEndEventName, this._extraHandlerB, true);
      this._extraHandlerB = null;
    }
    element.removeEventListener(transitionEndEventName, this._handleProxyB, true);
    this._elementB = null;
  }
  this._handleProxyB = null;
};
/** @private */
adf.shared.impl.animationUtils.AnimationContext.prototype._handleTransitionEndB = function()
{
  if (!this._handledB)
  {
    // Mark this element's event as being handled, remove the listeners:
    this._handledB = true;
    this._removeTransitionEndB();

    // If both elements' events were handled, invoke the finishFunction:
    if (this._handledA)
      this._performFinish(); // both events were handled
  }
};
/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-core.js ---------------------- */
/* ------------------------------------------------------ */

adf.mf.log.AMX = adf.mf.log.AMX ||
  new adf.mf.log.logger("oracle.adfmf.amx");

// --------- Config Initialization --------- //
(function()
{
  amx.dtmode = false; // TODO deprecated, use adf.mf.environment.profile.dtMode instead
  // this boolean value will be set directly via the Selenium scripts
  amx.testmode = amx.testmode || false;
  amx.failsafeinvoked = false;

  // GREGOR
  amx.CALL_IDX = 1;

  if (adf.mf.environment.profile.dtMode != null)
  {
    amx.dtmode = adf.mf.environment.profile.dtMode;
  }

  /**
   * Gets the agent type and version.
   * @param {string} givenUserAgentString the navigator's userAgent property
   * @return {Object} with members: a String for the agent type ("iOS", "Android", "trident",
   *                  "webkit", "gecko"), a String for the agent subtype if applicable ("Chrome",
   *                  "Generic", null), and a Number for the agent version
   * @private
   */
  function _getAgentTypeAndVersion(givenUserAgentString)
  {
    var versionParser = _parseFloatVersion;
    var agentType = "unknown";
    var agentSubtype = null;
    var agentVersion = -1;
    var incompatible = false;
    var userAgent = givenUserAgentString.toLowerCase();
    if (userAgent.indexOf("msie") != -1 || userAgent.indexOf("trident") != -1)
    {
      agentType = "trident";
      var possibleVersion = versionParser(userAgent, /trident\/(\d+[.]\d+)/);
      if (possibleVersion != -1)
      {
        // 7.0 = IE11
        // 6.0 = IE10
        // 5.0 = IE9
        // 4.0 = IE8
        agentVersion = possibleVersion;
      }
      else
      {
        possibleVersion = versionParser(userAgent, /msie (\d+\.\d+);/);
        if (possibleVersion == -1)
          possibleVersion = versionParser(userAgent, /msie (\d+\.\d+)b;/); // expression for betas
        agentVersion = possibleVersion - 4; // Trident versions are 4 behind IE numbers
      }
      if (document.documentMode != null)
      {
        // If a documentMode is provided, it would be an IE number and Trident versions are 4 behind IE numbers.
        // The actual Trident version in use would be the smaller of the 2 numbers:
        agentVersion = Math.min(agentVersion, document.documentMode - 4);
      }
      incompatible = _getReasonIfUnsupported(agentVersion, 6);
    }
    else if (userAgent.indexOf("edge") !== -1)
    {
      agentType = "UWP";

      // we do not need a agentSubtype for now since it will always be edge

      agentVersion = versionParser(userAgent, /edge\/(\d+([.]\d+)*)/);

      // for now it will be compatible until we move to a newer edge for input type="time" etc.
      incompatible = false;
    }
    else if (userAgent.indexOf("applewebkit") != -1)
    {
      agentType = "webkit";
      // 536.26.17 = Mac Desktop Safari 6.0.2
      // 535.1 = Chrome 13.0.782.1
      // 534.46 = Safari 5.1 or iOS 5
      // 525.18 = Mac/Windows Desktop Safari 3.1.1
      // 420.1 = iOS 3
      agentVersion = versionParser(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
      if (userAgent.match(/ip(hone|ad|od)/))
      {
        agentType = "iOS";
        var mobileSafariVersion = versionParser(userAgent, /version\/(\d+([.]\d+)*)/);
        if (mobileSafariVersion != -1) // WebView won't contain version info
          incompatible = _getReasonIfUnsupported(mobileSafariVersion, 6.0);
      }
      else if (userAgent.match(/android/))
      {
        if (userAgent.match(/chrome\//))
        {
          agentType = "Android";
          agentSubtype = "Chrome";
        }
        else // pre-KitKat aka 4.4
        {
          agentType = "Android";
          agentSubtype = "Generic";
        }
        var androidVersion = versionParser(userAgent, /android (\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(androidVersion, 4);
      }
      else if (userAgent.match(/chrome/)) // desktop Chrome
      {
        var chromeVersion = versionParser(userAgent, /chrome\/(\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(chromeVersion, 29);
      }
      else // desktop Safari
      {
        var safariVersion = versionParser(userAgent, /version\/(\d+([.]\d+)*)/);
        incompatible = _getReasonIfUnsupported(safariVersion, 6.1);
      }
    }
    else if (userAgent.indexOf("gecko/")!=-1)
    {
      agentType = "gecko";
      // rv:5 = Firefox 5
      // rv:2 = Firefox 4
      // rv:1.9 = Firefox 3
      // rv:1.8.1 = Firefox 2
      // rv:1.8 = Firefox 1.5
      agentVersion = versionParser(userAgent, /rv:(\d+[.]\d+)/);
      incompatible = _getReasonIfUnsupported(agentVersion, 28);
    }

    var agentClass = " amx-" + agentType.toLowerCase();
    if (agentSubtype)
      agentClass += "-" + agentSubtype.toLowerCase();
    document.documentElement.className += agentClass;

    if (incompatible)
    {
      // Append the given User Agent string in case it is simply a matter of it
      // being in an unexpected format.
      incompatible += "; " + givenUserAgentString;
    }

    return {
      "type": agentType,
      "subtype": agentSubtype,
      "version": agentVersion,
      "incompatible": incompatible
    };
  }

  function _getReasonIfUnsupported(versionFound, versionRequired)
  {
    if (versionFound < versionRequired)
      return "" + versionFound + " < " + versionRequired;
    return false;
  }

  /**
   * Parses the float version out of of the specified agent string using
   * a regular expression to identify the version portion of the string.
   * @param {string} userAgent the lowercase navigator user agent string
   * @param {RegExp} versionNumberPattern the regular expression pattern used to extract a number that will be parsed into a float
   * @private
   */
  function _parseFloatVersion(userAgent, versionNumberPattern)
  {
    var matches = userAgent.match(versionNumberPattern);
    if (matches)
    {
      var versionString = matches[1];
      if (versionString)
        return parseFloat(versionString);
    }
    return -1;
  }

  // Add agent marker classes:
  adf.mf.internal.amx.agent = _getAgentTypeAndVersion(navigator.userAgent);

  adf.mf.internal.amx.agent.getTransitionEndEventName = function()
  {
    if (adf.mf.internal.amx.agent._transitionEndEventName == null)
    {
      var transitionEndEventName = "transitionend";
      var element = document.createElement("div");
      var transitions = {
        "WebkitTransition": "webkitTransitionEnd",
        "transition": "transitionend",
        "OTransition": "oTransitionEnd",
        "MozTransition": "transitionend"
      };

      for (var t in transitions)
      {
        if (element.style[t] !== undefined)
        {
          transitionEndEventName = transitions[t];
          break;
        }
      }
      adf.mf.internal.amx.agent._transitionEndEventName = transitionEndEventName;
    }
    return adf.mf.internal.amx.agent._transitionEndEventName;
  };

  /**
   * Internal cache of the isTransitionAfterRender result.
   */
  adf.mf.internal.amx.transitionAfterRender = null;

  /**
   * WARNING - This function and property are not supported and will be removed
   *           without any notice.
   * Internal flag that specifies whether we should render before transitioning or
   * display an empty placeholder for immediate transitioning.
   * @param {boolean} isFirstPage whether this is the initial page render
   * @return true for rendering before or false for immediate transitioning
   */
  adf.mf.internal.amx.isTransitionAfterRender = function(isFirstPage)
  {
    // See if an unsupported override was specified as an adf-property in the adf-config.xml file.
    // <adf-property name="amxTransitionMode" value="placeholder"/>
    var transitionAfterRender = adf.mf.internal.amx.transitionAfterRender;
    if (transitionAfterRender == null)
    {
      transitionAfterRender = true;

      // Get the value from the adf-config.xml object (might not be defined):
      var amxTransitionModeELExpression = adf.mf.internal.el.parser.parse ("#{applicationScope.configuration.amxTransitionMode}");
      var amxTransitionMode =
        adf.mf.environment.profile.mockData ?
          null :
        adf.mf.el.getLocalValue(amxTransitionModeELExpression);

      if ("placeholder" == amxTransitionMode)
        transitionAfterRender = false; // fast but ugly
      else
        transitionAfterRender = true; // pretty but slow

      if (isFirstPage)
      {
        // Unfortunately, applicationScope.configuration is not made available automatically
        // so we have to kick off an extra request for it so that the next time this method
        // gets called, we will know what the value is.
        // (Just before the first adf.mf.api.setContext call, we kicked off a request so
        // it will be available by the time we transition.)
        // Also, since we don't know what it is yet, we won't save off a cached result yet.
      }
      else
      {
        // Save it off so we don't have to continuously re-evaluate it.
        adf.mf.internal.amx.transitionAfterRender = transitionAfterRender;
      }
    }
    return transitionAfterRender;
  };

  amx.config =
  {
    debug:
    {
      enable: false,
      onScreen: false
    }
  };

  // TODO this and any of its uses need to be removed
  amx.log = {};

  function addToOnScreenAmxLog(text)
  {
    if (amx.config.debug.onScreen && !amx.amxDebug)
    {
      var debugDiv = document.createElement("div");
      debugDiv.setAttribute("id", "amxDebug");
      document.body.appendChild(debugDiv);
      amx.amxDebug = debugDiv;
      }

    if (amx.amxDebug)
      {
      if (amx.amxDebug.childNodes.length == 1)
        amx.amxDebug.appendChild(document.createElement("br"));
      else
        amx.amxDebug.insertBefore(document.createElement("br"), amx.amxDebug.firstChild);
      amx.amxDebug.insertBefore(document.createTextNode(text), amx.amxDebug.firstChild);
      }
  };

  amx.log.debug = function(text)
      {
    if (amx.config.debug.enable)
    {
      addToOnScreenAmxLog(text);
        console.log(text);
      }
  };

  amx.log.error = function(text)
  {
    text = "AMX-ERROR: " + text;
    addToOnScreenAmxLog(text);
    console.log(text);
  };

  amx.log.warn = function(text)
  {
    text = "AMX-WARN: " + text;
    addToOnScreenAmxLog(text);
      console.log(text);
  };

  // Add the AMX-specific loading contributors so that base-core's
  // adf.mf.api.isLoading() API will consider AMX's needs:
  adf.mf.api.addLoadingContributor(function()
    {
      // Return true if these things are all idle/finished or false if at least
      // one is still busy/processing.
      var isIdle =
        adf.mf.api.amx.acceptEvent() &&
        (adf.mf.internal.amx._showLoadingCalls == 0) &&
        (adf.mf.internal.getUnresolvedCallDepth() == 0) &&
        (amx.getCurrentPageName() != null) &&
        adf.mf.internal.amx._pageBuildPromiseResolve == null &&
        !adf.mf.internal.amx.isUIChangePaused();
      if (!isIdle)
        return false; // short circuit; busy, still loading

      var animatingElements = document.getElementsByClassName("amx-animating")
      var animatingElementsCount = animatingElements.length;
      if (animatingElementsCount > 0)
      {
        // We need to look at every animating element and check whether it is using
        // display none styling
        for (var i = 0; i < animatingElementsCount; ++i)
        {
          if (animatingElements[i].style.display != "none")
            return false; // short circuit; found one non-display:none animation; busy
        }
      }

      var deferredLoadingElements = document.getElementsByClassName("amx-deferred-loading")
      var deferredLoadingElementCount = deferredLoadingElements.length;
      if (deferredLoadingElementCount > 0)
      {
        // We need to look at every deferred loading element and check whether it is using
        // display  none styling
        for (var i=0; i<deferredLoadingElementCount; ++i)
        {
          if (deferredLoadingElements[i].style.display != "none")
            return false; // short circuit; found one non-display:none indicator; busy
        }
      }

      return true; // idle, not loading
    });

})();

/**
 * Internal function for looping over object members.
 * @private
 */
adf.mf.internal.amx._each = function(obj, callback)
{
  for (var key in obj)
  {
    if (obj.hasOwnProperty(key))
      callback(key, obj[key]);
  }
};

// --------- /Config Initialization --------- //
/**
 * A counter for the numnber of calls made to showLoading indicator. This is required because there are several starting
 * points that can occur for long operations. The issue is that they can overlap so you are calling the start more then
 * once. The solution to this problem is to keep a count of the number of calls to start and increment this value. There
 * will be a corresponding number if calls to hide and when we get to zero we will do hiding.
 * @type {number}
 * @private
 */
adf.mf.internal.amx._showLoadingCalls = 0;

/**
 * Internal function called to bring up the loading indicator.
 * @private
 */
adf.mf.internal.amx._showLoadingIndicator = function()
{
  var loadingDiv = document.getElementById("amx-loading");
  var cl = loadingDiv.classList;
  cl.remove("hidden");        // get rid of the display:none
  cl.add("beforeShowing");    // now at display:block but with opacity:0
  cl.remove("beforeShowing"); // get rid of opacity:0
  cl.add("showing");          // animate to opacity:1

  // Let WAI-ARIA users know the page is loading
  var loadingLiveRegion = document.getElementById("amx-loading-live-region");
  if (loadingLiveRegion != null)
  {
    var msgLoading = adf.mf.resource.getInfoString("AMXInfoBundle", "MSG_LOADING");
    if (msgLoading == null) // will be null if too soon (e.g. initial page load)
      msgLoading = "Loading";
    loadingLiveRegion.textContent = msgLoading;
  }
};

/**
 * This function shows the busy indicator.
 * You are responsible for hiding the indicator or else it will be shown longer than necessary.
 * First consider whether you really need to use this API.
 * This function is generally targeted for component developers.
 * If you are an app developer, you might simply need to use amx:loadingIndicatorBehavior tag in
 * your page with its failSafeDuration attribute.
 * @param {number} failSafeDuration The approximate duration (non-negative integer in milliseconds) that the framework
 *                                  will wait between showing and hiding the loading indicator (assuming some other
 *                                  trigger has not already shown the indicator); if null or not specified, 10000 (10
 *                                  seconds) will be used instead.
 * @param {function() : string} failSafeClientHandler The optional JavaScript function that will be invoked when the failSafeDuration
 *                                         has been reached. This function can be used to decide how to proceed. This
 *                                         function must return a String that is one of these values:
 *                                         (a) "hide" (meaning just hide the indicator like the default fail-safe),
 *                                         (b) "repeat" (meaning restart the timer for another duration where the function
 *                                             may get invoked again), or
 *                                         (c) "freeze" (meaning keep the indicator up and wait indefinitely; the page may
 *                                             become stuck in a frozen state until restarted).
 */
adf.mf.api.amx.showLoadingIndicator = function(failSafeDuration, failSafeClientHandler)
{
  // This will set a timer to actually launch the busy indicator.
  // This is set on a timer to allow us to cancel this and not show any busy indicator if the action being
  // performed is less then 250ms.

  // If this is the first call to showing the Loading/Busy Indicator and we are not starting of the feature
  // then we have to set the timer to show the loading/busy indicator.
  if (adf.mf.internal.amx._showLoadingCalls == 0 && adf.mf.internal.amx._loadingIndicatorNotFirstTime == true)
  {
    adf.mf.internal.amx._showLoadingIndicator();

    // Need a failsafe timer that will guarantee that the loading indicator is removed.

    // The amx:view tag supports an amx:loadingIndicatorBehavior which lets you
    // define defaults for the page (see amx:view's render() function):
    var actualFailSafeDuration = adf.mf.internal.amx._failSafeDuration; // default is 10 seconds (10,000 ms)
    var actualFailSafeClientHandler = adf.mf.internal.amx._failSafeClientHandler;

    // If passed-in overrides were given, use those instead of the defaults:
    if (failSafeDuration !== undefined)
      actualFailSafeDuration = failSafeDuration;
    if (failSafeClientHandler !== undefined)
      actualFailSafeClientHandler = failSafeClientHandler;

    var failSafeTimerHandler = function()
    {
      var result = "hide";
      try
      {
        if (actualFailSafeClientHandler != null)
          result = actualFailSafeClientHandler();
      }
      catch (problem)
      {
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "adf.mf.api.amx.showLoadingIndicator", "MSG_PROBLEM_WHILE_INVOKING_FAIL_SAFE_HANDLER");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx", "showLoadingIndicator", problem);
      }

      if (adf.mf.internal.amx._failSafeTimer != null) // if still applicable
      {
        if (result == "freeze")
          return;
        else if (result == "repeat")
          adf.mf.internal.amx._failSafeTimer =
            window.setTimeout(failSafeTimerHandler, actualFailSafeDuration);
        else // "hide"
          adf.mf.internal.amx.killLoadingIndicator();
      }
    };

    adf.mf.internal.amx._failSafeTimer =
      window.setTimeout(failSafeTimerHandler, actualFailSafeDuration);
    // Set the number of calls to 1
    adf.mf.internal.amx._showLoadingCalls = 1;
  }
  else
  {
    // This is not the first call so we need to just increase the number of calls. This is neeeded as we will decrement
    // this value and when we hit zero then we will remove the loading/busy indicator.
    adf.mf.internal.amx._showLoadingCalls = adf.mf.internal.amx._showLoadingCalls + 1;
  }
};

/**
 * To ensure that the loading/busy indicator for some unknown reason is removed we have a failsafe timer that will
 * ensure that this is removed. This is required because the user will be unable to interact with the page as loading/
 * busy indicator is blocking all input.
 */
adf.mf.internal.amx.killLoadingIndicator = function()
{
  // Since the failsafe had to kick in we need to clear the timer and also delete the old timer.
  // Clear the timer so it is not called again.
  window.clearTimeout(adf.mf.internal.amx._failSafeTimer);
  // Need to delete the old timer
  delete adf.mf.internal.amx._failSafeTimer;
  // Need to reset the calls to 0
  adf.mf.internal.amx._showLoadingCalls = 0;
  // Transition the loading/busy indicator off.
  var loadingDiv = document.getElementById("amx-loading");
  var transitionEndFunction =
    function()
    {
      loadingDiv.classList.remove("hiding"); // no longer animating
      loadingDiv.classList.add("hidden");    // set display:none

      // Blank out the loading WAI-ARIA live region so that you won't hear the text when not loading
      var loadingLiveRegion = document.getElementById("amx-loading-live-region");
      if (loadingLiveRegion != null)
      {
        loadingLiveRegion.textContent = "";
      }

      // We are done with showing the initial HTML for the page:
      adf.mf.internal.api.queueShowPageComplete();
      adf.mf.internal.amx.addBuildGestureIfApplicable();
    };
  adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe(
    loadingDiv,
    transitionEndFunction);

  loadingDiv.classList.remove("showing"); // get rid of opacity:1
  loadingDiv.classList.add("hiding");     // animate to opacity:0

  // if we are in test mode, then set the failsafe invoked flag
  if (amx.testmode)
  {
    amx.failsafeinvoked = true;
  }
};

/**
 * Hides one instance of the loading indicator.
 */
adf.mf.api.amx.hideLoadingIndicator = function()
{
  // This function will decrement the showLoadingIndicator calls.
  // Once attribute and when it goes to zero will start the process for hiding the loading/busy indicator.

  if (adf.mf.internal.amx._showLoadingCalls == 0)
    return;

  adf.mf.internal.amx._showLoadingCalls = adf.mf.internal.amx._showLoadingCalls - 1;
  if (adf.mf.internal.amx._showLoadingCalls == 0)
  {
    var loadingDiv = document.getElementById("amx-loading");
    var cl = loadingDiv.classList;
    cl.remove("showing"); // get rid of opacity:1
    cl.add("hiding");     // animate to opacity:0
    cl.remove("hiding");  // no longer animating
    cl.add("hidden");     // set display:none

    // Clear the failsafe timer so it is not called.
    window.clearTimeout(adf.mf.internal.amx._failSafeTimer);

    // Need to delete the old failsafe timer
    delete adf.mf.internal.amx._failSafeTimer;

    // Blank out the loading WAI-ARIA live region so that you won't hear the text when not loading
    var loadingLiveRegion = document.getElementById("amx-loading-live-region");
    if (loadingLiveRegion != null)
    {
      loadingLiveRegion.textContent = "";
    }
  }
};

/**
 * This is a special case for clearing the loading/busy indicator. On the initial load of the feature we set the style
 * on the DIV to show the loading indicator. This means there will be no call to hiding and instead call this function.
 * Unfortunalty this function will get called multiple times based on where this call had to put. This means we need
 * to make sure this is only called the once and we rely on the attribute being set for this.
 */
adf.mf.api.amx.hideLoadingIndicatorOnlyIfFirstTime = function()
{
  // If this is the first time this function is called then we will hide the loading/busy indicator.
  if (adf.mf.internal.amx._loadingIndicatorNotFirstTime == null)
  {
    // Based on the path taken to all this function there may have been other calls to showing. We need to ensure that
    // the counter has been set back to zero.
    adf.mf.internal.amx._showLoadingCalls = 0;
    adf.mf.internal.amx._loadingIndicatorNotFirstTime = true;
    var loadingDiv = document.getElementById("amx-loading");
    var transitionEndFunction = function()
      {
        loadingDiv.classList.remove("hiding"); // no longer animating
        loadingDiv.classList.add("hidden");    // set display:none

        // We are done with showing the initial HTML for the page:
        adf.mf.internal.api.queueShowPageComplete();
        adf.mf.internal.amx.addBuildGestureIfApplicable();
      };
    adf.shared.impl.animationUtils.addOneTimeTransitionEndWithFailsafe(
      loadingDiv,
      transitionEndFunction);

    loadingDiv.classList.remove("showing"); // get rid of opacity:1
    loadingDiv.classList.add("hiding");     // animate to opacity:0

    // MAX's use of iframes makes computed styles unfeasible; this may cause
    // other problems for MAX.
    if (adf.mf.internal.amx.getComputedStyle(loadingDiv).opacity == 0 ||
        adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
    {
      // Already at zero opacity so no transition will take place, clean up now:
      transitionEndFunction();
    }

    var incompatible = adf.mf.internal.amx.agent["incompatible"];
    if (incompatible)
    {
      // Log the warning:
      adf.mf.log.logInfoResource(
        "AMXInfoBundle",
        adf.mf.log.level.SEVERE,
        "_getAgentTypeAndVersion",
        "MSG_ERROR_UNSUPPORTED_BROWSER",
        incompatible);

      // Show the warning to the user so they can take action:
      if (!adf.mf.environment.profile.dtMode && // not in DT mode
        !adf.suppressUnsupportedBrowserError) // isn't suppressing the warning
      {
        var unsupportedBrowserError =
          adf.mf.resource.getInfoString(
            "AMXInfoBundle",
            "MSG_ERROR_UNSUPPORTED_BROWSER",
            incompatible);
        alert(unsupportedBrowserError);
      }
    }
  }
  else
  {
    adf.mf.api.amx.hideLoadingIndicator();
  }
};

/**
 * When an app is deployed using debug mode, allow repeated taps on the page
 * that occur within a set time limit to cause build information to be displayed
 * to the user.
 */
adf.mf.internal.amx.addBuildGestureIfApplicable = function()
{
  if (adf._debugBodyPageTapCount == null)
  {
    adf._debugBodyPageTapCount = [ 0, 0 ]; // tap count, timestamp
    var bodyPage = document.getElementById("bodyPage");
    if (bodyPage != null &&
        bodyPage.classList.contains("amx-debug"))
    {
      adf.mf.api.amx.addBubbleEventListener(
        bodyPage,
        "touchend",
        function(event)
        {
          var currentTime = (new Date()).getTime();

          // Have we surpassed the limit for repeated tapping?
          if (currentTime - adf._debugBodyPageTapCount[1] > 3000)
            adf._debugBodyPageTapCount = [ 1, currentTime ]; // exceeded time limit
          else
            ++adf._debugBodyPageTapCount[0]; // increment the tap counter

          if (adf._debugBodyPageTapCount[0] == 10) // tapped enough times
          {
            var buildInfo = adf.mf.internal.BUILD_INFO;
            if (buildInfo != null)
            {
              var productVersion = buildInfo["PRODUCT_VERSION"];
              var jobName = buildInfo["JOB_NAME"];
              var buildNumber = buildInfo["BUILD_NUMBER"];

              // Do not show an alert if there is nothing to display or if we are
              // in automation mode (don't want to interfere with testing when
              // rapidly tapping).
              if (productVersion != "?" &&
                document.getElementById("bodyPage").className.indexOf("amx-automation") == -1)
              {
                var buildInfo = "Oracle MAF " + productVersion + " - " + jobName + " " + buildNumber;
                adf.mf.api.amx.addMessage("info", buildInfo, null, null);
              }
            }
          }
        });
    }
  }
};

/**
 * Bulk load a set of providers so they cached and accessibly locally.
 * @param {Object} treeNodeIterator is the tree node iterator to load the provider from
 * @param {number} startingPoint to load from, typically 0 but recursive calls will change those to
 *        be page/set boundary markers
 * @param {number} numberOfRows to load up to the number of providers in the collection. Represents
 *        the total number of rows, not relative to the starting point
 * @param {function} success the callback to invoke when all the providers have been loaded
 * @param {function} failed the callback to invoke on error
 */
adf.mf.api.amx.bulkLoadProviders = function(
  treeNodeIterator,
  startingPoint,
  numberOfRows,
  success,
  failed)
{
  // Do not process bulk loads during navigation
  if (adf.mf.internal.amx._navigationInProgress)
  {
    if (failed != null)
    {
      var loadIgnoredMessage = adf.mf.resource.getInfoString(
        "AMXErrorBundle", "ERROR_BULK_LOAD_IGNORED_DUE_TO_NAVIGATION");

      failed(loadIgnoredMessage, null); // invoke failure callback; load was invalid
    }

    return;
  }

  var navigationIdAtStart = adf.mf.internal.amx._navigationId;
  var scb = success;
  var fcb = failed;

  var tnb = treeNodeIterator.getTreeNodeBindings();

  // Get the number of cached rows after the starting point
  var cachedRows = treeNodeIterator.getCachedRowCount(startingPoint);
  // Get the total number of rows in the collection model (not just cached)
  var maxRows = tnb.keys.length;
  // Get the desired number of rows that should be cached (from 0, aka total)
  var desiredRowCount =
    (
      (numberOfRows == -1) ||
      (maxRows < numberOfRows &&
        (
          !tnb ||
          !tnb.hasMoreKeys
        )
      )
    ) ? maxRows : numberOfRows;

  if (cachedRows + startingPoint < desiredRowCount)
  {
    // fetch more data - note this will call nextSet and then recurse to fetch any remaining rows
    // if need be
    var newIndex = startingPoint + cachedRows;
    var isFetchingMoreRows = false;
    if (newIndex < 0)
    {
      newIndex = 0;
    }
    else if (newIndex >= maxRows)
    {
      newIndex = maxRows - 1;
      isFetchingMoreRows = true;
    }
    treeNodeIterator.setCurrentIndex(newIndex);

    var hasMoreKeys = tnb.hasMoreKeys;

    treeNodeIterator.nextSet(
      function()
      {
        // If the page has been navigated when we got here after we started the load, then
        // there's nothing for us to do with the fetched data so we must ignore it:
        if (navigationIdAtStart != adf.mf.internal.amx._navigationId || adf.mf.internal.amx._navigationInProgress)
        {
          var loadIgnoredMessage =
            adf.mf.resource.getInfoString(
              "AMXErrorBundle", "ERROR_BULK_LOAD_IGNORED_DUE_TO_NAVIGATION");
          fcb(loadIgnoredMessage, null); // invoke failure callback; load was invalid
          return;
        }

        // See if the last call was supposed to load more than the maximum number of rows
        if (isFetchingMoreRows)
        {
          tnb = treeNodeIterator.getTreeNodeBindings();
          var newMaxRows = tnb.keys.length;
          if (newMaxRows <= maxRows)
          {
            if (!tnb.hasMoreKeys && hasMoreKeys)
            {
              // If the flag for hasMoreKeys was true but is now false, then the load was
              // successful but there were no rows to be loaded
              scb(null, null);
              return;
            }
            else
            {
              // See if the number of cached rows changed. If so, then call the success callback,
              // else treat this as a failure since no rows were loaded with no apparent reason
              var newCachedRows = treeNodeIterator.getCachedRowCount(startingPoint);

              // Get the total number of rows in the collection model (not just cached)
              if (newCachedRows > cachedRows)
              {
                scb(null, null);
              }
              else
              {
                fcb(null, null);
              }
              return;
            }
          }
        }

        if (isFetchingMoreRows)
        {
          ++newIndex;
        }
        adf.mf.api.amx.bulkLoadProviders(treeNodeIterator, newIndex, desiredRowCount,
          success, failed);
      },
      fcb);
  }
  else
  {
    // we have the data already cached
    try
    {
      scb(null, null);
    }
    catch(fe)
    {
      fcb(fe, null);
    }
  }
};

// ------ amx UI ------ //
(function()
{
  // this tells if the app is transitioning something (events should be frozen when doing so)
  amx.transitioning = false;

  amx.acceptEvent = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amx.acceptEvent", "MSG_DEPRECATED", "amx.acceptEvent", "adf.mf.api.amx.acceptEvent");
    return adf.mf.api.amx.acceptEvent();
  };

  /**
   * Determines whether an event can be processed.
   * @return {Boolean} whether it is safe to proceed with event processing (not in the middle of a transition)
   */
  adf.mf.api.amx.acceptEvent = function()
  {
    return !amx.transitioning && !adf.mf.environment.profile.dtMode;
  };

  amx.getCurrentPageName = function()
  {
    var currentPage = document.querySelector(".amx-view-container.current");
    if (currentPage != null)
      return currentPage.getAttribute("data-pagename");
    return null;
  };

  /**
   * Determines whether the environmentMode is set to mobileApplicationAccelerator.
   * @return {Boolean} true if environmentMode is set to mobileApplicationAccelerator, otherwise false.
   */
  adf.mf.internal.amx.isMobileApplicationAcceleratorMode = function ()
  {
    if (adf.mf.environment.profile.environmentMode == "mobileApplicationAccelerator")
    {
      return true;
    }
    return false;
  };

  amx.hooks = {};
  // ------ Public API ------ //
  var isFirstPage = true;
  var initPromise = null;

  //  Let the navigation handler manage view history and the MfContextInstance.
  adf.mf.internal.useNavHandlerViewHistory = true;

  /**
   * @deprecated Use amxNode.getVolatileState instead.
   */
  adf.mf.api.amx.getVolatileState = function(amxNodeId)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.getVolatileState", "MSG_DEPRECATED", "adf.mf.api.amx.getVolatileState",
      "amxNode.getVolatileState");

    var stateValue = adf.mf.internal.amx._getVolatileStateMap();

    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * @deprecated Use amxNode.setVolatileState instead.
   */
  adf.mf.api.amx.setVolatileState = function(amxNodeId, payloadJsonObject)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.setVolatileState", "MSG_DEPRECATED", "adf.mf.api.amx.setVolatileState",
      "amxNode.setVolatileState");

    var stateValue = adf.mf.internal.amx._getVolatileStateMap();

    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_VOLATILE_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_VOLATILE_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  adf.mf.internal.amx._getVolatileStateMap = function()
  {
    if (adf.mf.environment.profile.dtMode && adf.mf.internal.amx._volatileStateMap == null)
    {
      // This is needed because the controller will not call setMfContextInstance in DT mode:
      adf.mf.internal.amx._volatileStateMap = {};
    }
    return adf.mf.internal.amx._volatileStateMap;
  };

  /**
   * @deprecated Use amxNode.getClientState instead.
   */
  adf.mf.api.amx.getClientState = function(amxNodeId)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.getClientState", "MSG_DEPRECATED", "adf.mf.api.amx.getClientState",
      "amxNode.getClientState");

    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      var payloadJsonObject = stateValue[amxNodeId];
      return payloadJsonObject;
    }
  };

  /**
   * @deprecated Use amxNode.setClientState instead.
   */
  adf.mf.api.amx.setClientState = function(amxNodeId, payloadJsonObject)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.api.amx.setClientState", "MSG_DEPRECATED", "adf.mf.api.amx.setClientState",
      "amxNode.setClientState");
    var stateValue = adf.mf.internal.amx._getClientStateMap();
    if (amxNodeId == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_ASSOCIATING_CLIENT_STATE",
          amxNodeId));
    }
    else if (stateValue == null)
    {
      throw new Error(
        adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_NOT_AVAILABLE",
          stateValue));
    }
    else
    {
      stateValue[amxNodeId] = payloadJsonObject;
    }
  };

  /**
   * Using true for the following flag results in "oracle.adfmf.framework - adf.mf.el - setValue] Since the
   * java is not available we will skip the remote write." failure messages when attempting to navigate.
   * @private
   */
  adf.mf.internal.amx._useBruceApproach = (adf.mf.api.getQueryStringParamValue(adf.mf.api.getQueryString(), "useBruceWay") == "true");

  adf.mf.internal.amx._getClientStateMap = function()
  {
    var stateValue;
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var stateName = "#{bindings.amxInternalClientState}";
      if ((stateValue = adf.mf.el.getLocalValue(stateName)) === undefined)
      {
        stateValue = {};
        var getFailed  = function(req, message)
        {
          throw new Error(
            adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_CLIENT_STATE_ACCESS_FAILED",
              message));
        };
        adf.mf.el.setLocalValue({"name":stateName, "value":stateValue}, function(){}, getFailed);
      }
    }
    else // don't use Bruce's way
    {
      if (adf.mf.environment.profile.dtMode && adf.mf.internal.amx._nonBruceClientStateMap == null)
      {
        // This is needed because the controller will not call setMfContextInstance in DT mode:
        adf.mf.internal.amx._nonBruceClientStateMap = {};
      }
      stateValue = adf.mf.internal.amx._nonBruceClientStateMap;
    }

    return stateValue;
  };

  /**
   * Establish (or re-establish) the mfContext instance for the page that the user will now be interacting with.
   * Used by the controller's navigation handler during tansition to a new view.
   * @param viewHistoryItem  the view history stack entry associtated with the current view.
   * @param brandNewInstance is this a new view instance or an existing one (e.g. a back navigation)?
   * @export
   */
  adf.mf.internal.amx.setMfContextInstance = function(viewHistoryItem, brandNewInstance)
  {
    // Prepare the client state map (the bucket that survives navigation):
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var pageDef    = viewHistoryItem.amxPage;
      var resetState = false; // per Bruce, use false here (may in the future consider how brandNewInstance plays into it)
      var reSync     = false; // per Bruce, use false here (may in the future consider how brandNewInstance plays into it)
      var resetViewScope = adf.mf.internal.lastNavIsDifferentView;
      var setFailed  = function(req, message)
      {
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_MF_CONTEXT_SET_FAILED",
            message));
      };
      adf.mf.api.setCurrentContext(pageDef, resetState, reSync, resetViewScope, function(){}, setFailed);
    }
    else // don't use Bruce's way
    {
      if (viewHistoryItem._nonBruceClientStateMap == null)
      {
        viewHistoryItem._nonBruceClientStateMap = {};
      }
      adf.mf.internal.amx._nonBruceClientStateMap = viewHistoryItem._nonBruceClientStateMap;
    }

    // Prepare a fresh volatile state map (the bucket that resets at navigation):
    adf.mf.internal.amx._volatileStateMap = {};
  };

  /**
   * Remove the mfContext instance for the page that the user will now be leaving.
   * Used by the controller's navigation handler during tansition to a new view.
   * @param viewHistoryItem  the view history stack entry associtated with the view to be removed.
   * @export
   */
  adf.mf.internal.amx.removeMfContextInstance = function(viewHistoryItem)
  {
    // Purge the client state map (the bucket that survives navigation) since this instance will never be used again:
    if (adf.mf.internal.amx._useBruceApproach)
    {
      var pageDef      = viewHistoryItem.amxPage;
      var instanceId   = viewHistoryItem.itemId;
      var removeFailed = function(req, message)
      {
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_MF_CONTEXT_REMOVE_FAILED",
            message));
      };
      adf.mf.api.removeContextInstance(pageDef, instanceId, function(){}, removeFailed);
    }
    else // don't use Bruce's way
    {
      adf.mf.internal.amx._nonBruceClientStateMap = null;
    }
  };

  adf.mf.internal.amx._purgeOnNav = function()
  {
    // Purge any elements that might be disconnected from the bodyPage.
    // Examples: inputDate and selectManyChoice pickers on Android.
    var elementsToPurge = document.getElementsByClassName("amx-purge-on-nav");
    for (var i=elementsToPurge.length-1; i>=0; --i)
      adf.mf.api.amx.removeDomNode(elementsToPurge[i]);
  };

  adf.mf.internal.amx._handlePageTransition = function(transitionType, isBack, currentElement, newElement, alwaysFunction)
  {
    if (adf.mf.internal.amx._pageTransitionCancelFunction != null)
      adf.mf.internal.amx._pageTransitionCancelFunction();

    // Ensure prerequisites are met:
    currentElement.style.display = "block";
    newElement.style.display = "block";
    newElement.classList.remove("new");
    newElement.classList.add("current");

    var properties = {};
    properties["parentFlipAllowed"] = true; // no other visible siblings plus parent and grandparent have equal dimensions
    properties["dimensionsFromParent"] = true;
    properties["finishedFunction"] = alwaysFunction;
    properties["callbackParams"] = [];
    properties["animationEnabled"] = true;
    properties["isRtl"] = document.documentElement.dir == "rtl";
    properties["fineLogger"] = function(message)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINER,
        "adf.mf.internal.amx", "_handlePageTransition", message);
    };

    if (isBack)
    {
      if (transitionType.indexOf("Start") != -1)
        transitionType = transitionType.replace(/Start/, "End");
      else if (transitionType.indexOf("End") != -1)
        transitionType = transitionType.replace(/End/, "Start");
      else if (transitionType.indexOf("Left") != -1)
        transitionType = transitionType.replace(/Left/, "Right");
      else if (transitionType.indexOf("Right") != -1)
        transitionType = transitionType.replace(/Right/, "Left");
      else if (transitionType.indexOf("Up") != -1)
        transitionType = transitionType.replace(/Up/, "Down");
      else if (transitionType.indexOf("Down") != -1)
        transitionType = transitionType.replace(/Down/, "Up");
      else if ("slide" == transitionType)
        transitionType = "slideEnd";
      else if ("flip" == transitionType)
        transitionType = "flipEnd";
    }

    adf.mf.internal.amx._pageTransitionCancelFunction =
      adf.shared.impl.animationUtils.transition( // WARNING this is impl (not a public API) and will change without notice
        transitionType,
        currentElement,
        newElement,
        properties);
  };

  /**
   * Checks and logs windows event leaks in debug mode.
   * @param callerFunctionName name of caller function to display in log
   * @private
   */
  adf.mf.internal.amx._checkForWindowsEventLeaks = function(callerFunctionName)
  {
      if ("release" != adf.mf.internal.BUILD_CONFIGURATION) // if debug mode...
      {
        // Check for window event leaks:
        var windowEventDebugString = adf.mf.api.amx.getEventDebugString(window, 200);
        if ("DOM events: \n  n/a\nSpecial events:\n  n/a" != windowEventDebugString)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle",
                                      adf.mf.log.level.SEVERE,
                                      callerFunctionName,
                                      "MSG_WINDOW_EVENT_LEAKS",
                                      "\n" + windowEventDebugString);
        }
      }
  };

  /**
   * @deprecated
   */
  amx.doNavigation = function(outcome)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "doNavigation",
      "MSG_DEPRECATED", "amx.doNavigation", "adf.mf.api.amx.doNavigation");
    adf.mf.api.amx.doNavigation.apply(this, arguments);
  };

  adf.mf.api.amx.doNavigation = function(outcome)
  {
    // Trigger the amxnavigatestart event prior to the critical section lock
    adf.mf.internal.triggerEvent(
      document,
      "Events",
      "amxnavigatestart",
      false,
      false,
      null,
      {
        "outcome": outcome
      });

    adf.mf.internal.amx._queueCriticalSectionFunction(
      doNavigationImpl,
      this,
      false,
      outcome);
  };

  // Global value to indicate if the last navigation resulted in a different view.
  adf.mf.internal.lastNavIsDifferentView = true;

  function doNavigationImpl(outcome)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Perform navigation", adf.mf.log.level.FINE, "adf.mf.api.amx.doNavigation");
    adf.mf.api.amx.showLoadingIndicator();

    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    if (!amx.containsELExpressions (outcome))
    {
      // no el expressions detected, just pass outcome as-is
          resolve(outcome);
    }
    else
    {
      var invokeCallback = function(req,res)
      {
            resolve(res);
      };
      try
      {
        // Assume that this is a method expression that returns a String.
        // Also, we do not care if it is a success or failure - any exception passed back
        // will be converted properly below via the amx.getObjectValue call.
        adf.mf.el.invoke(outcome,[],"java.lang.String",[], invokeCallback, invokeCallback);
      }
      catch(e)
      {
        // just invoke the callback
        invokeCallback(outcome, e);
      }
    }
      });

    promise.then(
      function(outcome)
    {
      var navRequest = {};
      navRequest.currentViewId = adf.mf.internal.controller.ViewHistory.peek().viewId;
      // be sure to convert from any json type structures to something
      // usable by javascript
      navRequest.outcome = amx.getObjectValue(outcome);

      var navSuccess = function(req, result)
      {
        var transitionType = result.getTransitionType();
        var amxPage = result.getVdlDocumentPath();
        var isBack = result.isBackNavigation();
        adf.mf.internal.lastNavIsDifferentView = result.isDifferentViewId();

        if (transitionType == "none")
          transitionType = null;

        // We did not find a target for navigation, so exit early. This is a valid case
        // and Faces behaves similarly. It allows developers to return "null" or an invalid
        // target and stay on the same page. If we do not exit here, the bindings will be
        // cleared and not re-initialized
        if (amxPage == null)
        {
          adf.mf.api.amx.hideLoadingIndicator();
          return;
        }

        // before attempting to navigate, make sure all popups are closed
        // NOTE: amx-popup is lazily loaded, so we must check for the existence
        // of the function before calling it
        if (adf.mf.internal.amx.closePopups)
        {
          adf.mf.internal.amx.closePopups();
        }

        // Before we strip off the IDs, call the destroy methods on any AMX nodes
          var current = document.querySelector("#bodyPageViews > .current");
          adf.mf.internal.amx.processDestroy(current);

        // Strip off any ID attributes on the old page's elements. This will prevent any issues
        // with getElementById finding elements on the old page instead of the new page.
          if (current != null)
        {
            adf.mf.internal.amx.stripIds(current);
        }

        if (adf.mf.internal.amx.isTransitionAfterRender(false)) // render before transitioning
        {
            adf.mf.api.amx.displayAmxPage(amxPage).then(function(page)
          {
            var perf = adf.mf.internal.perf.startMonitorCall("Transition to page", adf.mf.log.level.FINER, "adf.mf.api.amx.doNavigation:transition");

            try
            {
                var newPage = page;

              if (transitionType != null)
              {
                amx.transitioning = true;

                // Purge any elements that might be disconnected from the bodyPage:
                adf.mf.internal.amx._purgeOnNav();

                adf.mf.internal.amx._handlePageTransition(
                    transitionType, isBack, current, newPage,
                  function()
                  {
                    amx.transitioning = false;
                    adf.mf.api.amx.hideLoadingIndicator();
                      adf.mf.api.amx.removeDomNode(current);
                    adf.mf.internal.amx._pageTransitionCancelFunction = null;
                    adf.mf.internal.triggerEvent(
                      document,
                      "Events",
                      "amxnavigateend",
                      false,
                      false,
                      null,
                      {
                        "outcome": outcome,
                        "amxPage": amxPage
                      });
                    perf.stop();
                  });
              }
              else
              {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
                  "doNavigation", "MSG_NOT_TRANSITIONING");
                amx.transitioning = true;

                // Purge any elements that might be disconnected from the bodyPage:
                adf.mf.internal.amx._purgeOnNav();

                // we just show it.
                  current.classList.remove("current");
                  current.classList.add("old");
                  newPage.classList.remove("new");
                  newPage.classList.add("current");
                  adf.mf.internal.amx.processDestroy(current);
                  adf.mf.api.amx.removeDomNode(current);
                amx.transitioning = false;
                adf.mf.api.amx.hideLoadingIndicator();
                adf.mf.internal.triggerEvent(
                  document,
                  "Events",
                  "amxnavigateend",
                  false,
                  false,
                  null,
                  {
                    "outcome": outcome,
                    "amxPage": amxPage
                  });
                perf.stop();
              }
            }
            catch (e)
            {
              perf.stop();
              throw e;
            }
          });
        }
        else // use placeholder transitioning
        {
          // Transition to blank immediately, don't wait for the new page to be present:
          amx.transitioning = true;

          // Purge any elements that might be disconnected from the bodyPage:
          adf.mf.internal.amx._purgeOnNav();

          amx._stillTransitioningAway = true;
          amx._stillDisplayingAmxPage = true;
          var viewContainerElement = adf.mf.internal.amx._createViewContainerElement();
            var newPage = viewContainerElement;
          if (transitionType != null)
          {
            adf.mf.internal.amx._handlePageTransition(transitionType, isBack, current,
              viewContainerElement,
              function()
            {
              amx._stillTransitioningAway = false;
              amx.transitioning = (amx._stillDisplayingAmxPage || amx._transitioningAway);
                adf.mf.api.amx.removeDomNode(current);
              adf.mf.internal.amx._pageTransitionCancelFunction = null;
            });
          }
          else
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "doNavigation",
              "MSG_NOT_TRANSITIONING");
            amx._stillTransitioningAway = false;
            // we just show it.
              current.classList.remove("current");
              current.classList.add("old");
              newPage.classList.remove("new");
              newPage.classList.add("current");
              adf.mf.internal.amx.processDestroy(current);
              adf.mf.api.amx.removeDomNode(current);
          }

          adf.mf.api.amx.displayAmxPage(amxPage).then(
            function(page)
          {
            amx._stillDisplayingAmxPage = false;
            amx.transitioning = (amx._stillDisplayingAmxPage || amx._stillTransitioningAway);
            adf.mf.api.amx.hideLoadingIndicator();
            adf.mf.internal.triggerEvent(
              document,
              "Events",
              "amxnavigateend",
              false,
              false,
              null,
              {
                "outcome": outcome,
                "amxPage": amxPage
              });
          });
        }
      };

      var navFailed = function(req, message)
      {
        adf.mf.api.amx.hideLoadingIndicator();
        throw new Error(
          adf.mf.resource.getInfoString("AMXErrorBundle", "ERROR_NAVIGATION_FAILED", message));
      };

      // Give renderers a chance to save off anything they want to preserve (e.g. scroll positions):
        var current = document.querySelector("#bodyPageViews > .current");
        adf.mf.internal.amx.processPreDestroy(current);

      // if debug mode...
      // Check for window event leaks
      adf.mf.internal.amx._checkForWindowsEventLeaks("doNavigation");

      adfc.NavigationHandler.handleNavigation(navRequest, navSuccess, navFailed);

        perfOp.stop();
      },
      function()
      {
        perfOp.stop();
      });

    return promise;
  }

  var initQueue = [];
  var postDisplayQueue = [];

  /**
   * This should only be called by adf.mf.api.amx.removeDomNode().
   * Remove an AMXNode for a given DOM node. Calls any pre-destroy and destroy methods
   * on the type handlers for nodes removed as a result of this call and then removes
   * the HTML from the page.
   * @param  {Node} domNode the HTML DOM node to remove. Must be a root DOM node for an
   *         AMX node.
   * @return {boolean} true if the node is a DOM node that represents an AMX node and
   *         was removed.
   */
  adf.mf.internal.amx.removeAmxDomNode = function(domNode)
  {
    var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
    if (amxNode != null)
    {
      adf.mf.internal.amx.processPreDestroy(domNode);
      adf.mf.internal.amx.processDestroy(domNode);
      return true;
    }

    return false;
  };

  adf.mf.internal.amx.processPreDestroy = function(parent)
  {
    // Find all elements that have a preDestroy implementation (including parent)
    var childrenWithPreDestroy = parent.querySelectorAll(".amx-has-predestroy");

    var handlePreDestroy =
      function(domNode)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
        var nodeTypeHandler = amxNode.getTypeHandler();
        if (nodeTypeHandler && nodeTypeHandler.preDestroy)
        {
          // Prevent duplicate preDestroy calls:
          if (domNode.getAttribute("data-predestroyed") == null)
          {
            domNode.setAttribute("data-predestroyed", true);

            /**
             * Renderer function so you can be notified just before the current view is destroyed;
             * when about to navigate to a new view.
             * @param domNode the root DOM node associated with this renderer
             * @param amxNode the AMX component object associated with this renderer
             */
            nodeTypeHandler.preDestroy(domNode, amxNode);
          }
        }
      };

    if (parent.classList.contains("amx-has-predestroy"))
      handlePreDestroy(parent);
    for (var i=0, count=childrenWithPreDestroy.length; i<count; ++i)
      handlePreDestroy(childrenWithPreDestroy[i]);
  };

  adf.mf.internal.amx.processDestroy = function(parent)
  {
    // Find all elements that have a destroy implementation (including parent)
    var childrenWithDestroy = parent.querySelectorAll(".amx-has-destroy");

    var handleDestroy =
      function(domNode)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxNode");
        var nodeTypeHandler = amxNode.getTypeHandler();
        if (nodeTypeHandler && nodeTypeHandler.destroy)
        {
          // Prevent duplicate destroy calls:
          if (domNode.getAttribute("data-destroyed") == null)
          {
            domNode.setAttribute("data-destroyed", true);

            nodeTypeHandler.destroy(domNode, amxNode);
          }
        }
      };

    if (parent.classList.contains("amx-has-predestroy"))
      handleDestroy(parent);
    for (var i=0, count=childrenWithDestroy.length; i<count; ++i)
      handleDestroy(childrenWithDestroy[i]);
  };

  /**
   * This function processes the amxNodes registered by the amx.queueForInit and
   * calls 'init' function on their related typeHandlers.
   *
   * The processing of the queue takes place immediatelly after the rendering
   * of the amx tree or application of the updates to the amx tree.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   */
  amx.processAndCleanInitQueue = function()
  {
    _processAndCleanQueue(initQueue, "init");
  };

  /**
   * This function processes the amxNodes registered by the amx.queueForPostDisplay and
   * calls 'postDisplay' function on their related typeHandlers.
   *
   * The processing of the queue takes place immediatelly after the processing of the
   * init queue.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * The amxNodes that are currently outside of the document will not be processed.
   */
  amx.processAndCleanPostDisplayQueue = function()
  {
    _processAndCleanQueue(postDisplayQueue, "postDisplay");
  };

  /**
   * This is implementation of the queue processing used for the init and post display queues.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param queue {Array<Object>} queue which will be processed.
   * @param method {String} function to be called on typeHandler of each amxNode in the queue.
   */
  var _processAndCleanQueue = function(queue, method)
  {
    if (queue.length > 0 && method != null)
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      // sort queue by depth to ensure that the nodes are processed in hierarchical order
      adf.mf.api.amx.AmxNode.__sortNodesByDepth(queue);
      // processing the queue with shift enable to handle concurent addition of the
      // amxNodes into the queue
      var amxNode;
      while ((amxNode = queue.shift()) != null)
      {
        // try to get fresh domNode
        // using getElementById ensures that the domNode is already in document
        // in all other cases there is no reason to process it since it is
        // not initable or displayable amxNode
        var domNode = document.getElementById(amxNode.getId());
        if (domNode != null)
        {
          var nodeTypeHandler = amxNode.getTypeHandler();
          // verify that the typeHandler implements current method
          if (adf.mf.internal.amx.implementsFunction(nodeTypeHandler, method))
          {
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "amx", "_processAndCleanQueue",
                "Invoking the \'" + method + "\' method on the type handler for node " +
                amxNode.getId());
            }
            // invoke typeHandler function for current AmxNode
            nodeTypeHandler[method](domNode, amxNode);
          }
          else
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
              "_processAndCleanQueue", "MSG_CANT_" + method.toUpperCase() + "_NODE", domNode);
          }
        }
      }
    }
  };

  /**
   * This function enques the amxNode to the end of the init processing queue.
   *
   * The queue itself will be processed after the render phase where all
   * newly rendered or rerendered amxNodes are inserted into the document.
   *
   * Nodes that are currently outside of the document will not be processed.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param amxNode {Object} node which typeHandler supports init method
   */
  amx.queueForInit = function(amxNode)
  {
    if (amxNode != null)
    {
      initQueue[initQueue.length] = amxNode;
    }
  };

  /**
   * This function enques the amxNode to the end of the post display processing queue.
   *
   * The queue itself will be processed after the init phase where all
   * amxNodes from init queue (registered by the #queueForInit function)
   * are processed.
   *
   * Nodes that are currently outside of the document will not be processed.
   *
   * The amxNodes are processed in the same hierarchical order as they are
   * rendered.
   *
   * @param amxNode {Object} node which typeHandler supports postDisplay method
   */
  amx.queueForPostDisplay = function(amxNode)
  {
    if (amxNode != null)
    {
      postDisplayQueue[postDisplayQueue.length] = amxNode;
    }
  };

  /**
   * Create and insert a new view container element (no content yet).
   * @return {HTMLElement} the newly-created view container element
   * @private
   */
  adf.mf.internal.amx._createViewContainerElement = function()
  {
    var viewContainerElement = document.createElement("div");
    viewContainerElement.className = "amx-view-container new";
    // TODO consider injecting placeholder DOM here so it isn't completely blank
    document.getElementById("bodyPageViews").appendChild(viewContainerElement);
    return viewContainerElement;
  };

  /**
   * Processes all the bundles on the page
   * @private
   * @param {adf.mf.api.amx.AmxTag} amxTag the root tag of the page
   * @return {Object} promise object that is resolved once all bundles have been loaded
   */
  function loadBundles(amxTag)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    if (adf.mf.environment.profile.dtMode)
    {
          resolve();
    }
    else
    {
      // amx:loadBundle only allowed under the root tag of the page
      // or the fragment
      var bundles = amxTag.getChildren(
        adf.mf.api.amx.AmxTag.NAMESPACE_AMX,
        "loadBundle");

          var childPromises = [];
      var numBundles = bundles.length;

      if (numBundles == 0)
      {
            resolve();
      }
      else
      {
        for (var i = 0; i < numBundles; ++i)
        {
          var bundleTag = bundles[i];
          var basename = bundleTag.getAttribute("basename");
          var variable = bundleTag.getAttribute("var");

              var loadPromise = amx.loadBundle(basename, variable);
              childPromises.push(loadPromise);

              adf.mf.internal.BasePromise.all(childPromises).then(
              function()
              {
                  resolve();
                },
              function()
              {
                  reject.apply(null, arguments);
              });
        }
      }
    }
      });
  }

  /**
   * Load and display an AMX page.
   * @param {Object} amxPageName the name of the page to load
   * @return {Object} promise object that is resolved once the page has been rendered. Currently
   *         resolved with the DOM node for the view container element
   */
  adf.mf.api.amx.displayAmxPage = function(amxPageName) /* used by base-controller.js */
  {
    adf.mf.api.amx.showLoadingIndicator();
    var that = this;
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        adf.mf.internal.amx._queueCriticalSectionFunction(
          displayAmxPageImpl,
          that,
          false,
          amxPageName,
          {
            "resolve": resolve,
            "reject": reject
          });
      });
  };

  /**
   * Object to track AMX nodes that are busy. This is used for performance to track when a page has
   * fully loaded or after a page has fully reacted to a data change event after an AMX event has
   * been queued.
   *
   * @constructor
   */
  function PageBusyTracker()
  {
    this._operations = [];
    this._nodeCount = 0;
  }

  /**
   * Sets the node count to zero. Used when a new page is being loaded
   */
  PageBusyTracker.prototype.reset = function()
  {
    this._nodeCount = 0;

    adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.amx._pageWaitingInformation", "reset",
      "Node count has been reset");
  };

  /**
   * Increments the number of nodes waiting on a condition.
   */
  PageBusyTracker.prototype.increment = function()
  {
    ++this._nodeCount;

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "increment",
        "Nodes in a waiting state is now " + this._nodeCount);
    }
  };

  /**
   * Decrements the number of nodes waiting on a condition.
   */
  PageBusyTracker.prototype.decrement = function()
  {
    --this._nodeCount;

    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "decrement",
        "Nodes in a waiting state is now " + this._nodeCount);
    }
  };

  /**
   * Notifies the tracker that a top level operation has begun that should not be stopped until all
   * the nodes are in a resolved state (not INITIAL, WAITING_ON_EL_EVALUATION or
   * PARTIALLY_RENDERED).
   *
   * @param {boolean} stopCurrent if true and there already is an active operation, it will be
   *        stopped as part of this call. If not, the new operation will be stopped along with
   *        the current one.
   * @param {string} operationName the name of the operation
   * @param {Object} the logging level for this operation
   * @param {string} operationDescription the description of the operation
   * @param {string} instance name for this operation. For example, event name
   */
  PageBusyTracker.prototype.startOperation = function(
    stopCurrent,
    operationName,
    level,
    operationDescription,
    instanceName)
  {
    var numOper = this._operations.length;
    if (numOper)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "startOperation",
          "An operation was already running: " + this.getActiveOperation() +
          "\n  New operation: " + operationName + " " + instanceName);
      }

      if (stopCurrent)
      {
        for (var i = 0; i < numOper; ++i)
        {
          this._operations[i].stop();
        }

        this._operations = [];
      }
    }

    var oper = adf.mf.internal.perf.startMonitorOperation(operationName, level, operationDescription, instanceName);
    this._operations.push(oper);
  };

  /**
   * Checks if all AMX nodes are in a resolved state, and if so, stops any ongoing operations.
   */
  PageBusyTracker.prototype.checkComplete = function()
  {
    var numOper = this._operations.length;
    if (numOper && this._nodeCount == 0)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
          "Operation is complete: " + this.getActiveOperation());
      }

      for (var i = 0; i < numOper; ++i)
      {
        this._operations[i].stop();
      }

      this._operations = [];
    }
    else if (numOper)
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
          "Operation is not complete yet. Waiting count: " + this._nodeCount);
      }
    }
    else
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx._pageWaitingInformation", "checkComplete",
        "checkComplete called when there was no active operation");
    }
  };

  /**
   * Gets if an operation is active
   *
   * @return {boolean} true if there is an active operation
   */
  PageBusyTracker.prototype.isOperationActive = function()
  {
    return this._operations.length > 0;
  };

  /**
   * Get the active operation if there is one
   *
   * @return {Object|null} the active operation or null
   */
  PageBusyTracker.prototype.getActiveOperation = function()
  {
    return this.isOperationActive() ? this._operations[0] : null;
  };

  /**
   * Check if there are any AMX nodes in a waiting state
   *
   * @return {boolean} true if there are nodes waiting
   */
  PageBusyTracker.prototype.areNodesWaiting = function()
  {
    return this._nodeCount > 0;
  };

  adf.mf.internal.amx._pageBusyTracker = new PageBusyTracker();

  function displayAmxPageImpl(amxPageName, promiseCallbacks)
  {
    // Return a promise object that holds the critical section
    // as long as needed
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        // Start a new page off with a node waiting count of 0
        adf.mf.internal.amx._pageBusyTracker.reset();

        adf.mf.internal.amx._pageBusyTracker.startOperation(
            false,
            "Load page",
            adf.mf.log.level.INFO,
            "Time to fully render the page", amxPageName);

        // Track the time to the initial page rendering (not fully-loaded)
        var perfOp = adf.mf.internal.perf.startMonitorOperation(
          "Initial page render",
          adf.mf.log.level.FINE,
          "adf.mf.api.amx.displayAmxPage");

        adf.mf.api.addBatchDataChangeListener(adf.mf.internal.amx._handleBatchDataChangeListener);

        // Store the current page name. This is used by the fragment to resolve relative URIs
        adf.mf.internal.amx._currentPageName = amxPageName;

        // Get the page (this must be a promise because it is an AJAX call)
        var amxPageTagPromise = getAmxTagForPage(adfc.Util.addFeatureRootPrefix(amxPageName), false);

        var initDataPromise = initData(amxPageName); // initializes the context

        // clear the bindings
        amx.clearBindings();

        // When amxPage, initData, and initUI resolve, we continue:
        var promises = [ amxPageTagPromise, initDataPromise, initUI() ];
        adf.mf.internal.BasePromise.all(promises).then(
          function(params)
            {
              // Load the message bundles before evaluating any EL
            var amxPageTag = params[0];
            loadBundles(amxPageTag).then(
                  function()
                  {
                    // Build the AMX node tree once the tags have been loaded
                var buildAmxNodeTreePromise = buildAmxNodeTree(amxPageName, amxPageTag);

                    // Resume any queued critical section requests, from this point
                    // on we are not operating in the critical section
                    resolve();

                    // Wait for the EL to arrive so that we may render the page
                buildAmxNodeTreePromise.then(
                        function(amxPageNode)
                        {
                          //debugPrintAmxNodeTree(amxPageNode);

                          // We render the page
                          var perfRender = adf.mf.internal.perf.startMonitorCall("Render AMX page",
                             adf.mf.log.level.FINER, "adf.mf.api.amx.displayAmxPage:render", amxPageName);
                    var pageContentElement;
                          // set flag to prevent independent processing of the init and postDisplay queues
                          // only wait if there is some render event which enqueues the rendered node into
                          // the processing queue and process these queues after the whole render phase is complete
                          amx.mustProcessQueues = false;
                          try
                          {
                      pageContentElement = amxPageNode.render();
                          }
                          finally
                          {
                            perfRender.stop();
                          }

                    var perfAfterRender =
                      adf.mf.internal.perf.startMonitorCall(
                        "After render AMX page",
                        adf.mf.log.level.FINER,
                        "adf.mf.api.amx.displayAmxPage:afterRender",
                        amxPageName);

                          try
                          {
                      var viewContainer;
                            if (adf.mf.internal.amx.isTransitionAfterRender(isFirstPage)) // render before transitioning
                            {
                              // TODO: remove jQ code and stop using string concatination with HTML
                        viewContainer = document.createElement("div");
                        viewContainer.setAttribute("data-pageName", amxPageName);
                        viewContainer.className = "amx-view-container";
                        viewContainer.classList.add("new");

                        document.getElementById("bodyPageViews").appendChild(viewContainer);
                            }
                            else // use placeholder transitioning
                            {
                              var viewContainerElement;
                              if (isFirstPage)
                              {
                                // Since we are not doing a navigation, we have to create the element ourselves:
                                viewContainerElement = adf.mf.internal.amx._createViewContainerElement();
                              }
                              else
                              {
                                // The element was already created in the doNavigation code (where it might kick off a
                                // transition animation) so just get it and use it:
                                var viewContainerElements = document.getElementsByClassName("amx-view-container");
                                viewContainerElement = viewContainerElements[viewContainerElements.length - 1];
                              }
                              viewContainerElement.setAttribute("data-pageName", amxPageName);
                              adf.mf.api.amx.emptyHtmlElement(viewContainerElement);
                            }

                      if (pageContentElement != null)
                        viewContainer.appendChild(pageContentElement);

                            //TODO: needs to move this refresh above
                            // We process and clean the initQueue
                            amx.processAndCleanInitQueue();

                            //If it is the first page, we handler the display
                            if (isFirstPage)
                            {
                        viewContainer.classList.remove("new");
                        viewContainer.classList.add("current");
                              isFirstPage = false;
                            }

                            amx.processAndCleanPostDisplayQueue();

                      promiseCallbacks["resolve"](viewContainer);
                          }
                          finally
                          {
                            perfAfterRender.stop();
                            adf.mf.api.amx.hideLoadingIndicatorOnlyIfFirstTime();
                            perfOp.stop();
                            // reset mustProcessQueues to true
                            // every call of the rerender outside of the data change event
                            // will immediatelly trigger processing of the init and postDisplay
                            // queues
                            amx.mustProcessQueues = true;
                            // Check if the page has finished rendering
                            adf.mf.internal.amx._pageBusyTracker.checkComplete();
                          }
                 },
                 function()
                 {
                   perfOp.stop();
                   adf.mf.internal.amx._pageBusyTracker.checkComplete();
                       });
              },
              function()
              {
                perfOp.stop();
                adf.mf.internal.amx._pageBusyTracker.checkComplete();
                // Reject the promise return
                reject();
                  });
          },
          function()
          {
            // TODO: print error
            adf.mf.api.amx.hideLoadingIndicator();
            perfOp.stop();
            // Reject the promise return
            reject();
            });
      });
  }

  // ------ resource loading ------ //
  var loadedJavaScriptResources = {};
  var loadedCssResources = {};
  var loadingCssLinks = [];
  var cssLoadingCheckInterval = null;
  var cssLoadingWaitStarted = 0;
  var cssLastCheckSheetCount = 0;

  /**
   * Internal function for loading XML files
   * @param {string} resourceName the resource to load
   * @param {boolean} async whether the request should be asynchronous
   * @param {function} successCB the XML file could be parsed
   * @param {function} errorCB the XML file could not be parsed
   * @private
   */
  adf.mf.internal.amx._loadXmlFile = function(resourceName, async, successCB, errorCB)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Load XML file", adf.mf.log.level.FINE, "adf.mf.internal.amx._loadXmlFile", resourceName);
    var perf = adf.mf.internal.perf.startMonitorCall("Load XML file", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.load");

    //  Load the XML:
    adf.mf.api.resourceFile._loadFileWithAjax(
      resourceName,
      async,
      function(responseText)
      {
        perf.stop();
        if ((responseText != null) && (responseText.length > 0))
        {
          perf = adf.mf.internal.perf.startMonitorCall("Parse XML file", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.parse");
          var isUWP = (adf.mf.internal.amx.agent["type"] === "UWP");
          var amxPage;

          // Unfortunately Edge browser has a limit of 128 characters for attribute values.
          // This causes issues with long EL statements in UWP page. So on UWP use a native
          // xml parser
          if (!adf.mf.environment.profile.mockData && isUWP)
          {
            amxPage = new Windows.Data.Xml.Dom.XmlDocument();

            var xmlLoadSettings = new Windows.Data.Xml.Dom.XmlLoadSettings();
            xmlLoadSettings.elementContentWhiteSpace = false;

            amxPage.loadXml(responseText, xmlLoadSettings);
          }
          else
          {
            var parser = new DOMParser();
            amxPage = parser.parseFromString(responseText, "text/xml");
          }
          var firstTag = null;
          var possibleFirstTag = amxPage.firstChild;
          while (firstTag == null && possibleFirstTag != null)
          {
            if (possibleFirstTag.nodeType == 1) // an element
              firstTag = possibleFirstTag;
            else
              possibleFirstTag = possibleFirstTag.nextSibling;
          }

          perf.stop();
          if (firstTag != null)
          {
            try
            {
              perf = adf.mf.internal.perf.startMonitorCall("Parse tags", adf.mf.log.level.FINER, "adf.mf.internal.amx._loadXmlFile.parseTags");
              var amxPageTag = new adf.mf.api.amx.AmxTag(null, firstTag);
              perf.stop();

              var promise = adf.mf.internal.amx._preProcessTagTree(amxPageTag);
              promise.then(
                function()
                {
                  perfOp.stop();
                  successCB(amxPageTag);
                });
            }
            catch (e)
            {
              perfOp.stop();
              errorCB(e);
            }
          }
          else
          {
            perfOp.stop();
            errorCB("No root view tag found");
          }
        }
        else
        {
          perfOp.stop();
          errorCB("Empty response");
        }
      },
      function()
      {
        perfOp.stop();
        errorCB.apply(window, arguments);
      });
  };

  /**
   * Function to load a JavaScript file
   * @param {string} src the URI to the JavaScript file
   * @return {Object} a promise for when the loading is complete
   */
  amx.includeJs = function(src)
  {
    var loadState = loadedJavaScriptResources[src];
    if (loadState == null) // possibilities are null, a promise, or true
    {
      // Never attempted to load this file so load it:
      var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
        {
      // Use an XHR to retrieve the JavaScript. Usage of an XHR allows us to be notified
      // of when the script has been loaded, or has failed to load to be able to correctly
          // invoke the correct promise method.
      adf.mf.api.resourceFile.loadJsFile(
        src,
        true,
        function()
        {
          loadedJavaScriptResources[src] = true;
              resolve();
        },
        function()
        {
          adf.mf.api.adf.logInfoResource(
            "AMXInfoBundle",
            adf.mf.log.level.SEVERE,
            "amx.includeJs",
            "MSG_FAILED_TO_LOAD",
            src);
              reject();
        },
        null);
        });
      loadedJavaScriptResources[src] = promise;
      return promise;
    }
    else if (loadState === true) // other options are undefined and false
    {
      // File was already loaded successfully:
      return adf.mf.internal.BasePromise.resolve();
    }
    else // a promise
    {
      // File was already requested to be loaded with this promise:
      return loadState;
    }
  };

  /**
   * Function that checks for the completion of loading CSS files
   * (polls from a callback from a window interval)
   */
  function waitTillCssLoaded()
  {
    var styleSheets = document.styleSheets;
    var numStyleSheets = styleSheets.length;

    // Don't bother checking if the count has not changed from the last poll
    if (cssLastCheckSheetCount == numStyleSheets)
    {
      return;
    }
    cssLastCheckSheetCount = numStyleSheets;
    // Loop through all the nodes that we are still waiting to finish loading
    for (var i = 0; i < loadingCssLinks.length; ++i)
    {
      var obj = loadingCssLinks[i];
      var nonLoadedNode = obj["node"];

      for (var j = 0; j < numStyleSheets; ++j)
      {
        var linkNode = styleSheets[j].ownerNode;
        // See if this style sheet is for the node we are waiting to be loaded.
        if (nonLoadedNode == linkNode)
        {
          // When the style sheet appears in the styleSheets collection,
          // it has finished loading
          obj["resolve"](linkNode);

          // Remove the item from the array
          loadingCssLinks.splice(i--, 1);

          if (loadingCssLinks.length == 0)
          {
            // We are not waiting on any more nodes
            window.clearInterval(cssLoadingCheckInterval);
            cssLoadingCheckInterval = null;
            return;
          }

          break;
        }
      }
    }

    var timeWaiting = new Date().getMilliseconds() - cssLoadingWaitStarted;
    // Since the code is not notified of CSS files that failed to load, only way for a maximum
    // of 5 seconds for all CSS files to load and then throw an error
    if (timeWaiting >= 5000)
    {
      for (var index = 0, size = loadingCssLinks.length; i < size; ++i)
      {
        var obj = loadingCssLinks[index];
        // Notify the listener that the resource failed to load
        obj["reject"]();
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "amx.includeCss",
          "MSG_FAILED_TO_LOAD", obj["path"]);
      }
      loadingCssLinks = [];
      window.clearInterval(cssLoadingCheckInterval);
      cssLoadingCheckInterval = null;
    }
  };

  /**
   * Function to load a CSS file
   * @param {string} path the URI to the CSS file
   * @return {Object} promise that is resolved once the style sheet has been loaded.
   */
  amx.includeCss = function(path)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    if (loadedCssResources[path])
    {
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "amx", "includeCss",
          "CSS file has already been loaded: " + path);
      }

      // Return a promise object already resolved to indicate that the source
      // has already been loaded
      return adf.mf.internal.BasePromise.resolve();
    }

    var isUWP = (adf.mf.internal.amx.agent["type"] === "UWP");

    // Currently, the only supported means in WebKit browsers to determine if a style sheet has
    // finished loading is to check for the style sheet to appear in the document.styleSheets
    // collection. There are no events that are associated with the loading, so polling this
    // collection is the only means, at the moment, to determine this information.
    //
    // We need to use a <link> tag so that the URLs in the CSS are preserved. If we were to
    // attempt to use a <style> tag and inject the content from the CSS file into the page, the
    // relative URLs would no longer work.

    if (isFinestLoggingEnabled)
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "amx", "includeCss",
        "Loading CSS file : " + path);
    }
    loadedCssResources[path] = true;

    // Create a link element
    var node = document.createElement("link");
    node.setAttribute("rel", "stylesheet");
    node.setAttribute("type", "text/css");

    var perf = null;
    // Currently UWP has issues with loading resource from local directory.
    // So we have to workaround it by loading the resource as data uri
    if (isUWP && window.AdfmfCallback && AdfmfCallback.isLocalResource(path))
    {
      perf = adf.mf.internal.perf.startMonitorCall("Include CSS file", adf.mf.log.level.FINER, "amx.includeCss");

      // use callback interface from windows to get data uri from a file
      // and return the base promise
      return AdfmfCallback.setDataURIForLocalResource(node, path).then(
        function()
        {
          // href is loaded successfully add the node to DOM
          document.head.appendChild(node);

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "amx", "includeCss",
              "Successfully loaded CSS file: " + path);
          }
          perf.stop();
        },
        function()
        {
          // append the node with the invalid href
          node.setAttribute("href", path);
          document.head.appendChild(node);

          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "amx.includeCss",
          "MSG_FAILED_TO_LOAD", path);

          perf.stop();
        });
    }
    else
    {
      node.setAttribute("href", path);
      document.head.appendChild(node);
    }

    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        // Store an object with the promise object to be able to notify when loaded,
    // and the node to check to see when the loading has completed.
    loadingCssLinks.push(
      {
        "path": path,
        "node": node,
            "resolve": resolve,
            "reject": reject
      });

    // See if a timer has already been started, if not start one to poll the document.styleSheets
    // collection
    if (cssLoadingCheckInterval == null)
    {
      // Use a 10ms timeout. These resources are local to the device, so it should not take long
      // for them to be loaded.
      cssLoadingCheckInterval = window.setInterval(waitTillCssLoaded, 10);
    }

    // Set or reset when we started to wait for the CSS to load. This leaves a maximum wait time
    // of 5 seconds from the last CSS file added.
    cssLoadingWaitStarted = new Date().getMilliseconds();

        // Return the promise object so that the caller may be notified once the CSS file has been
    // completely loaded
    var perf = adf.mf.internal.perf.startMonitorCall("Include CSS file", adf.mf.log.level.FINER, "amx.includeCss");
      }).then(
      function()
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "amx", "includeCss",
            "Successfully loaded CSS file: " + path);
        }

          if (perf != null)
        perf.stop();
      });
  };
  // ------ /resource loading ------ //

  // TODO: add more comments to the iterator implementation classes below
  /**
   * Iterator object to support iterating over a JavaScript items array with hasNext and next methods
   * @constructor
   */
  function ArrayIterator(items)
  {
    // Empty arrays are currently sent to the JavaScript side as nulls by the embedded side. As
    // such, convert the value into an empty array
    this._items = items || [];
    this._index = -1;
    this._length = this._items.length;
  }

  ArrayIterator.prototype =
  {
    next: function()
    {
      return this.hasNext() ? this._items[++this._index] : undefined;
    },

    hasNext: function()
    {
      return this._index + 1 < this._length;
    },

    previous: function()
    {
      return this.hasPrevious() ? this._items[--this._index] : undefined;
    },

    hasPrevious: function()
    {
      return this._index > 0 && this._index - 1 < this._length;
    },

    getCurrent: function()
    {
      return this._index >= 0 && this._index <= this._length ? this._items[this._index] : undefined;
    },

    getCurrentIndex: function()
    {
      return this._index;
    },

    isTreeNodeIterator: function()
    {
      return false;
    },

    isAllDataLoaded: function()
    {
      // Arrays cannot implement the behavior of notifying the consumer that more data may be able
      // to be loaded. It is up to the page author to configure the loading of more information
      // manually
      return true;
    },

    getAvailableCount: function()
    {
      return this._length;
    },

    getTotalCount: function()
    {
      return this._length;
    },

    getRowKey: function()
    {
      if (this._index == -1)
      {
        return null;
      }

      var currentItem = this._items[this._index];
      return currentItem == null ? null :
        typeof currentItem["rowKey"] === "function" ?
          currentItem.rowKey() : this._index;
    },

    /**
     * Sets the index to the value specified. Note that calling next will cause
     * the item after this index to be returned. Therefore, calling the function
     * with -1 will cause the next item to load to be the first item (index 0).
     */
    setCurrentIndex: function(index)
    {
      this._index = index;
    },

    /**
     * Sets the current item by the row key
     * @param {string} rowKey the row key
     * @return {boolean} true if the rowKey was found, false otherwise
     */
    setCurrentRowKey: function(rowKey)
    {
      this._index = -1;
      while (this.hasNext())
      {
        this.next();
        if (this.getRowKey() == rowKey)
        {
          return true;
        }
      }

      return false;
    }
  };

  /**
   * Iterator object to use with TreeNodeIterator with hasNext and next methods
   * @constructor
   */
  function TreeNodeIteratorWrapper(items)
  {
    this._first = true;
    this._items = items;
    // cache available size of the iterator to avoid
    // multiple calculations
    // Iterator is not suppose to life longer than one iteration
    // so this is safe to do here since any data change
    // during the iteration will corrupt data anyway and it should
    // be avoided in a code that uses this iterator.
    this._availableCount = items.getCachedRowCount(0);
    this._totalCount = items.getTreeNodeBindings().keys.length;
  }

  TreeNodeIteratorWrapper.prototype =
  {
    /**
     * @return {TreeNode} representation of the next row in the collection
     */
    next: function()
    {
      if (this._first)
      {
        this._first = false;
        return this._items.localFirst();
      }

      return this._items.localNext();
    },

    /**
     * @return {Boolean} true if the next row is available in local collection
     */
    hasNext: function()
    {
      if (this._first)
      {
        return this._items.localFirst() !== undefined;
      }
      return this._items.getCurrentIndex() < this._availableCount - 1;
    },

    /**
     * @return {TreeNode} representation of the previous row in the collection or undefined
     *         if already at the beginning
     */
    previous: function()
    {
      return this._first ? undefined : this._items.localPrevious();
    },

    /**
     * @return {Boolean} true if the previous row is available in local collection
     */
    hasPrevious: function()
    {
      return this._first == false;
    },

    /**
     * @return {TreeNode} representation of the row on current index
     */
    getCurrent: function()
    {
      return this._items.getCurrentRow();
    },

    /**
     * @return {Integer} index of the current position in collection
     */
    getCurrentIndex: function()
    {
      return this._items.getCurrentIndex();
    },

    isTreeNodeIterator: function()
    {
      return true;
    },

    /**
     * @return true if there are more data to be loaded from the backend
     */
    isAllDataLoaded: function()
    {
      return this._items.getTreeNodeBindings().hasMoreKeys !== true;
    },

    /**
     * @return {Integer} number of all available items on the backend
     */
    getAvailableCount: function()
    {
      return this._availableCount;
    },

   /**
    * @return {Integer} total number of items in collection on backend
    */
    getTotalCount: function()
    {
      return this._totalCount;
    },

   /**
    * @return {String} rowKey of the current position in collection
    */
    getRowKey: function()
    {
      if (this._first)
      {
        return null;
      }

      return this._items.getCurrentKey();
    },

    /**
     * Sets the index to the value specified. Note that calling next will cause
     * the item after this index to be returned. Therefore, calling the function
     * with -1 will cause the next item to load to be the first item (index 0).
     */
    setCurrentIndex: function(index)
    {
      this._items.setCurrentIndex(index);
      this._first = index == -1;
    },

    /**
     * Sets the current item by the row key
     * @param {string} rowKey the row key
     * @return {boolean} true if the rowKey was found, false otherwise
     */
    setCurrentRowKey: function(rowKey)
    {
      this._first = false;
      return this._items.setCurrentRowKey(rowKey);
    }
  };

  /**
   * Create an iterator that will support either a JavaScript array of objects or iterator over a
   * tree node iterator (collection model).
   * @param {(Array|TreeNodeIterator)} the items to iterate over
   * @return {Object} iterator object with "next", "hasNext", and "isTreeNodeIterator" functions
   *                           where "next" will return undefined when no more objects are available.
   */
  adf.mf.api.amx.createIterator = function(items)
  {
    if (items != null && items[".type"] === "TreeNodeIterator")
    {
      return new TreeNodeIteratorWrapper(items);
    }
    else
    {
      return new ArrayIterator(items);
    }
  };

  /**
   * Convenient method to sequentialy resolve each item of an array. If the itemResolver method
   * returns a promise, it will wait until resolved before processing the next element.
   * If the itemResolver returns the direct value, it will to the next item.
   *
   * @param {(Array|TreeNodeIterator)} items is the array or the TreeNodeIterator to iterate threw
   * @param {function} itemResolver(item) function that will resolve the item. Can return the value
   *        or a promise that will resolve with the value
   * @return {Promise} promise that will resolve with the array of values returned by the item
   *         resolver
   */
  amx.serialResolve = function(items,itemResolver)
  {
    var _type = null;

    try
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST, "amx", "serialResolve",
          "items is of type: " + items.constructor.name + " or " + items[".type"]);
      }
      _type = items.constructor.name || items[".type"];
    }
    catch (te)
    {
      /* ignore */
    }

    if (_type === "TreeNodeIterator")
    {
      return amx.iteratorResolve(items, itemResolver);
    }
    else
    {
      var promiseResolve = null;
      var promiseReject = null;
      var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
        {
          promiseResolve = resolve;
          promiseReject = reject;
        });
      var results = [];
      var i = 0;

      function resolveAndNext()
      {
        if (i < items.length)
        {
          var item = items[i];
          var itemResolverResult = itemResolver(item, i);

          // if it is a promise (but not a jquery object, which is also a promise), then, pipe it
          if (typeof itemResolverResult !== "undefined" && itemResolverResult !== null &&
            adf.mf.internal.amx.implementsFunction(itemResolverResult, "then") &&
            !itemResolverResult.jquery)
          {
            itemResolverResult.then(
              function(result)
            {
              results.push(result);
              i += 1;
              resolveAndNext();
              },
              function(result)
            {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                "resolveAndNext", "MSG_SERIAL_RESOLVE_DEFERRED_REJECTED", i);
                promiseReject();
            });
          }
          else
          {
            // if it is a normal object or a jqueryObject, then, just push the value and move to the next
            results.push(itemResolverResult);
            i += 1;
            resolveAndNext();
          }
        }
        else
        {
          // once we run out
          promiseResolve(results);
        }
      }
      resolveAndNext();
      return promise;
    }
  };

  /**
   * Determine if parameter is a finite number
   * @param {Object} n is the object to check
   */
  adf.mf.internal.amx.isFiniteNumber = function (n)
  {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  /**
   * Iterates over items provided by elNodeIterator and executes itemResolver for each item.  The number of iterations can be
   * limited by providing maxIterations.  If the itemResolver method returns a promise, it will wait until resolved before processing the next element.
   * If the itemResolver returns the direct value, it will do the next item.
   * @param {TreeNodeIterator} elNodeIterator is the iterator to iterate over
   * @param {function} itemResolver(item) function that will resolve the item. Can return the value or a promise that will resolve with the value
   * @param {Object} maxIterations specifies the maximum number of iterations to perform
   */
  amx.iteratorResolve = function(elNodeIterator,itemResolver,maxIterations)
  {
    var promiseResolve = null;
    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        promiseResolve = resolve;
      });
    var results = [];
    var methodNext = "first";
    var rowCount = 0;
    var _maxIterations = Infinity;
    if (maxIterations)
    {
      _maxIterations = maxIterations;
    }

    function resolveNext()
    {
      if (elNodeIterator.hasNext() && rowCount < _maxIterations)
      {
        elNodeIterator[methodNext](
          function(a,b)
        {
          methodNext = "next";
          var item = b[0].value;

          //FIXME: for now, turn this off for debugging
          var itemResolverResult = itemResolver(item,elNodeIterator.getCurrentIndex());

          // if it is a promise (but not a jquery object, which is also a promise), then, pipe it
          if (typeof itemResolverResult !== "undefined" && itemResolverResult !== null &&
            adf.mf.internal.amx.implementsFunction(itemResolverResult, "promise") &&
            !itemResolverResult.jquery)
          {
            itemResolverResult.then(function(result)
            {
              results.push(result);
              ++rowCount;
              resolveNext();
            });
          }
          else
          {
            // If it is a normal object or a jqueryObject, then, just push the value and move to
            // the next
            results.push(itemResolverResult);
            ++rowCount;
            resolveNext();
          }
          },
          function(a,b)
          {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
              "resolveNext", "MSG_ITERATOR_FIRST_NEXT_ERROR");

            // Only log the exception at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx.iteratorResolve", "resolveNext", adf.mf.util.stringify(arguments));
            }
        });
      }
      else
      {
        promiseResolve(results);
      }
    }
    resolveNext();

    return promise;
  };

  /*TreeNodeIterator
k: id
k: treeNodeBindings
k: index
k: currentKey
k: createRow
k: first
k: getCurrentIndex
k: getCurrentKey
k: getCurrentRow
k: hasNext
k: hasPrevious
k: last
k: next
k: nextSet
k: previous
k: previousSet
k: refresh
k: setCurrentIndex
k: fetch
k: getKeys
k: removeCurrentRow
k: setCurrentRowWithKey
k: fetchSet
k: fetchProviderByKey
k: updateKeys
   */

  // ------ /Public API ------ //

  function initUI()
  {
    if (initPromise)
    {
      return initPromise;
    }
    else
    {
      initPromise = new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      // adf.mf.environment.profile.mockData=true for the DT as well as the RT test harness mode. The DT
      // requires that featureLevelIncludes.jso be in the feature root, NOT relative
      // to the directory of the AMX
      if (adf.mf.environment.profile.mockData)
      {
        adf.mf.api.resourceFile.loadJsonFile(
          adfc.Util.addFeatureRootPrefix("featureLevelIncludes.jso"),
          true,
          function(data)
          {
            loadIncludes(data);
                resolve();
          },
          function()
          {
            // do nothing, no config.
                resolve();
          });
      }
      else
      {
            container.internal.device.integration.getAmxIncludeList(
              function(includes)
        {
          loadIncludes(includes);
                resolve();
              },
              function(er)
        {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                  "initUI", "MSG_AMX_INCLUDE_FAILED");

                // Only log the exception at a fine level for security reasons
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "initUI", "container.internal.device.integration.getAmxIncludeList", er);
                resolve();
        });
      }
        });

      return initPromise;
    }
  }

  function loadIncludes(includes)
  {
    if (includes)
    {
      adf.mf.internal.amx._each(includes, function(idx, include)
      {
        var file = include.file;
        if (!amx.hasProtocol(file))
        {
          file = adfc.Util.addFeatureRootPrefix(include.file);
        }
        if (include.type == "StyleSheet")
        {
          amx.includeCss(file);
        }
        else if (include.type == "JavaScript")
        {
          amx.includeJs(file);
        }
      });
    }
  }

  function initData(amxPageName)
  {
    return mockInitData(amxPageName);
  }

  var initDataDone = false;

  function mockInitData(pagename)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    // if the data has not been initialized, and we are not in the Oracle Shell (ADFMobile undefined), then, we load the model.jso
    //TODO: need to add condition for :  typeof ADFMobile === "undefined" & and !forceInitDataMock
    if (!initDataDone && adf.mf.environment.profile.mockData)
    {
      // before we do anything, make sure all of the el gets set up by trying to retrieve the application scope
      // this will allow any data in model.jso that isn't bindings related to not get over-written
      adf.mf.el.getLocalValue("#{applicationScope}");
      pagename = pagename || "nopage";
      // adf.mf.environment.profile.mockData=true for the DT as well as the RT test harness mode. The DT
      // requires that model.jso be in the feature root, NOT relative
      // to the directory of the AMX
      adf.mf.api.resourceFile.loadJsonFile(
        adfc.Util.addFeatureRootPrefix("model.jso"),
        true,
        function(data)
        {
          if (data)
          {
            //model = data;
            //adf.mf.el.addVariable("bindings", data);
                adf.mf.internal.amx._each(data,
                  function(key,value)
            {
              adf.mf.el.addVariable(key, value);
            });

            adf.mf.el.addVariable("applicationScope", {});
            adf.mf.el.addVariable("pageFlowScope", {});
            initDataDone = true;
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "mockInitData-a",
                  "MSG_AMX_MODEL_JSO_LOADED");
                initContext(pagename, resolve);
          }
          else
          {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                  "mockInitData-b", "MSG_NO_MODEL_JSO_FOUND");
            adf.mf.environment.profile.mockData = false;
                initContext(pagename, resolve);
          }
        },
        function(error)
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                "mockInitData-c", "MSG_NO_MODEL_JSO_FOUND");

              // Only log the exception at a fine level for security reasons
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "mockInitData", "adf.mf.api.resourceFile.loadJsonFile", error);

              adf.mf.environment.profile.mockData = false;
              initContext(pagename, resolve);
        });
    }
    else
    {
          initContext(pagename, resolve);
    }
    });
  }

  var amxTransitionModeELExpression = adf.mf.internal.el.parser.parse ("#{applicationScope.configuration.amxTransitionMode}");

  function initContext(amxPageName, callback)
  {
    var promise = new adf.mf.internal.BasePromise(function (resolve, reject)
    {
      if (!adf.mf.environment.profile.mockData)
      {
        var perf = adf.mf.internal.perf.startMonitorCall("Initialize context for",
          adf.mf.log.level.FINER, "adf.mf.internal.amx:initContext", amxPageName);

        // Prime the EL values for the a variable that will be used in
        // adf.mf.internal.amx.isTransitionAfterRender:
        if (!adf.mf.environment.profile.mockData)
          amx.getElValue(amxTransitionModeELExpression, true);

        //
        //  Set the current context.
        //
        var newViewScope = adf.mf.internal.lastNavIsDifferentView;
        adf.mf.api.setCurrentContext(amxPageName, true, true, newViewScope, function ()
        {
          perf.stop();
          resolve();
        },
        function (ex)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "initContext",
            "MSG_SET_CONTEXT_FAILED", amxPageName);

          // Only log the exception at a fine level for security reasons
          adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
            "initContext", "adf.mf.api.setCurrentContext", ex);

          perf.stop();
          resolve();
        });
      }
      else
      {
        resolve();
      }
    });
    promise.then(function ()
    {
      callback();
    });
  }

  // pageStructAndDef data by pageName
  var amxPages = {};

  /**
   * Load a new instance of the amxPage JSON structure.
   * Returns a promise that will resolve with the amxPage JSON Structure. <br />
   *
   * @param {Object} uri the URI to the AMX page
   */
  function loadAmxPage(uri)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        resourcesDataPromise.then(
          function()
          {
            adf.mf.internal.amx._loadXmlFile(
              uri,
              true,
              function(data)
              {
                resolve(data);
              },
              function(e)
              {
                reject("Unable to load the XML file: " + uri, e);
              });
          });
      });
  }

  /**
   * Reloads the current AMX page UI.
   * It should only be invoked in MobileApplicationAcceleratorMode.
   * This function does not reload the feature or page,
   * nor it affects any of the bindings, scopes, etc.
   *
   * This is an internal API and it is used by MAX.
   *
   * @return {Promise}
   */
  adf.mf.internal.amx.softReloadCurrentAmxPage = function ()
  {
    var that = this;
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        adf.mf.api.finishAnyLoading().then(
          function ()
          {
            adf.mf.api.amx.showLoadingIndicator();

            adf.mf.internal.amx._queueCriticalSectionFunction(
              softReloadCurrentAmxPageImpl,
              that,
              true,
              {
                "resolve": resolve,
                "reject": reject
              });
          });
      });
  };

  function softReloadCurrentAmxPageImpl(promiseCallbacks)
  {
    var amxPage = amx.getCurrentPageName();

    // if current page path is null
    // or the environmentMode is not set to MobileApplicationAccelerator
    // hide the loading indicator and do nothing
    if (amxPage == null || !adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
    {
      adf.mf.api.amx.hideLoadingIndicator();
      promiseCallbacks["reject"]();
    }
    else
    {
      // NOTE: amx-popup is lazily loaded, so we must check for the existence
      // of the function before calling it
      if (adf.mf.internal.amx.closePopups)
      {
        adf.mf.internal.amx.closePopups();
      }

      // Before we strip off the IDs, call the destroy methods on any AMX nodes
      var current = document.querySelector("#bodyPageViews > .current");
      adf.mf.internal.amx.processDestroy(current);

      // Strip off any ID attributes on the page's elements.
      if (current != null)
      {
        adf.mf.internal.amx.stripIds(current);
      }

      // Purge any elements that might be disconnected from the bodyPage:
      adf.mf.internal.amx._purgeOnNav();

      // invoke displayAmxPage to reload the amxPage
      adf.mf.api.amx.displayAmxPage(amxPage).then(
        function(newPage)
        {
          current.classList.remove("current");
          current.classList.add("old");
          newPage.classList.remove("new");
          newPage.classList.add("current");
          adf.mf.internal.amx.processDestroy(current);
          adf.mf.api.amx.removeDomNode(current);
          adf.mf.api.amx.hideLoadingIndicator();
          promiseCallbacks["resolve"]();
        });

      // if debug mode...
      // Check for window event leaks
      adf.mf.internal.amx._checkForWindowsEventLeaks("softReloadCurrentAmxPage");
    }
  };

  /**
   * Removes all element IDs from the given subtree (root included).
   * @param {Element} root the root element of the subtree whose IDs are to be removed
   */
  adf.mf.internal.amx.stripIds = function(root)
  {
    // Strip off any ID attributes on the old page's elements. This will prevent any issues
    // with getElementById finding elements on the old page instead of the new page.
    var treeWalker =
     document.createTreeWalker(
       root,
       NodeFilter.SHOW_ELEMENT,
       function(node)
       {
         return (node.hasAttribute("id")) ?
           NodeFilter.FILTER_ACCEPT :
           NodeFilter.FILTER_SKIP;
       },
       false);

    while (treeWalker.nextNode())
    {
      treeWalker.currentNode.removeAttribute("id");
    }

    root.removeAttribute("id"); // remove it from the root too
  };

  var amxTagForPagePromiseMap = {};

  /**
   * Return a promise object (or cached tag) that will get resolved with the amxPage root tag.
   * This will first try to get it from the cache, or load it if needed.
   *
   * @param {Object} uri The URI of the page to load
   * @param {Boolean} getCacheInsteadOfPromise whether to get the cached tag or a promise
   * @return {Object} either a promise object or a possibly undefined adf.mf.api.amx.AmxTag
   */
  function getAmxTagForPage(uri, getCacheInsteadOfPromise)
  {
    // Note that we are caching the tag hierarchy per page. If there is ever a problem with the
    // retained AMX tag hierarchies taking up too much RAM, then we should remove the cache and
    // regenerate the tags from the XML each time.

    // Get the base URI to resolve the relative path
    var prefix = adfc.Util.addFeatureRootPrefix("/");
    var relUri = uri;
    if (relUri.substring(0, prefix.length) == prefix)
    {
      relUri = relUri.substring(prefix.length);
    }

    var amxPageTag = amxPages[relUri];
    if (getCacheInsteadOfPromise)
    {
      return amxPageTag;
    }

    var promise;

    if (amxPageTag)
    {
      promise = new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      if (amxPageTag instanceof adf.mf.api.amx.AmxTag)
      {
            resolve(amxPageTag);
      }
      else
      {
        // The tag is not actually a tag, but the error arguments stored in the map
            reject(amxPageTag);
      }
        });
    }
    else
    {
      promise = amxTagForPagePromiseMap[relUri];
      if (promise == null)
      {
        promise = new adf.mf.internal.BasePromise(
          function(resolve, reject)
          {
            loadAmxPage(uri).then(
            function(amxPageTag)
            {
              // do not cache if in MAX Mode
              if(!adf.mf.internal.amx.isMobileApplicationAcceleratorMode())
              {
                amxPages[relUri] = amxPageTag;
              }

                delete amxTagForPagePromiseMap[relUri];

                resolve(amxPageTag);
              },
              function(msgAndE)
            {
                var msg = msgAndE[0];
                var e = msgAndE[1];
              amxPages[relUri] = [ msg, e ];
                delete amxTagForPagePromiseMap[relUri];

                // forward the failure argument to the promise
              var args = Array.prototype.slice.call(arguments);
                reject.apply(null, args);
            });
          });
        amxTagForPagePromiseMap[relUri] = promise;
      }
    }

    return promise;
  }

  // Expose for use by the amx:fragment
  adf.mf.internal.amx.__getAmxTagForPage = getAmxTagForPage;

  /**
   * Get the AmxNode root node for the currently loaded page.
   *
   * @return {(adf.mf.api.amx.AmxNode|null)} the amx node or null if the
   *         page is not loaded.
   */
  adf.mf.api.amx.getPageRootNode = function()
  {
    return amxPageRootNode;
  };

  /**
   * Object used by the functions in markNodeForUpdate to pass the state
   * of the changes between the functions.
   * @constructor
   * @private
   */
  function AmxNodeChangesResults()
  {
    this._affectedNodeIds = {};
    this._affectedNodes = [];

    this._nodesToRecreate = [];

    this._descendentChanges = {};
    this._ancestorNodes = [];

    this._attributeChanges = {};

    this._changeResult = {};

    this._initialStates = {};

    this._hasChanges = false;
  }

  AmxNodeChangesResults.prototype =
  {
    /**
     * Get if there are changes to any nodes
     * @return {Boolean} true if any nodes were updated
     */
    hasChanges: function()
    {
      return this._hasChanges;
    },

    /**
     * Get the array of AMX nodes that have been changed and need to
     * be visited during the application of render changes.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes to visit
     */
    getAffectedNodes: function()
    {
      return this._affectedNodes;
    },

    /**
     * Get the result of the updateChildren function for an affected AMX node.
     * @param {number} amxNodeId the ID of the AMX node
     * @return {(number|null)} the result or null. One of the adf.mf.api.amx.AmxNodeChangeResult
     *         constants
     */
    getChangeResult: function(amxNodeId)
    {
      return this._changeResult[amxNodeId];
    },

    /**
     * Get the change result for a given AMX node ID
     * @param {number} amxNodeId the ID of the AMX node
     * @return {(adf.mf.api.amx.AmxAttributeChange|null)} the attribute change object or null
     *         if the node was not affected
     */
    getAttributeChanges: function(amxNodeId)
    {
      return this._attributeChanges[amxNodeId];
    },

    /**
     * Get the AMX nodes that need to be re-created
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes to re-create
     */
    getAmxNodesToRecreate: function()
    {
      return this._nodesToRecreate;
    },

    /**
     * Get the AMX nodes that have been queued to see if they can handle changes to descendents
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX ancestor nodes
     */
    getAmxNodesForDescendentChanges: function()
    {
      return this._ancestorNodes;
    },

    /**
     * Get the AMX descedent changes for a given ancestor AMX node ID
     * @param {number} amxNodeId the ID of the ancestor AMX node
     * @return {(adf.mf.api.amx.AmxDescendentChanges|null)} the changes object or null if the node
     *         has no descendent changes.
     */
    getDescendentChanges: function(amxNodeId)
    {
      return this._descendentChanges[amxNodeId];
    },

    /**
     * Notifies this object that a node has been recreated
     * @param {adf.mf.api.amx.AmxNode} oldAmxNode node that was re-created
     * @param {adf.mf.api.amx.AmxNode} newAmxNode re-created node
     */
    amxNodeRecreated: function(oldAmxNode, newAmxNode)
    {
      var index = this._affectedNodes.indexOf(oldAmxNode);
      if (index != -1)
      {
        this._affectedNodes[index] = newAmxNode;
      }

      var wasRendered = oldAmxNode.isRendered();

      if (wasRendered)
      {
        // If the node was rendered, and still is, we will just swap the root DOM
        // in place
        var id = newAmxNode.getId();
        if (newAmxNode.isReadyToRender())
        {
          this._changeResult[id] = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
        }
        else
        {
          // Otherwise we need to mark the parent to be re-rendered
          var initialState = this._initialStates[id];
          var attributeChanges = this._attributeChanges[id];
          var renderedAmxNode = newAmxNode.__getClosestRenderedNode(true);

          this._markNodeAffected(renderedAmxNode);
          this._queueCallToAncestor(newAmxNode, initialState, attributeChanges, renderedAmxNode);
        }
      }
    },

    /**
     * Called after calling the ancestor nodes getDescendentChangeAction function to see how
     * a change should be handled.
     * @param {adf.mf.api.amx.AmxNode} amxNode the ancestor AMX node.
     * @param {number} descendentChangeResult the value returned from getDescendentChangeAction
     */
    setDescendentChangesResult: function(
      amxNode,
      descendentChangeResult)
    {
      var amxNodeId = amxNode.getId();
      var currentResult = this._changeResult[amxNodeId];

      // If the node is not already marked for another change or if the
      // descendent changes require a more invasive change, then store the result
      // from asking about the descendent refresh changes
      if (currentResult == null || descendentChangeResult > currentResult)
      {
        this._changeResult[amxNodeId] = descendentChangeResult;

        if (descendentChangeResult != adf.mf.api.amx.AmxNodeChangeResult["NONE"])
        {
          this._markNodeAffected(amxNode);
        }
      }
    },

    /**
     * During the application of changes, adds a change result to this object.
     * @param {adf.mf.api.amx.AmxNode} amxNode the affected AMX node
     * @param {number} initialState one of the AMX node state constants representing the node
     *        state before the attributes and children were updated
     * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the attribute changes
     *        object for the AMX node
     * @param {number} changeResult the change result returned from updateChildren
     */
    addChangeResult: function(
      amxNode,
      initialState,
      attributeChanges,
      changeResult)
    {
      // Get the closest ancestor rendered AMX node
      var renderedAmxNode = amxNode.__getClosestRenderedNode(true);

      var id = amxNode.getId();

      this._initialStates[id] = initialState;
      this._attributeChanges[id] = attributeChanges;

      this._hasChanges = true;

      // See if this is a recreate result
      if (changeResult == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"])
      {
        this._nodesToRecreate.push(amxNode);
      }

      if (renderedAmxNode == null)
      {
        // The rendered AMX node will be null if the page has not rendered yet, in that case
        // the change result does not matter
        return;
      }

      // Mark the rendered AMX node as one to visit later if the change result is not NONE
      if (changeResult != adf.mf.api.amx.AmxNodeChangeResult["NONE"])
      {
        this._markNodeAffected(renderedAmxNode);
      }

      if (renderedAmxNode === amxNode)
      {
        // Honor the change result if the affected node is currently rendered
        this._changeResult[id] = changeResult;
      }
      else
      {
        // Allow the rendered ancestor to be notified of the change
        this._queueCallToAncestor(amxNode, initialState, attributeChanges, renderedAmxNode);
      }
    },

    _markNodeAffected: function(amxNode)
    {
      var id = amxNode.getId();
      if (this._affectedNodeIds[id] !== true)
      {
        this._affectedNodeIds[id] = true;
        this._affectedNodes.push(amxNode);
      }
    },

    _queueCallToAncestor: function(
      amxNode,
      initialState,
      attributeChanges,
      renderedAmxNode)
    {
      var renderedId = renderedAmxNode.getId();

      // If the rendered AMX node is not the changed AMX node, then we need
      // to ask the rendered node if it wishes to perform a refresh instead
      // of being rerendered
      var changes = this._descendentChanges[renderedId];

      // See if this parent has already been added as one to be called
      if (changes == null)
      {
        // Create a new changes object to be used later
        changes = new adf.mf.api.amx.AmxDescendentChanges();
        this._descendentChanges[renderedId] = changes;
        this._ancestorNodes.push(renderedAmxNode);
      }

      // Add the child's attribute changes and other state to the changes object
      // so that the parent can decide if it can refresh based on the results
      changes.__addAmxNode(
        amxNode,
        initialState,
        attributeChanges);

      // Note that we do not actually call the parent at this point, that is done
      // in a later pass
    }
  };

  /**
   * Called by markNodeForUpdate to update the attributes and initialize any new nodes created
   * as a result.
   * @param {adf.mf.api.amx.AmxNode} rootNode the root AMX node of the page
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} args the information passed to the
   *        mark node for update function
   * @private
   */
  function applyUpdatesToAmxNodeHierarchy(
    rootNode,
    args)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    var affectedAmxNodes = args.getAffectedNodes();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": affectedAmxNodes });
    var changes = new AmxNodeChangesResults();

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var nodeId = amxNode.getId();
        var affectedAttributes = args.getAffectedAttributes(nodeId);

        // Get the attributes that have changed for this node
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
            "Found node to apply updates. ID: " + nodeId);
        }

        var nodeWasRendered = amxNode.isRendered();

        var initialState = amxNode.getState();

        // Notify the node of the changed attributes
        var collectionChanges = args.getCollectionChanges(nodeId);
        var attributeChanges = amxNode.updateAttributes(affectedAttributes, collectionChanges);

        // Notify the tag instances
        amxNode.__updateTagInstanceAttributes(args);

        // See if the AMX node's converter was affected
        amxNode.__processConverterChanges(args, attributeChanges);

        var state = amxNode.getState();
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
            "Node attributes have been applied. New node state: " +
            adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
        }

        if (state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
        {
          // Allow the rendered ancestor node to be notified of the change
          changes.addChangeResult(amxNode, initialState, attributeChanges,
            adf.mf.api.amx.AmxNodeChangeResult[nodeWasRendered ? "RERENDER" : "NONE"]);

          // Do not attempt to apply changes to nodes if a parent is not rendered.
          // The node should have removed all the children at this point, so this
          // function does not need to perform that logic.
          return adf.mf.api.amx.VisitResult["REJECT"];
        }

        var skipBuild;
        var changeResult;

        // Do not create or update the children of nodes in the initial state
        if (state != adf.mf.api.amx.AmxNodeStates["INITIAL"])
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "Updating the children of the node");
          }

          // Update the children of the node only if the node is not in the
          // initial state. If it is, then the _buildVisitCallback below
          // will initialize the children
          changeResult = amxNode.updateChildren(attributeChanges);

          // Pick up any changes to the node's state as a result of the updateChildren
          // call.
          state = amxNode.getState();

          // Skip the initialization of the node and descendents if the updateChildren
          // call has caused the state of the node to go back to the initial state.
          // This means that the node's type handler changed the state back to initial
          // as a result of not being able to successfully create its children.
          skipBuild = (state == adf.mf.api.amx.AmxNodeStates["INITIAL"]);

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "New node state: " +
              adf.mf.api.amx.AmxNodeStates.getLabelForValue(state) +
              ". Should the build visit callback be skipped: " + skipBuild +
              ". Update children method returned: " +
              adf.mf.api.amx.AmxNodeChangeResult.getLabelForValue(changeResult));
          }
        }
        else
        {
          changeResult = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
          skipBuild = false;
        }

        // Record the change result
        changes.addChangeResult(amxNode, initialState, attributeChanges, changeResult);

        // See if the node has requested to be recreated
        var resultIsRecreate = changeResult == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"];
        if (resultIsRecreate)
        {
          skipBuild = true;
        }

        // Process the children tree under the node to initialize any newly
        // created nodes (does nothing if they are all already rendered or in the
        // unrendered state) as long as the node was able to create its children.
        if (skipBuild == false)
        {
          // Pass in the affected nodes into the visit context. This will allow
          // the _buildVisitCallback to skip any descendent nodes (they will be visited
          // later when they are updated). This improves performance by not visiting
          // the same nodes more than once.
          var contextData = {
            "affectedAmxNodes": affectedAmxNodes,
            "targetNode": amxNode
          };

          amxNode.visit(
            new adf.mf.api.amx.VisitContext({ "data": contextData }),
            adf.mf.internal.amx._buildVisitCallback);

          // Pick up any changes to the state as a result of initialization
          state = amxNode.getState();

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "applyUpdatesToAmxNodeHierarchy",
              "Node state after invoking the build visit callback: " +
              adf.mf.api.amx.AmxNodeStates.getLabelForValue(state));
          }
        }

        // Do not progress down the hierarchies of nodes that are in the initial state,
        // or are not rendered or if the change result is to replace (recreate) the node
        if (resultIsRecreate ||
          state == adf.mf.api.amx.AmxNodeStates["INITIAL"] ||
          state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
        {
          return adf.mf.api.amx.VisitResult["REJECT"];
        }
        else
        {
          return adf.mf.api.amx.VisitResult["ACCEPT"];
        }
      });

    return changes;
  }

  /**
   * Called by markNodeForUpdate to recreate any AMX nodes and their descendants.
   * @private
   */
  function recreateRequestedAmxNodes(
    rootNode,
    changeResults)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

    // For each node, we actually only want the parent node in context. Therefore, go through the
    // array and collect all of the parent nodes.
    var childNodesByParentId = {};
    var affectedNodeParents = [];
    var amxNode;
    var parentId;

    var amxNodes = changeResults.getAmxNodesToRecreate();

    for (var i = 0, size = amxNodes.length; i < size; ++i)
    {
      amxNode = amxNodes[i];
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "recreateRequestedAmxNodes",
          "Will attempt to recreate node with ID " + amxNode.getId());
      }

      var parent = amxNode.getParent();
      parentId = parent.getId();
      var children = childNodesByParentId[parentId];
      if (children == null)
      {
        children = [ amxNode ];
        childNodesByParentId[parentId] = children;
        affectedNodeParents.push(parent);
      }
      else
      {
        children.push(amxNode);
      }
    }

    // Now visit each parent
    rootNode.visit(
      new adf.mf.api.amx.VisitContext({ "amxNodes": affectedNodeParents }),
      function(
        visitContext,
        parentAmxNode)
      {
        var parentId = parentAmxNode.getId();
        var children = childNodesByParentId[parentId];
        var recreatedNodes = [];
        var i, size;

        // Loop through each child node that has changes
        for (i = 0, size = children.length; i < size; ++i)
        {
          var amxNode = children[i];
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "recreateRequestedAmxNodes",
              "Re-creating node " + amxNode.getId());
          }

          var tag = amxNode.getTag();
          var stampKey = amxNode.getStampKey();
          var newAmxNode = tag.buildAmxNode(parentAmxNode, stampKey);

          // Replace the child
          if (parentAmxNode.replaceChild(amxNode, newAmxNode))
          {
            // Push the nodes onto an array to process after initialization
            recreatedNodes.push([ amxNode, newAmxNode ]);
          }
          else
          {
            // TODO: log warning
          }
        }

        // Initialize the new nodes and create their children by visiting
        // the parent so that the parent is put into context
        parentAmxNode.visit(
          new adf.mf.api.amx.VisitContext(),
          adf.mf.internal.amx._buildVisitCallback);

        // Notify the change results of the new children (has to be done after node initialization)
        for (i = 0, size = recreatedNodes.length; i < size; ++i)
        {
          var arr = recreatedNodes[i];
          // Replace the node in the change results object
          changeResults.amxNodeRecreated(arr[0], arr[1]);
        }

        // Return accept since we are visiting the parent of the node to replace and not the node
        // itself.
        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  /**
   * Called by markNodeForUpdate to see if ancestor AMX nodes wish to handle changes to non-rendered
   * descendent AMX nodes.
   * @private
   */
  function processDescendentChanges(
    rootNode,
    changeResults)
  {
    var amxNodes = changeResults.getAmxNodesForDescendentChanges();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": amxNodes });

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var id = amxNode.getId();
        var descendentChanges = changeResults.getDescendentChanges(id);
        var descendentChangeAction = amxNode.__getDescendentChangeAction(descendentChanges);

        // We do not support a value of REPLACE for child refresh changes
        if (descendentChangeAction == adf.mf.api.amx.AmxNodeChangeResult["REPLACE"])
        {
          // TODO: log error
          descendentChangeAction = adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
        }

        changeResults.setDescendentChangesResult(amxNode, descendentChangeAction);

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  /**
   * Called by markNodeForUpdate to re-render any nodes and invoke and refresh methods
   * as appropriate.
   * @private
   */
  function applyRenderChanges(
    rootNode,
    changeResults)
  {
    var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
    var affectedNodes = changeResults.getAffectedNodes();
    var visitContext = new adf.mf.api.amx.VisitContext({ "amxNodes": affectedNodes });

    var perf = adf.mf.internal.perf.startMonitorCall("Apply render changes", adf.mf.log.level.FINER, "adf.mf.internal.amx:applyRenderChanges");
    // set flag to prevent independent processing of the init and postDisplay queues
    // only wait if there is some rerender event which enqueues the rendered node into
    // the processing queue and process these queues after the whole refresh is complete
    amx.mustProcessQueues = false;

    rootNode.visit(
      visitContext,
      function (
        visitContext,
        amxNode)
      {
        var id = amxNode.getId();
        var changeResult = changeResults.getChangeResult(id);

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyRenderChanges",
            "Found node to apply render changes. ID: " + id +
            ". Change result: " +
            adf.mf.api.amx.AmxNodeChangeResult.getLabelForValue(changeResult));
        }

        switch (changeResult)
        {
          case adf.mf.api.amx.AmxNodeChangeResult["REFRESH"]:
            var attributeChanges = changeResults.getAttributeChanges(id);
            var descendentChanges = changeResults.getDescendentChanges(id);

            // Don't pass null as the attribute changes, but instead pass an empty object
            // so that it is easier to work with
            if (attributeChanges == null)
            {
              attributeChanges = new adf.mf.api.amx.AmxAttributeChange();
            }

            amxNode.refresh(attributeChanges, descendentChanges);
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "applyRenderChanges",
                "Completed the refresh of node " + id);
            }
            break;

          case adf.mf.api.amx.AmxNodeChangeResult["RERENDER"]:
            amxNode.rerender();
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "applyRenderChanges",
                "Completed the re-render of node " + id);
            }

            // Do not perform operations on the children
            return adf.mf.api.amx.VisitResult["REJECT"];
        }

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "applyRenderChanges",
            "Completed the processing of the changes for node " + id);
        }

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });

      // now process the queues at once to init and postDisplay
      // all newly rendered nodes
      amx.processAndCleanInitQueue();
      amx.processAndCleanPostDisplayQueue();
      // set flag that the single rerender function call on the amxNode should also invoke
      // processing of the init and postDisplay queues
      amx.mustProcessQueues = true;

    perf.stop();
  }

  /**
   * @deprecated
   */
  adf.mf.internal.amx.markNodeForUpdate = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "markNodeForUpdate", "MSG_DEPRECATED", "adf.mf.internal.amx.markNodeForUpdate",
      "adf.mf.api.amx.markNodeForUpdate");
    return adf.mf.api.amx.markNodeForUpdate.apply(this, arguments);
  };

  /**
   * Function for TypeHandlers to notify the framework of a state change to an AmxNode that requires the
   * AmxNode hierarchy to be updated at that node and below. If a custom createChildrenNodes method
   * exists on the TypeHandlers, it will be called again for these AmxNode. This will allow AmxNode that
   * stamp their children to add new stamps due to a user change.
   * The refresh method will be called on the AmxNode with the provided properties if the AmxNode is
   * ready to render. If the AmxNode is not ready to render, the framework will wait for any EL to be
   * resolved and the refresh method will be called once all the data is available.
   * @param {adf.mf.api.amx.AmxNodeUpdateArguments} args the change arguments
   */
  adf.mf.api.amx.markNodeForUpdate = function(args)
  {
    // See if the function was called with the deprecated API
    if (!(args instanceof adf.mf.internal.amx.AmxNodeUpdateArguments))
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.amx.markNodeForUpdate", "MSG_DEPRECATED",
        "Passing nodes and objects as arguments",
        "Pass one adf.mf.api.amx.AmxNodeUpdateArguments object");

      // Use a temporary variable until we are done reading from arguments
      var convertedArgs = new adf.mf.internal.amx.AmxNodeUpdateArguments();

      for (var arg = 0, argc = arguments.length; arg < argc; arg += 2)
      {
        amxNode = arguments[arg];
        affectedAttributes = arguments[arg + 1];

        for (var attrName in affectedAttributes)
        {
          convertedArgs.setAffectedAttribute(amxNode, attrName);
        }
      }

      // Now update the args variable
      args = convertedArgs;
    }

    adf.mf.internal.amx._queueCriticalSectionFunction(
      adf.mf.internal.amx._markNodeForUpdateImpl,
      this,
      true,
      args);
  };

  adf.mf.internal.amx._markNodeForUpdateImpl = function(
    args)
  {
    // Check if the update has been canceled since it was queued
    if (args.isCanceled())
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx._markNodeForUpdateImpl", "Canceled",
          "The node update has been canceled");
      }

      return;
    }

    // Begin tracking EL cache misses in a batch (only if not in the mock data environment)
    if (!adf.mf.environment.profile.mockData)
    {
      adf.mf.el.startGetValueBatchRequest();
    }

    var perfOp = adf.mf.internal.perf.startMonitorOperation("Mark node for update", adf.mf.log.level.FINE,
      "adf.mf.api.amx.markNodeForUpdate");

    var rootNode = adf.mf.api.amx.getPageRootNode();
    try
    {
      // First, ensure the nodes are sorted
      var amxNodes = args.getAffectedNodes();
      if (amxNodes.length > 1)
      {
        adf.mf.api.amx.AmxNode.__sortNodesByDepth(amxNodes);
      }

      // Make a first pass at the nodes. In this pass we are only applying attribute
      // changes and initializing the AMX node hierarchy, no rendering should be done
      // at this point.
      var changeResults = applyUpdatesToAmxNodeHierarchy(rootNode, args);

      // See if any nodes are marked to be re-created
      if (changeResults.getAmxNodesToRecreate().length > 0)
      {
        // Make a second pass to recreate any AMX nodes marked for recreation by
        // the type handler
        recreateRequestedAmxNodes(rootNode, changeResults);

        amxNodes = changeResults.getAffectedNodes();
        // Ensure the nodes are still in the correct hierarchical order
        if (amxNodes.length > 1)
        {
          adf.mf.api.amx.AmxNode.__sortNodesByDepth(amxNodes);
        }
      }

      // Now process any ancestor nodes that are re-rendered to handle changes
      // to descendent AMX nodes
      processDescendentChanges(
        rootNode,
        changeResults);

      var pageBuildPromiseResolve = adf.mf.internal.amx._pageBuildPromiseResolve;

      if (pageBuildPromiseResolve == null)
      {
        // Only perform re-rendering if the page has been rendered
        applyRenderChanges(
          rootNode,
          changeResults);
      }
      // If the page has not yet been rendered and nodes were affected, then go ahead and resolve
      // the page build promise so the render may take place once the update has completed
      else if (changeResults.hasChanges())
      {
        adf.mf.internal.amx._pageBuildPromiseResolve = null;
        pageBuildPromiseResolve(rootNode);
      }
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }
    finally
    {
      try
      {
        // Flush the batch so that any missed EL are sent for loading
        if (!adf.mf.environment.profile.mockData)
        {
          adf.mf.el.flushGetValueBatchRequest();
        }
      }
      catch(e)
      {
        adf.mf.internal.amx.errorHandlerImpl(null, e);
      }

      perfOp.stop();

      adf.mf.internal.amx._pageBusyTracker.checkComplete();
    }
  };

  var amxPageRootNode = null;
  adf.mf.internal.amx._buildVisitCallback = function (
    visitContext,
    node)
  {
    var state = node.getState();
    var contextData = visitContext.data;
    if (contextData != null)
    {
      var targetAmxNode = contextData["targetNode"];
      if (targetAmxNode != node)
      {
        // Now see if the node being visited is actually a descendant that
        // will be visited later by another change.
        var affectedAmxNodes = contextData["affectedAmxNodes"];
        if (affectedAmxNodes.indexOf(node) >= 0)
        {
          // No need to visit this node now
          return adf.mf.api.amx.VisitResult["REJECT"];
        }
      }
    }

    if (state == adf.mf.api.amx.AmxNodeStates["UNRENDERED"])
    {
      // If the node is unrendered, nothing more needs to be done
      return adf.mf.api.amx.VisitResult["REJECT"];
    }

    if (state != adf.mf.api.amx.AmxNodeStates["INITIAL"])
    {
      // Only initialize nodes in the initial state. All other states
      // are updated by the data change framework
      return adf.mf.api.amx.VisitResult["ACCEPT"];
    }

    // Initialize the node. This will populate the attributes,
    // both static and EL driven and also create the children
    node.init();

    // Check to see the new state of the node
    switch (node.getState())
    {
      case adf.mf.api.amx.AmxNodeStates["INITIAL"]:
        // Store on the context that a cache miss occurred:
        visitContext._allNodesReadyToRender = false;

        // Do not process the children of a node in the initial state:
        return adf.mf.api.amx.VisitResult["REJECT"];

      case adf.mf.api.amx.AmxNodeStates["UNRENDERED"]:
        // Do not process the children of unrendered nodes:
        return adf.mf.api.amx.VisitResult["REJECT"];

      case adf.mf.api.amx.AmxNodeStates["WAITING_ON_EL_EVALUATION"]:
        // Store on the context that a cache miss occurred:
        visitContext._allNodesReadyToRender = false;

        // Process the children (type handlers must set the node's state
        // to initial to stop children creation and processing):
        return adf.mf.api.amx.VisitResult["ACCEPT"];

      default:
        return adf.mf.api.amx.VisitResult["ACCEPT"];
    }
  };

  adf.mf.internal.amx._pageBuildPromiseResolve = null;
  /**
   * Builds the AMX node hierarchy.
   *
   * @private
   * @param {string} amxPageName the name of the page that is being loaded.
   * @param {adf.mf.api.amx.AmxTag} rootTag the root AMX tag of the page
   * @return {Object} promise object resolved with the root AMX node once the page
   *         is ready to render.
   */
  function buildAmxNodeTree(
    amxPageName,
    rootTag)
  {
    var promise = new adf.mf.internal.BasePromise(function(resolve, reject)
      {
    var visitContext = null;

    var perf = adf.mf.internal.perf.startMonitorCall("Build AMX node tree", adf.mf.log.level.FINER, "adf.mf.internal.amx:buildAmxNodeTree");
    try
    {
          // Store off the promise object so that we can use it during the first data
      // change event
          adf.mf.internal.amx._pageBuildPromiseResolve = resolve;

      visitContext = new adf.mf.api.amx.VisitContext();
      visitContext._allNodesReadyToRender = true;

      if (amxPageName == null)
      {
        var viewHistory = adf.mf.internal.controller.ViewHistory.peek();
        amxPageName = viewHistory["amxPage"];
      }

      if (rootTag == null)
      {
        rootTag = amxPages[amxPageName];
      }

      amxPageRootNode = rootTag.buildAmxNode(null, null);

      if (!adf.mf.environment.profile.mockData)
      {
        adf.mf.el.startGetValueBatchRequest(); // prevent chatty getValue calls

        // we want to make sure we always are updated with the current values for
        // availableHeight and availableWidth, so we attempt to retrieve the values
        // here and then we can just call getLocalValue in any place afterwards
        adf.mf.internal.amx.evaluateExpression("#{deviceScope.hardware.screen.availableHeight}");
        adf.mf.internal.amx.evaluateExpression("#{deviceScope.hardware.screen.availableWidth}");
      }
      amxPageRootNode.visit(
        visitContext,
        adf.mf.internal.amx._buildVisitCallback);
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }
    finally
    {
      perf.stop();
    }

    try
    {
      if (!adf.mf.environment.profile.mockData)
      {
        adf.mf.el.flushGetValueBatchRequest(); // done preventing chatty getValue calls
      }
    }
    catch(e)
    {
      adf.mf.internal.amx.errorHandlerImpl(null, e);
    }

    if (visitContext._allNodesReadyToRender)
    {
      // If there were no cache misses, then do not wait for a data change event
      // and render immediately
          adf.mf.internal.amx._pageBuildPromiseResolve = null;
          resolve(amxPageRootNode);
    }

        // Do not resolve the promise if the node tree has not yet been rendered.
    // We will wait for the first data change event that delivers the first batch
    // of EL values to the cache to render the page.
      },
      true /* needed for jQuery-like callbacks without timeouts */);

    return promise;
  }

  function debugPrintAmxTagTree(tag, prefix)
  {
    if (prefix == null)
    {
      prefix = "";
    }

    var str = prefix + "<" + tag._prefixedName;
    var attr = tag.getAttributes();
    for (var name in attr)
    {
      str += " " + name + "=\"" + attr[name] + "\"";
    }

    var children = tag.getChildren();
    if (children.length == 0)
    {
      str += "/>";
      console.log(str);
      return;
    }

    str += ">";
    console.log(str);
    for (var i = 0, size = children.length; i < size; ++i)
    {
      var childTag = children[i];
      debugPrintAmxTagTree(childTag, prefix + "  ");
    }

    console.log(prefix + "</" + tag._prefixedName + ">");
  }

  function debugPrintAmxNodeTree(rootNode)
  {
    rootNode.visit(
      new adf.mf.api.amx.VisitContext(),
      function(
        visitContext,
        node)
      {
        var prefix = "";
        for (var p = node.getParent(); p != null; p = p.getParent())
        {
          prefix += "  ";
        }
        var str = "AmxNode(" + node.getId() +"): ";
        var attrNames = node.getDefinedAttributeNames();
        for (var i in attrNames)
        {
          str += (attrNames[i] + ":" + node.getAttribute(attrNames[i])) + " ";
        }
        console.log(prefix + str);

        return adf.mf.api.amx.VisitResult["ACCEPT"];
      });
  }

  // --------- Rendering Logic --------- //
  /**
   * Singleton object for maintaining a stack of prefixes for IDs on HTML elements inside of
   * iterating AMX nodes.
   */
  var iterationIdStack =
  {
    _prefix: "",
    _lengthStack: [],
    // Valid ID characters are everything that NMTOKEN allows from XML minus ":" since we are using
    // colons as separators. See http://www.w3.org/TR/2000/WD-xml-2e-20000814#NT-Nmtoken
    // For now just check a sub-set of NMTOKEN as the list is quite lengthy of allowed unicode
    // characters.
    _invalidCharsRe: /[^\w\.\-]/g,

    /**
     * Get the current prefix.
     * @return {String} a non-null string to use as a prefix for node IDs
     */
    getCurrentPrefix: function()
    {
      return this._prefix;
    },

    /**
     * Push an iterator prefix onto the stack.
     * @param {string} baseId the ID of the iterating AMX node to use as the base of the ID prefix
     *                 for the iterator's children nodes.
     * @param {Object} iterationKey the object to convert to a string to uniquely identify items
     *                 in the iterator.
     */
    pushIterator: function(baseId, iterationKey)
    {
      // Save off the old prefix length so that we know the length to truncate to during the
      // pop call.
      var oldLength = this._prefix.length;
      this._lengthStack.push(oldLength);

      // Create the new prefix
      var newPrefix = baseId + ":" + this._escapeIterationKey(iterationKey);

      this._prefix += newPrefix + ":";
    },

    /**
     * Pop the prefix back to the value before the current iteration.
     */
    popIterator: function()
    {
      var newLength = this._lengthStack.pop();
      if (newLength > 0)
      {
        this._prefix = this._prefix.substr(0, newLength);
      }
      else
      {
        this._prefix = "";
      }
    },

    /**
     * Escape an iteration key for usage in an HTML ID attribute.
     * @param {Object} iterationKey the key for the current iteration
     * @return {string} an ID-safe string that may be used to identify the current iteration
     * @private
     */
    _escapeIterationKey: function(iterationKey)
    {
      // Note that we may want to consider using an ID token cache to improve memory usage
      // so that smaller strings are used. The disadvantage is that the token generation would
      // have to be repeatable so that the node state would be correctly re-applied. For now,
      // we just wish to ensure there are no invalid characters
      if (iterationKey == null)
      {
        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "_escapeIterationKey",
          "MSG_INVALID_ITERATION_KEY");

        // Only log the details at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "iterationIdStack", "_escapeIterationKey", iterationKey);

        return "null";
      }
      var strVal = iterationKey.toString();
      // Replace any non-ID friendly values with a sequence of characters unlikely to appear in the
      // value. This assumes that most characters
      // of the iterationKey will be valid and therefore produce a unique key. Using a token
      // cache would address this if this assumption becomes an issue.
      return strVal.replace(this._invalidCharsRe, "._.");
    },

    /**
     * Determine if there is an iteration container.  Searches the prefix for ":" and returns true
     * if the character is found.
     * @return {Boolean} true if an iteration container has been set; false otherwise.
     */
    hasTopIterationContainer: function()
    {
      if (this._prefix.indexOf(":") > -1)
      {
        return true;
      }
      return false;
    },

    /**
     * Returns ID of top-most iteration container.  Finds first occurence of ":" in prefix and returns
     * substring leading up to it.
     * @return {String} ID of top-most iteration container
     */
    getTopIterationContainer: function()
    {
      if (this._prefix.indexOf(":") > -1)
      {
        return this._prefix.substr(0,this._prefix.indexOf(":"));
      }
      return "";
    }
  };

  // ------ resource loading ------ //
  var resourcesData = null;
  // Load the resources.json file that contains the mapping of the resources
  // needed for AMX nodes:
  var resourcesDataPromise = new adf.mf.internal.BasePromise(function(resolve, reject)
    {
      adf.mf.api.resourceFile.loadJsonFile(
        adf.wwwPath + "js/amx-resources.json",
        true,
        function(data)
        {
          resourcesData = data;
          resolve();
        },
        function()
        {
          // TODO this needs to be promoted to a formal error; do not use amx.log
          amx.log.error("Unable to load the resources JSON file.");
          reject();
        });
    });

  /**
   * Internal function for loading the JS files from the profile in series.
   * @param {Array.<string>} listOfFiles the list of files to load
   * @return {adf.mf.internal.BasePromise} a promise that will resolve when all Files are loaded
   */
  var loadFilesSequentialPromise = function(listOfFiles)
  {
    var promise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        // Load the JS resources serially since the order is required due to dependencies:
        if (listOfFiles == null)
        {
          resolve(); // no JS files to load
        }
        else // load all of the files
        {
          _resourceLoadNextResource(resolve, listOfFiles, 0, listOfFiles.length);
        }
      });
    return promise;
  };

  var _resourceLoadNextResource = function(entrireListLoadedResolve, listOfFiles, listIndex, fileCount)
  {
    if (listIndex == fileCount)
    {
      // All jsResource files have been loaded
      entrireListLoadedResolve();
    }
    else // load the next file in the list
    {
      var theResource = listOfFiles[listIndex];
      var nextIndex = listIndex+1;
      var loadState = loadedJavaScriptResources[theResource];
      if (loadState == null) // possibilities are null, a promise, or true
      {
        // No attempt has been made yet to load this file:
        var loadedArrayResolve = null;
        var loadedArrayReject = null;
        loadedJavaScriptResources[theResource] =
          new adf.mf.internal.BasePromise(function(resolve, reject)
            {
              loadedArrayResolve = resolve;
              loadedArrayReject = reject;
            });
        adf.mf.api.resourceFile.loadJsFile(
          theResource,
          true,
          function()
          {
            loadedArrayResolve(theResource);
            loadedJavaScriptResources[theResource] = true;
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          },
          function(failure)
          {
            loadedArrayReject(failure);
            loadedJavaScriptResources[theResource] = true;
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          },
          null);
      }
      else if (loadState == true)
      {
        // This file was already loaded so move onto the next file
        _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
      }
      else
      {
        // Someone has already made a request for it so we need to wait on its promise
        // before we move onto the next file:
        loadState.then(
          function()
          {
            _resourceLoadNextResource(entrireListLoadedResolve, listOfFiles, nextIndex, fileCount);
          });
      }
    }
  };

  /**
   * Called from findResourcesForTag to find all the resources for a given namespace object and tag name.
   * @param {Object} nsObj resources object for a namespace from the JSON object.
   * @param {string} tagName the local AMX node name or "*" for resources global to the namespace.
   * @param {Array.<string>} fileList Array where a list of files to load will be added
   */
  function findTagNsResources(nsObj, tagName, fileList)
  {
    var tagObj = nsObj[tagName];
    if (tagObj == null)
    {
      return;
    }
    var js = tagObj["js"];
    var index, size;
    if (js != null)
    {
      // Load any required javascript files:
      if (Array.isArray(js))
      {
        for (index = 0, size = js.length; index < size; ++index)
        {
          var theResource = js[index];
          if (loadedJavaScriptResources[theResource] !== true && // if undefined or a promise, then push
            fileList.indexOf(theResource) == -1) // prevent repeats
          {
            fileList.push(theResource);
          }
        }
      }
      else
      {
        if (loadedJavaScriptResources[js] !== true) // if undefined or a promise, then push
        {
          if (fileList.indexOf(js) == -1) // prevent repeats
            fileList.push(js);
        }
      }
    }
  }

  /**
   * Function to load any JavaScript or CSS file dependencies for an AMX tag.
   * @param {adf.mf.api.amx.AmxTag} tag the AMX tag.
   * @param {Array.<string>} fileList of resource to be loaded to allow the calling function to
   *                determine when all the resources have been loaded.
   */
  function findResourcesForTag(tag, fileList)
  {
    // The first level of objects are keyed by the namespace URI of the XML node:
    var ns = tag.getNamespace();
    var nsObj = resourcesData[ns];
    if (nsObj != null)
    {
      // Load any resources for all tags in this namespace:
      findTagNsResources(nsObj, "*", fileList);

      // Second level are keyed by the tag's local name:
      findTagNsResources(nsObj, tag.getName(), fileList);
    }

    // Process all the children tags
    var children = tag.getChildren();
    for (var index = 0, size = children.length; index < size; ++index)
    {
      var childTag = children[index];
      findResourcesForTag(childTag, fileList);
    }
  }
  // ------ /resource loading ------ //

  // ------ API for TypeHandlers ------ //

  /**
   * @deprecated
   */
  amx.registerRenderers = function(theNamespace, typeHandlerMap)
  {
    var typeHandlerDetail = "";
    adf.mf.internal.amx._each(typeHandlerMap, function(key, value)
    {
      if (typeHandlerDetail != "")
        typeHandlerDetail += ", ";
      typeHandlerDetail += key;
    });

    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "amx.registerRenderers", "MSG_AMX_REGISTER_DEPRECATED",
      typeHandlerDetail, theNamespace);

    if (theNamespace == "amx")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "amx.registerTypeHandlers", "MSG_NS_DEPRECATED",
        "amx", adf.mf.api.amx.AmxTag.NAMESPACE_AMX, typeHandlerMap);
      theNamespace = adf.mf.api.amx.AmxTag.NAMESPACE_AMX;
    }
    else if (theNamespace == "dvtm")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "registerTypeHandlers", "MSG_NS_DEPRECATED",
        "dvtm", adf.mf.api.amx.AmxTag.NAMESPACE_DVTM, typeHandlerMap);
      theNamespace = adf.mf.api.amx.AmxTag.NAMESPACE_DVTM;
    }

    adf.mf.internal.amx._each(typeHandlerMap, function(tagName, deprecatedTypeHandlerObject)
    {
      // If it is a function, then, it is actually the "render" of the NodeTypeHandler
        if (deprecatedTypeHandlerObject && (typeof deprecatedTypeHandlerObject === "function"))
      {
        deprecatedTypeHandlerObject =
        {
          render: deprecatedTypeHandlerObject
        };
      }

      // Convert the old style TypeHandler objects into classes needed for the new API:
      var typeHandlerClass = adf.mf.api.amx.TypeHandler.register(theNamespace, tagName);
        adf.mf.internal.amx._each(deprecatedTypeHandlerObject,
        function(functionName, functionImplementation)
      {
        typeHandlerClass.prototype[functionName] = functionImplementation;
      });
    });
  };

  /**
   * Notify the framework that an iteration node is being processed. Should be called by iterating
   * renderers for each stamp.
   * @param {string} amxNodeId the ID of the iterating AMX node to use as the base of the ID prefix
   *                 for the iterator's children nodes.
   * @param {Object} iterationKey the object to convert to a string to uniquely identify items
   *                 in the iterator.
   */
  amx.beginIterationContainer = function(amxNodeId, iterationKey)
  {
    iterationIdStack.pushIterator(amxNodeId, iterationKey);
  };

  /**
   * Notify the framework that an iteration node has finished being processed. Should be called by
   * iterating renderers after each stamp. Must correspond to a call to beginIterationContainer.
   */
  amx.endIterationContainer = function()
  {
    iterationIdStack.popIterator();
  };

  /**
   * @deprecated
   */
  amx.renderSubNodes = function(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderSubNodes", "MSG_DEPRECATED", "amx.renderSubNodes", "amxNode.renderDescendants");
    return adf.mf.api.amx.renderSubNodes.apply(this, arguments);
  };

  /**
   * @deprecated
   */
  adf.mf.api.amx.renderSubNodes = function(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "renderSubNodes", "MSG_DEPRECATED", "adf.mf.api.amx.renderSubNodes",
      "amxNode.renderDescendants");

    return amxNode.renderSubNodes();
  };

  /**
   * @deprecated
   */
  amx.isUITag = function(nsPrefixedTagName)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "isUITag", "MSG_DEPRECATED", "amx.isUITag", "AmxTag.isUITag");

    return adf.mf.internal.amx.AmxTagHandler.__hasHandler(nsPrefixedTagName) == false;
  };

  /**
   * @deprecated
   */
  amx.renderNode = function(node)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "renderNode",
      "MSG_DEPRECATED", "amx.renderNode", "amxNode.render");
    return adf.mf.api.amx.renderNode.apply(this, arguments);
  };

  /**
   * Render a amxNode or the xmlNode. If it is an xmlNode, then, it will be processed before rendering it.
   * @param {(xmlNode|adf.mf.api.amx.AmxNode)} node The node for a given element. Can be the process AMXNode or the XMLNode.
   * @return the rendered DOM node or null if nothing rendered
   */
  adf.mf.api.amx.renderNode = function(node)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "renderNode", "MSG_DEPRECATED", "adf.mf.api.amx.renderNode",
      "amxNode.render");
    return node.renderNode();
  };

  // --------- Critical section --------- //
  /**
   * Singleton class to handle the critical section of updating the AMX node hierarchy
   * @private
   */
  var criticalSection =
  {
    _queue: [],
    _blockedCount: 0,
    _timeout: null,
    _running: false,

    /**
     * Queues a method to be run in the critical section
     * @private
     */
    queue: function(method)
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.queue",
          "Queuing method");
      }

      this._queue.push(method);

      if (this._queue.length == 1 && this._blockedCount == 0 && this._running == false)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.queue",
            "Running method now. Queue length is " + this._queue.length);
        }

        // If this is the only method and we are not blocked, run it synchronously
        this.run();
      }
      else
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.queue",
            "Scheduling execution for later. Queue length is " + this._queue.length);
        }

        // Run the method later
        this._scheduleTimeout();
      }
    },

    /**
     * Prevent any more methods from running until the resume has been called. The resume must
     * be called one time for every call to pause.
     * @private
     */
    pause: function()
    {
      ++this._blockedCount;

      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.pause",
          "Blocked count: " + this._blockedCount);
      }
    },

    /**
     * Resume after having been paused
     * @private
     */
    resume: function()
    {
      this._blockedCount = Math.max(0, this._blockedCount - 1);

      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.resume",
          "Blocked count: " + this._blockedCount);
      }

      this._scheduleTimeout();
    },

    /**
     * Runs the next function in critical section
     * @private
     */
    run: function()
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection.run",
          "Run invoked");
      }

      this._timeout = null;

      // Ensure that we are ready to run
      if (this._running || this._blockedCount > 0 || this._queue.length == 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.run",
            (this._running ? "Run called when a method is already running" :
              (this._blockedCount ?
                ("Block count preventing run. Count: " + this._blockedCount) :
                "The queue is empty"
              )
            ));
        }

        return;
      }

      this._running = true;

      var method = this._queue.shift();

      // Some of the methods that are queued are dependent on the current view. If the navigation ID has changed, then
      // do not run the method and check the next queued method.
      while (method != null)
      {
        var navigationId = method["navigationId"];

        if (navigationId >= 0 && navigationId != adf.mf.internal.amx._navigationId)
        {
          // Do not process any methods that were queued for an old page. Go to the next
          // item in the queue. Note that shift returns undefined if the array is empty
          method = this._queue.shift();
        }
        else
        {
          break;
        }
      }

      if (method == null)
      {
        // No more queued methods to run
        return;
      }

      var methodFinished = false;

      try
      {
        var fn = method["func"];
        var params = method["params"];
        var thisObj = method["thisObj"];

        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection.run",
            "Before critical method invocation. Queue length is now " + this._queue.length);
        }

        var result = fn.apply(thisObj, params);

        // The function is allowed to return a promise object if the task is asynchronous
        // and we need to block until it is fully finished
        if (result != null && typeof(result["then"]) == "function")
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "criticalSection.run",
              "Promise object was returned, will wait for resolution");
          }

          var callback = adf.mf.internal.getProxyFunction(this, this._promiseCallback);

          result.then(callback, callback);
        }
        else
        {
          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "criticalSection.run",
              "Method finished without a Promise object");
          }
          methodFinished = true;
        }
      }
      catch (e)
      {
        // If there was an exception, a promise object was not returned
        methodFinished = true;

        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
          "criticalSection.run",
          "MSG_CRITICAL_SECTION_FUNCTION_EXCEPTION");

        // Only log the exception at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "criticalSection", "run", e);
      }
      finally
      {
        if (methodFinished)
        {
          this._running = false;
          this._scheduleTimeout();
        }
      }
    },

    /**
     * Callback when a method has returned a promise object
     * @private
     */
    _promiseCallback: function()
    {
      if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._promiseCallback",
          "_promiseCallback called");
      }

      this._running = false;
      this._scheduleTimeout();
    },

    /**
     * Schedules the run method to be called when not busy
     * @private
     */
    _scheduleTimeout: function()
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);
      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
          "_scheduleTimeout called");
      }

      // Ensure the critical section is ready before scheduling a callback and ensure that a
      // callback has not already been set
      if (this._running == false && this._timeout == null && this._blockedCount == 0 &&
        this._queue.length > 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
            "Scheduling a timeout");
        }

        this._timeout = window.setTimeout(adf.mf.internal.getProxyFunction(this, this.run), 1);
      }
      else if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "criticalSection._scheduleTimeout",
          (this._running ? "A method is already running" :
            (this._timeout != null ? "Timeout was already scheduled" :
              (this._blockedCount != 0 ?
                ("Critical section is blocked. Count: " + this._blockedCount) :
                "Queue is empty"
              )
            )
          ));
      }
    }
  };

  /**
   * Allows code that needs to use the critical section to queue a callback
   * when the critical section is free. This functionality is akin to the Java synchronized
   * block.
   * @param {function} func the function to invoke. It may return a promise object which
   *        will block the critical section until resolved (or fails)
   * @param {Object} thisObject the object to use as "this" when invoking the function.
   * @param {boolean} tiedToCurrentViewId if this is true, then the function will not be run
   *        if a navigation is currently executing that will result in a new view
   * @param {...Object} var_args parameters to pass to the function.
   * @private
   */
  adf.mf.internal.amx._queueCriticalSectionFunction = function(
    func,
    thisObject,
    tiedToCurrentViewId
    /* ... arguments */)
  {
    if (adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
    {
      adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.amx", "_queueCriticalSectionFunction",
        "Critical section function being queued");
    }

    var params = Array.prototype.slice.call(arguments, 3);

    var navigationId = tiedToCurrentViewId === true ? adf.mf.internal.amx._navigationId : -1;

    criticalSection.queue(
      {
        "func": func,
        "thisObj": (thisObject || window),
        "params": params,
        "navigationId": navigationId
      });
  };

  /**
   * Internal function for usage by type handlers to be able to pause changes to the UI.
   * Typical use case is to prevent updates to the AMX hierarchy and DOM nodes during
   * an animation. This prevents the DOM from being replaced while another task, like animation
   * is under way.
   */
  adf.mf.internal.amx.pauseUIChanges = function()
  {
    criticalSection.pause();
  };

  /**
   * Internal function for usage by type handlers to be able to resume changes to the UI.
   * See adf.mf.internal.amx.pauseUIChanges.
   */
  adf.mf.internal.amx.resumeUIChanges = function()
  {
    criticalSection.resume();
  };

  /**
   * Internal function for usage by the isLoading() API to be able to tell if
   * something is pausing UI changes.
   * See adf.mf.internal.amx.pauseUIChanges.
   */
  adf.mf.internal.amx.isUIChangePaused = function()
  {
    return criticalSection._running || criticalSection._blockedCount != 0;
  };
  // --------- /Critical section --------- //

  // --------- Data Change Logic --------- //
  var queuedBatchDataChanges = [];
  var queuedCollectionModelChanges = {};

  // Used to prevent bulk loads and queued critical section functions from being processed across navigation boundaries.
  adf.mf.internal.amx._navigationId = 0;
  adf.mf.internal.amx._navigationInProgress = false;

  /**
   * Process the data change queue once the critical section is available.
   * Method is only to be called from the critical section
   * @private
   */
  function processBatchDataChangeQueue()
  {
    // Ensure that there are queued changes
    if (queuedBatchDataChanges.length == 0)
    {
      return;
    }

    var q = queuedBatchDataChanges;
    var cmc = queuedCollectionModelChanges;

    queuedBatchDataChanges = [];
    queuedCollectionModelChanges = {};

    // Process the changes
    handleDataChangeImpl(q, cmc);
  }

  /**
   * Function called from the navigation listener to throw out any queued data changes when
   * a navigation has taken place.
   */
  function clearDataChangeQueue()
  {
    queuedBatchDataChanges = [];
    queuedCollectionModelChanges = {};
  }

  /**
   * Queue batch data changes and schedule the callback to the processBatchDataChangeQueue.
   * @param {Array.<string>} dependencyArray the array of EL to queue.
   * @param {Object} collectionModelChanges collection model changes
   */
  function queueBatchDataChange(dependencyArray, collectionModelChanges)
  {
    var initialLength = queuedBatchDataChanges.length;

    for (var i = 0, size = dependencyArray.length; i < size; ++i)
    {
      var el = dependencyArray[i];
      // Ensure the EL is only added once
      if (queuedBatchDataChanges.indexOf(el) < 0)
      {
        queuedBatchDataChanges.push(el);
      }

      if (collectionModelChanges != null)
      {
        var collectionChanges = collectionModelChanges[el];
        if (collectionChanges != null)
        {
          var currentCollectionModelChanges = queuedCollectionModelChanges[el];
          if (currentCollectionModelChanges != null)
          {
            // If a value is already present, we cannot merge the changes, so ensure that
            // itemized is false.
            queuedCollectionModelChanges[el] = { "itemized": false };
          }
          else
          {
            queuedCollectionModelChanges[el] = collectionChanges;
          }
        }
      }
    }

    // If the queue was empty, queue the callback to the process function
    // to handle the queued changes once the critical section is available
    if (initialLength == 0)
    {
      adf.mf.internal.amx._queueCriticalSectionFunction(
        processBatchDataChangeQueue,
        this,
        false);
    }
  }

  /**
   * Listener for the controller navigation events
   */
  function navigationListener(event)
  {
    if (event.isNavigationStart())
    {
      adf.mf.internal.amx._navigationInProgress = true;

      // Stop any critical section functions from running while a navigation is being processed
      adf.mf.internal.amx.pauseUIChanges();
    }
    else if (event.isNavigationEnd())
    {
      var navResult = event.getNavigationResult();

      if (navResult.isDifferentViewId())
      {
        var navigationId = adf.mf.internal.amx._navigationId;

        // Increment the navigationId
        adf.mf.internal.amx._navigationId = navigationId > 1000000 ? 0 : navigationId + 1;

        // Remove any queued data changes for the old view
        clearDataChangeQueue();
      }

      adf.mf.internal.amx._navigationInProgress = false;

      // Resume the critical section queue
      adf.mf.internal.amx.resumeUIChanges();
    }
  }

  // The 'adfc' window object is loaded after amx-core, so delay the addition if the listener until
  // after the page finishes loading
  document.addEventListener("showpagecomplete",
    function ()
    {
      adfc.NavigationHandler.addNavigationListener(navigationListener);
    }, false);

  // On Android 4.0.x releases, we have noticed that the UI will not always repaint after the DOM
  // has been changed in a data change listener. As a result, we need to check the user agent
  // to see if this is an Android 4.0 device.
  var requiresUiInValidation = false;
  if (adf.mf.internal.amx.agent["type"] == "Android")
  {
    // Example user agent string we want to match:
    // Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30
    var ua = navigator.userAgent;
    if (/Android 4\.0(\.\d+)?;/.test(ua))
    {
      requiresUiInValidation = true;
    }
  }

  /**
   * Callback used to handle batch data changes.
   * @param {Array} dependencyArray an Array of EL expression dependency strings that have changed
   *        (not full expressions)
   * @see adf.mf.api.addBatchDataChangeListener
   * @private
   */
  adf.mf.internal.amx._handleBatchDataChangeListener = function(
    dependencyArray,
    collectionModelChanges)
  {
    if (dependencyArray != null)
    {
      // If there is no root node, then we are getting a data change during navigation, or during
      // the building of the tree. Since we have not yet built the node hierarchy, we do not need
      // to process the change at this time.
      var rootAmxNode = adf.mf.api.amx.getPageRootNode();
      if (rootAmxNode == null)
      {
        return;
      }

      // Queue the work onto a critical section function
      queueBatchDataChange(dependencyArray, collectionModelChanges);
    }
  }

  /**
   * Process the work of _handleBatchDataChangeListener. This is called from
   * processBatchDataChangeQueue which is run from the critical section.
   * This method should never be called directly, but always from a critical section
   */
  function handleDataChangeImpl(dependencyArray, collectionModelChanges)
  {
    var perfOp = adf.mf.internal.perf.startMonitorOperation("Process data change event", adf.mf.log.level.FINE,
      "adf.mf.internal.amx._handleBatchDataChangeListener");

    var affectedNodeCount = 0;
    try
    {
      var isFinestLoggingEnabled = adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST);

      if (isFinestLoggingEnabled)
      {
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.internal.amx", "_handleBatchDataChangeListener",
          adf.mf.util.stringify(dependencyArray));
      }

      var markNodeForUpdateArgs = new adf.mf.internal.amx.AmxNodeUpdateArguments();
      var hasCollectionModelChanges = collectionModelChanges != null;
      var collectionChangesElMap = null;

      if (hasCollectionModelChanges)
      {
        collectionChangesElMap = {};
        for (var el in collectionModelChanges)
        {
          var data = collectionModelChanges[el];
          collectionChangesElMap[el] = new adf.mf.api.amx.AmxCollectionChange(data);
        }
      }

      for (var i = 0, size = dependencyArray.length; i < size; ++i)
      {
        var el = dependencyArray[i];
        var valueExpr = adf.mf.internal.el.parser.parse("#{" + el + "}");

        var nodes = adf.mf.api.amx.AmxNode.__getNodesDependentOnElToken(valueExpr);
        for (var n = 0, nodeSize = nodes.length; n < nodeSize; ++n)
        {
          var node = nodes[n];
          var nodeId = node.getId();

          if (isFinestLoggingEnabled)
          {
            adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
              "adf.mf.internal.amx", "_handleBatchDataChangeListener",
              "Node affected by change to EL #{" + el + "}: "+ nodeId);
          }

          var attrNames = node.__getAttributesForElDependency(valueExpr);
          for (var a = 0, asize = attrNames.length; a < asize; ++a)
          {
            var attrName = attrNames[a];
            if (isFinestLoggingEnabled)
            {
              adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
                "adf.mf.internal.amx", "_handleBatchDataChangeListener",
                "Affected attribute: " + attrName);
            }

            markNodeForUpdateArgs.setAffectedAttribute(node, attrName);

            if (hasCollectionModelChanges)
            {
              var collectionChange = collectionChangesElMap[el];
              if (collectionChange != null)
              {
                markNodeForUpdateArgs.setCollectionChanges(nodeId, attrName, collectionChange);
              }
            }
          }

          node.__processTagInstancesForElDependency(markNodeForUpdateArgs, valueExpr);
        }
      }

      affectedNodeCount = markNodeForUpdateArgs.getAffectedNodes().length;
      if (affectedNodeCount > 0)
      {
        if (isFinestLoggingEnabled)
        {
          adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
            "adf.mf.internal.amx", "_handleBatchDataChangeListener",
            affectedNodeCount + " nodes have been affected by the data changes");
        }

        // Call the internal mark node for update function which does not check for being in
        // the critical section since we are already in the critical section
        adf.mf.internal.amx._markNodeForUpdateImpl(markNodeForUpdateArgs);

        // On Android, there is a bug in the web view that changes from the data change events may
        // not be redrawn. So, invoke a callback to invalidate the WebView, forcing the repainting of
        // the WebView. Bug seen in at least the 4.0.3 Android version of the WebView
        if (requiresUiInValidation && window["AdfmfCallback"] != null)
        {
          window.AdfmfCallback.invalidateUi();
        }
      }
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "handleDataChangeImpl", "MSG_BATCH_DATA_CHANGE_FAILED");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "AMX", "handleDataChangeImpl", ex);
    }
    finally
    {
      perfOp.stop();
    }
  };

  amx.clearBindings = function()
  {
    adf.mf.api.amx.AmxNode.__clearBindings();
  };

  // Helper method
  // return boolean
  amx.containsELExpressions = function(elString)
  {
		if (!elString)
			return false;
		if (elString.getExpression)
			return true;
		return amx.getElsFromString(elString).length > 0;
  };

  // Helper method
  // return an array
  amx.getElsFromString = function(elString)
  {
    var result = [];

    if (elString != null)
    {
      var regEx = /[#,$]{.*?}/g;
      var m = regEx.exec(elString);
      while (m != null)
      {
        if (result.indexOf(m[0]) < 0)
        {
          result.push(m[0]);
        }
        m = regEx.exec(elString);
      }
    }

    return result;
  };
  // --------- /Data Change Logic --------- //

  /**
   * An event triggering an outcome-based navigation.
   * See also the Java API oracle.adfmf.amx.event.ActionEvent.
   * @constructor
   */
  adf.mf.api.amx.ActionEvent = function()
  {
    this[".type"] = "oracle.adfmf.amx.event.ActionEvent";
  };
  amx.ActionEvent = adf.mf.api.amx.ActionEvent; // deprecated syntax

  /**
   * A DOM event.
   * @param {string} amxNodeId the component ID
   * @param {Object} eventType the type of event
   * @param {Event} originalEvent the original DOM event object
   * @constructor
   */
  adf.mf.api.amx.DomEvent = function(amxNodeId, eventType, originalEvent)
  {
    this[".type"] = "oracle.adfmf.amx.event.DomEvent";
    this.amxNodeId = amxNodeId;
    this.eventType = eventType;
    this.source = originalEvent.target;
    this.currentTarget = originalEvent.currentTarget;
    this.originalEvent = originalEvent;
  };

  /**
   * An event for notifying that a specified row has been moved.
   * It contains the key for the row that was moved along with the key for the row it was inserted before.
   * See also the Java API oracle.adfmf.amx.event.MoveEvent.
   * @param {Object} rowKeyMoved the rowKey that was moved
   * @param {Object} rowKeyInsertedBefore the rowKey that the moved row was inserted before
   * @constructor
   */
  adf.mf.api.amx.MoveEvent = function(rowKeyMoved, rowKeyInsertedBefore)
  {
    this[".type"] = "oracle.adfmf.amx.event.MoveEvent";
    this.rowKeyMoved = rowKeyMoved;
    this.rowKeyInsertedBefore = rowKeyInsertedBefore;
  };
  adf.mf.internal.amx.MoveEvent = adf.mf.api.amx.MoveEvent; // deprecated syntax

  /**
   * An event for changes of selection for a component.
   * See also the Java API oracle.adfmf.amx.event.SelectionEvent.
   * @param {Object} oldRowKey the rowKey that has just been unselected
   * @param {Array<Object>} selectedRowKeys the array of rowKeys that have just been selected.
   * @constructor
   */
  adf.mf.api.amx.SelectionEvent = function(oldRowKey, selectedRowKeys)
  {
    this.oldRowKey = oldRowKey;
    this.selectedRowKeys = selectedRowKeys;
    this[".type"] = "oracle.adfmf.amx.event.SelectionEvent";
  };
  amx.SelectionEvent = adf.mf.api.amx.SelectionEvent; // deprecated syntax

  /**
   * An event for changes of value for a component.
   * See also the Java API oracle.adfmf.amx.event.ValueChangeEvent.
   * @param {Object} oldValue the previous value of the component.
   * @param {Object} newValue the new value of the component.
   * @constructor
   */
  adf.mf.api.amx.ValueChangeEvent = function(oldValue, newValue)
  {
    this.oldValue = oldValue;
    this.newValue = newValue;
    this[".type"] = "oracle.adfmf.amx.event.ValueChangeEvent";
  };
  amx.ValueChangeEvent = adf.mf.api.amx.ValueChangeEvent; // deprecated syntax

  /**
   * An event for range changes for a component (e.g. load more rows in listView).
   * See also the Java API oracle.adfmf.amx.event.RangeChangeEvent.
   * @param {string} eventSourceId the source ID of the event
   * @param {string} contextFreeValue the context-free value expression or null if not available
   * @param {Object} lastLoadedRowKey the row key of the last row loaded before the requested range or null if not available
   * @param {number} fetchSize the size to fetch or null if not available
   * @constructor
   */
  adf.mf.api.amx.RangeChangeEvent = function(
    eventSourceId,
    contextFreeValue,
    lastLoadedRowKey,
    fetchSize)
  {
    this.eventSourceId = eventSourceId;
    this.contextFreeValue = contextFreeValue;
    this.lastLoadedRowKey = lastLoadedRowKey;
    this.fetchSize = fetchSize;
    this[".type"] = "oracle.adfmf.amx.event.RangeChangeEvent";
    // Consider using: this[".type"] = "oracle.adfmf.framework.event.RangeChangeEvent";
  };

  /**
   * Process an AMX Event. Change the value if attributeValueName is defined, process the appropriate
   * setPropertyListener and actionListener sub tags and then process the [amxEventType]Listener attribute.
   * @param {adf.mf.api.amx.AmxNode} amxNode The node to process the event on.
   * @param {string} amxEventType String that represents the event type that triggered the call.
   * @param {string} attributeValueName The name of the attribute whose value will be changed (or undefined if not applicable).
   * @param {string} newValue The new value to be applied to the attribute sent in (or undefined if not applicable).
   * @param {Object} amxEvent The new AmxEvent being queued.
   * @param {Object} finishedCallback The optional function to invoke once the event has been processed.
   * @deprecated
   */
  amx.processAmxEvent = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    finishedCallback)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "processAmxEvent",
      "MSG_DEPRECATED", "amx.processAmxEvent", "amxNode.processAmxEvent");
    return adf.mf.api.amx.processAmxEvent(amxNode, amxEventType,
      attributeValueName, newValue, amxEvent, finishedCallback);
  };

  //adf.mf.internal.amx._useBatchProcessing = false;

  /**
   * Process an AMX Event. Change the value if attributeValueName is defined, process the
   * appropriate setPropertyListener and actionListener sub tags and then process the
   * [amxEventType]Listener attribute. For valueChange events, the attribute must have already
   * been registered on the node as the input value. Use getInputValueAttribute on the type handler
   * of the AMX node to return the attribute name that accepts the input value for which value
   * changes occur.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode The node to process the event on.
   * @param {string} amxEventType String that represents the event type that triggered the call.
   * @param {(string|undefined)} attributeValueName The name of the attribute whose value will be
   *        changed (or undefined if not applicable).
   * @param {(string|undefined)} newValue The new value to be applied to the attribute sent in
   *        (or undefined if not applicable).
   * @param {Object} amxEvent The new AmxEvent being queued.
   * @param {function=} successfulCallback An optional function to invoke once the event has been
   *        successfully processed.
   * @param {function=} failureCallback Optional callback function if the processing of the event
   *        fails
   */
  adf.mf.api.amx.processAmxEvent = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    successfulCallback,
    failureCallback)
  {
    // Show the loading indicator as this could take some time to process.
    adf.mf.api.amx.showLoadingIndicator();

    // Need a wrapper promise incase we are in design time and we will resolve this either in the else
    // or end of phase 4.
    var that = this;
    var promise = new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
        var currPage = amx.getCurrentPageName();
        var nodeId = amxNode.getId();

        adf.mf.internal.amx._pageBusyTracker.startOperation(
          true,
          "Process AMX event",
          adf.mf.log.level.INFO,
          "Time to process event",
          "Page: " + currPage + " event of type " + amxEventType + " on node " + nodeId);

        // No adf.mf.internal.amx._pageBusyTracker.checkComplete will be called from this method. This
        // allows any subsequent data change events to be tracked and included in the current operation

        if (adf.mf.api.amx.getPageRootNode() == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being
          // delivered.
          reject();
        }
        else
        {
          var funcType = adf.mf.internal.amx.processAmxEventImplSerial;

          if (adf.mf.environment.profile.useBatchProcessing && !adf.mf.environment.profile.mockData)
          {
            funcType = adf.mf.internal.amx.processAmxEventImplBatch;
          }

          adf.mf.internal.amx._queueCriticalSectionFunction(
            funcType,
            that,
            true,
            amxNode,
            amxEventType,
            attributeValueName,
            newValue,
            amxEvent,
            {
              "resolve": resolve,
              "reject": reject
            });
        }
      });

    if (successfulCallback != null)
    {
      promise.then(successfulCallback);
    }

    if (failureCallback != null)
    {
      promise["catch"](failureCallback);
    }

    // Hide the loading indicator once the event is fully done and the callbacks have been fired
    promise.then(adf.mf.api.amx.hideLoadingIndicator, adf.mf.api.amx.hideLoadingIndicator);

    return promise;
  };

  // TODO: this method is gross. We need to refactor it to fit into one screen and break out the internals into
  // several functions so that it is readable
  adf.mf.internal.amx.processAmxEventImplBatch = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    promiseArgs)
  {
    // Return a promise object to the critical section
    return new adf.mf.internal.BasePromise(
      function(batchResolve, batchReject)
      {
        // Perform a visit to the node to put it back into context
        // TODO: find a way to get context free EL for listener tags so that we do not need to
        // re-establish context
        var rootNode = adf.mf.api.amx.getPageRootNode();
        if (rootNode == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being
          // delivered.
          promiseArgs["reject"]();
          batchReject();
          return;
        }

        var perf = adf.mf.internal.perf.startMonitorCall("Process AMX batch",
          adf.mf.log.level.FINER, "adf.mf.internal.amx.processAmxEventImplBatch");

        // Check if the deprecated API is in use (passing the AMX node as a jQuery object with the
        // root DOM element)
        if (amxNode != null && amxNode.jquery)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
                "processAmxEventImplBatch", "MSG_AMX_EVENT_JQUERY_DEPRECATED");
          amxNode = amxNode.data("amxNode");
        }

        // We need to use visit pattern to set up the context for this node the event is attached to
        var nodeFound = rootNode.visit(
          new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
          function (visitContext, amxNode)
          {
            // This function is only called when the node has been found and the context setup.
            var validationGroup = null;
            var popupActions = [];

            if (!adf.mf.environment.profile.dtMode)
            {
              // Start the batch request. This is to prevent us from doing all the set property and
              // action event one at a time and instead process all all the children at once we
              // queue up all the EL that needs to be proccessed in order. Once
              // completed the flush will process all the EL in one round trip.
              adf.mf.util.startBatchRequest();

              adf.mf.internal.pushNonBlockingCall();

              // detect if we might need to refresh the validation message area
              if (amxEventType === "valueChange" &&
                attributeValueName === amxNode.__getAttributeToValidate())
              {
                // First find the closest rendered node for validation group purposes
                var domNode = null;
                var renderedAmxNode = amxNode.__getClosestRenderedNode();

                if (renderedAmxNode != null)
                {
                  domNode = document.getElementById(renderedAmxNode.getId());
                }

                // We need to retrieve this here because calling setElValue will cause this domNode
                // to potentially be swapped out with a new one if the control doesn't support the
                // refresh method
                validationGroup = _getClosestWithClass(domNode, "amx-validationGroup");
              }

              // If this is a value change event then we need to convert the new value first before
              // we continue to process.
              var converter = amxNode.getConverter();
              if (converter && amxEventType === "valueChange" && attributeValueName === "value")
              {
                var rawValue = newValue;

                newValue = converter.getAsObject(newValue);

                if (newValue === "" && rawValue !== "")
                {
                  // There was a conversion error, do not process the event
                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                }
              }

              // Phase 1) Set the new value on the attribute. We need to first fetch the current
              //          value of the attribute (this has to be an EL Expression so we assume it is
              //          and let the setELValue figure out where it really needs to go. For our
              //          part we just get the value for this attribute that get returned and assume
              //          it is an EL expression for this attribute. This is  different from the
              //          rich client. First we know what the type (EL Expression or literal) and
              //          set the value immediatly if this is a literal. Once the "value" has been
              //          fetched for this attribute then the assumed EL expression and send off in
              //          another request for to be updated with the new value.

              // Make sure we have an attribute value name we are looking to update.
              if (attributeValueName)
              {
                // TODO: Need to change this into a non-promise call as we are in batch mode here.
                amxNode.setAttribute(attributeValueName, newValue);
              }

              // Phase 2) Process the setPropertyListeners and actionListeners of this node passed
              //          in. Since any component can have other types of components we are going to
              //          be looking for specific component types. We need to create a
              //          childrenPromise to make sure we can wait on this before we go to the next
              //          phase.
              // Get all the child tag instances from the AMX node.
              var tagInstances = amxNode.__getAllTagInstances();
              // Loop over all the children
              // Looking for one of five specific AMX tags here.
              //   1) setPropertyListener
              //   2) actionListener
              //   3) clientListener
              //   4) showPopupBehavior
              //   5) closePopupBehavior
              for (var i=0, length = tagInstances.length; i < length; i++)
              {
                var tagInstance = tagInstances[i];
                // Get the attribute type. If none is specified assume an action attribute.
                // TODO: Not sure thie assumption is correct as it assumes a type when none existis.
                //       I would expect a type would always be specified but because you are looking
                //       at AMX XML nodes we only see what is defined.
                var attrType;
                var type = tagInstance.getAttribute("type");
                if (type != null)
                {
                  attrType = adf.mf.internal._getEventTypeResolvedForBidi(type);
                }
                else
                {
                  // use default type
                  attrType = "action";
                }

                var subTag = tagInstance.getTag();

                if ((subTag.getNsPrefixedName() ===
                    adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":setPropertyListener") &&
                  attrType === amxEventType)
                {
                  // Get the from expression
                  var from = tagInstance.getAttributeExpression("from");
                  var isEl = false;
                  if (from)
                  {
                    from = from.toContextFreeExpression().getExpression();
                    isEl = true;
                  }
                  else
                  {
                    from = tagInstance.getAttribute("from", false);
                  }

                  if (from != null)
                  {
                    // Get a context free EL expression for the "to" so that we do not need to
                    // perform another visit to set the value
                    var toEl = tagInstance.getAttributeExpression("to").toContextFreeExpression();

                    // Set the value without trying to resolve the "from" value.
                    var setObject =
                    {
                      "name": toEl.getExpression(),
                      "expression": toEl,
                      "value": from
                    };

                    if (isEl)
                    {
                      // "from" is just a reference alias
                      setObject[adf.mf.internal.api.constants["VALUE_REF_PROPERTY"]] = true;
                    }

                    amx.setElValue(setObject);
                  }
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":actionListener")
                {
                  // Process the action listener tag if there is an amxEventType passed matches the
                  // attribute type.
                  if (attrType == amxEventType)
                  {
                    // Create the arrays of paramaters and and paramater types.
                    var params     = [];
                    var paramTypes = [];
                    if (amxEvent)
                    {
                      params.push(amxEvent);
                      paramTypes.push(amxEvent[".type"]);
                    }

                        // Invoke the action event. This returns a promise.
                    var expr = tagInstance.getAttributeExpression("binding");
                    adf.mf.api.amx.invokeEl(expr, params, null, paramTypes);
                  }
                }
                else if ((subTag.getNsPrefixedName() ===
                    adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":clientListener") &&
                  attrType === amxEventType)
                {
                  // Execute it:
                  adf.mf.internal._processClientListener(attrType, amxEvent, amxNode, tagInstance);
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":showPopupBehavior")
                {
                  // Process the show popup behavior tag if there is an amxEventType passed in
                  // matches the attribute type.
                  if (attrType === amxEventType)
                  {
                    popupActions.push(
                      { "type": "show", "node": amxNode, "tagInstance": tagInstance });
                  }
                }
                else if (subTag.getNsPrefixedName() === adf.mf.api.amx.AmxTag.NAMESPACE_AMX +
                  ":closePopupBehavior")
                {
                  // Process the close popup behavior tag if there is an amxEventType passed in
                  // matches the attribute type.
                  if (attrType === amxEventType)
                  {
                    popupActions.push({ "type": "close", "node": amxNode, "tagInstance": tagInstance });
                  }
                }
              }
              // Start of Phase 3.
              // Process the listener if there is an amxEvent passed in and we have a listener
              // attribute on the compoenent.
              if (amxEvent)
              {
                var attParams     = [];
                var attParamTypes = [];
                attParams.push(amxEvent);
                attParamTypes.push(amxEvent[".type"]);

                var el = amxNode.getAttributeExpression(amxEventType + "Listener");
                adf.mf.api.amx.invokeEl(el, attParams, null, attParamTypes);
              }

              var scb = function(request, response)
              {
                // Check if an exception was returned (the success callback is still invoked in
                // these cases, so this callback must process the presence of an exception)
                if (Array.isArray(response) && response.length >= 1)
                {
                  var rl = response.length;
                  for (var r=0; r < rl; r++)
                  {
                    var obj = response[r];
                    if (obj != null &&
                      obj[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === true)
                    {
                      // Call the failure callback instead
                      fcb(request, response);
                      return;
                    }
                  }
                }

                // Have a call back from all the events being proccessed. Now need to go over the
                // popup stack and process them
                for (var j = 0, len = popupActions.length; j < len; j++)
                {
                  amxNode = popupActions[j]["node"];
                  var tagInstance = popupActions[j]["tagInstance"];
                  var type = popupActions[j]["type"];

                  // we want to show the popup
                  rootNode.visit(
                    new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                    function (visitContext, amxNode)
                    {
                      // Invoke the show popup behavior. This returns a promise to the calling function.
                      if (type == "show")
                      {
                        amx.processShowPopupBehavior(amxNode, tagInstance);
                      }
                      else
                      {
                        amx.processClosePopupBehavior(amxNode, tagInstance);
                      }

                      return adf.mf.api.amx.VisitResult["COMPLETE"];
                    });
                }

                // Phase 4) Required Validations process the required validators. First we will wait
                //          for the previous phase to complete.
                // detect if we need to refresh the validation message area
                if (validationGroup !== undefined &&
                  adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
                {
                  // Due to the fact that we have been called back both by the setAttribute promise
                  // object as well as the serialResolve being used to iterate the children, we have
                  // lost the context of the amxNode. Use a visit to re-obtain the context so that
                  // iterating EL expressions may be correctly evaluated.
                  rootNode.visit(
                    new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                    function (visitContext, amxNode)
                    {
                      // this is a required value, so refresh the messages for this group
                      // let the validation context know that this group has been modified
                      // this method is defined in amx-validation.js
                      amx.requiredControlValueChanged(validationGroup);

                      return adf.mf.api.amx.VisitResult["COMPLETE"];
                    });
                }

                // resolve the root promise
                promiseArgs["resolve"]();
                batchResolve();
                adf.mf.internal.popNonBlockingCall();
              };

              var fcb = function()
              {
                // resolve the root promise
                promiseArgs["reject"].apply(null, arguments);
                batchReject.apply(null, arguments);
                adf.mf.internal.popNonBlockingCall();
                // TODO: Need to do something here. Not sure what
              };

              // Done processing all the events in batch mode. Time to send them over to the java
              // side to be processed
              perf.stop();
              adf.mf.util.flushBatchRequest(false, [scb], [fcb]);
            }
            else
            {
              perf.stop();

              // if adf.mf.environment.profile.dtMode, just resolve the promise
              promiseArgs["resolve"]();
              batchResolve();
            }

            return adf.mf.api.amx.VisitResult["COMPLETE"];
          });

        if (nodeFound == false)
        {
          perf.stop();

          // This may happen if an AMX event is processed after a navigation takes place. If so,
          // then just resolve the promise and hide the loading indicator
          promiseArgs["reject"]();
          batchReject();
        }
      });
  };

  // TODO: this method is gross. We need to refactor it to fit into one screen and break out the internals into
  // several functions so that it is readable
  adf.mf.internal.amx.processAmxEventImplSerial = function(
    amxNode,
    amxEventType,
    attributeValueName,
    newValue,
    amxEvent,
    promiseArgs)
  {
    return new adf.mf.internal.BasePromise(
      function(serialPromiseResolve, serialPromiseReject)
      {
        // Perform a visit to the node to put it back into context
        // TODO: find a way to get context free EL for listener tags so that we do not need to re-establish context
        var rootNode = adf.mf.api.amx.getPageRootNode();
        if (rootNode == null)
        {
          // Do not process any events after the page has been unloaded.
          // This may happen if an event kicks off a navigation and other events are still being delivered.
          promiseArgs["reject"]();
          serialPromiseReject();
          return;
        }

        // Prevent any data change events from processing while the event is being processed.
        // This is necessary to stop the AMX node hierarchy from being modified as we are
        // processing the child tags and nodes of the target node. If we remove the target,
        // we are no longer able to setup context of the node using visiting.
        var perf = adf.mf.internal.perf.startMonitorCall("Process AMX event", adf.mf.log.level.FINER,
          "adf.mf.internal.amx.processAmxEventImplSerial");

        // Check if the deprecated API is in use (passing the AMX node as a jQuery object with the
        // root DOM element)
        if (amxNode != null && amxNode.jquery)
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING,
            "processAmxEventImplSerial", "MSG_AMX_EVENT_JQUERY_DEPRECATED");
          amxNode = amxNode.data("amxNode");
        }

        // We need to use visit pattern to set up the context for this node the event is attached to.
        var nodeFound = rootNode.visit(
          new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
          function (visitContext, amxNode)
          {
            var validationGroup = null;
            if (!adf.mf.environment.profile.dtMode)
            {
              adf.mf.internal.pushNonBlockingCall();
              // detect if we might need to refresh the validation message area
              if (amxEventType === "valueChange" &&
                attributeValueName === amxNode.__getAttributeToValidate())
              {
                // First find the closest rendered node for validation group purposes
                var domNode = null;
                var renderedAmxNode = amxNode.__getClosestRenderedNode();
                if (renderedAmxNode != null)
                {
                  domNode = document.getElementById(renderedAmxNode.getId());
                }

                // we need to retrieve this here because calling setElValue will cause this domNode
                // to potentially be swapped out with a new one if the control doesn't support the
                // refresh method
                validationGroup = _getClosestWithClass(domNode, "amx-validationGroup");
              }

              // If this is a value change event then we need to convert the new value first before
              // we continue to process.
              if (amxNode.getConverter() && amxEventType === "valueChange" &&
                attributeValueName === "value")
              {
                newValue = amxNode.getConverter().getAsObject(newValue);
              }

              // Phase 1) Set the new value on the attribute. We need to first fetch the current
              //          value of the attribute (this has to be an EL Expression so we assume it is
              //          and let the setELValue figure out where it really needs to go. For our
              //          part we just get the value for this attribute that get returned and assume
              //          it is an EL expression for this attribute. This is  different from the
              //          rich client. First we know what the type (EL Expression or literal) and
              //          set the value immediatly if this is a literal. Once the "value" has been
              //          fetched for this attribute then the assumed EL expression and send off in
              //          another request for to be updated with the new value.
              // TODO: I do not know what this means for input values as they are most likly never
              //       EL bound. Another question is what does this mean for disclosure state? In
              //       the rich client EL driven disclosure state is only driven the first time it
              //       is evaluated and from then on it is controlled by the component (or the
              //       developer) who set the value in JS.

              // Need a new promise to represent when the set has completed. Since this can go to
              // Java that means this operation may happen asynchronously and we need to wait for it
              // to finish. This will be initialized later but we need this defined here for scoping
              // purposes as this is used below in the promise.all.
              var setValuePromise = [];

              // Make sure we have an attribute value name we are looking to update.
              if (attributeValueName)
              {
                setValuePromise.push(amxNode.setAttribute(attributeValueName, newValue));
              }

              // Wait for Phase 1 to complete.
              // Note: when setValuePromise is undefined, then, the promise.all will resolve
              // immediately (which is what we want).
              // Other wise we will continue to wait until the set value has completed.
              var childrenPromise = null;
              adf.mf.internal.BasePromise.all(setValuePromise)["catch"](
                function()
                {
                  // bug 16371894: setValuePromise failed so we abort further processing and reject
                  // childrenPromise
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_SET_VALUE_REJECTED");

                  // For security purposes, only log at FINE level
                  if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                  {
                    adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                      "adf.mf.internal.amx", "processAmxEventImplSerial",
                      "Value rejected: " + newValue);
                  }

                  childrenPromise = new adf.mf.internal.BasePromise(
                    function(resolve, reject)
                    {
                      reject();
                    });
                })
                .then(
                  function()
                  {
                    // Phase 2) Process the setPropertyListeners and actionListeners of this node
                    // passed in. Since any component can have other types of components we are
                    // going to be looking for specific component types. We need to create a
                    // childrenPromise to make sure we can wait on this before we go to the next
                    // phase.
                    // Get all the child tag instances from the AMX node.
                    var tagInstances = amxNode.__getAllTagInstances();

                    // Need a new promise variable as proccessing the child components action, set
                    // property, show popup, close popup behaviors may require calls into the Java
                    // engine and this will always be done Asynchronously.
                    if (tagInstances.length > 0)
                    {
                      // Restore the child variables if this is an iterator or stamped component.
                      // This is required in order to process the specific children in the same and
                      // have thier attribute EL or values. Call serialResolve on the chidlren and
                      // pass it the anonyos function to be applied to all the children.
                      // The returned promise will be used to make sure to wait on it before
                      // performing the next phase.
                      // TODO: Break this our into its own function. This should be a simple case
                      //       statement that calls the specific function for the type of component.
                      childrenPromise = amx.serialResolve(tagInstances,
                        function(tagInstance, i)
                        {
                          // Get the attribute type. If none is specified assume an action attribute
                          // TODO: Not sure thie assumption is correct as it assumes a type when
                          //       none exists. I would expect a type would always be specified but
                          //       because you are looking at AMX XML nodes we only see what is
                          //       defined.
                          var attrType;
                          if (tagInstance.getAttribute("type") != null)
                          {
                            attrType = adf.mf.internal._getEventTypeResolvedForBidi(
                              tagInstance.getAttribute("type"));
                          }
                          else
                          {
                            // use default type
                            attrType = "action";
                          }

                          var subTag = tagInstance.getTag();

                          // Looking for one of five specific AMX tags here.
                          //   1) setPropertyListener
                          //   2) actionListener
                          //   3) clientListener
                          //   4) showPopupBehavior
                          //   5) closePopupBehavior
                          // TODO: this code could explode as more behaviors are added. This needs
                          // to be broken out into a core behavior class that is subclassed by the
                          // specific behaviors. and then just call the function on the behavior.
                          // Maybe this should be an interface that we look for and then execute the
                          // function if it is defined.
                          if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":setPropertyListener" &&
                            attrType === amxEventType)
                          {
                            // Need a new promise as set property listener has two phases. One to
                            // retrieve the data "from" and one to set the "to".
                            var propPromiseResolve = null;
                            var propPromise = new adf.mf.internal.BasePromise(
                              function(resolve, reject)
                              {
                                propPromiseResolve =
                                  function()
                                  {
                                    resolve();
                                  };
                              });

                            // Due to the fact that we have been called back both by the
                            // setAttribute promise object as well as the serialResolve being used
                            // to iterate the children, we have lost the context of the amxNode. Use
                            // a visit to re-obtain the context so that iterating EL expressions may
                            // be correctly evaluated.
                            var nestedVisitNodeFound = rootNode.visit(
                              new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                              function (visitContext, amxNode)
                              {
                                // Get the from expression
                                var fromEL = tagInstance.getAttributeExpression("from");

                                if (fromEL)
                                {
                                  // Get a context free EL expression for the "to" so that we do not
                                  // need to perform another visit to set the value.
                                  var toEl = tagInstance.getAttributeExpression("to")
                                    .toContextFreeExpression();

                                  // Get the value and when it has been retieved the always function
                                  // will be invoked and this is where we will set the value we just
                                  // retrieved.
                                  var getAlways =
                                    function(requestAndResponse)
                                    {
                                      var response = requestAndResponse[1];

                                      // Have the new value now set it based on the EL binding for
                                      // the element
                                      amx.setElValue(
                                        {
                                          "name": toEl.getExpression(),
                                          "expression": toEl,
                                          "value": response[0].value
                                        }).then(propPromiseResolve, propPromiseResolve);
                                    };

                                  amx.getElValue(fromEL).then(getAlways, getAlways);
                                }
                                else
                                {
                                  var from = tagInstance.getAttribute("from", false);
                                  // Get a context free EL expression for the "to" so that we do not
                                  // need to perform another visit to set the value.
                                  var toEl = tagInstance.getAttributeExpression("to")
                                    .toContextFreeExpression();
                                  amx.setElValue(
                                    {
                                      "name": toEl.getExpression(),
                                      "expression": toEl,
                                      "value": from
                                    })
                                    .then(propPromiseResolve, propPromiseResolve);
                                }

                                return adf.mf.api.amx.VisitResult["COMPLETE"];
                              });

                            if (nestedVisitNodeFound == false)
                            {
                              // Resolve the promise if the node could no longer be found
                              propPromiseResolve();
                            }

                            // Return the promise to the calling function (This is within the
                            // amx.serialResolve). It needs this as it will wait for this to finish
                            // before going to the next child in the hiearchy.
                            return propPromise;
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":actionListener")
                          {
                            // Process the action listener tag if there is an amxEventType passed
                            // matches the attribute type
                            if (attrType == amxEventType)
                            {
                              // Create the arrays of paramaters and and paramater types
                              var params     = [];
                              var paramTypes = [];

                              if (amxEvent)
                              {
                                params.push(amxEvent);
                                paramTypes.push(amxEvent[".type"]);
                              }

                              var actionListenerPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the action event. This returns a promise.
                                  var expr = tagInstance.getAttribute("binding");
                                  actionListenerPromise = adf.mf.api.amx.invokeEl(
                                    expr,
                                    params,
                                    null,
                                    paramTypes);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return actionListenerPromise;
                            }
                            else
                            {
                              // Returning null allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":clientListener")
                          {
                            // Process the clientListener tag if there is an amxEventType passed in
                            // matches the attribute type
                            if (attrType === amxEventType)
                            {
                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the clientListener.
                                            adf.mf.internal._processClientListener(attrType, amxEvent,
                                              amxNode, tagInstance);
                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return null;
                            }
                            else
                            {
                              // Returning allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":showPopupBehavior")
                          {
                            // Process the show popup behavior tag if there is an amxEventType
                            // passed in matches the attribute type.
                            if (attrType === amxEventType)
                            {
                              var showPopupPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the show popup behavior. This returns a promise to the calling function.
                                  showPopupPromise = amx.processShowPopupBehavior(amxNode, tagInstance);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return showPopupPromise;
                            }
                            else
                            {
                              // Returning null allows any calling function to resolve immediately
                              return null;
                            }
                          }
                          else if (subTag.getNsPrefixedName() ===
                              adf.mf.api.amx.AmxTag.NAMESPACE_AMX + ":closePopupBehavior")
                          {
                            // Process the close popup behavior tag if there is an amxEventType
                            // passed in matches the attribute type.
                            if (attrType === amxEventType)
                            {
                              var closePopupPromise = null;

                              // Due to the fact that we have been called back both by the
                              // setAttribute promise object as well as the serialResolve being used
                              // to iterate the children, we have lost the context of the amxNode.
                              // Use a visit to re-obtain the context so that iterating EL
                              // expressions may be correctly evaluated.
                              rootNode.visit(
                                new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                                function (visitContext, amxNode)
                                {
                                  // Invoke the close popup behavior. This returns a promise to the
                                  // calling function.
                                  closePopupPromise = amx.processClosePopupBehavior(amxNode, tagInstance);

                                  return adf.mf.api.amx.VisitResult["COMPLETE"];
                                });

                              return closePopupPromise;
                          }
                          else
                          {
                            // Returning null allows any calling function to resolve immediately
                            return null;
                          }
                        }
                        else
                        {
                          // Returning null if there are no match to any tag (this is the catch
                          // all). This allows any calling function to resolve immediately.
                          return null;
                        }
                      });
                    }
                    else
                    {
                      // There are no children so we need to create an empty promise and resolve it.
                      // This is because we will be waiting on this before going to the next phase.
                      childrenPromise = new adf.mf.internal.BasePromise(
                        function(resolve, reject)
                        {
                          resolve();
                        });
                    }
                  });

              // Phase 3) process the listeners. First we will wait for the previous phase to finish
              // before we continue on. Need to create another promise for the listeners. This is
              // required to be able to wait for the this phase to complete.
              var listenerPromiseResolve = null;
              var listenerPromiseReject = null;
              var listenerPromise = new adf.mf.internal.BasePromise(
                function(resolve, reject)
                {
                  listenerPromiseResolve = resolve;
                  listenerPromiseReject = reject;
                });

              // Wait for phase 2 to complete.
              adf.mf.internal.BasePromise.all([childrenPromise])["catch"](
                function()
                {
                  // Bug 16371894: childrenPromise was rejected so we abort further processing and
                  // reject listenerPromise
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_CHILDREN_REJECTED");
                  listenerPromiseReject();
                })
                .then(
                  function()
                  {
                    // Start of Phase 3.
                    // Process the listener if there is an amxEvent passed in.
                    if (amxEvent)
                    {
                      var params     = [];
                      var paramTypes = [];

                      params.push(amxEvent);
                      paramTypes.push(amxEvent[".type"]);

                      // Due to the fact that we have been called back both by the setAttribute
                      // promise object as well as the serialResolve being used to iterate the
                      // children, we have lost the context of the amxNode. Use a visit to re-obtain
                      // the context so that iterating EL expressions may be correctly evaluated.
                      var nestedVisitNodeFound = rootNode.visit(
                        new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                        function (visitContext, amxNode)
                        {
                          var el = amxNode.getAttributeExpression(amxEventType + "Listener");

                          adf.mf.api.amx.invokeEl(
                            el,
                            params,
                            null,
                            paramTypes,
                            function()
                            {
                              listenerPromiseResolve();
                            },
                            function()
                            {
                              listenerPromiseResolve();
                            });

                          return adf.mf.api.amx.VisitResult["COMPLETE"];
                        });

                      if (nestedVisitNodeFound == false)
                      {
                        // Resolve the promise if the node could no longer be found
                        listenerPromiseResolve();
                      }
                    }
                    else
                    {
                      listenerPromiseResolve();
                    }
                  });

              // Phase 4) Required Validations process the required validators. First we will wait
              // for the previous phase to complete.
              adf.mf.internal.BasePromise.all([listenerPromise])["catch"](
                function()
                {
                  // bug 16371894: listenerPromise failed so skip validation.  We are done at this
                  // point so reject promise and clean up
                  adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
                    "adf.mf.internal.amx.processAmxEventImplSerial",
                    "MSG_PROCESS_AMX_EVENT_LISTENERS_REJECTED");
                  perf.stop();
                  adf.mf.internal.popNonBlockingCall();

                  // reject the root promise
                  promiseArgs["reject"]();
                  serialPromiseReject();
              })
              .then(
                function()
                {
                  // detect if we need to refresh the validation message area
                  if (validationGroup !== undefined &&
                      adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
                  {
                    // Due to the fact that we have been called back both by the setAttribute
                    // promise object as well as the serialResolve being used to iterate the
                    // children, we have lost the context of the amxNode. Use a visit to re-obtain
                    // the context so that iterating EL expressions may be correctly evaluated.
                    rootNode.visit(
                      new adf.mf.api.amx.VisitContext({ "amxNodes": [ amxNode ] }),
                      function (visitContext, amxNode)
                      {
                        // this is a required value, so refresh the messages for this group
                        // let the validation context know that this group has been modified
                        // this method is defined in amx-validation.js
                        amx.requiredControlValueChanged(validationGroup);

                        return adf.mf.api.amx.VisitResult["COMPLETE"];
                      });
                  }

                  perf.stop();

                  // resolve the root promise
                  promiseArgs["resolve"]();
                  serialPromiseResolve();
                  adf.mf.internal.popNonBlockingCall();
                });
            }
            else
            {
              perf.stop();

              // If adf.mf.environment.profile.dtMode, just resolve the promise
              promiseArgs["resolve"]();
              serialPromiseResolve();
            }

            return adf.mf.api.amx.VisitResult["COMPLETE"];
          });

        if (nodeFound == false)
        {
          perf.stop();

          // This may happen if an AMX event is processed after a navigation takes place. If so,
          // then just resolve the promise and hide the loading indicator
          promiseArgs["reject"]();
          serialPromiseReject();
        }
      });
  };

  function _getClosestWithClass(domNode, classNameToMatch)
  {
    // Find the closest ancestor (including self that uses the given class name)
    if (domNode == null || (domNode.classList && domNode.classList.contains(classNameToMatch)))
    {
      return domNode;
    }
    else
    {
      return _getClosestWithClass(domNode.parentNode, classNameToMatch);
    }
  }

  /**
   * Internal function to invoke a clientListener.
   * @param {string} type the event type that occurred
   * @param {Object} amxEvent the AMX event that occurred
   * @param {adf.mf.api.amx.AmxNode} amxNode the AMX node of the component that triggered the event
   * @param {adf.mf.internal.amx.AmxTagInstance} clientListenerTagInstance the AMX tag instance of
   *  the clientListener
   */
  adf.mf.internal._processClientListener = function(
    type,
    amxEvent,
    amxNode,
    clientListenerTagInstance)
  {
    var method = clientListenerTagInstance.getAttribute("method");

    if (method != null && method.length > 0)
    {
      try
      {
        // Produce the client event object by copying over the AMX event properties to it.
        var timeStamp = (new Date()).getTime();
        var clientEvent =
        {
          "toString": function()
          {
            var result = "oracle.adfmf.amx.event.ClientEvent{ ";

            // Always start with these properties (in this order):

            // The ID of the AMX Node
            var value = clientEvent["amxNodeId"];
            if (value != null)
              result += "amxNodeId:\"" + value + "\"";
            else
            {
              value = clientEvent["amxNode"];
              if (value != null && value.getId)
                result += "amxNode.getId():\"" + value.getId() + "\"";
              else
                result += "(no amxNode.getId)";
            }

            // The type
            value = clientEvent["type"];
            if (value != null)
              result += ", type:\"" + clientEvent["type"] + "\"";

            // The timeStamp
            value = clientEvent["timeStamp"];
            if (value != null)
              result += ", timeStamp:\"" + clientEvent["timeStamp"] + "\"";

            // Print the rest of the properties (order not guaranteed):
            for (var key in clientEvent)
            {
              if (key != "amxNodeId" && key != "type" && key != "timeStamp")
              {
                value = clientEvent[key];
                var valueType = typeof value;
                if (valueType != "function")
                {
                  result += ", " + key + ":";
                  if (valueType == "string")
                    result += "\"";
                  result += value;
                  if (valueType == "string")
                    result += "\"";
                }
              }
            }

            result += " }";
            return result;
          }
        };

        for (var key in amxEvent)
        {
          clientEvent[key] = amxEvent[key];
        }

        // Add some additional properties if they don't overwrite ones of the same name from the
        // AMX event.
        if (clientEvent["type"] === undefined)
          clientEvent["type"] = type;

        if (clientEvent["amxNode"] === undefined)
          clientEvent["amxNode"] = amxNode;

        if (clientEvent["timeStamp"] === undefined)
          clientEvent["timeStamp"] = timeStamp;

        // Invoke the clientListener's method as a function.
        // If it is not already a function (e.g. a use case for MAX) then we
        // need to sandbox-convert it to a function via new Function:
        if (typeof method != "function")
          method = (new Function("return " + method))();

        method(clientEvent);
      }
      catch (problem)
      {
        var message = "Problem with clientListener type=\"" + type + "\" method=\"" + method + "\":\n\n";
        alert(message + problem);
      }
    }
  };

  /**
   * Internal function to convert bidi types so both bidi and non-bidi equivalents are handled
   * with the same event.
   * @param {string} rawEventType the application developer-specified event type
   * @return {string} the resolved direction-explicit event type
   * @private
   */
  adf.mf.internal._getEventTypeResolvedForBidi = function(rawEventType)
  {
    var resolvedEventType = rawEventType;
    if (resolvedEventType == "swipeStart")
    {
      if (document.documentElement.dir == "rtl")
        resolvedEventType = "swipeRight";
      else
        resolvedEventType = "swipeLeft";
    }
    else if (resolvedEventType == "swipeEnd")
    {
      if (document.documentElement.dir == "rtl")
        resolvedEventType = "swipeLeft";
      else
        resolvedEventType = "swipeRight";
    }
    return resolvedEventType;
  };

  /**
   * Internal function. Calls adf.mf.el.getLocalValue and processes the resulting value, performing
   * any conversions if necessary. Currently converts JS objects with a ".null" property to a null
   * value.
   *
   * @param {string} expr The EL expression
   * @return {Object} the result
   */
  adf.mf.internal.amx.evaluateExpression = function(expr)
  {
    var value = adf.mf.el.getLocalValue(expr);

    return (value != null && value[".null"] === true) ? null : value;
  };

  /**
   * adf.mf.el.getValue wrapper using the promise for asynchronous
   * .then(requestAndResponse)  - response is an array of the values in the
   *                            same order as the el values passed in
   * .catch(requestAndException) - never invoked
   * @param {boolean=} ignoreErrors if true, causes EL errors to be ignored.
   *                   use sparingly for pre-loading data into the client side
   *                   EL cache. Primary goal is to ignore loop based variables
   *                   during pre-fetching of data while not stamping.
   */
  amx.getElValue = function (singleOrArrayOfEls, ignoreErrors)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    if (!adf.mf.environment.profile.dtMode)
    {
          var arrayOfEls = (adf.mf.internal.util.is_array(singleOrArrayOfEls)) ?
            singleOrArrayOfEls : [singleOrArrayOfEls];

      arrayOfEls = arrayToEL (arrayOfEls);

          var perf = adf.mf.internal.perf.startMonitorCall("AMX get EL value",
            adf.mf.log.level.FINER, "amx:getElValue");

      // this function will help convert the response from a call to adf.mf.el.getValue
      // to an array of objects that is exactly the length of the request el.
      // This handles full failure, full success, and partial success situations
      var makeResponseArray = function(partialResponses)
      {
        // in a full failure case, the partialResponses will be undefined
        if (partialResponses === undefined)
        {
          partialResponses = [];
        }

        var partialResponseIndex = 0;

        var resultArray = [];

        for (var i = 0; i < arrayOfEls.length; ++i)
        {
          var currentEl = arrayOfEls[i];
          var val = null;
          // we are guaranteed that any successes will be in the order of the request/ However,
              // we are not guaranteed that the length of the response array is the length of the
              // request array, so we keep state to know which partial response index we are on and
              // we will use that value instead of making the slightly more costly call of
              // getLocalValue
          var isException = true;
              if (partialResponseIndex < partialResponses.length &&
                partialResponses[partialResponseIndex].name == currentEl.getExpression())
          {
            var nvp = partialResponses[partialResponseIndex];
                if (nvp !== null &&
                  nvp[adf.mf.internal.api.constants.EXCEPTION_FLAG_PROPERTY] === undefined)
            {
              isException = false;
              val = nvp.value;
                  // we found a match, so increment the partial response index for when we loop
                  // back around
              ++partialResponseIndex;
            }
          }

          if (isException)
          {
            try
            {
                  // we don't have any data for what this EL is, so call getLocalValue and use what
                  // is cached
              val = adf.mf.el.getLocalValue(currentEl);
            }
            catch(innerEx)
            {
              // if this throws an exception, then do nothing, since val will be undefined
              // and we will set it to null in the check below
              ;
            }
          }

              // make sure we never return an "undefined" value - make sure it is just a json null
              // struct
          if (val === undefined)
          {
            val = {".null" : true};
          }
              resultArray.push(
                { name: currentEl.getExpression(), expression: currentEl, value: val });
        }

        return resultArray;
      };

      var successFunc = function(request,response)
      {
        var resultArray;
        try
        {
          resultArray = makeResponseArray(response);
        }
        finally
        {
          perf.stop();
        }

            resolve([request,resultArray]);
      };

      var failureFunc = function(request,exception)
      {
        var resultArray;
        try
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "getElValue",
                "MSG_GETVALUE_FAILED");

              // For security purposes, only log at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "amx", "getElValue",
                  "Request that failed: " + request + " exception: " + exception);
              }

          resultArray = makeResponseArray();
        }
        finally
        {
          perf.stop();
        }
            resolve([request,resultArray]);
      };

      try
      {
        adf.mf.el.getValue(arrayOfEls, successFunc, failureFunc, ignoreErrors);
      }
      catch (ex)
      {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "getElValue",
              "MSG_GETVALUE_EXCEPTION");

            // For security purposes, only log at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx", "getElValue",
                "EL strings: " + adf.mf.util.stringify(arrayOfEls) + " error: " + ex);
            }

            // call the failure function to handle resolving the promise object
        failureFunc(arrayOfEls, ex);
      }
    }
    else
    {
      // if adf.mf.environment.profile.dtMode then, return the result
      var response = [{value:singleOrArrayOfEls}];
          resolve([singleOrArrayOfEls,response]);
    }
      });
  };

  /**
   * Converts array of strings to array of ELExpressions.
   *
   * @param {type} expressions
   * @returns {Array}
   */
  function arrayToEL (expressions)
  {
    if (expressions[0].tokens)
      return expressions;
    var elExpressions = [];
    for (var i = 0; i < expressions.length; i++)
    {
      elExpressions.push (adf.mf.internal.el.parser.parse (expressions[i]));
    }
    return elExpressions;
  }

  /**
   * adf.mf.el.setValue wrapper using the promise for asynchronous
   */
  amx.setElValue = function(nameValues)
  {
    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    if (!adf.mf.environment.profile.dtMode)
    {
          var perf = adf.mf.internal.perf.startMonitorCall("AMX set EL value",
            adf.mf.log.level.FINER, "amx:setElValue");

      try
      {
        adf.mf.el.setValue(nameValues,
          function(request, response)
          {
            perf.stop();
                resolve([request,response]);
          },
          function(request, exception)
          {
            perf.stop();
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "setElValue",
                  "MSG_SETVALUE_FAILED");

                // For security purposes, only log at FINE level
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                    "amx", "setElValue",
                    "Request arguments: " + adf.mf.util.stringify(nameValues) +
                    " exception: " + exception);
                }

                reject([request,exception]);
          });
      }
      catch (ex)
      {
        perf.stop();

        adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "setElValue",
              "MSG_SETVALUE_EXCEPTION");

            // For security purposes, only log at FINE level
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx", "setElValue",
                "Name: " + nameValues.name + " error: " + ex);
            }

        // TODO: why is this resolve and not reject?
            resolve();
      }
    }
    else
    {
      // if adf.mf.environment.profile.dtMode, just resolve
          resolve();
    }
      });
  };

  amx.loadBundle = function(basename, variable)
  {
    if (!adf.mf.environment.profile.mockData)
    {
      return new adf.mf.internal.BasePromise(
        function(resolve, reject)
        {
      try
      {
            // Kilgore: add a placeholder for the resources to be loaded into:
            adf.mf.el.addVariable(variable, {});
            adf.mf.api.invokeMethod("oracle.adfmf.framework.api.Model", "loadBundle", basename,
              variable,
              function()
        {
              resolve();
            },
            function(req,ex)
        {
                adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "loadBundle",
                  "MSG_LOADBUNDLE_FAILED");

                // Only log the details at a fine level for security reasons
                if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
                {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                    "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
                      " variable: " + variable + " exception: " + ex);
                }

              resolve();
        });
      }
      catch (ex)
      {
            adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "loadBundle",
              "MSG_LOADBUNDLE_EXCEPTION");

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
                  " variable: " + variable + " exception: " + ex);
            }
      }
        });
    }
    else
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "loadBundle",
        "MSG_LOADBUNDLE_SKIPPED");

      // Only log the details at a fine level for security reasons
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "amx.loadBundle", "adf.mf.api.invokeMethod", "Basename: " + basename +
            " variable: " + variable);
      }
      return;
    }
  };

  /**
   * @deprecated
   */
  amx.invokeEl = function(expression, params, returnType, types)
  {
    if (expression && expression.getExpression)
      expression = expression.getExpression ();

    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "amx.invokeEl", "MSG_DEPRECATED", "amx.invokeEl", "adf.mf.api.amx.invokeEl");

    return new adf.mf.internal.BasePromise(
      function(resolve, reject)
      {
    try
    {
      if (expression && !adf.mf.environment.profile.dtMode)
      {
        if (!adf.mf.environment.profile.mockData)
        {
          //TODO: needs to inject correct params, and handle return type
              adf.mf.el.invoke(expression, params, "void", types,
                function(req,res)
          {
                resolve(res);
                },
                function(req,exp)
          {
                reject(exp);
          });
        }
        else
        {
              adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "invokeEl",
                "MSG_AMX_DO_NOT_CALL_ADFMF_EL_INVOKE");

              // For security purposes, only log at FINE level
              if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
              {
                adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                  "amx", "invokeEl",
                  "Deprecated call with expression: " + expression);
              }

              resolve();
        }
      }
      else
      {
            resolve();
      }
    }
    catch (ex)
    {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "invokeEl",
            "MSG_INVOKEEL_EXCEPTION");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "amx", "invokeEl",
              "Call failed. Expression: " + expression  + " error: " + ex);
          }

          resolve();
    }
      });
  };

  /**
   * Utility similar to adf.mf.el.invoke() for invoking an EL method but will refrain execution in
   * environments such as design time previews.
   *
   * @param {string} expression the EL method to invoke
   * @param {Array.<string>} params an array of parameters to send to the method
   * @param {string} returnType null or the return type for the method
   * @param {Array.<string>} paramTypes an array of types for each parameter in the params array
   * @param {function} successCallback optional function to call when the method is invoked
   * @param {function} failureCallback optional function to call if something failed while
   *   attempting to invoke the method
   */
  adf.mf.api.amx.invokeEl = function(expression, params, returnType, paramTypes, successCallback,
    failureCallback)
  {
    try
    {
      if (expression && expression.getExpression)
        expression = expression.getExpression ();

      if (expression && !adf.mf.environment.profile.dtMode)
      {
        if (!adf.mf.environment.profile.mockData)
        {
          //TODO: needs to inject correct params, and handle return type
          if (returnType == null)
            returnType = "void";
          adf.mf.el.invoke(expression, params, returnType, paramTypes, successCallback,
            failureCallback);
        }
        else
        {
          adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "invokeEl",
            "MSG_AMX_DO_NOT_CALL_ADFMF_EL_INVOKE");

          // For security purposes, only log at FINE level
          if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
          {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
              "adf.mf.api.amx", "invokeEl",
              "invokeEl called in mock mode with expression: " + expression);
          }

          if (successCallback)
            successCallback();
        }
      }
      else
      {
        if (successCallback)
          successCallback();
      }
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "invokeEl",
        "MSG_INVOKEEL_EXCEPTION");

      // For security purposes, only log at FINE level
      if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
      {
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "adf.mf.api.amx", "invokeEl",
          "Call failed. Expression: " + expression + " error: " + ex);
      }
      if (failureCallback)
        failureCallback();
    }
  };

  /**
   * Take the varName and varValue and store it for this domNode.
   */
  amx.storeVariable = function(domNode, varName, varValue) // TODO is this still used?
  {
    var amxVar = adf.mf.internal.amx._getNonPrimitiveElementData(domNode, "amxVar");
    domNode.classList.add("amxVar");
    if (!amxVar)
    {
      amxVar = {};
      adf.mf.internal.amx._setNonPrimitiveElementData(domNode, "amxVar", amxVar);
    }
    amxVar.name = varName;
    amxVar.value = varValue;
  };

  //FIXME: remove this (for backward compability with the dvt team)
  amx.storeVarNameValue = amx.storeVariable; // TODO is this still used?

  /**
   * Restore iterator stamp variables for use during listener invocation.
   * May be used by component authors to reset the EL context during a callback.
   * @return a non-null (but possibly empty) array of amxVar data objects that were restored
   * @see cleanVariables
   * @deprecated use adf.mf.internal.amx.restoreContext instead
   */
  amx.restoreVariables = function(domNodes) // TODO is this still used?
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "restoreVariables", "MSG_DEPRECATED", "amx.restoreVariables",
      "adf.mf.internal.amx.restoreContext");

    if (domNodes.length == 1)
    {
      return adf.mf.internal.amx.restoreContext(domNodes);
    }
    else
    {
      var results = [];
      for (var i = 0, size = domNodes.length; i < size; ++i)
      {
        results = results.concat(adf.mf.internal.amx.restoreContext(domNodes[i]));
      }
      return results;
    }
  };

  /**
   * Use to restore rendering context of a node post-rendering.
   * May be used by component authors to reset the EL context during a callback.
   * @param {DOMNode} domNode the HTML DOM node to restore the context of.
   * @return a non-null (but possibly empty) array of amxVar data objects that were restored
   * @see cleanVariables
   */
  adf.mf.internal.amx.restoreContext = function(domNode) // TODO is this still used?
  {
    // TODO: consider allowing the type handlers for the DOM nodes
    // to have hooks for restoring the context instead of hard-coding
    // this to only support AMX variables that were introduced during
    // rendering.
    var amxVars = getAmxVars(domNode);
    for (var i = 0, size = amxVars.length; i < size; ++i)
    {
      var amxVar = amxVars[i];
      adf.mf.el.addVariable(amxVar.name, amxVar.value);
    }
    return amxVars;
  };

  /**
   * @deprecated use adf.mf.internal.amx.tearDownContext instead
   */
  amx.cleanVariables = function(varsToClean) // TODO is this still used?
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "cleanVariables", "MSG_DEPRECATED", "amx.cleanVariables",
      "adf.mf.internal.amx.tearDownContext");

    adf.mf.internal.amx.tearDownContext(varsToClean);
  };

  /**
   * Tear down the context setup by adf.mf.internal.amx.restoreContext.
   * @param {Object} contextResult the value returned from adf.mf.internal.amx.restoreContext
   * @see adf.mf.internal.amx.restoreContext
   */
  adf.mf.internal.amx.tearDownContext = function(contextResult) // TODO is this still used?
  {
    for (var i = 0, size = contextResult.length; i < size; ++i)
    {
      adf.mf.el.removeVariable(contextResult[i].name);
    }
  };


  /**
   * @deprecated
   */
  amx.isValueFalse = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "isValueFalse",
      "MSG_DEPRECATED", "amx.isValueFalse", "adf.mf.api.amx.isValueFalse");
    return adf.mf.api.amx.isValueFalse.apply(this, arguments);
  };

  /**
   * Returns true if the value is boolean false or string "false".
   * If undefined, returns false.
   */
  adf.mf.api.amx.isValueFalse = function(value)
  {
    if (typeof value !== "undefined")
    {
      if (value === false || value === "false" || value === 0 || value === "0")
      {
        return true;
      }
      else
      {
        return false;
      }
    }
    else
    {
      return false;
    }
  };

  /**
   * @deprecated
   */
  amx.isValueTrue = function(value)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "isValueTrue",
      "MSG_DEPRECATED", "amx.isValueTrue", "adf.mf.api.amx.isValueTrue");
    return adf.mf.api.amx.isValueTrue.apply(this, arguments);
  };

  /**
   * Returns true if the value is boolean true or string "true".
   * If undefined, returns false.
   */
  adf.mf.api.amx.isValueTrue = function(value)
  {
    if (typeof value !== "undefined")
    {
      if (value === true || value === "true" || value === 1 || value === "1")
      {
        return true;
      }
      else
      {
        return false;
      }
    }
    else
    {
      return false;
    }
  };

  /**
   * Return the list of var object {name:..,value:..} starting from this domNode up to the root document.
   */
  function getAmxVars(domNode) // TODO is this still used?
  {
    var amxVars = [];
    _getAmxVars(amxVars, domNode);
    return amxVars;
    }

  function _getAmxVars(amxVars, node)
    {
    if (node != null)
    {
      if (node.classList.contains("amxVar"))
      {
        amxVars.push(adf.mf.internal.amx._getNonPrimitiveElementData(node, "amxVar"));
  }
      _getAmxVars(amxVars, node.parentNode);
    }
  }

  // ------ API for TypeHandlers ------ //
  /**
   * Function called for each time a page has been loaded. Walks the entire tag tree and
   * performs any necessary initialization.
   * @param {adf.mf.api.amx.AmxTag} rootTag the root AMX tag of the page
   * @return {Object} Promise object that is resolved once the processing has been
   *         completed.
   * @private
   */
  adf.mf.internal.amx._preProcessTagTree = function(rootTag)
  {
    var fileArray = [];

    var perf = adf.mf.internal.perf.startMonitorCall("Process tag tree", adf.mf.log.level.FINER, "adf.mf.internal.amx._preProcessTagTree");
    findResourcesForTag(rootTag, fileArray);

    // Create a promise to load all the resources serially.
    var loadResourcePromise = loadFilesSequentialPromise(fileArray);

    // Hook to load additional files for the page when in automation mode. This function
    // will only exist if amx-automation.js has been loaded
    if (adf.mf.internal.amx.getAutomationResourcesForHierarchy != null)
    {
      // Save off the base promise
      var basePromise = loadResourcePromise;

      // Setup a new promise to return
      loadResourcePromise = new adf.mf.internal.BasePromise(
        function (resolve, reject)
        {
          // Wait for the base files to load
          basePromise.then(
            function()
            {
              // Now that the type handlers have loaded, load any needed automation files
              var automationFiles = adf.mf.internal.amx.getAutomationResourcesForHierarchy(rootTag);
              loadFilesSequentialPromise(automationFiles).then(
                function()
                {
                  // Resolve the promise for performance and the code waiting on the processing
                  resolve();
                });
            });

        });
    }

    return loadResourcePromise.then(
      function()
      {
        perf.stop();
      });
  };

  function processCssLinks(amxNode)
  {
    cssNodes = [];

    // We build the list of cssNodes
    adf.mf.internal.amx._each(amxNode.nodes, function(idx, node)
    {
      if (node.tagName === "amx:CSSInclude") // TODO is this still valid?
      {
        cssNodes.push(node);
      }
    });

    // We add them to the <head /> document
    // TODO: needs to check if the css was already added
    // TODO: probably needs to try to return a promise that will resolve when the css is loaded.
    adf.mf.internal.amx._each(cssNodes, function(idx, cssNode)
    {
      amx.includeCss(cssNode.file);
    });
  }

  function getNodeTypeHandler(amxNode)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle",
      adf.mf.log.level.SEVERE, "getNodeTypeHandler", "MSG_AMX_GET_NODE_TYPE_HANDLER_DEPRECATED");

    return amxNode.getTypeHandler();
  }
  amx.getNodeTypeHandler = getNodeTypeHandler;

  // ------ TypeHandler ------ //

  /**
   * Abstraction for TypeHandler implementations.
   * To extend TypeHandler, use:
   * <pre><code>(function()
   *   {
   *     // TypeHandler for custom "x" tags:
   *     var x = adf.mf.api.amx.TypeHandler.register("http://xmlns.example.com/custom", "x");
   *
   *     x.prototype.render = function(amxNode)
   *     {
   *       var rootElement = document.createElement("div");
   *       rootElement.appendChild(document.createTextNode("Hello World"));
   *       return rootElement;
   *     };
   *
   *     // TypeHandler for custom "y" tags:
   *     var y = adf.mf.api.amx.TypeHandler.register("http://xmlns.example.com/custom", "y");
   *
   *     y.prototype.render = function(amxNode)
   *     {
   *       var rootElement = document.createElement("div");
   *       rootElement.appendChild(document.createTextNode("Goodbye World"));
   *       return rootElement;
   *     };
   *
   *   })();</code></pre>
   * @constructor adf.mf.api.amx.TypeHandler
   * @augments adf.mf.api.AdfObject
   */
  function TypeHandler()
  {
    this.Init();
  }

  // make adf.mf.api.amx.TypeHandler a subclass of adf.mf.api.AdfObject
  adf.mf.api.amx.TypeHandler = TypeHandler;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.TypeHandler, adf.mf.api.AdfObject, "adf.mf.api.amx.TypeHandler");

  /**
   * Initializes the TypeHandler class
   * @protected
   */
  adf.mf.api.amx.TypeHandler.InitClass = function()
  {
    TypeHandler._classDictionary = {};
    TypeHandler._instanceDictionary = {};
  };

  /**
   * Register a TypeHandler class with a tag namespace and name.
   * @param {string} theNamespace the xmlns for the tag
   * @param {string} tagName the name of the tag (no namespace)
   * @param {adf.mf.api.amx.TypeHandler=} precreatedClass optional pre-created class to register
   * @return {function} the registered adf.mf.api.amx.TypeHandler subclass so that prototype functions can be added
   */
  adf.mf.api.amx.TypeHandler.register = function(theNamespace, tagName, precreatedClass)
  {
    // make sure that our class is initialized, since we are using a Factory Method
    adf.mf.api.AdfObject.ensureClassInitialization(TypeHandler);
    var registeredClass = precreatedClass;

    if (theNamespace != null && theNamespace.indexOf(":") != -1 && tagName != null)
    {
      if (registeredClass == null)
      {
        // Create the new class and make it inherit from adf.mf.api.amx.TypeHandler:
        registeredClass = function RegisteredTypeHandler()
        {
          this.Init();
        };
        adf.mf.api.AdfObject.createSubclass(registeredClass, adf.mf.api.amx.TypeHandler,
          "TypeHandler[" + theNamespace + ":" + tagName + "]");
      }

      // Make the association so we can find the class:
      var id = theNamespace + ":" + tagName;
      this._classDictionary[id] = registeredClass;
    }
    else // invalid registration, do not register the TypeHandler class
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "adf.mf.api.amx.TypeHandler.register", "MSG_INVALID_TYPE_HANDLER_REGISTRATION",
        theNamespace, tagName);
    }

    return registeredClass;
  };

  /**
   * Renders the initial set of DOM for this component.
   * @param {adf.mf.api.amx.AmxNode} amxNode an object that describes the instance of the component to be rendered
   * @param {string} id the id of this component
   */
  adf.mf.api.amx.TypeHandler.prototype.render = function(amxNode, id)
  {
    if (this.create)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle",
        adf.mf.log.level.SEVERE, "render", "MSG_DEPRECATED", "typeHandler.render",
        "Use typeHandler.prototype.render instead for " + amxNode.getTag().getNsPrefixedName());
      return this.create(amxNode, id);
    }
    else
    {
      var tag = amxNode.getTag();
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "render",
        "MSG_NO_RENDERER", tag.getNsPrefixedName());

      var rootElement = document.createElement("div");
      rootElement.appendChild(document.createTextNode(
        "Missing prototype.render function in the TypeHandler for the " + tag.getName() +
        " tag in the " + tag.getNamespace() + " namespace; id = " + id));

      return rootElement;
    }
  };

  /**
   * Function that checks to see if the attributes that have changed may be handled
   * by the refresh function. May be overridden to make custom changes to the children
   * due to an attribute change. If the sub-class only needs to react to individual
   * attribute changes, it may override only the attributeChangeResult function
   * instead.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  adf.mf.api.amx.TypeHandler.prototype.updateChildren = function(
    amxNode,
    attributeChanges)
  {
    var changedAttributes = attributeChanges.getChangedAttributeNames();
    var result = adf.mf.api.amx.AmxNodeChangeResult["NONE"];

    for (var i = 0, num = changedAttributes.length; i < num; ++i)
    {
      // The AmxNodeChangeResult is order by the least amount of changes as the lowest
      // number, so using the maximum return value will provide the desired behavior
      result = Math.max(result,
        this.attributeChangeResult(amxNode, changedAttributes[i], attributeChanges));
    }

    return result;
  };

  /**
   * Checks if the type handler can handle updating the DOM in response to a changed
   * attribute. Called from updateChildren. Currently the base implementation supports
   * styleClass and inlineStyle changes to be handled by the refresh function.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {string} attributeName the name of the attribute to check
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @return {number} one of the adf.mf.api.amx.AmxNodeChangeResult constants.
   */
  adf.mf.api.amx.TypeHandler.prototype.attributeChangeResult = function(
    amxNode,
    attributeName,
    attributeChanges)
  {
    return attributeName == "styleClass" || attributeName == "inlineStyle" ?
      adf.mf.api.amx.AmxNodeChangeResult["REFRESH"] :
      adf.mf.api.amx.AmxNodeChangeResult["RERENDER"];
  };

  /**
   * Called to refresh the HTML of a node. This method is called after the updateChildren
   * method and should be implemented by type handlers that wish to update their DOM in
   * response to a change.
   *
   * @param {adf.mf.api.amx.AmxNode} amxNode AMX node that has changed
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {(adf.mf.api.amx.AmxDescendentChanges|null)} descendentChanges the changes for any
   *        descendent nodes that need to be refreshed.
   */
  adf.mf.api.amx.TypeHandler.prototype.refresh = function(
    amxNode,
    attributeChanges,
    descendentChanges)
  {
    var styleClassChanged = attributeChanges.hasChanged("styleClass");
    var inlineStyleChanged = attributeChanges.hasChanged("inlineStyle");

    if (styleClassChanged || inlineStyleChanged)
    {
      var element = document.getElementById(amxNode.getId());
      if (element != null)
      {
        if (styleClassChanged)
        {
          this._refreshStyleClass(amxNode, attributeChanges, element);
        }

        if (inlineStyleChanged)
        {
          this._refreshInlineStyle(amxNode, attributeChanges, element);
        }
      }
    }
  };

  /**
   * Allows a DOM element to be associated to the AMX node. Necessary for
   * AmxNode.getAmxNodeForElement to function. Calling this method is only necessary
   * if the element is located outside of its parent element or under a different node's
   * element (element is not a direct descendent of a node rendered for the amxNode's
   * root element or its own children elements).
   * @param {adf.mf.api.amx.AmxNode} amxNode the AMX node
   * @param {object} elem the DOM element
   */
  adf.mf.api.amx.TypeHandler.prototype.associateElementWithAmxNode = function(amxNode, elem)
  {
    adf.mf.internal.amx._setNonPrimitiveElementData(elem, "amxNode", amxNode);
    elem.classList.add("amx-node");
  };

  /**
   * Updates the style class of the root DOM element. This function will use the difference from
   * the old value and the new value to determine what style classes to add and which to remove,
   * so all style classes that were added by other code (like the render function of AmxNode) will
   * not be affected.
   *
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {Element} element the DOM element to which to apply the changes
   * @return {boolean} true if the changes were made
   */
  adf.mf.api.amx.TypeHandler.prototype._refreshStyleClass = function(
    amxNode,
    attributeChanges,
    element)
  {
    var oldValue = attributeChanges.getOldValue("styleClass");
    var newValue = amxNode.getAttribute("styleClass");

    oldValue = oldValue == null || oldValue == "" ? [] : oldValue.split(" ");
    newValue = newValue == null || newValue == "" ? [] : newValue.split(" ");

    var i, num, sc;
    var classList = element.classList;

    for (i = 0, num = oldValue.length; i < num; ++i)
    {
      sc = oldValue[i];
      if (newValue.indexOf(sc) == -1 && sc != "")
      {
        classList.remove(sc);
      }
    }

    for (i = 0, num = newValue.length; i < num; ++i)
    {
      sc = newValue[i];
      if (oldValue.indexOf(sc) == -1 && sc != "")
      {
        classList.add(sc);
      }
    }
  };

  /**
   * Called from the refresh function to update the
   * inline style of the root DOM element. This function will use the difference from the old value
   * and the new value to determine what changes to apply. So all style
   * that was added by other code (like the render function of AmxNode) will not be
   * affected.
   *
   * @param {adf.mf.api.amx.AmxAttributeChange} attributeChanges the changed attributes
   * @param {Element} element the DOM element to which to apply the changes
   * @return {boolean} true if the changes were made
   */
  adf.mf.api.amx.TypeHandler.prototype._refreshInlineStyle = function(
    amxNode,
    attributeChanges,
    element)
  {
    var oldValue = attributeChanges.getOldValue("inlineStyle");
    var newValue = amxNode.getAttribute("inlineStyle");
    var style;

    if (adf.mf.environment.profile.dtMode)
    {
      // if adf.mf.environment.profile.dtMode, remove el
      newValue = newValue.replace(/#\{(.*?)\}/ig, ' ');
    }

    var newStyle = null;
    if (oldValue != null && oldValue != "")
    {
      if (style == oldValue)
      {
        newStyle = newValue;
      }
      else
      {
        style = element.getAttribute("style") || "";
        index = style.indexOf(oldValue);
        if (index >= 0)
        {
          var prefix;
          if (index == 0)
          {
            prefix = ""
          }
          else
          {
            prefix = style.substr(0, index);
          }

          var suffix;
          if (index == oldValue.length - 1)
          {
            suffix = "";
          }
          else
          {
            suffix = style.substr(index + oldValue.length);
          }

          newStyle = prefix + newValue + suffix;
        }
      }
    }
    else if (newValue != null && newValue != "")
    {
      style = element.getAttribute("style") || "";
      if (style.length > 0)
      {
        if (style.charAt(style.length - 1) === ";")
        {
          newStyle = style + newValue;
        }
        else
        {
          newStyle = style + ";" + newValue;
        }
      }
      else
      {
        newStyle = newValue;
      }
    }

    if (newStyle != null)
    {
      // Use setAttribute and not style.cssText as Safari will change the style attribute
      // and 'sanitize' the value. While not a bad thing, causes the ability to compare
      // the new value and the old value to be broken. If the style is set via the attribute,
      // the formatting is kept and the value can be used for comparisson
      element.setAttribute("style", newStyle);
    }
  };

  /**
   * DO NOT USE; this method is experimental and will be removed without notice.
   * @param {adf.mf.api.amx.AmxNode} amxNode an object that describes the instance of the component
   * @param {string} amxNodeId the id of this component
   * @param {string} eventType the event type
   * @param {HTMLElement} rootElement the root element of the component
   * @param {boolean} useDocument in some cases, the event node is the document
   */
  adf.mf.api.amx.TypeHandler.prototype.__experimentalCLAssociation = function(
    amxNode,
    amxNodeId,
    eventType,
    rootElement,
    useDocument)
  {
    // DO NOT USE; this method is experimental and will be removed without notice.
    // This is a temporary experiment for TypeHandler-speicfic clientListener implementation.
    // The idea is this can be overridden to connect a listener to a DOM element other than the
    // root (the default element bound to the event).
    adf.mf.api.amx.addBubbleEventListener(
      useDocument ? document : rootElement,
      eventType,
      adf.mf.api.amx.TypeHandler._experimentalCLHandler,
      {
        "amxNode": amxNode,
        "amxNodeId": amxNodeId,
        "eventType": eventType
      });

    if (useDocument)
    {
      // If rootElement is document then the listener could leak so we have to
      // define an __amxRemoveFunctions entry so that it will be cleaned up when
      // the real element is removed:
      if (rootElement.__amxRemoveFunctions == null)
        rootElement.__amxRemoveFunctions = [];
      rootElement.__amxRemoveFunctions.push(
        function()
        {
          adf.mf.api.amx.removeBubbleEventListener(
            document,
            eventType,
            adf.mf.api.amx.TypeHandler._experimentalCLHandler);
        });
    }
  };

  /**
   * DO NOT USE; this method is experimental and will be removed without notice.
   * @param {Object} domEvent the browser's DOM event object
   */
  adf.mf.api.amx.TypeHandler._experimentalCLHandler = function(domEvent)
  {
    var data = domEvent.data;
    var amxNode = data["amxNode"];
    var amxNodeId = data["amxNodeId"];
    var eventType = data["eventType"];
    var event = new adf.mf.api.amx.DomEvent(amxNodeId, eventType, domEvent);
    adf.mf.api.amx.processAmxEvent(amxNode, eventType, undefined, undefined, event, function() {});
  };

  /**
   * Gets the attribute to be used for validation. If a non-null value is returned, the
   * AmxNode's storeModifyableEl method will be called for this attribute, so it is not necessary
   * for the type handler to manually call this method.
   *
   * @return {string|null} the name of the attribute to use for validation. By default null is
   *         returned.
   */
  adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute = function()
  {
    return null;
  };

  // ------ /TypeHandler ------ //

  // ------ AmxNode enums ------ //
  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeStates =
  {
    /** Initial state. The node has been created but not populated */
    "INITIAL": 0,
    /** EL based attributes needed for rendering have not been fully loaded yet */
    "WAITING_ON_EL_EVALUATION": 1,
    /** EL attributes have been loaded, the node has not yet been rendered */
    "ABLE_TO_RENDER": 2,
    /**
     * The EL is not fully loaded but the node has partially rendered itself (reserved for future
     * use)
     */
    "PARTIALLY_RENDERED": 3,
    /** The node has been fully rendered */
    "RENDERED": 4,
    /** The node is not to be rendered */
    "UNRENDERED": 5,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the state label for a state value
     *
     * @param {int} state one of the node state values
     * @return {string|null} the label or null if not a valid state
     */
    getLabelForValue: function(state)
    {
      for (var label in adf.mf.api.amx.AmxNodeStates)
      {
        if (adf.mf.api.amx.AmxNodeStates[label] == state)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeChangeResult =
  {
    /**
     * Allows a type handler that is rendered to take no action in response to an attribute change
     * on a non-rendered descendent AMX node.
     */
    "NONE": 0,

    /**
     * The type handler is able to handle the change to AMX node and its children AMX nodes and
     * will be able to update DOM in response to a change after a call to the refresh method.
     */
    "REFRESH": 1,

    /**
     * The type handler is able to handle the change to the AMX node and its children AMX nodes,
     * but the HTML should only be recreated, there is no need to modify the node hierarchy. The
     * refresh method will not be called on the type handler.
     */
    "RERENDER": 2,

    /**
     * The type handler cannot handle the change. The HTML as well as the
     * node hierarchy should be recreated. This value may only be returned from the updateChildren
     * method on a type handler and cannot be returned from the getDescendentChangeAction method.
     */
    "REPLACE": 3,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the label for a constant value
     *
     * @param {int} result one of the change result values
     * @return {string|null} the label or null if not a valid change result
     */
    getLabelForValue: function(result)
    {
      for (var label in adf.mf.api.amx.AmxNodeChangeResult)
      {
        if (adf.mf.api.amx.AmxNodeChangeResult[label] == result)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeCreateChildrenNodesResult =
  {
    /**
     * The type handler could not create the children yet.
     */
    "NONE": 0,

    /**
     * The type handler created the children.
     */
    "HANDLED": 1,

    /**
     * The type handler generated a placeholder to be shown until the real children can be created.
     */
    "DEFERRED": 2,

    /**
     * Method that may be used for debugging (should not be used for normal usage) to get
     * the label for a constant value
     *
     * @param {int} result one of the children node result values
     * @return {string|null} the label or null if not a valid result
     */
    getLabelForValue: function(result)
    {
      for (var label in adf.mf.api.amx.AmxNodeCreateChildrenNodesResult)
      {
        if (adf.mf.api.amx.AmxNodeCreateChildrenNodesResult[label] == result)
        {
          return label;
        }
      }

      return null;
    }
  };

  /**
   * @namespace
   */
  adf.mf.api.amx.AmxNodeNotifications =
  {
    /**
     * Notification type broadcast to a type handler when an AMX node is about to be removed from
     * the node hierarchy.
     */
    "PRE_REMOVAL": 0,
    /**
     * Notification type broadcast to a type handler when an AMX node is going from a rendered to an
     * unrendered state.
     */
    "UNRENDERED": 1
  };
  // ------ /Node enums ------ //

  // ------ Visit ------ //
  /**
   * Constant values for visit results.
   * @namespace
   */
  adf.mf.api.amx.VisitResult =
  {
    /** Continue visiting the children of the current node. */
    "ACCEPT": 0,
    /** Skip the children of the current node but continue visiting. */
    "REJECT": 1,
    /** Stop visiting */
    "COMPLETE": 2
  };

  /**
   * A visit context object to direct tree visitation.
   * <p>
   * Parameter properties:
   * <dl>
   *   <dt>amxNodes</dt>
   *   <dd>An array of AMX nodes to visit</dd>
   * </dl>
   * @param {{amxNodes: Array.<adf.mf.api.amx.AmxNode>, data: Object}} params An object
   *        containing key/value pairs to populate the visit context. If the "data" object
   *        is passed, it may be retrieved in the callback via the "data" field value.
   * @constructor adf.mf.api.amx.VisitContext
   */
  function VisitContext(params)
  {
    this._walk = null;
    this._visit = null;

    if (params != null)
    {
      // Allow custom data to be stored on the context
      this.data = params["data"];

      var nodes = params["amxNodes"];
      if (nodes != null)
      {
        this._visit = nodes;
        this._walk = [];
        for (var i = 0, size = nodes.length; i < size; ++i)
        {
          for (var n = nodes[i]; n != null; n = n.getParent())
          {
            if (this._walk.indexOf(n) >= 0)
            {
              break;
            }

            this._walk.push(n);
          }
        }
      }
    }
    else
    {
      this.data = null;
    }
  }

  adf.mf.api.amx.VisitContext = VisitContext;

  adf.mf.api.amx.VisitContext.prototype =
  {
    /**
     * Get if all nodes should be visited.
     * @return {boolean} true if all nodes should be visited
     */
    isVisitAll: function()
    {
      return this._visit == null;
    },

    /**
     * Get the nodes that should be walked during visitation. This list does not necessarily
     * include the nodes that should be visited (callback invoked).
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that should be walked.
     */
    getNodesToWalk: function()
    {
      return this._walk;
    },

    /**
     * Get the list of nodes to visit.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of nodes that should be visited.
     */
    getNodesToVisit: function()
    {
      return this._visit;
    },

    /**
     * Convenience function to determine what child AMX nodes, including facets, if any,
     * should be walked of the given parent AMX node. Allows for type handlers to optimize how to
     * walk the children if not all are being walked.
     *
     * @param {adf.mf.api.amx.AmxNode} parentNode the parent node
     * @return {(Array.<adf.mf.api.amx.AmxNode>|null)} array of the children to walk, may be empty.
     *         returns null if all the children should be visited (isVisitAll is true)
     */
    getChildrenToWalk: function(parentNode)
    {
      if (this._walk == null)
      {
        return null;
      }

      return this._walk.filter(
        function(node, index, array)
        {
          return node.getParent() == parentNode;
        });
    }
  };
  // ------ /Visit ------ //

  // ------ AMX Collection change ------ //
  function AmxCollectionChange(data)
  {
    this._itemized = data["itemized"];
    this._hasMoreKeysChanged = data["hasMoreKeysChanged"] == true;

    if (this._itemized)
    {
      this._created = [];
      this._deleted = [];
      this._updated = [];
      this._dirtied = [];

      var i;
      var size;

      var created = data["created"];
      if (created != null)
      {
        for (i = 0, size = created.length; i < size; ++i)
        {
          var obj = created[i];
          this._created.push(obj["key"]);
          // Note: In a future version we may need to pull more information off of the "obj"
        }
      }

      var updated = data["updated"];
      if (updated != null)
      {
        for (i = 0, size = updated.length; i < size; ++i)
        {
          this._updated.push(updated[i]);
        }
      }

      var deleted = data["deleted"];
      if (deleted != null)
      {
        for (i = 0, size = deleted.length; i < size; ++i)
        {
          this._deleted.push(deleted[i]);
        }
      }

      var dirtied = data["dirtied"];
      if (dirtied != null)
      {
        for (i = 0, size = dirtied.length; i < size; ++i)
        {
          this._dirtied.push(dirtied[i]);

          // It is possible for the embedded side to send both dirtied and updated
          // at the same time. Check for this, and remove the key from the updated
          // if present
          var index = this._updated.indexOf(dirtied[i]);
          if (index >= 0)
          {
            this._updated.splice(index, 1);
          }
        }
      }
    }
  }

  adf.mf.api.amx.AmxCollectionChange = AmxCollectionChange;

  AmxCollectionChange.prototype =
  {
    /**
     * Return true if the flag has changed marking if more rows are available or not
     * has changed state.
     */
    hasMoreKeysChanged: function()
    {
      return this._hasMoreKeysChanged;
    },

    /**
     * Return if the change to the collection may be itemized
     * @return {boolean} true if the change may be itemized
     */
    isItemized: function()
    {
      return this._itemized;
    },

    /**
     * Get an array of the keys that were created.
     * @return {Array.<string>|null} created keys or null if the change cannot be itemized
     */
    getCreatedKeys: function()
    {
      return this._itemized ? this._created : null;
    },

    /**
     * Get an array of the keys that were removed.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getDeletedKeys: function()
    {
      return this._itemized ? this._deleted : null;
    },

    /**
     * Get an array of the keys that were updated.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getUpdatedKeys: function()
    {
      return this._itemized ? this._updated : null;
    },

    /**
     * Get an array of the keys that were dirtied.
     * @return {Array.<string>|null} the array of keys or null if the change cannot be itemized
     */
    getDirtiedKeys: function()
    {
      return this._itemized ? this._dirtied : null;
    }
  };
  // ------ /AMX Collection change ------ //


  // ------ AMX Attribute change ------ //
  /**
   * Object to allow type handlers to determine the changes that have been made during a data change
   * event.
   */
  function AmxAttributeChange()
  {
    this._changedAttributes = {};
    this._oldValues = {};
    this._length = 0;
    this._collectionChanges = {};
    this._custom = {};
  }
  adf.mf.api.amx.AmxAttributeChange = AmxAttributeChange;

  AmxAttributeChange.prototype =
  {
    /**
     * Get a custom value stored by setCustomValue
     * @param {string} key the key
     * @return {(Object|null)} the object or null if not set
     */
    getCustomValue: function(key)
    {
      return this._custom[key];
    },

    /**
     * Set a custom value. This is useful for a type handler to "pass" information between the
     * updateChildren method and the refresh method.
     * @param {string} key the key
     * @param {Object} value the value to store
     */
    setCustomValue: function(key, value)
    {
      return this._custom[key] = value;
    },

    /**
     * Get the names of the attributes that have been affected during the current change.
     * @return {Array.<string>} array of the attribute names
     */
    getChangedAttributeNames: function()
    {
      return Object.keys(this._changedAttributes);
    },

    /**
     * Check if the attribute change is a collection change
     * @param {string} name the attribute name
     * @return {boolean} true if the change is a collection change
     */
    isCollectionChange: function(name)
    {
      return this._collectionChanges[name] != null;
    },

    /**
     * Get the collection model change information for an attribute
     * @param {string} name the attribute name
     * @return {(adf.mf.api.amx.AmxCollectionChange|null)} the change object if available
     */
    getCollectionChange: function(name)
    {
      var change = this._collectionChanges[name];
      return change == null ? null : change;
    },

    /**
     * Get the value of the attribute before the change was made
     * @param {string} name the attribute name
     */
    getOldValue: function(name)
    {
      return this._oldValues[name];
    },

    /**
     * Check if the attribute with the given name has changed.
     * @param {string} name the attribute name
     */
    hasChanged: function(name)
    {
      return this._changedAttributes[name] == true;
    },

    /**
     * Get the number of attribute changes
     */
    getSize: function()
    {
      return this._length;
    },

    /**
     * Mark an attribute as having been changed
     * @param {string} name the attribute name
     * @param {Object} oldValue the attribute's old value
     * @param {(adf.mf.api.amx.AmxCollectionChange|null)} collectionChanges the collection model
     *        change information if applicable
     * @ignore
     */
    __addChangedAttribute: function(name, oldValue, collectionChanges)
    {
      if (this.hasChanged(name) == false)
      {
        ++this._length;
        this._changedAttributes[name] = true;
      }
      this._oldValues[name] = oldValue;

      if (collectionChanges != null)
      {
        this._collectionChanges[name] = collectionChanges;
      }
    }
  };
  // ------ /AMX Attribute change ------ //

  // ------ AMX children changes ------ //
  function AmxDescendentChanges()
  {
    this._amxNodes = [];
    this._amxNodeChanges = {};
    this._previousStates = {};
  }

  adf.mf.api.amx.AmxDescendentChanges = AmxDescendentChanges;

  AmxDescendentChanges.prototype =
  {
    /**
     * Get the un-rendered changed descendent AMX nodes.
     * @return {Array.<adf.mf.api.amx.AmxNode>} array of AMX nodes that have changed
     */
    getAffectedNodes: function()
    {
      return this._amxNodes;
    },

    /**
     * Get the changes for a given AMX node.
     * @param {adf.mf.api.amx.AmxNode} amxNode the descendent AMX node that was changed
     * @return {adf.mf.api.amx.AmxAttributeChange} the changes that were made to the descendent node
     */
    getChanges: function(amxNode)
    {
      var id = amxNode.getId();
      return this._amxNodeChanges[id];
    },

    /**
     * Get the state of the descendent node before the changes were applied.
     * @param {adf.mf.api.amx.AmxNode} amxNode the descendent AMX node that was changed
     * @return {number} one of the adf.mf.api.amx.AmxNodeStates constant values
     */
    getPreviousNodeState: function(amxNode)
    {
      var id = amxNode.getId();
      return this._previousStates[id];
    },

    __addAmxNode: function(
      amxNode,
      previousState,
      attributeChanges)
    {
      var id = amxNode.getId();
      this._amxNodes.push(amxNode);
      this._previousStates[id] = previousState;
      this._amxNodeChanges[id] = attributeChanges;
    }
  };
  // ------ /AMX children changes ------ //

})();
// ------ /amx UI ------ //

// --------- amx UA --------- //
(function()
{
  var _hasTouch = null;

  amx.hasTouch = function()
  {
    if (_hasTouch === null)
    {
      _hasTouch = isEventSupported("touchstart");

      if (_hasTouch &&
        adf.mf.environment.profile.mockData &&
        navigator.userAgent.indexOf("Windows") != -1)
      {
        // Mock mode for browsers (e.g. Chrome) on UWP is better when using mouse events:
        _hasTouch = false;
      }
    }
    return _hasTouch;
  };

  var isEventSupported = (function()
  {
    var TAGNAMES =
    {
      'select' : 'input',
      'change' : 'input',
      'submit' : 'form',
      'reset' : 'form',
      'error' : 'img',
      'load' : 'img',
      'abort' : 'img'
    };

    function isEventSupported(eventName)
    {
      var el = document.createElement(TAGNAMES[eventName] || 'div');
      eventName = 'on' + eventName;
      var isSupported = (eventName in el);
      if (!isSupported)
      {
        el.setAttribute(eventName, 'return;');
        isSupported = typeof el[eventName] == 'function';
      }
      el = null;
      return isSupported;
    }
    return isEventSupported;
  })();
})();
// --------- /amx UA --------- //

// --------- Utilities --------- //
(function()
{
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

  amx.uuid = function(len)
  {
    len = len || 10;
    var chars = CHARS, uuid = [];
    var radix = chars.length;

    for (var i = 0; i < len; i++)
      uuid[i] = chars[0 | Math.random()*radix];

    return uuid.join('');
  };

  amx.arrayRemove = function(a, from, to)
  {
    var rest = a.slice((to || from) + 1 || a.length);
    a.length = from < 0 ? a.length + from : from;
    return a.push.apply(a, rest);
  };

  /**
   * @deprecated use adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute instead
   */
  amx.registerInputValue = function(amxNode, attrName)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "registerInputValue",
      "MSG_DEPRECATED", "amx.registerInputValue",
      "adf.mf.api.amx.TypeHandler.prototype.getInputValueAttribute");

    // Mirror the code in AmxNode's _setupInputValueValidation without calling the type handler
    if (amxNode._attributeToValidate === undefined)
    {
      amxNode._attributeToValidate = attrName;
      amxNode.storeModifyableEl(attrName);
    }
  };

  /**
   * Rendrer would call this function to change the style of showRequired attribute
   * @param {Object} amxNode This is the amxNode object
   * @param {Object} field This object is returned from createField method and must have a
   *   "fieldRoot" property
   * @see See also the definition of amx.createField method inside amx-commonTags.js
   */
  adf.mf.api.amx.applyRequiredMarker = function(amxNode, field)
  {
    if (adf.mf.api.amx.isValueTrue(amxNode.getAttribute("showRequired")) ||
      adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")))
    {
      field.fieldRoot.classList.add("required");
    }
  };

  // safely return the value, handling json null objects,
  // undefined objects, and null objects by returning null
  amx.getObjectValue = function(value)
  {
    if (value == null)
    {
      return null;
    }

    if (typeof value === "undefined")
    {
      return null;
    }

    if (typeof value[".null"] !== "undefined")
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.INFO, "getObjectValue",
        "MSG_UNHANDLED_NULL");

      if (value[".null"] == true)
      {
        return null;
      }
    }

    return value;
  };

  /**
   * Get the value as a string. Null or undefined objects will
   * be returned as an empty string.
   * @param {Object} value the value
   * @return {string} the value as a string.
   */
  amx.getTextValue = function(value)
  {
    value = amx.getObjectValue(value);
    if (value == null)
    {
      return "";
    }

    // Ensure the value is a string
    return "" + value;
  };

  // Gets the amx_dtfolderpath if it is on the URL
  amx.getDtFolderPath = function()
  {
    var queryString = adf.mf.api.getQueryString();
    var amx_dtfolderpath = adf.mf.api.getQueryStringParamValue(queryString, "amx_dtfolderpath", null);
    return amx_dtfolderpath;
  };

  // Builds a string that is the relative path to
  // the folder containing the amx page we are currently
  // viewing.
  amx.currentPageContainingFolder = function()
  {
    try
    {
      // Check for DT folder path
      var amx_dtfolderpath = amx.getDtFolderPath();
      if(amx_dtfolderpath !== null)
      {
        return amx_dtfolderpath;
      }
      // Get current amx filename
      var amxPage = adf.mf.internal.controller.ViewHistory.peek().amxPage;
      // Break up the filename so we can get the length
      // of just the filename.
      var parts = amxPage.split("/");
      // Add the feature root prefix to the filename
      var amxPageFullPath = adfc.Util.addFeatureRootPrefix(amxPage);
    }
    catch (ex)
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
        "amx.currentPageContainingFolder", "MSG_CURRENT_PAGE_FOLDER_FAILED");

      // Only log the exception at a fine level for security reasons
      adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
        "amx", "currentPageContainingFolder", ex);

      return "";
    }
    // Strip off the filename
    return amxPageFullPath.substr(0,
      amxPageFullPath.length - parts[parts.length - 1].length);
  };

  // Determines if the tartget string has a protocol
  amx.hasProtocol = function(url)
  {
    return /^(:?ms-app*|\w+:)/.test(url);
  };

  // Builds the relative path based to the specified
  // resource assuming it is relative to the current
  // amx page.  If there is a protocol on the resource
  // then it is assumed to be an absolute path and
  // left unmodified
  amx.buildRelativePath = function(url)
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE, "buildRelativePath",
      "MSG_DEPRECATED", "amx.buildRelativePath", "adf.mf.api.amx.buildRelativePath");

    return adf.mf.api.amx.buildRelativePath.apply(this, arguments);
  };

  /**
   * Builds the relative path based to the specified resource assuming it is relative to the current
   * AMX page. If there is a protocol on the resource then it is assumed to be an absolute path and
   * left unmodified.
   * @param {string} url the location of the specified resource
   * @return {string} the resolved path
   */
  adf.mf.api.amx.buildRelativePath = function(url)
  {
    if(amx.hasProtocol(url))
    {
      return url;
    }

    url = url.replace("\\", "/");
    if(url.charAt(0) == "/")
    {
        // Check for DT folder path
        var amx_dtfolderpath = amx.getDtFolderPath();
        if (amx_dtfolderpath !== null)
        {
            var publicHtmlString = 'public_html/';
            var publicHtmlIndex    = amx_dtfolderpath.indexOf(publicHtmlString);

            return (amx_dtfolderpath.substring(0, publicHtmlIndex + publicHtmlString.length)) + url.substring(1);
        }
        else
        {
            return adfc.Util.addFeatureRootPrefix(url.substring(1));
        }
    }

    return amx.currentPageContainingFolder() + url;
  };

  /**
   * Adds a CSS className to the dom node if it doesn't already exist in the classNames list and
   * returns <code>true</code> if the class name was added.
   * @param {HTMLElement} domElement DOM Element to add style class name to
   * @param {string} className Name of style class to add
   * @return {boolean} <code>true</code> if the style class was added
   * @deprecated Use domElement.classList.add instead.
   */
  adf.mf.internal.amx.addCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.addCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.addCSSClassName",
      "domElement.classList.add");

    // TODO AdfAssert.assertDomElement(domElement);
    var added = false;

    if (className != null)
    {
      var classNames = className.split(" ");
      for (var i = 0, num = classNames.length; i < num; ++i)
      {
        var className = classNames[i];
        if (!domElement.classList.contains(className))
        {
          domElement.classList.add(className);
          added = true;
        }
      }
    }

    return added;
  };

  /**
   * Removes a CSS className to the dom node if it existd in the classNames list and
   * returns <code>true</code> if the class name was removed.
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className Name of style class to remove
   * @return {boolean} <code>true</code> if the style class was removed
   * @deprecated Use domElement.classList.remove instead.
   */
  adf.mf.internal.amx.removeCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.removeCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.removeCSSClassName",
      "domElement.classList.remove");
    // TODO AdfAssert.assertDomElement(domElement);

    var removed = false;

    if (className != null)
    {
      var classNames = className.split(" ");
      for (var i = 0, num = classNames.length; i < num; ++i)
      {
        var className = classNames[i];
        if (domElement.classList.contains(className))
        {
          domElement.classList.remove(className);
          removed = true;
        }
      }
    }

    return removed;
  };

  /**
   * Convenient function to add or removes a CSS className from the dom node. Will be deprecated
   * once all supported browsers support the classList.toggle function fully (IE 10 and 11
   * do not support the second argument of toggle).
   *
   * @param {boolean} add boolean value if we should do an add of a CSS className
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className the CSS className which should be added or removed
   * @return {boolean} <code>true</code> if the element's style class list changed
   */
  adf.mf.internal.amx.addOrRemoveCSSClassName = function(
    add,
    domElement,
    className) // TODO move into some "domutils" class
  {
    // For backward compatibility usage, check for spaces in the name
    var classNames = className.split(" ");

    var contains = false;
    var num = classNames.length;
    var classList = domElement.classList;

    for (var i = 0; i < num; ++i)
    {
      if (classList.contains(classNames[i]))
      {
        contains = true;
        break;
      }
    }


    if (add && !contains)
    {
      classList.add.apply(classList, classNames);
      return true;
    }
    else if (!add && contains)
    {
      classList.remove.apply(classList, classNames);
      return true;
    }

    return false;
  };

  /**
   * Check if the dom node contains the className
   * @param {HTMLElement} domElement DOM Element to remove style class name from
   * @param {string} className Name of style class to remove
   * @return {boolean} <code>true</code> if the style class is on the domElement
   * @deprecated Use domElement.classList.contains instead.
   */
  adf.mf.internal.amx.containsCSSClassName = function(domElement, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.containsCSSClassName", "MSG_DEPRECATED",
      "adf.mf.internal.amx.containsCSSClassName",
      "domElement.classList.contains");
    var classNames = className.split(" ");
    var containsAll = true;

    for (var i = 0, num = classNames.length; i < num; ++i)
    {
      var className = classNames[i];
      if (!domElement.classList.contains(className))
      {
        containsAll = false;
        break;
      }
    }

    return containsAll;
  };

  /**
   * Returns the index at which <code>className</code> appears within <code>currentClassName</code>
   * with either a space or the beginning or end of <code>currentClassName</code> on either side.
   * This function optimizes the runtime speed by not creating objects in most cases and assuming
   * 1) It is OK to only check for spaces as whitespace characters
   * 2) It is rare for the searched className to be a substring of another className, therefore
   *    if we get a hit on indexOf, we have almost certainly found our className
   * 3) It is even rarer for the searched className to be a substring of more than one className,
   *    therefore, repeating the search from the end of the string should almost always either return
   *    our className or the original search hit from indexOf
   * @param {string} currentClassName Space-separated class name string to search
   * @param {string} className String to search for within currentClassName
   * @return {number} index of className in currentClassName, or -1 if it doesn't exist
   * @deprecated Use domElement.classList instead.
   */
  adf.mf.internal.amx.getCSSClassNameIndex = function(currentClassName, className) // TODO move into some "domutils" class
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "adf.mf.internal.amx.getCSSClassNameIndex", "MSG_DEPRECATED",
      "adf.mf.internal.amx.getCSSClassNameIndex",
      "domElement.classList");
    // if no current class
    if (!currentClassName)
      return -1;
    else
    {
      // if the strings are equivalent, then the start index is the beginning of the string
      if (className === currentClassName)
        return 0;
      else
      {
        var classNameLength = className.length;
        var currentClassNameLength = currentClassName.length;

        // check if our substring exists in the string at all
        var nameIndex = currentClassName.indexOf(className);

        // if our substring exists then our class exists if either:
        // 1) It is at the beginning of the classNames String and has a following space
        // 2) It is at the end of the classNames String and has a leading space
        // 3) It has a space on either side
        if (nameIndex >= 0)
        {
          var hasStart = (nameIndex == 0) || (currentClassName.charAt(nameIndex - 1) == " ");
          var endIndex = nameIndex + classNameLength;
          var hasEnd = (endIndex == currentClassNameLength) || (currentClassName.charAt(endIndex) == " ");

          //one of the three condition above has been met so our string is in the parent string
          if (hasStart && hasEnd)
            return nameIndex;
          else
          {
            // our substring exists in the parent string but didn't meet the above conditions,  Were
            // going to be lazy and retest, searchig for our substring from the back of the classNames
            // string
            var lastNameIndex = currentClassName.lastIndexOf(className);

            // if we got the same index as the search from the beginning then we aren't in here
            if (lastNameIndex != nameIndex)
            {
              // recheck the three match cases
              hasStart = currentClassName.charAt(lastNameIndex - 1);
              endIndex = lastNameIndex + classNameLength;
              hasEnd =  (endIndex == currentClassNameLength) || (currentClassName.charAt(endIndex) == " ");

              if (hasStart && hasEnd)
                return lastNameIndex;
              else
              {
                // this should only happen if the searched for className is a substring of more
                // than one className in the classNames list, so it is OK for this to be slow.  We
                // also know at this point that we definitely didn't get a match at either the very
                // beginning or very end of the classNames string, so we can safely append spaces
                // at either end
                return currentClassName.indexOf(" " + className + " ");
              }
            }
          }
        }

        // no match
        return -1;
      }
    }
  };

  /**
   * Returns the element's right side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's right side position in Window coordinates
   */
  adf.mf.internal.amx.getElementRight = function(domElement) // TODO move into some "agent" class
  {
    var documentElementOffsetWidth = document.documentElement.offsetWidth;
    var domElementOffsetWidth = domElement.offsetWidth;
    var domElementLeft = adf.mf.internal.amx.getElementLeft(domElement);
    var domElementRight = documentElementOffsetWidth - domElementLeft - domElementOffsetWidth;
    return domElementRight;
  };

  /**
   * Returns the element's left side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's left side position in Window coordinates
   */
  adf.mf.internal.amx.getElementLeft = function(domElement) // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return adf.mf.internal.amx._webkitGetElementLeft(domElement);
    return adf.mf.internal.amx._baseGetElementLeft(domElement);
  };

  adf.mf.internal.amx._baseGetElementLeft = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomNode(element);

    var bodyElement = element.ownerDocument.body;
    var currParent  = element.offsetParent;
    var currLeft    = element.offsetLeft;

    while (currParent)
    {
      element = currParent;
      currLeft += element.offsetLeft;

      if (element != bodyElement)
        currLeft -= element.scrollLeft;

      currParent = currParent.offsetParent;
    }

    return currLeft;
  };

  adf.mf.internal.amx._webkitGetElementLeft = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomElement(element);

    // getBoundingClientRect was added in safari 4, webkit version 533
    // just look for the API versus the version
    if (!element.getBoundingClientRect)
      return this._baseGetElementLeft(element);

    var boundingRect = element.getBoundingClientRect();
    var elemLeft = boundingRect.left;
    var docElement = element.ownerDocument.documentElement;

    // adjust for the document scroll positions and window borders
    elemLeft -= (docElement.clientLeft - adf.mf.internal.amx.getBrowserViewportScrollLeft());
    return elemLeft;
  };

  /**
   * Returns the element's top side in Window coordinates.
   * @param {HTMLElement} domElement the DOM Element to look at
   * @return {number} the element's top side position in Window coordinates
   */
  adf.mf.internal.amx.getElementTop = function(domElement) // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return adf.mf.internal.amx._webkitGetElementTop(domElement);
    return adf.mf.internal.amx._baseGetElementTop(domElement);
  };

  adf.mf.internal.amx._baseGetElementTop = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomNode(element);

    var bodyElement = element.ownerDocument.body;
    var currParent  = element.offsetParent;
    var currTop     = element.offsetTop;

    //In safari/opera position absolute incorrectly account for body offsetTop
    if (adf.mf.internal.amx.getComputedStyle(element).position == "absolute")
    {
      currTop -= bodyElement.offsetTop;
    }

    while (currParent)
    {
      element = currParent;
      currTop += element.offsetTop;

      if (element != bodyElement)
        currTop -= element.scrollTop;

      currParent = currParent.offsetParent;
    }

    return currTop;
  };

  adf.mf.internal.amx._webkitGetElementTop = function(element) // TODO move into some "agent" class
  {
    // TODO AmxRcfAssert.assertDomElement(element);

    // getBoundingClientRect was added in safari 4, webkit version 533
    // just look for the API versus the version
    if (!element.getBoundingClientRect)
      return adf.mf.internal.amx._baseGetElementTop(element);

    var boundingRect = element.getBoundingClientRect();
    var elemTop = boundingRect.top;
    var docElement = element.ownerDocument.documentElement;

    // adjust for the document scroll positions and window borders
    elemTop -= (docElement.clientTop - adf.mf.internal.amx.getBrowserViewportScrollTop());
    return elemTop;
  };

  /**
   * @return {Number} returns the starting position on the canvas of the viewport
   */
  adf.mf.internal.amx.getBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return this._webkitGetBrowserViewportScrollLeft();
    return this._baseGetBrowserViewportScrollLeft();
  };

  adf.mf.internal.amx._baseGetBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    return document.documentElement.scrollLeft;
  };

  adf.mf.internal.amx._webkitGetBrowserViewportScrollLeft = function() // TODO move into some "agent" class
  {
    return document.body.scrollLeft;
  };

  /**
   * @return {Number} returns the top position on the canvas the viewport begins
   */
  adf.mf.internal.amx.getBrowserViewportScrollTop = function() // TODO use adf.mf.internal.amx.getBrowserViewportScrollTop
  {
    if (navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1)
      return this._webkitGetBrowserViewportScrollTop();
    return this._baseGetBrowserViewportScrollTop();
  };

  adf.mf.internal.amx._baseGetBrowserViewportScrollTop = function() // TODO move into some "agent" class
  {
    return document.documentElement.scrollTop;
  };

  adf.mf.internal.amx._webkitGetBrowserViewportScrollTop = function() // TODO move into some "agent" class
  {
    return document.body.scrollTop;
  };

  /**
   * Tries to return the current style, taking into account the inline styles and style sheets.
   * @param {HTMLElement} element the element in question
   * @param {string} pseudoElement the name of the pseudo-element e.g. ":after" or null if not applicable
   * @return {Object} the style computed style object
   */
  adf.mf.internal.amx.getComputedStyle = function(element, pseudoElement) // TODO move into some "agent" class
  {
    return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElement);
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
   * Called from our test code
   * @export
   * @param {DOMNode} ancestorNode the potential ancestor or possibly same node as the descendant
   * @param {DOMNode} node the potential descendant or same node as the ancestor
   * @return whether the ancestorNode is an ancestor of the node or they are the same nodes
   */
  adf.mf.internal.amx.isAncestorOrSelf = function(ancestorNode, node)
  {
    return (node == ancestorNode) ? true : adf.mf.internal.amx.isAncestor(ancestorNode, node);
  };

  /**
   * Checks to see if the "ancestorNode" is a ancestor of "node".
   * @param {DOMNode} ancestorNode the potential ancestor
   * @param {DOMNode} node the potential descendant
   * @return whether the ancestorNode is an ancestor of the node
   */
  adf.mf.internal.amx.isAncestor = function(ancestorNode, node)
  {
    if (node == null)
      return false;
    var parentNode = node.parentNode;
    while (parentNode)
    {
      if (parentNode == ancestorNode)
        return true;
      parentNode = parentNode.parentNode;
    }
    return false;
  };

  /**
   * Temporary solution for getting non-primitive element data.
   * @param {HTMLElement} domElement the DOM element the data is associated with
   * @param {string} key the data key
   * @return {Object} the non-primitive data
   * @private
   */
  adf.mf.internal.amx._getNonPrimitiveElementData = function(domElement, key)
  {
    if (domElement == null) return undefined;
    if (domElement._amxNonPrimitiveData == null)
      return undefined;
    return domElement._amxNonPrimitiveData[key];
  };

  /**
   * Temporary solution for setting non-primitive element data.
   * @param {HTMLElement} domElement the DOM element the data is associated with
   * @param {string} key the data key
   * @param {Object} nonPrimitiveData the non-primitive data
   * @private
   */
  adf.mf.internal.amx._setNonPrimitiveElementData = function(domElement, key, nonPrimitiveData)
  {
    if (domElement == null) return;
    if (domElement._amxNonPrimitiveData == null)
      domElement._amxNonPrimitiveData = {};
    domElement._amxNonPrimitiveData[key] = nonPrimitiveData;
  };

  /**
   * Adds padding to a number string.  Does nothing if number is longer than paddingLength.
   * @param {number} number to be padded
   * @param {number} paddingLength specifies length to which to pad
   * @return {string} padded number at least paddingLength long
   */
  adf.mf.internal.amx.addPadding = function(number, paddingLength)
  {
    var padded = "" + number;
    for (var i = padded.length; i < paddingLength; ++i)
    {
      padded = "0" + padded;
    }
    return padded;
  };

  /**
   * Extracts time portion from date object and returns it as "HH:mm:ss"
   * @param {Date} dateObject
   * @return {string} returns time as "HH:mm:ss"
   */
  adf.mf.internal.amx.extractTimeFromDateObject = function(dateObject)
  {
    var time = adf.mf.internal.amx.addPadding(dateObject.getHours(), 2) + ":" +
      adf.mf.internal.amx.addPadding(dateObject.getMinutes(), 2) + ":" +
      adf.mf.internal.amx.addPadding(dateObject.getSeconds(), 2) + "." +
      adf.mf.internal.amx.addPadding(dateObject.getMilliseconds(), 3);
    return time;
  };

  /**
   * Extracts date portion from date object and returns it as "yyyy-MM-dd"
   * @param {Date} dateObject
   * @return {string} returns date as "yyyy-MM-dd"
   */
  adf.mf.internal.amx.extractDateFromDateObject = function(dateObject)
  {
    var time = adf.mf.internal.amx.addPadding(dateObject.getFullYear(), 4) + "-" +
      adf.mf.internal.amx.addPadding(dateObject.getMonth() + 1, 2) + "-" +
      adf.mf.internal.amx.addPadding(dateObject.getDate(), 2);
    return time;
  };

  /**
   * Updates time portion of date object with given time.
   * @param {Date} dateObject is the Date to be updated
   * @param {string} time is a string with this format: "hh:mm"
   */
  adf.mf.internal.amx.updateTime = function(dateObject, time)
  {
    if (time != null && typeof time !== "undefined" && time.length > 4)
    {
      var h = time.substring(0,2);
      var m = time.substring(3,5);
      dateObject.setHours(h);
      dateObject.setMinutes(m);
    }
  };

  /**
   * Updates date portion of date object with given date.
   * @param {Date} dateObject is the Date to be updated
   * @param {string} date is a string with this format: "yyyy-MM-dd".  The year must be full length (e.g. 1999, not 99)
   */
  adf.mf.internal.amx.updateDate = function(dateObject, date)
  {
    if (date != null && typeof date !== "undefined" && date.length > 9)
    {
      var i = date.indexOf("-");
      if (i > 3)
      {
        var year = date.substring(0, i);
        var j = date.indexOf("-", i+1);
        if (j > -1)
        {
          var month = date.substring(i+1, j) - 1;
          var day = date.substring(j+1, date.length);
          dateObject.setFullYear(year);
          dateObject.setMonth(month);
          dateObject.setDate(day);
        }
      }
    }
  };

  /**
   * Check if an object implements a function
   *
   * @param {(Object|null)} obj the object to check.
   * @param {string} name the name of the function to look for
   * @return {boolean} true if the object is non-null and implements a function by the given name
   */
  adf.mf.internal.amx.implementsFunction = function(
    obj,
    name)
  {
    return obj != null && typeof obj[name] === "function";
  };

  adf.mf.internal.NONBLOCKING_CALL_COUNTER = 0;
  adf.mf.internal.pushNonBlockingCall = function()
  {
    ++adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };

  adf.mf.internal.popNonBlockingCall = function()
  {
    --adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };

  adf.mf.internal.getUnresolvedCallDepth = function()
  {
    return adf.mf.internal.NONBLOCKING_CALL_COUNTER;
  };
}) ();
/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* --------------------- amx-event.js ------------------- */
/* ------------------------------------------------------ */

(function()
{
  var _currentFocusDomNode = null;
  var _focusBlurEventData = {}; // allows these focus/blur events to be unique from other focus/blur events

  /**
   * Internal method to bind to the focus method and be notified when another control gains focus
   */
  adf.mf.internal.amx.registerFocus = function(domNode, callback)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "focus",
      function(event)
      {
        // register this node in order to receive events when another control is tapped
        _currentFocusDomNode = domNode;
        if (callback)
        {
          callback(event);
        }
      },
      _focusBlurEventData);
  };

  /**
   * Internal method to bind to the blur method and be notified when another control gains focus
   */
  adf.mf.internal.amx.registerBlur = function(domNode, callback)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "blur",
      function(event)
      {
        // unregister this node - no more need to receive events when another control is tapped
        if (_currentFocusDomNode == domNode)
        {
          _currentFocusDomNode = null;
        }
        if (callback)
        {
          callback(event);
        }
      },
      _focusBlurEventData);
  };

  // this method calls blur on the currentFocus node
  // in order to give it a chance to saved its internal changes
  // first we will blur the node in order to trigger value change events etc
  // then we restore focus back so that we don't accidently cause the user to get the
  // wrong focus - due to keyboard hiding/showing in other words, so that the touchstart &
  // touchend events occur on the same element
  function blurCurrentNode()
  {
    var oldCurrentNode = _currentFocusDomNode;
    var oldActiveElement = document.activeElement;

    if (_currentFocusDomNode != null)
      adf.mf.api.amx.triggerBubbleEventListener(_currentFocusDomNode, "blur");

    if (document.activeElement != null && document.activeElement.blur != null)
      document.activeElement.blur();

    if (oldCurrentNode != null)
    {
      if (oldCurrentNode.tagName == "SELECT" || oldCurrentNode.tagName == "INPUT")
        adf.mf.api.amx.triggerBubbleEventListener(oldCurrentNode, "focus");
    }

    if (oldActiveElement != null && oldActiveElement.focus != null)
    {
      if (oldActiveElement.tagName == "SELECT" || oldActiveElement.tagName == "INPUT")
        oldActiveElement.focus();
    }

  }

  function triggerEvent(eventTarget, eventName, triggerExtra)
  {
    if (eventName == "tap")
    {
      // "tap" is not a real event so we need to trigger the real events for it
      var tapEvents = _getTapEvents();
      triggerEvent(eventTarget, tapEvents.start, triggerExtra);
      triggerEvent(eventTarget, tapEvents.end, triggerExtra);
    }
    else if (eventName == "taphold")
    {
      // "taphold" is not a real event so we need to trigger the real events for
      // it (the 2nd event needs to take place after the underlying 1st event's
      // timeout occurs hence the addition of 1 to the threshold).
      var tapHoldEvents = _getTapEvents();
      triggerEvent(eventTarget, tapHoldEvents.start, triggerExtra);
      setTimeout(
        function()
        {
          triggerEvent(eventTarget, tapHoldEvents.end, triggerExtra);
        },
        1+holdThreshold);
    }
    else
    {
      adf.mf.internal.triggerEvent(
        eventTarget,
        "HTMLEvents",
        eventName,
        true,
        true,
        triggerExtra);
    }
  }

  function _isSimpleObject(o)
  {
    return Object.prototype.toString.call(o) == "[object Object]";
  }

  /**
   * Utility to merge an arbitrary list of simple objects onto the given base object.
   * If any of the given objects is determined to not be a simple object, the merging
   * will cease and false is returned.
   * @param {Object} baseObject the simple object that the remaining objects will be added to (in order)
   * @return {Boolean} whether the full set of objects was merged
   */
  function _mergeSimpleObjects(baseObject)
  {
    if (!_isSimpleObject(baseObject))
      return false;

    // Loop through the rest of the arguments to merge their properties into the base object
    var args = Array.prototype.slice.call(arguments);
    for (var i=1, count=args.length; i<count; ++i)
    {
      var objectToMerge = args[i];

      if (!_isSimpleObject(objectToMerge))
        return false;

      for (var key in objectToMerge)
        baseObject[key] = objectToMerge[key];
    }

    return true;
  }

  var tapPendingIds = {};

  function cancelPendingTap()
  {
    tapPendingIds = {};
  }

  var _tapEvents = null;
  var _getTapEvents = function()
  {
    if (_tapEvents == null)
      _tapEvents = amx.hasTouch() ? { start: "touchstart", end: "touchend", cancel: "touchcancel" } : { start: "mousedown", end: "mouseup", cancel: "" };
    return _tapEvents;
  };

  var _addSpecialTapBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    var tapEvents = _getTapEvents();
    var tapId = null;
    var originalPosition = null;
    var startListener = function(event)
    {
      // if there is a node that registered its focus, then
      // the first thing to do is blur that focus here
      var newFocusedTagName = domNode.tagName;
      if (newFocusedTagName != "INPUT" && newFocusedTagName != "SELECT") // virtual keyboard elements
        blurCurrentNode();
      tapId = amx.uuid(); // TODO don't use amx.foo!
      tapPendingIds[tapId] = true;
      originalPosition = _getEventPagePosition(event);
    };
    var endListener = function(event)
    {
      if (tapPendingIds[tapId])
      {
        // Ignore taps if the finger moves too much between start and end.
        // The points might be null in automated testing mode so allow the tap
        // if points cannot be determined.
        var newPosition = _getEventPagePosition(event);
        var pointsCloseEnough =
          Math.abs(originalPosition["pageX"] - newPosition["pageX"]) < 25 &&
          Math.abs(originalPosition["pageY"] - newPosition["pageY"]) < 25;
        if (pointsCloseEnough ||
           originalPosition["pageX"] == null ||
           originalPosition["pageY"] == null ||
           newPosition["pageX"] == null ||
           newPosition["pageY"] == null)
        {
          adf.mf.api.amx.showLoadingIndicator();
          listener.call(this, event);
          adf.mf.api.amx.hideLoadingIndicator();
        }
        originalPosition = null;
        delete tapPendingIds[tapId];
        cancelPendingDrag(true, false);
      }
    };
    var cancelListener = function(event)
    {
      // Starting in Android 4.4, sometimes the browser will trigger a cancel
      // event before you lift your finger. In such cases, we can't reliably
      // honor the gesture as a tap because the 2 points are inaccurate.
      if (tapPendingIds[tapId])
      {
        originalPosition = null;
        delete tapPendingIds[tapId];
        cancelPendingDrag(true, false);
      }
    };
    // We used to ignore tap cancel but this is no longer valid with the new Chrome WebView in 4.4. Like native Chrome,
    // this will generate the cancel event if the preventDefault is not registered within 250ms. Since we get a touchStart
    // we need to figure out what the intent of the touch is (tap and hold or just tap or drag and drop). The issue
    // is the 250ms is a system time (outside the WebView) and when the WebView is busy (over long runs in Selenium), or
    // lots of open features then we start to slow down where some of the clicks are not addressed in time and we get a
    // touch cancel. What we do instead is treat the cancel like a touch end.
    if (tapEvents.cancel != "")
    {
      _addSpecialBubbleEventListener(
        domNode,
        eventType,
        listener,
        eventData,
        [
          [ tapEvents.start,  startListener ],
          [ tapEvents.end,    endListener ],
          [ tapEvents.cancel, cancelListener ]
        ]);
    }
    else
    {
      _addSpecialBubbleEventListener(
        domNode,
        eventType,
        listener,
        eventData,
        [
          [ tapEvents.start, startListener ],
          [ tapEvents.end,   endListener ]
        ]);
    }
  };
  // --------- /Tap Event --------- //

  // --------- Tap Hold --------- //
  var tapHoldPendingIds = {};

  function cancelPendingTapHold()
  {
    tapHoldPendingIds = {};
  }

  var holdThreshold = 800;

  var _addSpecialTapHoldBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    var tapEvents = _getTapEvents();
    var tapId = null;
    var startListener = function(event)
    {
      tapId = amx.uuid(); // TODO don't use amx.foo!
      tapHoldPendingIds[tapId] = new Date().getTime();

      // Since we are using a timer, we need to fetch our eventData now for reapplication in the timer
      var eventData = event.data;

      setTimeout(function()
      {
        // Note: here we double check if the time is greater than the threshold. This is useful since sometime timeout
        //       is not really reliable.
        if (tapHoldPendingIds[tapId] > 0)
        {
          var timeOffset = new Date().getTime() - tapHoldPendingIds[tapId];
          if (timeOffset >= holdThreshold)
          {
            // Call the listener but make sure our eventData is used:
            var eventDataToRestore = event.data;
            event.data = eventData;
            var result = listener.call(domNode, event);
            event.data = eventDataToRestore;

            // if the handler consumes the tapHold, remove it from the tapPendingIds so that it does not count like a tap
            if (result === "consumeTapHold")
            {
              // Android requires that we preventDefault, otherwise native select/edit text mode can be triggered
              // This code does also fixes softKeyboard show/hide bug and let's user select/edit text for inputText component
              var agent = adf.mf.internal.amx.agent;
              if (agent["type"] == "Android")
              {
                event.preventDefault();
              }
              cancelPendingTap();
              cancelPendingTapHold();
              cancelPendingDrag(false, false);
            }
          }
          delete tapHoldPendingIds[tapId];
        }

      }, holdThreshold);
    };
    var endListener = function(event)
    {
      if (tapHoldPendingIds[tapId])
      {
        delete tapHoldPendingIds[tapId];
      }
    };
    _addSpecialBubbleEventListener(
      domNode,
      eventType,
      listener,
      eventData,
      [
        [ tapEvents.start, startListener ],
        [ tapEvents.end, endListener ]
      ]);
  };
  // --------- /Tap Hold --------- //

  // --------- Drag Event --------- //
  var dragPendingIds = {};
  var dragEvents = null;

  function cancelPendingDrag(releaseLocks, triggerCancelOrEndBeforeRemove)
  {
    if (!triggerCancelOrEndBeforeRemove)
      dragPendingIds = {};

    if (releaseLocks)
    {
      if (!dragEvents)
        dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

      if (triggerCancelOrEndBeforeRemove)
      {
        // If a container is listening to drag events but a descendant gets removed, we need to
        // trigger the cancel/end listeners or else that container could get in a corrupt state:
        if (dragEvents.cancel != "")
          adf.mf.api.amx.triggerBubbleEventListener(document.documentElement, dragEvents.cancel);
        else
          adf.mf.api.amx.triggerBubbleEventListener(document.documentElement, dragEvents.end);
      }

      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag);
      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd);
      if (dragEvents.cancel != "")
        adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel);
      releaseDragLock();

      // delete the dragContext since it no longer applies
      adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", null);
    }
  }

  var DRAGSTART = "amxdragstart";
  var DRAGDRAG = "amxdragdrag";
  var DRAGEND = "amxdragend";

  /**
   * Options optional method implementation:
   */
  var mouseDragEvents =
  {
    start: "mousedown",
    drag: "mousemove",
    end: "mouseup",
    cancel: ""
  };

  var touchDragEvents =
  {
    start: "touchstart",
    drag: "touchmove",
    end: "touchend",
    cancel: "touchcancel"
  };

  // Handler for the event DRAGSTART event.
  function handleDragEvent(e, options)
  {
    var domNode = this;
    var id = "_" + amx.uuid(); // TODO don't use amx.foo!

    dragPendingIds[id] = true;

    var startEvent = e;
    var startPagePos = _getEventPagePosition(startEvent);

    // so far, we prevent the default, otherwise, we see some text select which can be of a distracting
    // since we create "meta events" we consume this one
    // e.preventDefault();
    // e.stopPropagation();

    var documentDragData = {
      "options": options,
      "domNode": domNode,
      "id": id,
      "startEvent": startEvent,
      "startPagePos": startPagePos,
      "dragStarted": false
    };

    if (!dragEvents)
      dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

    // We use the documentElement for the following 2 events so that the dragging doesn't stop when leaving the domNode.
    // In order to uniquely identify these listeners for removal the documentDragData will be passed in so that other
    // events of the same names on the document don't get lost.

    // drag
    adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag, documentDragData);

    // drag end
    adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd, documentDragData);

    // drag cancel
    if (dragEvents.cancel != "")
      adf.mf.api.amx.addBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel, documentDragData);
  }

  function documentDragDrag(e)
  {
    var documentDragData = e.data;
    var options = documentDragData["options"];
    var domNode = documentDragData["domNode"];
    var id = documentDragData["id"];
    var startEvent = documentDragData["startEvent"];
    var startPagePos = documentDragData["startPagePos"];

    // if the drag has not started, check if we need to start it
    if (!documentDragData["dragStarted"] && dragPendingIds[id])
    {
      var currentPagePos = _getEventPagePosition(e);
      var offsetX = (startPagePos.pageX - currentPagePos.pageX);
      var offsetY = (startPagePos.pageY - currentPagePos.pageY);

      // if the diff > threshold, then, we start the drag
      if (Math.abs(offsetX) > options.threshold || Math.abs(offsetY) > options.threshold)
      {
        var dragCtx = adf.mf.internal.amx._getNonPrimitiveElementData(document.documentElement, "dragCtx");
        if (dragCtx == null) // if no drag is already in progress on the element...
        {
          documentDragData["dragStarted"] = true;

          // we cancel any pending tap event
          cancelPendingTap();
          cancelPendingTapHold();

          // create the dragCtx
          adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", {});

          var dragStartExtra = buildDragExtra(startEvent, domNode, DRAGSTART, startPagePos, currentPagePos);
          triggerEvent(domNode, DRAGSTART, dragStartExtra);
        }
      }
    }

    if (documentDragData["dragStarted"] && dragPendingIds[id])
    {
      // making sure they they are canceled
      cancelPendingTap();
      cancelPendingTapHold();

      var dragExtra = buildDragExtra(e, domNode, DRAGDRAG);
      triggerEvent(domNode, DRAGDRAG, dragExtra);

      // since we create "meta events" we consume this event if the meta event was consumed
      if (dragExtra.preventDefault)
        e.preventDefault();
      if (dragExtra.stopPropagation)
        e.stopPropagation();
    }
  }

  function documentDragEnd(e)
  {
    _documentDragFinish(e);
  }

  function documentDragCancel(e)
  {
    _documentDragFinish(e);
  }

  function _documentDragFinish(e)
  {
    var documentDragData = e.data;
    var domNode = documentDragData["domNode"];
    var id = documentDragData["id"];

    if (documentDragData["dragStarted"] && dragPendingIds[id])
    {
      var extra = buildDragExtra(e, domNode, DRAGEND);
      triggerEvent(domNode, DRAGEND, extra);

      // since we create "meta events" we consume this event if the meta event was consumed
      if (extra.preventDefault)
        e.preventDefault();
      if (extra.stopPropagation)
        e.stopPropagation();

      // Let other elements have a chance at handling drag events:
      extra.releaseDragLock();
    }

    // unbind the document event that is specifically tied to this documentDragData instance
    adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.drag, documentDragDrag, documentDragData);
    adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.end, documentDragEnd, documentDragData);
    if (dragEvents.cancel != "")
      adf.mf.api.amx.removeBubbleEventListener(document.documentElement, dragEvents.cancel, documentDragCancel, documentDragData);
    delete dragPendingIds[id];

    // delete the dragContext
    adf.mf.internal.amx._setNonPrimitiveElementData(document.documentElement, "dragCtx", null);
  }

  var currentDragElementH = null;
  var currentDragElementV = null;

  /**
   * Mechanism to release a reservation for horizontal and/or vertical drag behavior for the given element.
   * @param {HTMLElement} element the element that no longer wants to consume the specified drag events
   * @param {Boolean} horizontal whether you want to reserve drag events for the horizontal axis
   * @param {Boolean} vertical whether you want to reserve drag events for the horizontal axis
   * @return {Boolean} whether your release request was successful for the specified axes
   */
  function releaseDragLock(element, horizontal, vertical)
  {
    var releasedTheLock = false;

    if (element)
    {
      releasedTheLock = true;

      if (horizontal)
      {
        if (currentDragElementH == null || currentDragElementH == element)
          currentDragElementH = null;
        else
          releasedTheLock = false;
        }

      if (vertical)
      {
        if (currentDragElementV == null || currentDragElementV == element)
          currentDragElementV = null;
        else
          releasedTheLock = false;
        }
      }
    else // purge all
    {
      releasedTheLock = true;
      currentDragElementH = null;
      currentDragElementV = null;
    }

    return releasedTheLock;
  }

  /**
   * Mechanism to establish a reservation for horizontal and/or vertical drag behavior for the given element.
   * @param {HTMLElement} element the element that wants to consume the specified drag events
   * @param {Boolean} horizontal whether you want to reserve drag events for the horizontal axis
   * @param {Boolean} vertical whether you want to reserve drag events for the horizontal axis
   * @return {Boolean} whether your reservation request was granted for the specified axes
   */
  function requestDragLock(element, horizontal, vertical)
  {
    var gotTheLock = false;

    if (element)
    {
      gotTheLock = true;

      if (horizontal)
      {
        if (currentDragElementH == null || currentDragElementH == element)
          currentDragElementH = element;
        else
          gotTheLock = false;
      }

      if (vertical)
      {
        if (currentDragElementV == null || currentDragElementV == element)
          currentDragElementV = element;
        else
          gotTheLock = false;
      }
    }

    return gotTheLock;
  }

  /**
   * Build the extra event info for the drag event.
   * @param {Object} event TODO
   * @param {HTMLElement} domNode the dragged element
   * @param {String} dragType the custom drag event name
   * @param {Object} startPagePos optional argument with pageX and pageY properties
   * @param {Object} currentPagePos optional argument with pageX and pageY properties
   */
  function buildDragExtra(event, domNode, dragType, startPagePos, currentPagePos)
  {
    var hasTouch = amx.hasTouch(); // TODO don't use amx.foo!
    var extra = _getEventPagePosition(event); // fetch the pageX and pageY as appropriate
    extra["eventSource"] = event;
    extra["preventDefault"] = false;
    extra["stopPropagation"] = false;
    extra["releaseDragLock"] = releaseDragLock;
    extra["requestDragLock"] = requestDragLock;

    if (hasTouch)
    {
      extra.touches = event.touches;
    }

    var dragCtx = adf.mf.internal.amx._getNonPrimitiveElementData(document.documentElement, "dragCtx");
    if (dragCtx)
    {
      if (dragType === DRAGSTART)
      {
        dragCtx.startPageX = extra.startPageX = extra.pageX;
        dragCtx.startPageY = extra.startPageY = extra.pageY;

        dragCtx.lastPageX = dragCtx.startPageX = extra.startPageX;
        dragCtx.lastPageY = dragCtx.startPageY = extra.startPageY;
      }
      else if (dragType === DRAGEND)
      {
        // because, on iOS, the touchEnd event does not have the .touches[0].pageX
        extra.pageX = dragCtx.lastPageX;
        extra.pageY = dragCtx.lastPageY;
      }

      if (startPagePos != null && dragCtx.originalAngle == null)
      {
        // Calculate, using the start page event location, the angle that the user moved their
        // finger. Allows callers to determine the directionality that the user intends to scroll.
        diffX = currentPagePos.pageX - startPagePos.pageX;
        diffY = startPagePos.pageY - currentPagePos.pageY; // Y direction is reversed;

        // Determine the angle
        // angle = arctan(opposite/adjacent) (converted from radians to degrees)
        // Note that this computation uses 0 degrees as east, 90 is north.
        // Angles to the south and west are negative (-90 is south)
        dragCtx.originalAngle = Math.round(Math.atan2(diffY, diffX) * 180 / Math.PI);
      }

      extra.originalAngle = dragCtx.originalAngle;
      extra.startPageX = dragCtx.startPageX;
      extra.startPageY = dragCtx.startPageY;
      extra.deltaPageX = extra.pageX - dragCtx.lastPageX;
      extra.deltaPageY = extra.pageY - dragCtx.lastPageY;

      dragCtx.lastPageX = extra.pageX;
      dragCtx.lastPageY = extra.pageY;
    }
    else
    {
      adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.WARNING, "buildDragExtra",
        "MSG_DRAG_CTX_NULL");
    }

    return extra;
  }

  function _getEventPagePosition(e)
  {
    var pageX, pageY;
    if (e.changedTouches && e.changedTouches.length > 0)
    {
      pageX = e.changedTouches[0].pageX;
      pageY = e.changedTouches[0].pageY;
    }
    else if (e.touches && e.touches.length > 0)
    {
      pageX = e.touches[0].pageX;
      pageY = e.touches[0].pageY;
    }
    else
    {
      pageX = e.pageX;
      pageY = e.pageY;
    }

    return {
      "pageX": pageX,
      "pageY": pageY
    };
  }

  // --------- /Drag Event --------- //

  // -------- Swipe Event --------- //

  var swipeThreshold = 5;

  /**
   * Determine if it is a swipe event, and if yes, build the swipeExtra
   */
  function buildSwipeExtra(domNode, event, dragExtra)
  {
    var swipeExtra = null;
    var swipeDone = domNode.getAttribute("data-swipeDone");

    if (swipeDone != "true" && dragExtra)
    {
      var offsetX = (dragExtra.pageX - dragExtra.startPageX);
      var offsetY = (dragExtra.pageY - dragExtra.startPageY);
      var absOffsetX = Math.abs(offsetX);
      var absOffsetY = Math.abs(offsetY);
      if (absOffsetX >= absOffsetY && absOffsetX > swipeThreshold)
      {
        // Only consider it a drag if the angle of the drag is within 30 degrees of due horizontal
        var angle = Math.abs(dragExtra.originalAngle);
        if (angle <= 30 || angle >= 150)
        {
          swipeExtra = {};
          swipeExtra.swipeType = (offsetX > -1)?"swipeRight":"swipeLeft";
          domNode.setAttribute("data-swipeDone", "true");
        }
      }
      else if (absOffsetY >= absOffsetX && absOffsetY > swipeThreshold)
      {
        // Only consider it a drag if the angle of the drag is within 30 degrees of due vertical
        var ang = Math.abs(dragExtra.originalAngle);
        if (ang >= 60 && ang <= 120)
        {
          swipeExtra = {};
          swipeExtra.swipeType = (offsetY > -1)?"swipeDown":"swipeUp";
          domNode.setAttribute("data-swipeDone", "true");
        }
      }
    }

    return swipeExtra;
  }
  // -------- /Swipe Event --------- //

// --------- /events --------- //

// --------- Event Enabler --------- //

  /**
   * Triggers an HTML bubble event listener (e.g. tap, taphold, keydown,
   * touchstart, touchmove, touchend, focus, blur, resize, etc.).
   * It is important to note that web browsers do not support all event types on
   * all DOM nodes. Refer to browser documentation for specifics.
   * @param {DOMNode} eventTarget the target DOM node for this event
   * @param {String} eventName the name of the HTML event to listen for
   */
  adf.mf.api.amx.triggerBubbleEventListener = function(eventTarget, eventName)
  {
    triggerEvent(eventTarget, eventName);
  };

  /**
   * Register a bubble event listener (e.g. tap, taphold, keydown, touchstart, touchmove, touchend, focus,
   * blur, resize, etc.). It is important to note that web browsers do not support all event types on all
   * DOM nodes. Refer to browser documentation for specifics. The eventData is optional and
   * serves as extra data to be made available to your listener function.
   * @param {DOMNode} domNode the target element for this event
   * @param {String} eventType the name of the event to listen for
   * @param {Function} listener the function that will be invoked when the specified element encounters this event (with a parameter that is the DOM event object)
   * @param {Object} eventData extra event data that will be made available on the "data" member of the event object
   */
  adf.mf.api.amx.addBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    // For special events (ones we made up that delegate to other real events), we have more
    // work to do in order to add the listeners:
    if ("tap" == eventType)
    {
      _addSpecialTapBubbleEventListener(domNode, eventType, listener, eventData);
    }
    else if ("taphold" == eventType)
    {
      _addSpecialTapHoldBubbleEventListener(domNode, eventType, listener, eventData);
    }
    else
    {
      // Adding a real event listener:
      _addBubbleEventListener(domNode, eventType, listener, eventData);
    }
  };

  var _addBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    // Internal note: we will support eventData using a technique similar to this:
    // domNode.addEventListener("click", function() { var tempData = eventData; yourListener(tempData); }, false)
    // but we need to follow the removeEventListener "handleEvent" guidance noted here and we will need a
    // mechanism to remove all listeners at once (for the removeDomNode function) so that means we need to
    // track the listeners using some ID mechanism).

    if (domNode != null && listener != null)
    {
      var actualListener = function(event)
      {
// TODO integrate .registerFocus and .registerBlur here
        var oldData = event.data;
        if (eventData != null)
        {
          if (oldData == null)
          {
            // No merging necessary (only new data)
            event.data = eventData;
          }
          else // Try merging the 2 pieces of data
          {
            var merged = {};
            if (_mergeSimpleObjects(merged, oldData, eventData))
              event.data = merged; // Use the merged result
            else
              event.data = eventData; // Both are not objects so we can't merge; use only new data
          }
        }
        var result = listener.call(this, event, event.triggerExtra);
        event.data = oldData;
        if (result !== undefined)
        {
          if ((event.result = result) === false)
          {
            // Stop the event from continuing (e.g. max length hit in an inputText)
            event.preventDefault();
            event.stopPropagation();
          }
        }
      };
      var newListener = {
        "actualListener": actualListener,
        "eventType": eventType,
        "listener": listener,
        "eventData": eventData
      };
      if (domNode._amxListeners == null)
        domNode._amxListeners = [];
      domNode._amxListeners.push(newListener);
      domNode.addEventListener(eventType, actualListener, false);
    }
  };

  var _addSpecialBubbleEventListener = function(domNode, eventType, eventKey, eventData, backingListeners)
  {
    // specialEventsMap is a map with keys like "tap", "taphold", "amxdrag":
    var specialEventsMap = domNode._amxSpecialEvents;
    if (specialEventsMap == null)
    {
      specialEventsMap = {};
      domNode._amxSpecialEvents = specialEventsMap;
    }

    // Since there can be multiple instances of each special event type, each type points to an instance map.
    // The eventKeysMap is keyed by something that allows unique removal.
    // This key could be the developer's passed-in listener function (in the case of "tap" and "taphold") or
    // the developer's payload object (in the case of "amxdrag").
    var eventKeysMap = specialEventsMap[eventType];
    if (eventKeysMap == null)
    {
      eventKeysMap = {};
      specialEventsMap[eventType] = eventKeysMap;
    }

    // Each entry in eventKeysMap is a map keyed by the event data (possibly null):
    var eventDataMap = eventKeysMap[eventKey];
    if (eventDataMap == null)
    {
      eventDataMap = {};
      eventKeysMap[eventKey] = eventDataMap;
    }

    // Each entry in eventDataMap is an array of instance listeners.
    var instanceListenersArray = eventDataMap[eventData];
    if (instanceListenersArray == null)
    {
      instanceListenersArray = [];
      eventDataMap[eventData] = instanceListenersArray;
    }

    // Each member of instanceListeners is a backing listener array where index 0 is an
    // DOM event type and index 1 is a DOM event handler function.
    for (var i=0, count=backingListeners.length; i<count; ++i)
    {
      var backingListener = backingListeners[i];
      _addBubbleEventListener(domNode, backingListener[0], backingListener[1], eventData);
      instanceListenersArray.push(backingListener);
    }
  };

  /**
   * Unregister a bubble event listener that was added via adf.mf.api.amx.addBubbleEventListener.
   * If eventType is not specified, all listeners registered by the add function will be removed.
   * If listener is not specified, all listeners registered by the add function of the given type will be removed.
   * @param {DOMNode} domNode the target element for which an event listener was previously added
   * @param {String} eventType the name of the event
   * @param {Function} listener the event listener function
   * @param {Object} eventData the extra event data
   */
  adf.mf.api.amx.removeBubbleEventListener = function(
    domNode,
    eventType,
    listener,
    eventData)
  {
    if (domNode != null)
    {
      if (eventType == null)
      {
        // Remove all special event listeners:
        _removeSpecialBubbleEventListener(domNode);
        delete domNode._amxSpecialEvents;

        // Remove all real event listeners:
        _removeBubbleEventListener(domNode);
      }
      else if ("tap" == eventType || "taphold" == eventType || "amxdrag" == eventType)
      {
        // For special events (ones we made up that delegate to other real events), we have more
        // work to do in order to remove the listeners:
        var eventKey = listener; // for "tap" and "taphold", the listener is the eventKey
        _removeSpecialBubbleEventListener(domNode, eventType, eventKey, eventData);
      }
      else
      {
        // Removing a real event listener:
        _removeBubbleEventListener(domNode, eventType, listener, eventData);
      }
    }
  };

  /**
   * Remove a bubble event listener.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {String} eventType the DOM event type (if not specified, all events will be removed)
   * @param {Function} listener the DOM event listener (if not specified, all events of the given type will be removed)
   * @param {Object} eventData the optional event data that is bundled with the event listener
   */
  var _removeBubbleEventListener = function(domNode, eventType, listener, eventData)
  {
    if (domNode != null && listener != null)
    {
      // Account for listeners not added via adf.mf.api.amx.addBubbleEventListener:
      domNode.removeEventListener(eventType, listener, false);
    }

    if (domNode != null && domNode._amxListeners != null)
    {
      // Account for listeners added via adf.mf.api.amx.addBubbleEventListener:
      var savedListeners = domNode._amxListeners;
      var savedListenerCount = savedListeners.length;
      for (var i=savedListenerCount-1; i>=0; --i)
      {
        var savedListener = savedListeners[i];
        var removeThisListener = false;
        if (eventType === undefined) // remove all saved listeners
        {
          eventType = savedListener["eventType"];
          removeThisListener = true;
        }
        else if (listener === undefined) // remove all saved listeners of this event type
          removeThisListener = savedListener["eventType"] == eventType;
        else if (eventData === undefined) // remove all saved listeners of this event type and listener function
          removeThisListener = savedListener["eventType"] == eventType && savedListener["listener"] == listener;
        else // remove only listeners that match this type, listener function, and event data
          removeThisListener = savedListener["eventType"] == eventType && savedListener["listener"] == listener && savedListener["eventData"] == eventData;

        if (removeThisListener)
        {
          domNode.removeEventListener(eventType, savedListener["actualListener"], false);
          savedListeners.splice(i, 1); // remove that listener from the array
        }
      }

      if (domNode._amxListeners.length == 0)
        delete domNode._amxListeners;
    }
  };

  /**
   * Remove any special event listeners associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {String} eventType optional eventType to limit what gets removed
   * @param {Object} eventKey optional eventKey to limit what gets removed
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialBubbleEventListener = function(domNode, eventType, eventKey, eventData)
  {
    var specialEventsMap = domNode._amxSpecialEvents;
    if (specialEventsMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventType == null)
    {
      // Remove for all possible special eventType values
      for (var foundEventType in specialEventsMap)
      {
        _removeSpecialEventForKeyAndData(domNode, specialEventsMap[foundEventType]);
        delete specialEventsMap[foundEventType];
      }
    }
    else
    {
      // Restrict removal to just this special eventType
      var eventKeysMap = specialEventsMap[eventType];
      _removeSpecialEventForKeyAndData(domNode, eventKeysMap, eventKey, eventData);
      if (Object.keys(eventKeysMap).length == 0)
        delete specialEventsMap[eventType]; // no more keys for this event type
    }

    if (Object.keys(specialEventsMap).length == 0)
      delete domNode._amxSpecialEvents; // no more special events of any type
  };

  /**
   * Remove special event listeners of a specific type associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} eventKeysMap map of all special event keys for a particular eventType
   * @param {Object} eventKey optional eventKey to limit what gets removed
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialEventForKeyAndData = function(domNode, eventKeysMap, eventKey, eventData)
  {
    if (eventKeysMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventKey == null)
    {
      // Remove all instances of this special eventType
      for (var foundEventKey in eventKeysMap)
      {
        _removeSpecialEventForData(domNode, eventKeysMap[foundEventKey]);
        delete eventKeysMap[foundEventKey];
      }
    }
    else
    {
      // Restrict removal to just this eventKey
      var eventDataMap = eventKeysMap[eventKey];
      _removeSpecialEventForData(domNode, eventDataMap, eventData);
      if (Object.keys(eventDataMap).length == 0)
        delete eventKeysMap[eventKey]; // no more keys for this event type and key combo
    }
  };

  /**
   * Remove special event listeners of a specific eventData associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} eventDataMap map of all special eventData for a particular eventType and eventKey
   * @param {Object} eventData optional eventData to limit what gets removed
   * @return {Boolean} whether the specified listeners were removed
   */
  var _removeSpecialEventForData = function(domNode, eventDataMap, eventData)
  {
    if (eventDataMap == null)
    {
      return; // nothing was registered so nothing to remove
    }

    if (eventData == null)
    {
      // Remove all instances of this special eventData
      for (var foundEventData in eventDataMap)
      {
        _removeSpecialEventInstanceListeners(domNode, eventDataMap[foundEventData], foundEventData);
        delete eventDataMap[foundEventData];
      }
    }
    else
    {
      // Restrict removal to just this eventData
      var instanceListeners = eventDataMap[eventData];
      _removeSpecialEventInstanceListeners(domNode, instanceListeners, eventData);
      delete eventDataMap[eventData]; // no more keys for this event type and key combo
    }
  };

  /**
   * Remove special event listeners of associated with the given information.
   * @param {DOMNode} domNode the DOM node that owns the event listeners
   * @param {Object} instanceListeners the backing listener array
   * @param {Object} eventData optional eventData to limit what gets removed
   */
  var _removeSpecialEventInstanceListeners = function(domNode, instanceListeners, eventData)
  {
    if (instanceListeners == null)
    {
      return; // nothing was registered so nothing to remove
    }

    // Remove the real underlying events for this custom event listener
    for (var i=instanceListeners.length-1; i>=0; --i)
    {
      var backingListener = instanceListeners[i];
      // Note, for now we are not passing along eventData so that callers can delete references to
      // instanceListeners.
      _removeBubbleEventListener(domNode, backingListener[0], backingListener[1], eventData);
    }
  };

  /**
   * Allow a DOM node to trigger custom AMX events for amx:showPopupBehavior, amx:setPropertyListener, etc.
   * like "tapHold" and the "swipe".
   * @param {adf.mf.api.amx.AmxNode} amxNode the AmxNode that owns the DOM for the event
   * @param {DOMNode} domNode the DOM node that can trigger the event
   * @param {String} eventType the type of event being associated; either "tapHold" or "swipe"
   */
  adf.mf.api.amx.enableAmxEvent = function(amxNode, domNode, eventType)
  {
    if (eventType == "swipe")
      _enableSwipe(amxNode, domNode);
    else if (eventType == "tapHold")
      _enableTapHold(amxNode, domNode);
  };

  var _enableSwipe = function(amxNode, domNode)
  {
    var handler = function(event, swipeExtra)
    {
      var tag = amxNode.getTag();
      var swipeType = swipeExtra.swipeType;

      // check that we have at least one action with this type
      var childrenTags = tag.getChildren();
      for (var i=0, size=childrenTags.length; i<size; ++i)
      {
        var childTag = childrenTags[i];
        var childType = childTag.getAttribute("type");

        // The event processing doesn't know about start/end so use left/right if applicable:
        if (childType == "swipeStart")
        {
          if (document.documentElement.dir == "rtl")
            childType = "swipeRight";
          else
            childType = "swipeLeft";
        }
        else if (childType == "swipeEnd")
        {
          if (document.documentElement.dir == "rtl")
            childType = "swipeLeft";
          else
            childType = "swipeRight";
        }

        if (childType == swipeType)
        {
          var event = new amx.ActionEvent(); // TODO don't use amx.foo!
          adf.mf.api.amx.processAmxEvent(amxNode, swipeType, undefined, undefined, event);
          return "consumeSwipe";
        }
      }
    };

    var swipeConsumed = false;
    adf.mf.api.amx.addDragListener(
      domNode,
      {
        start: function(event, dragExtra) {},

        drag: function(event, dragExtra)
        {
          if (!swipeConsumed)
          {
            var swipeExtra = buildSwipeExtra(domNode, event, dragExtra);
            if (swipeExtra)
            {
              var result = handler.call(this, event, swipeExtra);
              if (result === "consumeSwipe")
              {
                swipeConsumed = true;
                domNode.removeAttribute("data-swipeDone");
              }
            }
           }
        },

        end: function(event, dragExtra)
        {
          swipeConsumed = false;
          domNode.removeAttribute("data-swipeDone");
        },

        threshold: 5
      });
  };

  var _enableTapHold = function(amxNode, domNode)
  {
    adf.mf.api.amx.addBubbleEventListener(
      domNode,
      "taphold",
      function(event)
      {
        var tag = amxNode.getTag();

        // check that we have at least one action with this type
        var childrenTags = tag.getChildren();
        for (var i=0, size=childrenTags.length; i<size; ++i)
        {
          var childTag = childrenTags[i];
          if (childTag.getAttribute("type") == "tapHold")
          {
            var event = new amx.ActionEvent(); // TODO don't use amx.foo!
            adf.mf.api.amx.processAmxEvent(amxNode, "tapHold", undefined, undefined, event);
            return "consumeTapHold";
          }
        }
      });
  };

  /**
   * Allow a DOM node to trigger AMX drag events.
   * The payload object defines 3 member functions: "start", "drag", "end" where each one's first parameter
   * is the DOM event, the second parameter is a "dragExtra" object with members: "eventSource" (the DOM event
   * source), "pageX" (the x coordinate of the event, "pageY" the y coordinate of the event, "startPageX" (the
   * original pageX), "startPageY" (the original pageY), "deltaPageX" (the change in pageX), "deltaPageY" (the
   * change in pageY), "originalAngle" (if available, it will be the original angle of the drag in degrees
   * where 0 degrees as east, 90 is north, -90 is south, 180 is west), and modifiable member flags:
   * "preventDefault", and "stopPropagation".
   * @param {DOMNode} domNode the DOM node that can trigger the drag event
   * @param {Object} playload the specifics about the drag event
   * @param {Object} eventData the extra event data
   */
  adf.mf.api.amx.addDragListener = function(domNode, payload, eventData)
  {
    var options =
    {
      threshold: 5
    };
    _mergeSimpleObjects(options, payload);

    var backingListeners = [];
    if (options.start)
      backingListeners.push([ DRAGSTART, options.start ]);
    if (options.drag)
      backingListeners.push([ DRAGDRAG, options.drag ]);
    if (options.end)
      backingListeners.push([ DRAGEND, options.end ]);

    var dragEvents = amx.hasTouch() ? touchDragEvents : mouseDragEvents;

    backingListeners.push([ dragEvents.start, function(e)
      {
        domNode.setAttribute("data-amxDragInProgress", "yes");
        handleDragEvent.call(domNode, e, options);
      }]);
    backingListeners.push([ dragEvents.end, function(e)
      {
        cleanElementsWithDragInProgress();
      }]);
    if (dragEvents.cancel != "")
    {
      backingListeners.push([ dragEvents.cancel, function(e)
        {
          cleanElementsWithDragInProgress();
        }]);
    }

    _addSpecialBubbleEventListener(
      domNode,
      "amxdrag",
      payload,
      eventData,
      backingListeners);
  };

  function cleanElementsWithDragInProgress()
  {
    // Since we are not guaranteed to get an "end" for a "start" (e.g. the drag ended
    // on a different element than the start element) then we need to find all drag
    // elements and remove their "in-progress" markers:
    var elementsWithDragInProgress = document.querySelectorAll("*[data-amxDragInProgress]");
    for (var i = 0, count = elementsWithDragInProgress.length; i < count; ++i)
      elementsWithDragInProgress[i].removeAttribute("data-amxDragInProgress");

    // Ensure the drag is concluded:
    cancelPendingDrag(true, true);
  }

  /**
   * Apply innerHTML upon on element (this will call adf.mf.api.amx.emptyHtmlElement for
   * you).
   * @param {HTMLElement} parentElement the parent HTML element whose innerHTML is to be applied
   * @param {string} innerHtml the HTML to apply in the parentElement
   * @param {boolean} scriptEval whether script tags should be evaluated
   */
  adf.mf.api.amx.applyInnerHtml = function(parentElement, innerHtml, scriptEval)
  {
    adf.mf.api.amx.emptyHtmlElement(parentElement);
    parentElement.innerHTML = innerHtml;
    if (scriptEval)
    {
      // Loop through all script nodes in the parent (might be more than just innerHTML's):
      var scriptNodes = parentElement.querySelectorAll("script");
      for (var i = 0; i < scriptNodes.length; i++)
      {
        // Clone the node (if not previously-cloned)
        var scriptNode = scriptNodes[i];
        var scriptClone = cloneScriptNode(scriptNode);
        if (scriptClone)
          scriptNode.parentNode.replaceChild(scriptClone, scriptNode);
      }
    }
  };

  function cloneScriptNode(oldNode)
  {
    if (oldNode == null)
      return oldNode;
    var newNode = document.createElement("script");
    var cloneIdentifier = "data-amx-script-clone";
    newNode.setAttribute(cloneIdentifier, "yes"); // marker to prevent re-cloning
    newNode.text = oldNode.innerHTML;
    var attrs = oldNode.attributes;
    for (var i = attrs.length-1; i >= 0; i--)
    {
      var attr = oldNode.attributes[i];
      var attrName = attr.name;
      if (attrName == cloneIdentifier)
        return null; // found a script node that was previously-cloned
      newNode.setAttribute(attrName, attr.value);
    }
    return newNode;
  }

  /**
   * Remove a DOM node (and its children) but first removes event listeners
   * that were added via adf.mf.api.amx.addBubbleEventListener and ensures any
   * components inside it get cleaned up properly.
   * @param {DOMNode} domNode the DOM node to remove
   */
  adf.mf.api.amx.removeDomNode = function(domNode)
  {
    var i;

    // We need to proceed depth-first:
    if (domNode != null)
    {
      // Cancel pending drags if applicable
      // We need to cancel pending drags because they may have been abandoned
      // due to element removal during their "dragdrag" handlers.
      // This is needed for bug 18775524 but means we can't have a navigationDragBehavior.
      if (domNode.getAttribute && "yes" == domNode.getAttribute("data-amxDragInProgress"))
      {
        cancelPendingDrag(true, true);
      }

      // First we need to clean up any associated AMXNodes before the DOM is
      // removed or else the destroy handlers might lose important context.
      adf.mf.internal.amx.removeAmxDomNode(domNode);

      // Going depth-first, clean up the children:
      var children = domNode.childNodes;
      if (children != null)
      {
        for (i = children.length - 1; i >= 0; --i)
        {
          adf.mf.api.amx.removeDomNode(children[i]);
        }
      }

      // Unregister the event listeners:
      adf.mf.api.amx.removeBubbleEventListener(domNode);

      // In some cases an element delegates event listeners to the document like
      // amx:view for some document events. We need to make sure those get
      // unregistered too or else there would be a leak:
      if (domNode.__amxRemoveFunctions != null)
      {
        var removeFunctionCount = domNode.__amxRemoveFunctions.length;
        for (i = removeFunctionCount - 1; i >= 0; --i)
        {
          var removeFunc = domNode.__amxRemoveFunctions[i];
          try
          {
            removeFunc();
          }
          catch (problem)
          {
            adf.mf.log.logInfoResource(
              "AMXInfoBundle",
              adf.mf.log.level.SEVERE,
              "adf.mf.api.amx.removeDomNode",
              "MSG_ERROR_REMOVE_DOM_NODE_SCRIPT");

            // Only log the details at a fine level for security reasons
            if (adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
            {
              adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
                "adf.mf.api.amx", "removeDomNode",
                "Error in function: " + removeFunc + " error: " + problem);
            }
          }
        }
        domNode.__amxRemoveFunctions = null;
      }

      // Remove the node:
      if (domNode.parentNode != null)
        domNode.parentNode.removeChild(domNode);
    }
  };

  /**
   * Empty an HTML element by removing children DOM nodes and calling adf.mf.api.amx.removeDomNode on each
   * of the children nodes.
   * @param {HTMLElement} element the HTML element to empty
   */
  adf.mf.api.amx.emptyHtmlElement = function(element)
  {
    // HTMLElement element
    if (element != null)
    {
      var children = element.childNodes;
      if (children != null)
      {
        for (var i=children.length-1; i>=0; --i)
          adf.mf.api.amx.removeDomNode(children[i]);
      }
    }
  };

  /**
   * Enable scrolling for the given element.
   * This operation may append a style class to the element so ensure that you
   * do not overwrite the element class name after calling this API.
   */
  adf.mf.api.amx.enableScrolling = function(element)
  {
    var scrollPolicyClassName = "amx-scrollable";

    // In legacy skins, scrolling is much more aggressive so we have a different class name:
    var args = Array.prototype.slice.call(arguments);
    if (args.length == 2)
    {
      if (args[1] === true) // 2nd magic argument is whether you need legacy scrolling support
        scrollPolicyClassName = "amx-scrollPolicy-auto";
    }

    // Apply the class name:
    element.classList.add(scrollPolicyClassName);

    // Enable programmatic scrolling for Android if applicable:
    if (adf.mf.internal.amx.bindManualScrollers)
      adf.mf.internal.amx.bindManualScrollers(element);
  };

  function _shorten(object, limit)
  {
    if (object == null)
      result = object;
    else
    {
      var string = "" + object;
      if (string.length > limit)
        result = string.substring(0, limit-3).trim() + "...";
      else
        result = string;
      result = result.replace(/\n/g, " ").trim();
      result = result.replace(/[\s]+/g, " "); // collapse all spaces
    }
    return result;
  }

  /**
   * Generate a debugging string for events associated with a given HTML element.
   * @param {HTMLElement} element the HTML element whose event detail will be generated
   * @param {Number} shortenLimit optional number that can change the limit to the length of debug listener or data text
   * @return {String} a debugging string representing details about events associated with the given HTML element
   */
  adf.mf.api.amx.getEventDebugString = function(element, shortenLimit)
  {
    if (element == null)
      return element;

    if (shortenLimit === undefined)
      shortenLimit = 25;

    var domEventsMessage = "\n  n/a";
    var domListeners = element._amxListeners;
    if (domListeners != null)
    {
      var domListeners = element._amxListeners;
      var domListenerCount = domListeners.length;
      domEventsMessage = "";
      for (var i=0; i<domListenerCount; ++i)
      {
        var domListener = domListeners[i];
        var firstPrefix = "  " + (1+i) + " - ";
        var otherPrefix = Array(1+firstPrefix.length).join(" "); // empty spaces of equal length
        domEventsMessage += "\n" + firstPrefix + "type: " + domListener["eventType"];
        domEventsMessage += "\n" + otherPrefix + "listener: " + _shorten(domListener["listener"], shortenLimit);
        domEventsMessage += "\n" + otherPrefix + "data: " + _shorten(domListener["eventData"], shortenLimit);
      }
    }

    var specialEventsMessage = "\n  n/a";
    var specialEventsMap = element._amxSpecialEvents;
    if (specialEventsMap != null)
    {
      specialEventsMessage = "";
      var eventTypeCounter = 0;
      for (var eventType in specialEventsMap)
      {
        // Since there can be multiple instances of each special event type, each type points to an event key map.
        // The eventKeysMap is keyed by something that allows unique removal.
        // This key could be the developer's passed-in listener function (in the case of "tap" and "taphold") or
        // the developer's payload object (in the case of "amxdrag").
        var eventKeysMap = specialEventsMap[eventType];
        specialEventsMessage += "\n  " + ++eventTypeCounter + " - type: " + eventType;
        var eventKeyCounter = 0;
        for (var eventKey in eventKeysMap)
        {
          // Each entry in eventKeysMap is a eventDataMap.
          var eventDataMap = eventKeysMap[eventKey];
          specialEventsMessage += "\n    " + eventTypeCounter + "." + ++eventKeyCounter + " - key: " + _shorten(eventKey, shortenLimit);
          var eventDataCounter = 0;
          for (var eventData in eventDataMap)
          {
            // Each entry in eventDataMap is an array of instance listeners.
            var instanceListenersArray = eventDataMap[eventData];
            var instanceListenerCount = instanceListenersArray.length;
            specialEventsMessage += "\n      " + eventTypeCounter + "." + eventKeyCounter + "." + ++eventDataCounter + " - data: " + _shorten(eventData, shortenLimit);
            for (var i=0; i<instanceListenerCount; ++i)
            {
              // Each member of instanceListenersArray is a backing listener array where index 0 is an
              // DOM event type and index 1 is a DOM event handler function.
              specialEventsMessage += "\n        " + eventTypeCounter + "." + eventKeyCounter + "." + eventDataCounter + "." + (1+i) + " - DOM type: " + instanceListenersArray[i][0];
            }
          }
        }
      }
    }

    var message =
      "DOM events: " + domEventsMessage +
      "\nSpecial events:" + specialEventsMessage;
    return message;
  };

  //NOTE: The body of this function was removed to allow use of native scrolling in iOS 5.0 by
  // the use of the CSS "-webkit-overflow-scrolling: touch" on the amx-scrollable class, but the
  // binding itself remains because removing it causes AMX-processed touch events to fail
  // altogether.
  //TODO : Do we still need this (was in a jQuery load of amx-core)?
  adf.mf.api.amx.addBubbleEventListener(document.body, "touchmove", function(event) {});

  adf.mf.api.finishAnyLoading().then(
    function()
    {
      // Android workaround for form elements not appearing within visible part of the display
      // when a keyboard is shown (they would otherwise be covered up by the keyboard).
      if (adf.mf.internal.amx.agent["type"] == "Android")
      {
        var lastShowKeyboardTime = 0;
        var lastResizeTime = 0;
        var timeOutRunning = false;

        var scrollActiveElementIntoView = function()
        {
          timeOutRunning = false;

          var ae = document.activeElement;

          // Ignore the document body (when the active element has not been set).
          if (ae != document.body)
          {
            // Not every browser implements scrollIntoViewIfNeeded. The mobile browsers mostly
            // implement it, but check first before falling back on scrollIntoView.
            ae["scrollIntoViewIfNeeded"] ? ae.scrollIntoViewIfNeeded() : ae.scrollIntoView();
          }
        };

        var scrollActiveElementIntoViewIfAppropriate = function(newerTime, olderTime)
        {
          // Determine how long between the most recent showkeyboard and resize events.
          var timeDiff = newerTime - olderTime;

          // Is this resize due to the keyboard (close in time to the event)?
          if (timeDiff <= 750 && !timeOutRunning)
          {
            timeOutRunning = true;

            // Use a timeout to allow the browser time to redraw before trying to bring the
            // element into view.
            window.setTimeout(scrollActiveElementIntoView, 150);
          }
        };

        // Note: showkeyboard is only called on Android and it is called several times per one
        // showing of the keyboard for some unknown reason.
        document.addEventListener("showkeyboard",
          function(event)
          {
            // Record when the event was generated
            lastShowKeyboardTime = (new Date()).getTime();

            scrollActiveElementIntoViewIfAppropriate(lastShowKeyboardTime, lastResizeTime);
          });

        // The android:windowSoftInputMode is set to adjustResize, so the window will resize
        // to fit to the space left without the keyboard. Listen for this event so that we can
        // catch the resize event that happens after the showkeyboard event.
        window.addEventListener("resize",
          function(event)
          {
            // Record when the event was generated
            lastResizeTime = (new Date()).getTime();

            scrollActiveElementIntoViewIfAppropriate(lastResizeTime, lastShowKeyboardTime);
          });
      }
    });

})();
/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* ------------------- amx-validation.js ---------------------- */
/* ------------------------------------------------------ */

// ------ amx validations ------ //
(function()
{
  var ERROR_UPPER_STR = "ERROR";
  var WARNING_UPPER_STR = "WARNING";

  var INFO_STR = "info";
  var CONFIRMATION_STR = "confirmation";
  var WARNING_STR = "warning";
  var ERROR_STR = "error";
  var FATAL_STR = "fatal";

  // initialize display strings with fallback values - too early to load from resource bundle
  var INFO_DISPLAY_STR = "Info";
  var CONFIRMATION_DISPLAY_STR = "Confirmation";
  var WARNING_DISPLAY_STR = "Warning";
  var ERROR_DISPLAY_STR = "Error";
  var FATAL_DISPLAY_STR = "Fatal";

  var INFO_VAL = 4;
  var CONFIRMATION_VAL = 3;
  var WARNING_VAL = 2;
  var ERROR_VAL = 1;
  var FATAL_VAL = 0;

  // these maps are used to convert to and from severity string/int values
  var __severityStringToInt = {};
  __severityStringToInt[INFO_STR] = INFO_VAL;
  __severityStringToInt[CONFIRMATION_STR] = CONFIRMATION_VAL;
  __severityStringToInt[WARNING_STR] = WARNING_VAL;
  __severityStringToInt[ERROR_STR] = ERROR_VAL;
  __severityStringToInt[FATAL_STR] = FATAL_VAL;

  var __severityIntToDisplayString = {};
  __severityIntToDisplayString[INFO_VAL] = INFO_DISPLAY_STR;
  __severityIntToDisplayString[CONFIRMATION_VAL] = CONFIRMATION_DISPLAY_STR;
  __severityIntToDisplayString[WARNING_VAL] = WARNING_DISPLAY_STR;
  __severityIntToDisplayString[ERROR_VAL] = ERROR_DISPLAY_STR;
  __severityIntToDisplayString[FATAL_VAL] = FATAL_DISPLAY_STR;

  // This map is used to provide the associated resource bundle key. These ADFInfoBundle keys
  // are special cased in getResourceStringImpl(), and will always return a displayable value.
  var __severityDisplayStringBundleKey = {};
  __severityDisplayStringBundleKey[INFO_DISPLAY_STR] = "LBL_INFO_DISPLAY_STR";
  __severityDisplayStringBundleKey[CONFIRMATION_DISPLAY_STR] = "LBL_CONFIRMATION_DISPLAY_STR";
  __severityDisplayStringBundleKey[WARNING_DISPLAY_STR] = "LBL_WARNING_DISPLAY_STR";
  __severityDisplayStringBundleKey[ERROR_DISPLAY_STR] = "LBL_ERROR_DISPLAY_STR";
  __severityDisplayStringBundleKey[FATAL_DISPLAY_STR] = "LBL_FATAL_DISPLAY_STR";

  amx.validationsUnsetListEl = adf.mf.internal.el.parser.parse("#{validationScope.unsetList}");
  amx.validationsInvalidListEl = adf.mf.internal.el.parser.parse("#{validationScope.invalidList}");

  // this keeps track of the groups that have been validated
  // so that we know if we should be showing the required failures
  // or not
  var __validatedGroups = {};

  // this keeps track of whether or not we are currently validating group[s]
  var __isValidating = false;

  var validationExName = "oracle.adfmf.framework.exception.ValidationException";
  var batchValidationExName = "oracle.adfmf.framework.exception.BatchValidationException";

  adf.mf.api.amx.TypeHandler.register(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationGroup").prototype.render = function(amxNode)
  {
    var rootElement = document.createElement("div");
    var descendants = amxNode.renderDescendants();
    for (var i=0, size=descendants.length; i<size; ++i)
    {
      rootElement.appendChild(descendants[i]);
    }
    return rootElement;
  };

  // data change handler for when the validationList changes
  function validationsDataChangeHandler(el)
  {
    updateValidationMessages();
  }

  /**
   * This method will go through all of the items in validationData and extract
   * the current validation exceptions for the group id and add them to the
   * error message box.
   * @param validationData the data that contains all of the validation info
   * @param groupId the current group id
  */
  function updateValidationMessagesByGroupId(validationData, groupId)
  {
      var groupValidationData = validationData[groupId];
      if (groupValidationData === undefined)
      {
        return;
      }

      var groupInvalid = groupValidationData.invalid;
      for (item in groupInvalid)
      {
        var arrayList = groupInvalid[item];
        for(var index in arrayList)
        {
          var nvp = arrayList[index];
          adf.mf.api.amx.addMessage(nvp.name.toLowerCase(), nvp.value, null, null);
        }
      }

      // check for required failures
      var groupRequired = groupValidationData.required;
      for (item in groupRequired)
      {
        var text = groupRequired[item];
        adf.mf.api.amx.addMessage(ERROR_STR, text, null, null);
      }
  }

  /**
   * This method builds up the validation data given an array
   * of group ids to check. If any validation errors are present,
   * then they will be added to the error message box
   * @param groupsToCheck  the array of groups to check for validation errors
  */
  function updateValidationMessages(groupsToCheck)
  {
    if (amx.isValidating())
    {
      return;
    }

    // get all of the groups and all of the messages
    var validationGroupElements = document.getElementsByClassName("amx-validationGroup");

    if (validationGroupElements.length == 0)
    {
      // do nothing
      return;
    }

    var always =
      function(validationData)
      {
        // now show the message box
        if (groupsToCheck !== undefined && groupsToCheck != null && groupsToCheck.length > 0)
        {
          for (var i = 0; i < groupsToCheck.length; ++i)
          {
            var groupId = groupsToCheck[i];

            var groupValidationData = validationData[groupId];
            if (groupValidationData === undefined)
            {
              // no validation data present
              continue;
            }

            updateValidationMessagesByGroupId(validationData, groupId);
          }
        }
      };
    amx.buildValidationData(validationGroupElements).then(always, always);
  }

  function getCurrentPageGroup(id)
  {
    var thisPage = adf.mf.internal.controller.ViewHistory.peek().viewId;
    if (__validatedGroups[thisPage] === undefined)
    {
      __validatedGroups[thisPage] = {};
    }

    return __validatedGroups[thisPage];
  }

  function setGroupValidated(id)
  {
    var pageGroups = getCurrentPageGroup(id);
    pageGroups[id] = true;
  }

  function isGroupValidated(id)
  {
    var pageGroups = getCurrentPageGroup(id);
    return pageGroups[id] === true;
  }


  // detect if the xmlNode is rendered, visible, and shown on the screen
  amx.isNodeRendered = function(amxNode)
  {
    if (!amxNode.isReadyToRender())
    {
      return false;
    }

    // TODO: this has no place in a global function:
    if (amxNode.getTag().getNsPrefixedName() == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":popup")
    {
      if (amxNode.getAttribute("_renderPopup"))
      {
        return true;
      }

      return false;
    }

    var attr = amxNode.getAttribute("visible");
    if(typeof attr !== "undefined")
    {
      if(adf.mf.api.amx.isValueFalse(attr))
      {
        return false;
      }
    }

    return true;
  };

  function setValidationWatchData(groupId, amxNode, watchData, addRequired)
  {
    var attributeValue = amxNode.__getAttributeToValidate();
    if (attributeValue == null)
    {
      return;
    }

    var attributeValueEl = amxNode.getAttributeExpression(attributeValue, true);

    if (amx.containsELExpressions(attributeValueEl))
    {
      if (watchData.el[attributeValueEl] === undefined)
      {
        watchData.el[attributeValueEl] = [];
      }

      if(watchData.el[attributeValueEl].indexOf(groupId) < 0)
      {
        watchData.el[attributeValueEl].push(groupId);
      }
    }

    // now check to see if this is required
    if (adf.mf.api.amx.isValueTrue(amxNode.getAttribute("required")) == false)
    {
      return;
    }

    var nodeValue = amxNode.getAttribute(attributeValue);
    // if the returned value is an array, then we will validate the length
    if (Array.isArray(nodeValue))
    {
      if (nodeValue.length > 0)
      {
        return;
      }
    }
    else if (amx.getTextValue(nodeValue) !== "")
    {
      return;
    }

    if (addRequired == false)
    {
      // this group has not been validated yet, so disregard
      return;
    }

    var tag = amxNode.getTag();
    var key;
    var nsPrefixedName = tag.getNsPrefixedName();
    if (nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":selectOneChoice" ||
        nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":selectManyChoice")
    {
      key = "MSG_MAKE_A_SELECTION";
    }
    else
    {
      key = "MSG_ENTER_A_VALUE";
    }

    var msg = adf.mf.resource.getInfoString("AMXInfoBundle", key);
    var label = amxNode.getAttribute("label");
    if (label == null)
    {
      label = "";
    }
    var text = label + ": " + msg;

    if (watchData.required[groupId] === undefined)
    {
      watchData.required[groupId] = [];
    }

    watchData.required[groupId].push(text);
  }

  // add to the passed in list an el expressions that this node
  // and this node's descendants are watching
  function buildValidationWatchData(groupId, domElement, watchData, addRequired)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var childNodes = domElement.childNodes;

        if (childNodes && childNodes.length > 0)
        {
          var childPromiseArray = [];
          // for each node
          for (var i = 0; i < childNodes.length; ++i)
          {
            var childNode = childNodes[i];

            // only check for node info if this is an amx-node
            // if not, just assume this is a container for actual amx-nodes
            if (childNode.nodeType == 1/*ELEMENT_NODE*/ && childNode.classList.contains("amx-node"))
            {
              var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(childNode, "amxNode");
              if (amxNode === undefined)
              {
                continue;
              }

              if (amx.isNodeRendered(amxNode) == false)
              {
                continue;
              }

              setValidationWatchData(groupId, amxNode, watchData, addRequired);
            }

            var childPromise = buildValidationWatchData(groupId, childNode, watchData, addRequired);
            childPromiseArray.push(childPromise);
          }
          adf.mf.internal.BasePromise.all(childPromiseArray).then(
            function()
            {
              resolve();
            });
        }
        else
        {
          resolve();
        }
      });
  }

  // build a list of all the el expressions that this group/array of groups are watching
  function buildValidationGroupWatchData(groupElements, isValidating)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var arrayOfPromises = [];
        var watchData = {
          el: {},
          required: {}
        };

        for (var i = 0; i < groupElements.length; ++i)
        {
          var groupElement = groupElements[i];
          if (groupElement.length != null)
          {
            groupElement = groupElement[0];
          }
          var addRequired;
          var id = adf.mf.internal.amx._getNonPrimitiveElementData(groupElement, "amxNode").getId();
          if (isValidating == true)
          {
            // add this to the list so that buildElWatchArray will return any required
            // failures for this group
            setGroupValidated(id);
            addRequired = true;
          }
          else
          {
            addRequired = isGroupValidated(id);
          }

          arrayOfPromises.push(buildValidationWatchData(id, groupElement, watchData, addRequired));
        }

        adf.mf.internal.BasePromise.all(arrayOfPromises).then(
          function()
          {
            resolve(watchData);
          });
      });
  }

  function getValidationDataForGroup(validationData, groupId, watchData)
  {
    if (validationData[groupId] === undefined)
    {
      validationData[groupId] = {
        invalid: [],
        required: []
      };
    }

    return validationData[groupId];
  }

  function buildValidationDataInternal(groupElements, isValidating, validationWatchData)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        if (groupElements.length == 0)
        {
          // nothing to do here, so just resolve it
          resolve();
          return;
        }
        amx.getElValue(amx.validationsInvalidListEl).then(
          function(requestAndResponse)
          {
            var response = requestAndResponse[1];
            var invalidList = response[0].value;
            var elWatchPromise =
              new adf.mf.internal.BasePromise(
                function(elWatchPromiseResolve, elWatchPromiseReject)
                {
                  if (validationWatchData == null)
                  {
                    var always = function(watchData)
                      {
                        validationWatchData = watchData;
                        elWatchPromiseResolve();
                      };
                    buildValidationGroupWatchData(groupElements, isValidating).then(always, always);
                  }
                  else
                  {
                    elWatchPromiseResolve();
                  }
                });

            var elWatchPromiseAlways = function()
            {
              var hasError = false;
              var hasWarning = false;
              var validationData = {};

              for(var item in validationWatchData.required)
              {
                if(validationWatchData.required.hasOwnProperty(item))
                {
                  hasError = true;

                  var groupValidationData = getValidationDataForGroup(validationData, item, validationWatchData);
                  // add all of these to the required list
                  groupValidationData.required = validationWatchData.required[item];
                }
              }

              // iterate through the invalid el expressions and determine if
              // the expression is in the list of el expressions that are
              // defined in descendants of the validationGroup tag
              for(var item in invalidList)
              {
                if(invalidList.hasOwnProperty(item))
                {
                  var elInfo = validationWatchData.el[item];
                  if(elInfo === undefined)
                  {
                    // not in the list
                    continue;
                  }

                  var arrayList = invalidList[item];
                  if (hasError == false)
                  {
                    for(var index in arrayList)
                    {
                      var nvp = arrayList[index];
                      if (nvp.name == ERROR_UPPER_STR)
                      {
                        hasError = true;
                        break;
                      }

                      if (nvp.name == WARNING_UPPER_STR)
                      {
                        hasWarning = true;
                      }
                    }
                  }

                  for (var group in elInfo)
                  {
                    var groupId = elInfo[group];
                    var groupValidationData = getValidationDataForGroup(validationData, groupId, validationWatchData);
                    groupValidationData.invalid.push(arrayList);
                  }
                }
              }

              if (hasError)
              {
                // let the caller know that navigation should fail
                reject(validationData);
                return;
              }

              // succeeded, but with possible warnings, so send in the data array
              resolve(validationData);
            };

            elWatchPromise.then(elWatchPromiseAlways, elWatchPromiseAlways);
          },
          function(requestAndResponse)
          {
            // failed to retrieve the invalid list - allow navigation to proceed
            resolve();
          });
      });
  }

  amx.buildValidationData = function(elementArray)
  {
    return buildValidationDataInternal(elementArray, false, null);
  };

  function getGroupsById(domElement)
  {
    var popupElement = _getClosestAncestorByClassName(domElement, "amx-popup");
    var validationGroupElements;
    if (popupElement != null)
    {
      // we are inside a popup, so we need to get a list of all of the groups in this popup
      validationGroupElements = popupElement.getElementsByClassName("amx-validationGroup");
    }
    else
    {
      validationGroupElements = document.getElementsByClassName("amx-validationGroup");
    }

    var groupsById = {};
    for (var i = 0; i < validationGroupElements.length; ++i)
    {
      var groupElement = validationGroupElements[i];
      var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(groupElement, "amxNode");
      var id = amxNode.getId();
      groupsById[id] = groupElement;
    }

    return groupsById;
  }

  // get the list of all of the groups that this control validates against
  function getValidationGroupList(domElement)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(domElement, "amxNode");
        if (amxNode == null && adf.mf.environment.profile.mockData)
        {
          // Hosted CompGallery will experience this when changing row selection (e.g. listItemStyles.amx)
          resolve([]);
          return;
        }
        var tag = amxNode.getTag();
        var children = tag.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "validationBehavior");
        var len = children.length;
        var groups = [];

        if (len > 0)
        {
          var groupIdArray = [];
          var propPromises = [];

          for (var i = 0; i < len; ++i)
          {
            var subTag = children[i];

            var disabledEl = subTag.getAttribute("disabled");
            if (disabledEl != null)
            {
              var propPromise = new adf.mf.internal.BasePromise(
                function(propPromiseResolve, propPromiseReject)
                {
                  amx.getElValue(disabledEl)
                    .then(
                      function(requestAndResponse)
                      {
                        var response = requestAndResponse[1];
                        var resp = response[0];
                        if (adf.mf.api.amx.isValueTrue(resp.value))
                        {
                          propPromiseResolve();
                          return;
                        }
                        var groupId = subTag.getAttribute("group");
                        if (groupIdArray.indexOf(groupId) < 0)
                        {
                          groupIdArray.push(groupId);
                        }
                        propPromiseResolve();
                      },
                      propPromiseResolve);
                  });

              propPromises.push(propPromise);
            }
            else
            {
              var groupId = subTag.getAttribute("group");
              if (groupIdArray.indexOf(groupId) < 0)
              {
                groupIdArray.push(groupId);
              }
            }
          }

          adf.mf.internal.BasePromise.all(propPromises).then(
            function()
            {
              var groupsById = getGroupsById(domElement);
              for (var i = 0; i < groupIdArray.length; ++i)
              {
                var group = groupsById[groupIdArray[i]];
                if (typeof group !== "undefined")
                {
                  groups.push(group);
                }
              }

              resolve(groups);
            });
        }
        else
        {
          resolve(groups);
        }
      }, true /* needed for jQuery-like callbacks without timeouts */);
  }

  amx.requiredControlValueChanged = function(validationGroup)
  {
    if (amx.isValidating())
    {
      return;
    }

    // mark this group as validated
    var amxNode = adf.mf.internal.amx._getNonPrimitiveElementData(validationGroup, "amxNode");
    if (amxNode)
    {
      setGroupValidated(amxNode.getId());
      updateValidationMessages();
    }
  };

  function validateBegin()
  {
    __isValidating = true;
  }

  function validateEnd(groupElements, validationData)
  {
    __isValidating = false;

    if (groupElements === undefined || groupElements.length == 0)
    {
      // no groups were validated, exit early
      return;
    }

    var groupsToCheck = [];

    if (validationData !== undefined)
    {
      // if the validationData is not undefined, then there was a failure
      // go through and create a list of the groups that may need a message box
      for (groupId in validationData)
      {
        if(validationData.hasOwnProperty(groupId) == false)
        {
          continue;
        }

        groupsToCheck.push(groupId);
      }
    }

    updateValidationMessages(groupsToCheck);
  }

  amx.isValidating = function()
  {
    return __isValidating;
  };

  function validateInternal(domElement)
  {
    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        var always =
          function(groupElements)
          {
            // we now have the list of groups that we need to validate, so go
            // through them all and verify every el expressions is in the valid state
            if (groupElements.length == 0)
            {
              // everything is valid since there are no groups
              resolve(groupElements);
              return;
            }

            // make sure all of the unset values are validated
            amx.getElValue(amx.validationsUnsetListEl).then(
              function(requestAndResponse)
              {
                var response = requestAndResponse[1];
                var unsetList = response[0].value;
                // set this to null so that we only build up the node list when we want to
                // figure out if an item is valid or not
                var validationWatchData = null;
                var elToResolve = [];
                var unsetPromise =
                  new adf.mf.internal.BasePromise(
                    function(unsetPromiseResolve, unsetPromiseReject)
                    {
                      if (unsetList.length > 0)
                      {
                        buildValidationGroupWatchData(groupElements, true).then(function(watchData)
                        {
                          validationWatchData = watchData;
                          for (var i = 0; i < unsetList.length; ++i)
                          {
                            var item = unsetList[i];
                            if(validationWatchData.el[item] === undefined)
                            {
                              // not in the list
                              continue;
                            }

                            elToResolve.push(item);
                          }

                          if (elToResolve.length > 0)
                          {
                            amx.getElValue(elToResolve).then(
                              function(requestAndResponse)
                              {
                                var response = requestAndResponse[1];
                                // all the el expressions are resolved, so create an
                                // array of values to set
                                var setList = [];
                                // we might have more responses than just our requests, so make sure we handle that here
                                for (var i = 0; i < response.length; ++i)
                                {
                                  var item = response[i];
                                  if (elToResolve.indexOf(item.name) < 0)
                                  {
                                    // not part of what we requested
                                    continue;
                                  }

                                  setList.push({name:item.name, value:amx.getObjectValue(item.value)});
                                }
                                amx.setElValue(setList).then(
                                  function(requestAndResponse)
                                  {
                                    // success (but with possible failures), just continue
                                    // and check the invalid list later
                                    unsetPromiseResolve();
                                  },
                                  function(requestAndResponse)
                                  {
                                    // failure, just continue and check the invalid list later
                                    unsetPromiseResolve();
                                  });
                              },
                              function(requestAndResponse)
                              {
                                // failure, just continue and check the invalid list later
                                unsetPromiseResolve();
                              });
                          }
                          else
                          {
                            unsetPromiseResolve();
                          }
                        },
                        function()
                        {
                          unsetPromiseResolve();
                        });
                      }
                      else
                      {
                        unsetPromiseResolve();
                      }
                    });

                unsetPromise.then(
                  function()
                  {
                    buildValidationDataInternal(groupElements, true, validationWatchData).then(
                      function(validationData)
                      {
                        // we can navigate (may have warnings)
                        resolve([groupElements, validationData]);
                      },
                      function(validationData)
                      {
                        // we can NOT navigate
                        reject([groupElements, validationData]);
                      });
                  });
              },
              function(requestAndResponse)
              {
                // failed to retrieve the unset list - allow navigation to proceed
                resolve(groupElements);
              });
          };
        getValidationGroupList(domElement).then(always, always);
      }, true /* needed for jQuery-like callbacks without timeouts */);
  }

  /**
   * Use this when performing an operation like a navigation where you would want to prevent navigating
   * when there are unsatisfied validators (required or AMX validationBehavior).
   * The successCallback will be invoked if allowed to proceed.
   * @param {DOMNode} domNode the element whose associated validation is to be tested
   * @param {function} successCallback the function to invoke if the event should be accepted
   */
  adf.mf.api.amx.validate = function(domNode, successCallback)
  {
    amx.validate(domNode).then(function()
    {
      if (successCallback && adf.mf.api.amx.acceptEvent())
      {
        successCallback();
      }
    });
  };

  /**
   * Private, internal function.
   */
  amx.validate = function(domElement)
  {
    var perf = adf.mf.internal.perf.startMonitorCall("Validate node", adf.mf.log.level.FINER, "amx.validate");

    return new adf.mf.internal.BasePromise(function(resolve, reject)
      {
        validateBegin();
        validateInternal(domElement)
          .then(
            function(groupElementsAndValidationData)
            {
              var groupElements = groupElementsAndValidationData[0];
              validateEnd(groupElements);
              perf.stop();
              resolve();
            },
            function(groupElementsAndValidationData)
            {
              var groupElements = groupElementsAndValidationData[0];
              var validationData = groupElementsAndValidationData[1];
              validateEnd(groupElements, validationData);
              perf.stop();
              reject();
            });
      }, true /* needed for jQuery-like callbacks without timeouts */);
  };

  // register the data change handler
  adf.mf.api.addDataChangeListeners(amx.validationsInvalidListEl, validationsDataChangeHandler);

  //--------- ErrorHandler ---------//
  // taken from Trinidad.Core.js
  /**
   * Return true if the object or any of its prototypes'
   * are an instance of the specified object type.
   * @param {Object} obj the object instance
   * @param {Object} type the constructor function
   */
  function _instanceof(obj, type)
  {
    if (type == (void 0))
      return false;

    if (obj == (void 0))
      return false;

    while (typeof(obj) == "object")
    {
      if (obj.constructor == type)
        return true;

      // walk up the prototype hierarchy
      obj = obj.prototype;
    }

    return false;
  }

  /**
   * The is the home for all error handling. This gets registered as an error handler
   * in adf.mf.api.amx.loadTrinidadResources (amx-resource.js) and will extract the
   * relevant error information and call adf.mf.api.amx.addMessage
   *
   * @param request the channel request, can be null if this is called manually
   * @param response a JS Error instance, a TrConverterException or TrValidatorException instance,
   *                 or an exception in JSON form
  */
  adf.mf.internal.amx.errorHandlerImpl = function(request, response)
  {
    // detect if this is a known Trinidad error class
    if (_instanceof(response, window["TrConverterException"]) || _instanceof(response, window["TrValidatorException"]))
    {
      var facesMsg = response.getFacesMessage();
      var severity = facesMsg.getSeverity();
      var severityStr = ERROR_STR;
      if (severity == TrFacesMessage.SEVERITY_INFO)
      {
        severityStr = "info";
      }
      else if (severity == TrFacesMessage.SEVERITY_WARN)
      {
        severityStr = "warning";
      }
      else if (severity == TrFacesMessage.SEVERITY_ERROR)
      {
        severityStr = ERROR_STR;
      }
      else // if (severity == TrFacesMessage.SEVERITY_FATAL)
      {
        severityStr = "fatal";
      }
      adf.mf.api.amx.addMessage(severityStr, facesMsg.getDetail(), null, null);
      return;
    }

    // detect if this is a known js error class
    if (_instanceof(response, Error))
    {
      adf.mf.api.amx.addMessage(ERROR_STR, response.message, null, null);
      return;
    }

    // assume this is an exception from the channel
    var exceptionClassName = response[adf.mf.internal.api.constants.TYPE_PROPERTY];
    var isBatchValidation = (exceptionClassName == batchValidationExName);
    // check to see if we are in the process of validating all of the
    // el expressions contained in this group. We will go back and add
    // of the validation messages from the validationContext, so don't
    // add any that fire right now
    if (amx.isValidating())
    {
      if (isBatchValidation || exceptionClassName == validationExName)
      {
        return;
      }
    }

    if (isBatchValidation)
    {
      // loop through the the batch exceptions and add them one by one
      var batch = response.batch;
      if (batch !== undefined && batch != null)
      {
        for (var i = 0; i < batch.length; ++i)
        {
          addMessageFromException(batch[i]);
        }
      }
      return;
    }

    addMessageFromException(response);
  };

  function addMessageFromException(ex)
  {
    if (ex.exception)
      ex = ex.exception;
    var msg = ex.message;
    var severity = ex.severity;
    if (severity === undefined)
      severity = "fatal";
    adf.mf.api.amx.addMessage(severity == null ? "severe" : severity.toLowerCase(), msg, null, null);
  }

  /**
   * Adds a message to the message box (and shows it if it isn't already showing.
   * @param {string} severity the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   * @param {string} summary the short title of the message (e.g. exception message)
   * @param {string} detail null or the optional long detail of the message (e.g. stack trace)
   * @param {string} clientId null or the optional client ID that uniquely identify which component instance the message should be associated with
   */
  adf.mf.api.amx.addMessage = function(severity, summary, detail, componentClientId)
  {
    messageBoxCreate().addItem(severity, summary, detail);
  };

  function severityStringToInt(severity)
  {
    var val = __severityStringToInt[severity];
    if (val == null)
    {
      val = ERROR_VAL;
    }

    return val;
  }

  function severityIntToDisplayString(severity)
  {
    var val = __severityIntToDisplayString[severity];
    if (val == null)
    {
      val = ERROR_DISPLAY_STR;
    }

    return val;
  }

  //--------- ErrorHandler ---------//

  /**
   * Get the child elements that have the specified class names.
   * @param {HTMLElement} parentElement the element whose children will be traversed
   * @param {Array.<String>} classNames the class names to search for
   * @param {boolean} searchInChildOrder whether to start looking at the first child then second, etc.
   * @return {Array} an array of found elements whose entries match the specified classNames order
   */
  function _getChildrenByClassNames(parentElement, classNames, searchInChildOrder)
  {
    var childNodes = parentElement.childNodes;
    var childNodeCount = childNodes.length;
    var classNameCount = classNames.length;
    var foundChildren = [];
    var foundCount = 0;
    if (searchInChildOrder === false) // start with the last index
    {
      for (var i = childNodeCount - 1; i >= 0 && foundCount < classNameCount; --i)
      {
        var child = childNodes[i];
        for (var j = 0; j < classNameCount; ++j)
        {
          if (child.nodeType == 1/*ELEMENT_NODE*/ && child.classList.contains(classNames[j]))
          {
            foundChildren[j] = child;
            ++foundCount;
            break; // done with this specific child
          }
        }
      }
    }
    else // start with the first index:
    {
      for (var i = 0; i < childNodeCount && foundCount < classNameCount; ++i)
      {
        var child = childNodes[i];
        for (var j = 0; j < classNameCount; ++j)
        {
          if (child.nodeType == 1/*ELEMENT_NODE*/ && child.classList.contains(classNames[j]))
          {
            foundChildren[j] = child;
            ++foundCount;
            break; // done with this specific child
          }
        }
      }
    }
    return foundChildren;
  }

  /**
   * Get the nearest ancestor element that has the specified class name (could be the specified element too).
   * @param {HTMLElement} startingElement the element (inclusive) to find the closest ancestor with the given className
   * @param {string} className the class name to search for
   * @return {HTMLElement} the found ancestor element whose or null if not found
   */
  function _getClosestAncestorByClassName(startingElement, className)
  {
    if (startingElement == null)
      return null;
    else if (startingElement.className == className)
      return startingElement;
    else
      return _getClosestAncestorByClassName(startingElement.parentNode, className);
  }

  //--------- MessageBox ---------//
  function MessageBox()
  {
  }

 /**
   * Creates or returns the header object as the first entry in the content.
  */
  MessageBox.prototype.getHeader = function()
  {
    var headerClassName = "amx-messages-header";
    // ake sure that the first item in the content is not a header
    var firstNode = this.contentElement.firstChild;
    var headerNode;
    if (firstNode == null ||
      firstNode.nodeType != 1 /*ELEMENT_NODE*/ ||
      !firstNode.classList.contains(headerClassName))
    {
      headerNode = document.createElement("div");
      headerNode.className = headerClassName;
      this.contentElement.parentNode.insertBefore(headerNode, this.contentElement);
    }
    else
    {
      headerNode = firstNode;
    }
    return headerNode;
  };

  /**
   * This updates the messagebox label if the type of message
   * is more severe than the current label severity
   * ("error" takes precedence over "warning")
   * @param type the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   */
  MessageBox.prototype.setHeaderLabel = function(type)
  {
    var typeValue = severityStringToInt(type);

    if (this.headerValue == null || typeValue < this.headerValue)
    {
      this.headerValue = typeValue;
    }
    else
    {
      return;
    }

    // Ensure that we only have the most-severe header:
    var parentNode = this.contentElement.parentNode;
    var headers = parentNode.querySelectorAll(".amx-messages-header");
    for (var i=headers.length-1; i>=0; --i)
    {
      var oldHeader = headers[i];
      var oldValue = parseInt(oldHeader.getAttribute("data-value"), 10);
      if (oldValue >= this.headerValue)
      {
        adf.mf.api.amx.removeDomNode(oldHeader);
      }
    }

    var newHeader = severityIntToDisplayString(this.headerValue);
    var headerNode = this.getHeader();
    headerNode.setAttribute("data-value", this.headerValue);
    // remove the current message, if it exists
    headerNode.innerHTML = "";
    // now add the message label
    var labelNode = document.createElement("div");
    labelNode.className = "amx-messages-header-text";
    labelNode.textContent = adf.mf.resource.getInfoString(adf.mf.resource.ADFInfoBundleName, __severityDisplayStringBundleKey[newHeader]);
    labelNode.setAttribute("role", "heading");
    headerNode.appendChild(labelNode);
  };

  /**
   * This adds the passed in data to the current message box
   * Note: if the type of message is more severe than the current
   * label severity, it will be replace
   * ("error" takes precedence over "warning")
   * @param type the severity of the message (e.g. "fatal", "error", "warning", "confirmation", "info")
   * @param summary the error summary message
   * @param detail any extra detail to be shown to the user, or null
  */
  MessageBox.prototype.addItem = function(type, summary, detail)
  {
    this.setHeaderLabel(type);
    // for now, type can only be warning or error since we don't have graphics
    // for the other ones. So error will be "error" and "fatal" and all else
    // will be warnings
    var typeValue = severityStringToInt(type);
    var errorClass;
    switch (typeValue)
    {
      case INFO_VAL:
        errorClass = INFO_STR;
        break;
      case CONFIRMATION_VAL:
        errorClass = CONFIRMATION_STR;
        break;
      case WARNING_VAL:
        errorClass = WARNING_STR;
        break;
      default: // error and fatal
        errorClass = ERROR_STR;
    }
    var itemNode = document.createElement("div");
    itemNode.className = "amx-messages-item";
    itemNode.setAttribute("role", "listitem");
    var textItem1 = document.createElement("div");
    textItem1.className = "amx-messages-text amx-messages-text-" + errorClass + " amx-messages-" + errorClass;
    textItem1.textContent = summary;
    if (detail !== undefined && detail != null && detail != "")
    {
      textItem1.appendChild(document.createElement("br"));
      textItem1.appendChild(document.createTextNode(detail));
    }
    var prevMessagesItem = _getChildrenByClassNames(this.contentElement, ["amx-messages-item"], false)[0];
    var prevTextItem = null;
    if (prevMessagesItem != null)
      prevTextItem = _getChildrenByClassNames(prevMessagesItem, ["amx-messages-text"], false)[0];
    if (prevTextItem == null)
    {
      textItem1.classList.add("amx-messages-first");
    }
    else
    {
      prevTextItem.classList.remove("amx-messages-last");
    }
    // this is the last item
    textItem1.classList.add("amx-messages-last");
    itemNode.appendChild(textItem1);
    var icon = document.createElement("div");
    icon.className = "amx-messages-icon amx-messages-icon-" + errorClass;
    itemNode.appendChild(icon);
    this.contentElement.appendChild(itemNode);

    // now center the whole msg box vertically
    var messageBoxElement = this.messageBoxElement;
    var messageBoxComputedStyle = adf.mf.internal.amx.getComputedStyle(messageBoxElement);
    var messageBoxMarginTop = messageBoxComputedStyle.marginTop;
    var messageBoxMarginBottom = messageBoxComputedStyle.marginBottom;
    var messageBoxOuterHeight =
      messageBoxElement.offsetHeight +
      parseInt(messageBoxMarginTop, 10) +
      parseInt(messageBoxMarginBottom, 10);

    // In order to center the message box on the view, we need its height.
    // It is possible to display an error prior to displaying the first view so
    // in that case we should use the body height as a fallback.
    var bodyPageViews = document.getElementById("bodyPageViews");
    var firstViewContainer = _getChildrenByClassNames(bodyPageViews, ["amx-view-container"])[0];
    var viewElement = document.body;
    if (firstViewContainer != null)
      viewElement = _getChildrenByClassNames(firstViewContainer, ["amx-view"])[0];
    var viewHeight = viewElement.offsetHeight;

    var newTop;
    if (messageBoxOuterHeight < viewHeight)
    {
      newTop = (viewHeight - messageBoxOuterHeight)/2;
    }
    else
    {
      newTop = 0;
    }

    messageBoxElement.style.top = newTop + "px";
  };

  /**
   * Adds the footer than contains the OK button
  */
  MessageBox.prototype.addFooter = function(messageBoxContainer)
  {
    var footerNode = document.createElement("div");
    footerNode.className = "amx-messages-footer";
    var btnNode = document.createElement("div");
    btnNode.className = "amx-messages-btn amx-commandButton";
    // Adding WAI-ARIA Attribute for the message box commandButton role attribute
    btnNode.setAttribute("role", "button");
    var buttonLabel = document.createElement("div");
    buttonLabel.className = "amx-messages-btn-label amx-commandButton-label";

    // ADFInfoBundle[LBL_OK_DISPLAY_STR] is special cased in getResourceStringImpl(), and will always return a displayable value
    buttonLabel.textContent = adf.mf.resource.getInfoString(adf.mf.resource.ADFInfoBundleName, "LBL_OK_DISPLAY_STR");

    btnNode.appendChild(buttonLabel);
    footerNode.appendChild(btnNode);
    var mousedown = "mousedown";
    var mouseup = "mouseup";
    if (amx.hasTouch())
    {
      mousedown = "touchstart";
      mouseup = "touchend";
    }
    adf.mf.api.amx.addBubbleEventListener(btnNode, mousedown, function()
    {
      btnNode.classList.add("amx-selected");
    });
    adf.mf.api.amx.addBubbleEventListener(btnNode, mouseup, function()
    {
      btnNode.classList.remove("amx-selected");
    });
    adf.mf.api.amx.addBubbleEventListener(btnNode, "mouseout", function()
    {
      btnNode.classList.remove("amx-selected");
    });

    var extendedTarget = document.createElement("div");
    extendedTarget.className = "amx-extendedTarget";
    btnNode.appendChild(extendedTarget);

    messageBoxContainer.appendChild(footerNode);
    return btnNode;
  };

  /**
   * Creates the basic structure of this message box class
  */
  MessageBox.prototype.create = function()
  {
    var bodyPageViews = document.getElementById("bodyPageViews");
    var messageBoxElement = document.createElement("div");
    messageBoxElement.id = "amxMessageBox";
    // make sure this responds to dragging for scrolling purposes
    adf.mf.api.amx.enableScrolling(messageBoxElement);
    messageBoxElement.classList.add("messageBox");
    var messageBoxScreen = document.createElement("div");
    messageBoxScreen.className = "transparentScreen messageBoxScreen";
    bodyPageViews.appendChild(messageBoxScreen);
    bodyPageViews.appendChild(messageBoxElement);
    adf.mf.internal.amx._setNonPrimitiveElementData(messageBoxElement, "messageBox", this);
    var messageBoxObject = this;
    this.e = messageBoxElement;
    this.screen = messageBoxScreen;
    messageBoxElement.style.display = "none";
    var messageBoxContainer = document.createElement("div");
    messageBoxContainer.className = "messageBoxContainer";
    // Adding WAI-ARIA Attribute for role the message container div
    messageBoxContainer.setAttribute("role", "alertdialog");
    messageBoxElement.appendChild(messageBoxContainer);
    var messageBoxContent = document.createElement("div");
    messageBoxContent.className = "messageBoxContent";
    messageBoxContent.setAttribute("role", "list");
    messageBoxContainer.appendChild(messageBoxContent);
    this.contentElement = messageBoxContent;
    this.messageBoxElement = messageBoxElement;
    var okButton = this.addFooter(messageBoxContainer);

    /*adf.mf.api.amx.addBubbleEventListener(messageBoxScreen, "tap", function()
    {
      // this is always modal for now
      // messageBox.hide();
    });*/

    adf.mf.api.amx.addBubbleEventListener(okButton, "tap", function(event)
      {
        // Eat the event since this button is handling it:
        event.preventDefault();
        event.stopPropagation();

        // Delay the DOM removal so that the event eating doesn't fail to trigger a focus
        // on some input component behind this popup (we don't want the input's keyboard to appear):
        setTimeout(function()
        {
          messageBoxObject.hide();
        },
        0);
      });

    return messageBoxElement;
  };

  /**
   * Shows the message box to the user
  */
  MessageBox.prototype.show = function()
  {
    var messageBoxElement = this.e;
    var messageBoxScreen = this.screen;

    messageBoxScreen.style.display = "";
    messageBoxElement.style.display = "";

    // All view containers are now hidden from screen readers (we can't just
    // look for the first one because an error could occur while transitioning):
    var foundViewContainers = document.getElementsByClassName("amx-view-container");
    for (var i=0, elementCount=foundViewContainers.length; i<elementCount; i++)
    {
      foundViewContainers[i].setAttribute("aria-hidden", "true"); // Note: toggling this doesn't work on iOS 5 but does in iOS 6
    }
  };

  /**
   * Hides the message box from the user
  */
  MessageBox.prototype.hide = function()
  {
    var messageBoxElement = this.e;
    var messageBoxScreen = this.screen;

    var messageBoxContent = this.contentElement;
    messageBoxContent.innerHTML = "";

    adf.mf.api.amx.removeDomNode(messageBoxElement);
    adf.mf.api.amx.removeDomNode(messageBoxScreen);

    // All view containers are no longer hidden from screen readers (we can't just
    // look for the first one because an error could occur while transitioning):
    var foundViewContainers = document.getElementsByClassName("amx-view-container");
    for (var i=0, elementCount=foundViewContainers.length; i<elementCount; i++)
    {
      foundViewContainers[i].setAttribute("aria-hidden", "false"); // Note: toggling this doesn't work on iOS 5 but does in iOS 6
    }
  };

  function messageBoxCreate()
  {
    var messageBoxElement = null;
    var messageBoxObject = null;
    var foundMessageBoxElements = document.getElementsByClassName("messageBox");
    if (foundMessageBoxElements.length > 0)
    {
      messageBoxElement = foundMessageBoxElements[0];
      messageBoxObject = adf.mf.internal.amx._getNonPrimitiveElementData(messageBoxElement, "messageBox");
    }
    else
    {
      messageBoxObject = new MessageBox();
      messageBoxElement = messageBoxObject.create();
    }
    messageBoxObject.show();
    return messageBoxObject;
  };
  //--------- /MessageBox ---------//
})();
// @compiled on Sat Aug 13 01:07:17 MDT 2016
// Note: this is a generated file all changes will be lost. 


/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/ControlFlowEngine.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.ControlFlowEngine = ControlFlowEngine;
  function ControlFlowEngine()
  {}

  ControlFlowEngine.BACK_NAV_OUTCOME = "__back";
  // For backward compatability, remove after tests transition to the new value above.
  ControlFlowEngine.BACK_NAV_OUTCOME_OLD = "_BACK_BUTTON:";

  ControlFlowEngine.doRouting = function(routingState)
  {
    //
    //  See if routing is complete.
    //
    if (!routingState.isRoutingComplete())
    {
      //
      //  Routing is not yet complete so we need to get the ID of the next
      //  activity to be executed.
      //
      var getActivityIdComplete = function(nextActivityId, routingState1)
      {
         if (nextActivityId != null)
         {
           //
           //  Get the activity.
           //
           ControlFlowEngine.getActivity(
             function(activity)
             {
               if (activity)
               {
                 //
                 //  Get the implementation logic for the activity.
                 //
                 var activityLogic = ControlFlowEngine.getActivityLogic(activity);
                 if (activityLogic)
                 {
                   //
                   //  Update the routing state.
                   //
                   routingState1.setCurrentActivityId(nextActivityId);
                   routingState1.setNextActivityId(null);

                   //
                   //  Execute the activity.
                   //
                   ControlFlowEngine.executeActivity(activity, activityLogic, routingState,
                                          ControlFlowEngine.doRouting,
                                          routingState1.getRoutingFailedCallback());
                   return;
                 }
                 else
                 {
                   var errMsg = "ADFc: failed to find activity logic implementation: " + activity.getActivityType();
                   routingState.getRoutingFailedCallback()(errMsg);
                 }
               }
               else
               {
                  var errMsg2 = "ADFc: failed to find activity: " + nextActivityId;
                  routingState.getRoutingFailedCallback()(errMsg2);
               }
             },
             nextActivityId);
         }
         else
         {
           //
           //  We're not able to tell what activity to execute next.
           //
           routingState1.setRoutingComplete(true);
           ControlFlowEngine.doRouting(routingState1);
           return;
         }
      };
      ControlFlowEngine.getNextActivityId(routingState, getActivityIdComplete);
      return;
    }

    if (routingState.isRoutingComplete() && (routingState.getNavigationResult() == null))
    {
       if (routingState.getNavigationResult() == null)
       {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: constructing navigation result.");
        }

        var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();

        //
        //  Do we have back navigation?
        //
        var backNav = routingState.getBackNavigation();
        if (backNav)
        {
          var startingActivityId = routingState.getStartingActivityId();
          var currentActivityId = routingState.getCurrentActivityId();

          //
          // Determine if the current routing state has an incorrect back called on a page that is not bound to any task flows.
          // This should only happen if there is user error (they make an app without a task flow and invoke __back) or on devices that
          // can override the back system action. In both situations, we need to handle it as an invalid back action.
          //
          // Note: This won't be true on a task flow pop. The logic makes sure that the current activity is also the starting activity, which
          // might be the case on a valid task flow pop. However, any valid task flow scenario will also have a non-null taskFlowId.
          //
          var isLastTaskFlowBack = (startingActivityId != null && startingActivityId === currentActivityId && startingActivityId.getTaskFlowId() == null);
          if (isLastTaskFlowBack)
          {
           //
           // This might be an unbounded task flow. If so, we need to perform a check to see if the back action will result in the task flow being
           // exited, so that we can continue on with the unhandled back logic. If the current task flow won't be exited, then it is a valid
           // unbounded task flow action and we allow it.
           //
           isLastTaskFlowBack = ((currentTaskFlowEntry == null) || ((currentTaskFlowEntry.getViewHistoryLength() == 1) && !routingState.isBackNavTfPopped()));
          }
          
          //
          //  Is back navigation valid from the view we're currently on?
          //
          if (isLastTaskFlowBack ||
             (!routingState.isBackNavTfPopped() && !currentTaskFlowEntry.peekViewHistory().isBackNavigationValid()))
          {
            //
            // Always hide the loading indicator before further processing
            //
            adfc.internal.SystemUtil.hideLoadingIndicator();

            //
            // Since the navigation listeners already received a Navigation Start event, make sure to also send an End event.
            //
            ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), null);
            
            //
            // Let the native side optionally handle the back
            //
            if (adfc.internal.SystemUtil.onBackUnhandled())
            {
              //
              // Back was handled, so exit early
              //
              return;
            }

           if (adfc.internal.LogUtil.isFine())
           {
             adfc.internal.LogUtil.fine("ADFc: invalid back navigation detected, throwing an error.");
           }
           throw new Error("back navigation is not valid from the current view");
          }

          //
          //  Will the back navigation result in the current task flow being exited?
          //
          else if ((currentTaskFlowEntry.getViewHistoryLength() == 1) && !routingState.isBackNavTfPopped())
          {
            //
            //  Back navigation out of the TF.  We need to pop the flow that was exited.
            //
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("ADFc: back navigation out of a task flow, popping flow.");
            }
            var currentViewItem = currentTaskFlowEntry.peekViewHistory();
            routingState.setBackNavTfLeftViewItem(currentViewItem);

            var popSuccessCallback = function()
            {
              if (adfc.internal.LogUtil.isFine())
              {
                adfc.internal.LogUtil.fine("ADFc: task flow pop completed.");
              }
              var routingState1 = ControlFlowEngine.getCurrentRoutingState();
              ControlFlowEngine.clearCurrentRoutingState();
              routingState1.setBackNavTfPopped(true);
              ControlFlowEngine.doRouting(routingState1);
              return;
            }

            ControlFlowEngine.setCurrentRoutingState(routingState);
            var controllerState = adfc.internal.AdfcContext.getControllerState();
            controllerState.popTaskFlow(popSuccessCallback, routingState.getRoutingFailedCallback());
            return;
          }

          //
          //  See if we have already popped a back navigation exited flow.
          //
          else if (routingState.isBackNavTfPopped())
          {
             //
             //  We already popped the exited flow so create a result based on the
             //  view we're returning to.
             //
             if (adfc.internal.LogUtil.isFine())
             {
               adfc.internal.LogUtil.fine("ADFc: back navigation out of a task flow, flow already popped.");
             }
             var leftViewItem = routingState.getBackNavTfLeftViewItem();
             var returnedToViewItem = currentTaskFlowEntry.peekViewHistory();
             var navResult = ControlFlowEngine.constructBackNavResult(leftViewItem, returnedToViewItem);
             routingState.setNavigationResult(navResult);
             ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), navResult);
             (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
          }
          else
          {
            //
            //  Back navigation occurred within the same flow.
            //
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("ADFc: back navigation within a task flow.");
            }
            var leftViewItem1 = currentTaskFlowEntry.popViewHistory();
            var returnedToViewItem1 = currentTaskFlowEntry.peekViewHistory();
            var navResult1 = ControlFlowEngine.constructBackNavResult(leftViewItem1, returnedToViewItem1);
            routingState.setNavigationResult(navResult1);
            ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), navResult1);
            (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
          }
        }
        else
        {
          //
          //  We either had forward navigation or no navigation at all.
          //
          if (adfc.internal.LogUtil.isFine())
          {
            adfc.internal.LogUtil.fine("ADFc: forward navigation.");
          }
          ControlFlowEngine.constructForwardNavResult(
            function(navResult2)
            {
              routingState.setNavigationResult(navResult2);

              //
              //  See if back navigation is valid from the view we reached (if we reached a view).
              //  If we navigated to a view and we exited a task flow then back navigation is not
              //  valid.
              //
              if (routingState.isViewReached() && routingState.isTaskFlowReturnExecuted())
              {
                //
                //  Back navigation is not valid in this case.
                //
                var currentViewItem2 = currentTaskFlowEntry.peekViewHistory();
                currentViewItem2.setBackNavigationValid(false);
              }

              //
              //  Pass the navigation result back to the success function.
              //
              ControlFlowEngine.notifyEndNavigationListeners(routingState.getStartingViewId(), routingState.getNavigationResult());
              (routingState.getRoutingSuccessCallback())(routingState.getNavigationResult());
            },
            routingState);
        }
      }
    }
  };

  /**
   * Construct a NavigationResult object based on back navigation.
   */
  ControlFlowEngine.constructBackNavResult = function(backFromViewItem, retunredToViewItem)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: constructing back navigation result.");
    }
    newViewId = retunredToViewItem.viewId;
    vdlDocPath = retunredToViewItem.amxPage;
    transition = backFromViewItem.transitionType;
    var result = new adfc.NavigationResult(false, true, newViewId, vdlDocPath, transition, false, true);
    adfc.internal.ElUtil.setMfContextInstance(retunredToViewItem, false);
    ControlFlowEngine.logNavResult(result);
    return result;
  }

  /**
   * Construct a NavigationResult object based on forward (or no) navigation.
   */
  ControlFlowEngine.constructForwardNavResult = function(callback, routingState)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: constructing forward navigation result.");
    }

    var finalViewId = null;
    var newViewId = null;
    var transition = null;
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();

    //
    //  See if we navigated to a new view.  If the starting and ending task flow instance ID
    //  and viewId are the same then we didn't reach a new view, otherwise we did.
    //
    var newView = routingState.isViewReached();
    var differentView = newView;
    if (newView)
    {
       finalViewId = routingState.getCurrentActivityId();

       var startingTfInstance = routingState.getStartingTaskFlowInstanceId();
       var currentTfInstance = currentTaskFlowEntry.getInstanceId();
       if (startingTfInstance == currentTfInstance)
       {
         //
         //  We're still in the same task flow.
         //
         var startingViewId = routingState.getStartingActivityId();
         if ((finalViewId != null) && (startingViewId != null) && (startingViewId.equals(finalViewId)))
         {
           newView = false;
         }
         else if ((finalViewId == null) && (startingViewId == null))
         {
           newView = false;
         }
       }
       differentView = newView;

       //
       //  Figure out what type of transition to use for the new view.
       //
       transition = routingState.getTransition();
    }
    else
    {
      //
      //  See if we returned from a bounded task flow.
      //
      var tfEntry = routingState.getLastReturnedFromTfEntry();
      if (tfEntry != null)
      {
        //
        //  Navigation didn't reach a new view but we did return from a task flow.
        //  In this case return to the calling view activity in the flow we've
        //  returned to.
        //
        finalViewId = tfEntry.getCallingViewActivityId();
        differentView = true;
      }
    }

    var vdlDocPath = null;
    if (finalViewId != null)
    {
      newViewId = finalViewId.getLogicalViewId();
      var localId = finalViewId.getLocalActivityId();
      currentTaskFlowEntry.getTaskFlowDefinition(
        function(currentTaskFlowDef)
        {
          var finalActivity = currentTaskFlowDef.getActivities()[localId];
          vdlDocPath = finalActivity.getVldDocumentPath();
          ControlFlowEngine._constructForwardNavResultPhase2(
            transition,
            currentTaskFlowEntry,
            differentView,
            newView,
            newViewId,
            vdlDocPath,
            finalViewId,
            callback);
        });
    }
    else
    {
      ControlFlowEngine._constructForwardNavResultPhase2(
        transition,
        currentTaskFlowEntry,
        differentView,
        newView,
        newViewId,
        vdlDocPath,
        finalViewId,
        callback);
    }
  };

  ControlFlowEngine._constructForwardNavResultPhase2 = function(
    transition,
    currentTaskFlowEntry,
    differentView,
    newView,
    newViewId,
    vdlDocPath,
    finalViewId,
    callback)
  {
    if (transition == null)
    {
      transition = adfc.internal.ControlFlowCase.DEFAULT_TRANSITION;
    }

    if (newView)
    {
      //
      //  Push a new view history entry.
      //
      currentTaskFlowEntry.pushViewHistory(newViewId, vdlDocPath, transition);
    }
    else if (finalViewId != null)
    {
      //
      //  Reset the MfContextInstance.
      //
      adfc.internal.ElUtil.setMfContextInstance(currentTaskFlowEntry.peekViewHistory(), false);
    }

    var result = new adfc.NavigationResult(newView, false, newViewId, vdlDocPath, transition, false, differentView);
    ControlFlowEngine.logNavResult(result);
    callback(result);
  };

  ControlFlowEngine.logNavResult = function(navResult)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      var msg = "ADFc: navigationResult:" +
        " isDifferentViewId=" + navResult.mDifferentViewId +
        " isNewViewId=" + navResult.mNewViewId +
        " isBackNav=" + navResult.mBackNavigation +
        " viewId=" + navResult.mViewId +
        " vdlDocPath=" + navResult.mVdlDocumentPath +
        " transitionType=" + navResult.mTransitionType +
        " featureExited=" + navResult.mFeatureExited;
      adfc.internal.LogUtil.fine(msg);
    }
  }

  ControlFlowEngine.getNextActivityId = function(routingState, complete)
  {
    //
    //  If the routing state already has a next activity defined then that's
    //  what we want to use.
    //
    var result = routingState.getNextActivityId();
    if (result)
    {
      complete(result, routingState);
    }
    else
    {
      //
      //  Check for a special outcome.
      //
      var currentOutcome = routingState.getCurrentOutcome();
      if ((currentOutcome == ControlFlowEngine.BACK_NAV_OUTCOME) ||
         (currentOutcome == ControlFlowEngine.BACK_NAV_OUTCOME_OLD))
      {
        routingState.setBackNavigation(true);
        routingState.setRoutingComplete(true);
        complete(result, routingState);
      }
      else
      {
        //
        //  Evaluate the control flow rules to determine the next activity.
        //
        var findCfCaseComplete = function(routingState1)
        {
          var cfCase = routingState1.getControlFlowCase();
          if (cfCase)
          {
            result = cfCase.getTargetActivityId();
            routingState1.setTransition(cfCase.getTransition());
          }
          complete(result, routingState1);
        };
        routingState.setFindCfCaseCallback(findCfCaseComplete);
        routingState.resetCfRuleEvaluation();
        ControlFlowEngine.findControlFlowCase(routingState);
      }
    }
  };

  ControlFlowEngine.findControlFlowCase = function(routingState)
  {
    //
    //  We need to evaluate the control flow rules.  Get the current set
    //  of control flow rules from the current page flow.
    //
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(currentTaskFlow)
      {
        //
        //  Get the best matching control flow rule.
        //
        var alreadyTried = routingState.getTriedCfRules();

        //
        //  Get the best matching rule that has not already been tried.
        //
        var currentActivityId = routingState.getCurrentActivityId();
        var cfRule = ControlFlowEngine.getBestControlFlowRule(currentTaskFlow, currentActivityId, alreadyTried);
        if (cfRule != null)
        {
          //
          //  A rule was found.  Check to see if it has a matching control
          //  flow case.
          //
          var cfCase = cfRule.getControlFlowCase(routingState.getCurrentOutcome());
          if (cfCase != null)
          {
            //
            // Check the guard condition
            //
            var guardConditionCallback = function(executeCase, routingState1)
            {
              if (executeCase)
              {
                //
                //  A matching control flow case was found. Use it to identify
                //  the next activity to be executed.
                //
                var result = cfCase;
                routingState.setControlFlowCase(result);
                routingState.getFindCfCaseCallback()(routingState);
              }
              else
              {
                //
                //  A matching control flow case was not found.  Add this rule's
                //  from activity ID to the set of one's already tried and try again.
                //
                alreadyTried[cfRule.getFromActivityId().getLocalActivityId()] = true;
                ControlFlowEngine.findControlFlowCase(routingState);
              }
            };
            var guardCondition = cfCase.getGuardCondition();
            ControlFlowEngine.evaluateGuardCondition(guardCondition, routingState, guardConditionCallback);
          }
          else
          {
            //
            //  A matching control flow case was not found.  Add this rule's
            //  from activity ID to the set of one's already tried and try again.
            //
            alreadyTried[cfRule.getFromActivityId().getLocalActivityId()] = true;
            ControlFlowEngine.findControlFlowCase(routingState);
          }
        }
        else
        {
          //
          //  No control flow rule was found.
          //
          routingState.getFindCfCaseCallback()(routingState);
        }
      });
  };

  ControlFlowEngine.getBestControlFlowRule = function(pageFlow, fromId, excludeSet)
  {
    var WILDCARD_ID = "*";
    var result = null;

    //
    // The best matching rule is an exact match on the fromId.  Next, the best
    // matching rule is the one that has a fromId that ends with an asterisk,
    // matches the fromId up until the asterisk, and is the longest.
    //
    var cfRules = pageFlow.getControlFlowRules();
    if (fromId != null)
    {
      var localId = fromId.getLocalActivityId();
      if (!excludeSet[localId])
      {
        result = cfRules[localId];
      }
    }
    if (result == null)
    {
      //
      //  We didn't find an exact match so now we need to look for a best match.
      //  Get a hash map of control flow rules keyed by the local activity ID.
      //

      //
      //  Check for a null from activity ID.
      //
      if (fromId == null)
      {
        //
        //  See if there is a wild card rule that can be used.
        //
        if (!excludeSet[WILDCARD_ID])
        {
          result = cfRules[WILDCARD_ID];
        }
      }
      else
      {
        //
        //  Look for the longest match that ends with an asterisk.
        //
        var localActivityId = fromId.getLocalActivityId();
        for (var i = localActivityId.length - 1; i >= 0; i--)
        {
          var key = localActivityId.substring(0, i) + WILDCARD_ID;
          if (!(excludeSet[key]))
          {
            result = cfRules[key];
            if (result != null)
            {
              break;
            }
          }
        }
      }
    }

    return result;
  }

  ControlFlowEngine.evaluateGuardCondition = function(guardCondition, routingState, callback)
  {
    if (guardCondition != null)
    {
      var evalSuccessCallback = function(request, response)
      {
        var value = response[0].value;
        value = adfc.internal.ElUtil.resultToBoolean(value);
        callback(value, routingState);
      }
      var evalFailedCallback = function(request, response)
      {
        var errMsg = "ADFc: evaluation of control flow guard condition failed: " + request[0];
        routingState.getRoutingFailedCallback()(errMsg);
      }
      adfc.internal.LogUtil.fine("evaluateing control flow guard condition: " + guardCondition);
      adfc.internal.ElUtil.getValue(guardCondition, evalSuccessCallback, evalFailedCallback);
    }
    else
    {
      callback(true, routingState);
    }
  }

  ControlFlowEngine.getActivity = function(callback, activityId)
  {
    var result = null;
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        if (taskFlowDef)
        {
          var activities = taskFlowDef.getActivities();
          if (activities)
          {
            var localId = activityId.getLocalActivityId();
            result = activities[localId];
          }
          else
          {
            throw new Error("ADFc: task flow " + taskFlowDef.getTaskFlowId() + " does not have any activities");
          }
        }
        else
        {
          throw new Error("ADFc: failed to find task flow definition");
        }
        callback(result);
      });
  }

  ControlFlowEngine.getActivityLogic = function(activity)
  {
    var type = activity.getActivityType();
    var result = adfc.internal.ActivityLogic.getImplementation(type);
    return result;
  }

  ControlFlowEngine.executeActivity = function(activity, activityLogic, routingState, successCallback, failCallback)
  {
    if (adfc.internal.LogUtil.isFine())
    {
      adfc.internal.LogUtil.fine("ADFc: executing ControlFlowEngine.executeActivity(), activityId=" +
                         activity.getActivityId());
    }

    //
    //  Sanity check.
    //
    if (routingState.isRoutingComplete())
    {
      adfc.internal.LogUtil.severe("ADFc: attempting to execute activity when routing is already complete");
    }

    var bcChanged = false;
    var originalBindingPath = null;
    var activityBindingPath = null;

    var setBCPathSuccess = function()
    {
      //
      //  Execute the activity.
      //
      var exeSuccess = function(rState)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: execution of " + activity.getActivityId() + " succeeded.");
        }

        //
        //  Restore the original binding container if necessary.
        //
        var restoreBCPathSuccess = function()
        {
          successCallback(rState);
        }
        var restoreBCPathFailed = function()
        {
          failCallback("failed to restore binding container following activity execute");
        }
        if (bcChanged)
        {
          //
          //  Release the activity's binding container.
          //
          adfc.internal.ElUtil.resetBindingContainerPath(activityBindingPath, restoreBCPathSuccess, restoreBCPathFailed);
         }
        else
        {
          restoreBCPathSuccess();
        }
      }
      var exeFailed = function(message)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("ADFc: execution of " + activity.getActivityId() + " failed.");
        }
        var callback = function()
        {
          failCallback(message);
        }
        if (bcChanged)
        {
          //
          //  Restore the original binding container.
          //
          adfc.internal.ElUtil.setBindingContainerPath(originalBindingPath, false, callback, callback);
        }
      }
      activityLogic.execute(routingState, activity, exeSuccess, exeFailed);
    }

    var setBCPathFailed = function()
    {
      failCallback("failed to set the binding container path to: " + activityBindingPath);
    }

    var getBCPathSuccess = function(req, path)
    {
      originalBindingPath = path;
      activityBindingPath = ControlFlowEngine.getActivityBindingPath(activity);

      //
      //  See if we need to switch the binding containers.
      //
      if ((originalBindingPath != null) || (activityBindingPath != null))
      {
        //
        //  We need to switch.
        //
        bcChanged = true;
        adfc.internal.ElUtil.setBindingContainerPath(activityBindingPath, false, setBCPathSuccess, setBCPathFailed);
      }
      else
      {
        //
        //  No need to switch.
        //
        setBCPathSuccess();
      }
    }

    var getBCPathFailed = function()
    {
      failCallback("Failed to get the current binding container path");
    }

    //
    //  If the activity we're about to execute is NOT a view activity then get the current
    //  binding context path so we can swith and later switch back.
    //
    if (activity.getActivityType() != adfc.internal.ActivityType.VIEW)
    {
      //
      //  This is a non-view activity so switch the binding context.
      //
      adfc.internal.ElUtil.getCurrentBindingContainerPath(getBCPathSuccess, getBCPathFailed);
    }
    else
    {
      //
      //  This is a view activity so we don't need to switch the binding context.
      //
      setBCPathSuccess();
    }
  }

  ControlFlowEngine.getActivityBindingPath = function(activity)
  {
    //
    //  This method only returns a binding container path for method-call activities.
    //  The binding container for a view activity will be set by the AMX layer when
    //  if set the new page.
    //
    var bindingPath = null;
    var activityType = activity.getActivityType();
    if (activityType == adfc.internal.ActivityType.METHOD_CALL ||
       activityType == adfc.internal.ActivityType.ROUTER ||
       activityType == adfc.internal.ActivityType.TASK_FLOW_CALL ||
       activityType == adfc.internal.ActivityType.TASK_FLOW_RETURN )
    {
      bindingPath = activity.getActivityId().toString();
    }
    return bindingPath;
  }

  /**
   * Store the current routing state on a global so we can find it later.
   * Poor man's version of a Java thread local.
   */
  ControlFlowEngine.setCurrentRoutingState = function(instance)
  {
    adfc.internal.ControlFlowEngine.currentRoutingState = instance;
  }
  ControlFlowEngine.getCurrentRoutingState = function()
  {
    var result = null;
    if (typeof adfc.internal.ControlFlowEngine.currentRoutingState !== "undefined")
    {
      result = adfc.internal.ControlFlowEngine.currentRoutingState;
    }
    return result;
  }
  ControlFlowEngine.clearCurrentRoutingState = function()
  {
    if (typeof adfc.internal.ControlFlowEngine.currentRoutingState !== "undefined")
    {
      adfc.internal.ControlFlowEngine.currentRoutingState = null;
    }
  }
  
  ControlFlowEngine.notifyEndNavigationListeners = function(currentViewId, navigationResult)
  {
    var deliverNotifications = function()
    {
      //
      // Deliver navigation end event
      //
      var endNavEvent = new adfc.NavigationEvent(currentViewId, navigationResult, adfc.NavigationEventType.END);
      adfc.internal.NavigationHandlerImpl.notifyNavigationListeners(endNavEvent);
    }

    //
    //  Before sending end navigaiton events we may need to check if we're returning to the same view.
    //  If we are we need to restore that view activity's context in case any non-view activities
    //  have set a different context.
    //
    if ((navigationResult != null) && !navigationResult.isDifferentViewId())
    {
      //
      //  Navigation did not reach a different view activity, set that view's context.
      //
      var contextPath = navigationResult.getVdlDocumentPath();
      adfc.internal.ElUtil.setBindingContainerPath(contextPath, false, deliverNotifications, deliverNotifications);
    }
    else
    {
      //
      //  Navigaiton reached a different view activity so no need to restore the
      //  previous view's context.
      //
      deliverNotifications();
    }
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/ControlFlowEngine.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/adf/mf/internal/controller/ViewHistory.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adf) window.adf = {};
adf.mf                      = adf.mf                      || {};
adf.mf.internal             = adf.mf.internal             || {};
adf.mf.internal.controller  = adf.mf.internal.controller  || {};

(function(){

   adf.mf.internal.controller.ViewHistory = ViewHistory;
   function ViewHistory()
   {}
   
   /**
    * Peeks the current entry in the view history.
    * @export
    */
   ViewHistory.peek = function()
   {
      var controllerState = adfc.internal.AdfcContext.getControllerState();
      var tfEntry = controllerState.peekTaskFlowStack();
      var result = tfEntry.peekViewHistory();
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/adf/mf/internal/controller/ViewHistory.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationEvent.js///////////////////////////////////////

/*
* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationEvent = NavigationEvent;
  adfc.NavigationEventType = NavigationEventType;

  function NavigationEventType()
  {
  }
  NavigationEventType.START = "start";
  NavigationEventType.END = "end";

  /**
   * NavigationEvent represents information about view id changes during navigation.
   */
  function NavigationEvent(startingViewId, navigationResult, navigationEventType)
  {
      this.mStartingViewId = startingViewId;
      this.mNavigationResult = navigationResult;
      this.mNavigationEventType = navigationEventType;
  }
  
  /**
   * The initial view id (before navigation started). This should be available for both start and end
   * navigation events.
   * @return {string} the view id of the page where navigation started. For example, 
   * "/some-task-flow/some-page".
   * @export
   */
  NavigationEvent.prototype.getStartingViewId = function()
  {
      return this.mStartingViewId;
  }
  /**
   * The NavigationResult if navigation happened, or null, if navigation is not yet finished.
   * @return {NavigationResult} navigation result, including view id of the page that was navigated to, for example:
   * <code>
   *   var navResult = event.getNavigationResult();
   *   var endViewId = navResult.getViewId();
   * </code>
   * @export
   */
  NavigationEvent.prototype.getNavigationResult = function() 
  {
      return this.mNavigationResult;
  }
  
  /**
   * Has navigation started and not ended?
   * @return {Boolean}
   * @export
   */
  NavigationEvent.prototype.isNavigationStart = function()
  {
      return (this.mNavigationEventType == NavigationEventType.START);
  }

  /**
   * Has navigation ended and NavigationResult is available?
   * @return {Boolean}
   * @export
   */
  NavigationEvent.prototype.isNavigationEnd = function()
  {
      return (this.mNavigationEventType == NavigationEventType.END);
  }
  
  /**
   * String representation of the event.
   * @return {string}
   * @export
   */
  NavigationEvent.prototype.toString = function()
  {
    if (this.isNavigationStart())
    {
      return "Navigating from " + this.mStartingViewId;
    }
    else
    {
      return "Navigated from  " + this.mStartingViewId + " to " + this.mNavigationResult.getViewId();
    }
    return "Unknown";
  }
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationEvent.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/MetadataService.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };
if (!adfc.internal)
  adfc.internal = 
  {
  };(function ()
{

  /**
   *  Service for fetching various metadata resources.
   */
  adfc.internal.MetadataService = MetadataService;

  function MetadataService()
  {
  }

  /*
   * Setting up an LRU cache for the metadata. This will prevent from re-reading files in and parsing the controller
   * metadata.
   */
  var taskFlowDefCache = new adf.mf.internal.BaseLRUCache(5);

  /**
   * @param {Function} callback a callback function whose parameter is the
   *                            requested task flow definition or null if the
   *                            task flow could not be found.
   * @param {Object} taskFlowId the id of the task flow to be fetched.
   * @param {boolean} [useCache=true] determines whether task flow cache should be used to fetch task flow definition. If false,
   *        the cache won't be used to fetch the definition, but will be updated with the fetched definition,
   *        if one is found. If not specified, the default value is true.
   */
  MetadataService.getTaskFlowDefinition = function(callback, taskFlowId, useCache)
  {
    var docPath = taskFlowId.getDocumentUri();
    if (docPath == null)
    {
      callback(null);
    }
    else
    {
      //
      // useCache is an optional argument that defaults to true
      //
      if (useCache === undefined)
      {
        useCache = true;
      }
      //
      // cacheKey needs to be defined here because even though cache is not used
      // when useCache == false; it is used to store a newly parsed task flow definition
      //
      var cacheKey = MetadataService.constructCacheKey(docPath, taskFlowId);
      if (useCache)
      {
        // See if the data is already in the cache.
        var cacheDef = taskFlowDefCache.get(cacheKey);
        if (cacheDef && cacheDef != null)
        {
          callback(cacheDef);
          return;
        }
      }
      var filePath = adfc.Util.addFeatureRootPrefix(docPath);
      if (adfc.internal.LogUtil.isFine())
      {
        adfc.internal.LogUtil.fine("attempting to load task flow file: " + filePath);
      }
      adfc.internal.XmlUtil.loadXmlFile(filePath, function(document)
        {
          if (document != null)
          {
            var tfNodes = document.getElementsByTagName("task-flow-definition");
            if (adfc.internal.LogUtil.isFine())
            {
              adfc.internal.LogUtil.fine("number of task-flow-definition elements in the file = " + tfNodes.length);
            }
            var result = null;
            for (var i = 0;i < tfNodes.length;i++)
            {
              var tfNode = tfNodes.item(i);
              var taskFlowDef = adfc.internal.TaskFlowDefinitionXmlParser.parse(docPath, document, tfNode);
              if (taskFlowDef)
              {
                if (taskFlowDef.getTaskFlowId().equals(taskFlowId))
                {
                  result = taskFlowDef;
                  // Since spent all the time reading and parsing this Task Definition we need to stash it off
                  // in an LRU cache.
                  taskFlowDefCache.put(cacheKey, result);
                  break;
                }
              }
            }
            callback(result);
          }
          else 
          {
            adfc.internal.LogUtil.severe("failed to load task flow file " + filePath);
            callback(null);
          }
        });
    }
  };

  MetadataService.loadBootstrapMetadata = function (successCallback, failCallback, useCache)
  {
    adfc.internal.LogUtil.fine("loading bootstrap metadata ...");
    
    var unboundedFlowDocPath = adfc.Util.addFeatureRootPrefix("adfc-mobile-config.xml");
    var cacheKey = MetadataService.constructCacheKey(unboundedFlowDocPath);

    //
    // useCache is an optional argument that defaults to true
    //
    if (useCache === undefined)
    {
      useCache = true;
    }

    if (useCache)
    {
      // See if the data is already in the cache.
      var cacheDef = taskFlowDefCache.get(cacheKey);
      if (cacheDef && cacheDef != null)
      {
        // We found the data so we can now just call the success call back with the cached data.
        successCallback(cacheDef);
        return;
      }
    }

    adfc.internal.XmlUtil.loadXmlFile(unboundedFlowDocPath, function(document)
      {
        //
        //  Get the "adfc-mobile-config" element from the file.
        //
        if (document != null)
        {
          var nodes = document.getElementsByTagName("adfc-mobile-config");
          if ((nodes != null) && (nodes.length == 1))
          {
            var unboundedFlowNode = nodes[0];
            var unboundedFlowDef = adfc.internal.TaskFlowDefinitionXmlParser.parse(null, document, unboundedFlowNode);
            if (unboundedFlowDef != null)
            {
              var loadBootstrapSuccess = function ()
              {
                adfc.internal.LogUtil.fine("bootstrap metadata load complete.");
                successCallback(unboundedFlowDef);
                return;
              }
              taskFlowDefCache.put(cacheKey, unboundedFlowDef);
              //
              // Do not update controller state if this is a call to reload unbounded flow
              //
              if (useCache)
              {
                var controllerState = adfc.internal.AdfcContext.getControllerState();
                controllerState.pushTaskFlow(unboundedFlowDef, null, null, loadBootstrapSuccess, failCallback);
              }
              else
              {
                loadBootstrapSuccess();
              }
            }
            else 
            {
              var msg = "failed to parse the adfc-mobile-config element in bootstrap metadata document";
              adfc.internal.LogUtil.severe(msg);
              throw new Error(msg);
            }
          }
          else 
          {
            var msg2 = "failed to find adfc-mobile-config element in bootstrap metadata document";
            adfc.internal.LogUtil.severe(msg2);
            throw new Error(msg2);
          }
        }
        else 
        {
          var msg3 = "bootstrap metadata document adfc-mobile-config.xml is null";
          adfc.internal.LogUtil.severe(msg3);
          throw new Error(msg3);
        }
      });
  }

  MetadataService.constructCacheKey = function (docPath, taskFlowId)
  {
    var cacheKey = docPath;
    if (taskFlowId !== undefined)
    {
      cacheKey = taskFlowId.toString();
    }
    return cacheKey;
  }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/MetadataService.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/UrlUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adf) window.adf = {};
adf.FEATURE_ROOT = null;
adf.AMX_DTMODE = false;

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.UrlUtil = UrlUtil;
   function UrlUtil()
   {}
   
   UrlUtil.getEntryPointDocumentPath = function(queryString)
   {
      var path = null;
      if ((queryString != null) && (queryString.length > 0))
      {
         path = adfc.internal.UrlUtil.getUrlParamValue(queryString, "file");
         if (path != null)
         {
            path = unescape(path);
         }
      }   
      return path;
   }
   
   UrlUtil.getAmxDtMode = function(queryString)
   {
      var result = false;
      if ((queryString != null) && (queryString.length > 0))
      {
         var root = adfc.internal.UrlUtil.getUrlParamValue(queryString, "amx_dtmode");
         if (root != null)
         {
            root = unescape(root);
            result = adfc.internal.ElUtil.resultToBoolean(root);
         }
      }
      return result;
   }
   
   UrlUtil.getFeatureRoot = function(queryString)
   {
      var root = null;
      if ((queryString != null) && (queryString.length > 0))
      {
         root = adfc.internal.UrlUtil.getUrlParamValue(queryString, "featureRoot");
         if (root != null)
         {
            root = unescape(root);
         }
      }
      return root;
   }
   
   UrlUtil.getParamStartIndex = function(url, name)
   {
      var sb = "?" + name;
      var index = url.indexOf(sb);
      if (index < 0)
      {
         sb = "&" + name;
         index = url.indexOf(sb.toString());
      }
      return index;
   }

   UrlUtil.getParamEndIndex = function(url, startIndex)
   {
      var endIndex = url.indexOf('&', startIndex);
      if (endIndex < 0)
      {
         endIndex = url.length;
      }
      return endIndex;
   }

   UrlUtil.getUrlParamValue = function(url, paramName)
   {
      var result = null;
      if ((url != null) && (paramName != null))
      {
         //
         //  Find out where the parameter value begins within the URL.
         //
         var startIndex = adfc.internal.UrlUtil.getParamStartIndex(url, paramName);
         if (startIndex >= 0)
         {
            //
            //  Find out where the parameter and value end within the URL.
            //
            var endIndex = adfc.internal.UrlUtil.getParamEndIndex(url, startIndex + 1);

            //
            //  Get the substring.
            //
            var value = url.substring(startIndex, endIndex);

            //
            //  Find the equals sign.
            //
            var start2 = value.indexOf('=');
            if ((start2 >= 0) && (start2 < value.length))
            {
               result = value.substring(start2 + 1);
               if (result.length == 0)
               {
                  result = null;
               }
            }
         }
      }
      return result;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/UrlUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/metadata/MetadataService.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };(function ()
{
  adfc.MetadataService = MetadataService;

  /**
   * MetadataService is the public facing interface to the ADFc MetadataService.
   * @export
   */
  function MetadataService()
  {
  }

  /**
   * @param {string} [taskFlowIdString=null] taskFlowIdString the task flow id of the task flow to be reloaded.
   *        For example: "/feature1/task-flow.xml#task-flow-id". This is an optional argument. If not specified,
   *        or if null or empty, the unbounded task flow definition will be reloaded ("adfc-mobile-config.xml").
   * @param {Function} successCallback invoked upon successful reloading of the task flow definition
   * @param {Function} failCallback invoked if reloading failed.
   */
  MetadataService.reloadTaskFlowDefinition = function(taskFlowIdString, successCallback, failCallback)
  {
    if (arguments.length == 3)
    {
      //
      // null or empty taskFlowIdString is a request for reloading bootstrap metadata
      //
      if (taskFlowIdString && taskFlowIdString.trim().length)
      {
        var taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
        if (taskFlowId != null)
        {
          adfc.internal.MetadataService.getTaskFlowDefinition(
            function(taskFlowDefinition)
            {
              if (taskFlowDefinition && taskFlowDefinition != null)
                successCallback();
              else
                failCallback();
            },
            taskFlowId,
            false);
        }
        else
        {
          failCallback();
        }
      }
      else
      {
        adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback, false);
      }
    }
    else 
    {
      //
      // Since the first argument is optional, reassign callbacks
      //
      successCallback = arguments[0];
      failCallback = arguments[1];
      adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback, false);
    }
  }
})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/metadata/MetadataService.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/MethodCallActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.MethodCallActivityLogic = MethodCallActivityLogic;
   function MethodCallActivityLogic()
   {
   }
      
   MethodCallActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("MethodCallActivityLogic.prototype.execute() entered");
      adfc.internal.LogUtil.perfLog("BEGIN: MethodCallActivityLogic.execute");
      routingState.setCurrentOutcome(null);
      
      var getParamsSuccess = function(request, response)
      {
         var invokeSuccess = function(request2, response2)
         {
            adfc.internal.LogUtil.fine("method call invokation successful");
            
            //
            //  Store the return value.
            //
            var storeResultSuccess = function()
            {
               //
               //  Determine the outcome to generate.
               //
               var outcome = null;
               if (activity.getDefaultOutcome())
               {
                  outcome = activity.getDefaultOutcome();
               }
               else if (activity.isConvertToString())
               {
                  if (response2)
                  {
                     outcome = new String(response2);
                  }
               }
               routingState.setCurrentOutcome(outcome);
               adfc.internal.LogUtil.perfLog("END: MethodCallActivityLogic.execute");
               adfc.internal.LogUtil.fine("method call complete, outcome=" + outcome);
               successCallback(routingState);
            }
            
            var resultExpression = activity.getReturnValue();
            if ((resultExpression != null) && (resultExpression.length > 0))
            {
               //
               //  Store the result value.
               //
               adfc.internal.LogUtil.fine("storing method call result to: " + resultExpression);
               var setRequest = new Array();
               setRequest[0] = {name: resultExpression, value: response2};
               adfc.internal.ElUtil.setValue(setRequest, storeResultSuccess, failCallback);
            }
            else 
            {
               //
               //  There's no EL expression for storing the result.
               //
               adfc.internal.LogUtil.fine("no method call result to store");
               storeResultSuccess();
            }
         }
         
         //
         //  Build an array of the parameter values.
         //
         var paramValues = new Array(paramTypes.length);
         for (var i = 0; i < paramTypes.length; i++)
         {
            if (response[i] != undefined)
            {
              paramValues[i] = response[i].value;
            }
            else 
            {
              paramValues[i] = null;
              adfc.internal.LogUtil.fine("no parameter value for " + paramExpressions[i]);
            }     
         }
   
         //
         //  Execute the method.
         //
         var elExpression = activity.getMethodElExpression();
         adfc.internal.LogUtil.fine("executing method call expression: " + elExpression);
         adfc.internal.ElUtil.invokeMethod(elExpression, paramTypes, paramValues, invokeSuccess, failCallback);
      }
      
      //
      //  Collect the method's input parameter values.
      //
      var params = activity.getParameters();
      var paramExpressions = new Array();
      var paramTypes = new Array();
      if (params.length > 0)
      {
         for (var i = 0; i < params.length; i++)
         {
            paramExpressions.push(params[i].getValueExpression());
            paramTypes.push(params[i].getType());
         }
         adfc.internal.LogUtil.fine("getting method call activity parameter values");
         adfc.internal.ElUtil.getValues(paramExpressions, getParamsSuccess, failCallback);
      }
      else 
      {
         //
         //  There aren't any input params.
         //
         adfc.internal.LogUtil.fine("no method call activity parameters specified");
         getParamsSuccess(paramExpressions, paramExpressions);
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/MethodCallActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowReturnActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-return activity.
    */
   adfc.internal.TaskFlowReturnActivity = TaskFlowReturnActivity;
   function TaskFlowReturnActivity(activityId, outcomeName)
   {
      this.mActivityId = activityId;
      this.mOutcomeName = outcomeName;
   }

   TaskFlowReturnActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.TASK_FLOW_RETURN;
   }
  
   TaskFlowReturnActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   TaskFlowReturnActivity.prototype.getOutcomeName = function() 
   {
      return this.mOutcomeName;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowReturnActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedBeanDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ManagedBeanDefinition = ManagedBeanDefinition;
   function ManagedBeanDefinition(name, type, scope, props)
   {
      this.mBeanName = name;
      this.mBeanClass = type;
      this.mBeanScope = scope;
      this.mManagedProperties = props;
   }
   
   ManagedBeanDefinition.prototype.getBeanName = function() 
   {
      return this.mBeanName;
   }
   
   ManagedBeanDefinition.prototype.getBeanClass = function() 
   {
      return this.mBeanClass;
   }
   
   ManagedBeanDefinition.prototype.getBeanScope = function() 
   {
      return this.mBeanScope;
   }
   
   ManagedBeanDefinition.prototype.getManagedProperties = function() 
   {
      return this.mManagedProperties;
   }
   
   //
   //  Constents used to specify a bean's scope.
   //
   ManagedBeanDefinition.APPLICATION = "application";
   ManagedBeanDefinition.PAGE_FLOW = "pageFlow";
   ManagedBeanDefinition.VIEW = "view";

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedBeanDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowInputParameter.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow input parameter.
    */
   adfc.internal.TaskFlowInputParameter = TaskFlowInputParameter;
   function TaskFlowInputParameter(name, valueExpression, type, isRequired)
   {
      this.mName = name;
      this.mValueExpression = valueExpression;
      this.mType = type;
      this.mRequired = isRequired;
   }
   
   TaskFlowInputParameter.prototype.getName = function()
   {
      return this.mName;
   }
   
   TaskFlowInputParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }
   
   TaskFlowInputParameter.prototype.getType = function()
   {
      return this.mType;
   }
   
   TaskFlowInputParameter.prototype.isRequired = function()
   {
      return this.mRequired;
   }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowInputParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ViewIdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewIdUtil = ViewIdUtil;
   function ViewIdUtil()
   {
   }
   
   ViewIdUtil.logicalViewIdToActivityId = function(taskFlowId, logicalViewId)
   {
      var result = null;
      if ((logicalViewId != null) && (logicalViewId.length > 1))
      {
         //
         //  Figure out the local activityId from the logical viewId.
         //
         var localActivityId = null;
         if (taskFlowId == null)
         {
            //
            //  Unbounded ADF page flow case.
            //
            localActivityId = logicalViewId;
            if (localActivityId.charAt(0) == '/')
            {
               localActivityId = localActivityId.substring(1);
            }
         }
         else
         {
            //
            //  Make sure the logical viewId begins with "/" + localTaskFlowName.
            //
            var localTaskFlowName = taskFlowId.getLocalTaskFlowId();
            if (logicalViewId.indexOf(localTaskFlowName) == 1)
            {
               localActivityId = logicalViewId.substring(localTaskFlowName.length + 2);
            }
         }

         //
         //  Build the activityId.
         //
         if (localActivityId != null)
         {
            result = new adfc.internal.ActivityId(taskFlowId, localActivityId);
         }
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ViewIdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ManagedBeanDefinitionXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ManagedBeanDefinitionXmlParser = {};
adfc.internal.ManagedBeanDefinitionXmlParser.parse = function(docPath, taskFlowId, node)
{
   var beanName = null;
   var beanClass = null;
   var beanScope = null;
   var managedProps = new Array();
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "managed-bean-name")
         {
            beanName = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-bean-class")
         {
            beanClass = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-bean-scope")
         {
            beanScope = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "managed-property")
         {
            var prop = adfc.internal.ManagedPropertyDefinitionXmlParser.parse(child);
            if (prop != null)
            {
               managedProps.push(prop);
            }
         }
      }
   }
   var result = new adfc.internal.ManagedBeanDefinition(beanName, beanClass, beanScope, managedProps);
   return result;
}

adfc.internal.ManagedPropertyDefinitionXmlParser = {};
adfc.internal.ManagedPropertyDefinitionXmlParser.parse = function(node)
{
   var name = null;
   var type = null;
   var value = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "property-name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "property-class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            value = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.ManagedPropertyDefinition(name, type, value);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ManagedBeanDefinitionXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowCallActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.TaskFlowCallActivityLogic = TaskFlowCallActivityLogic;
  function TaskFlowCallActivityLogic()
  {
  }

  TaskFlowCallActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
  {
    adfc.internal.LogUtil.fine("TaskFlowCallActivityLogic.prototype.execute() entered");
    adfc.internal.LogUtil.perfLog("BEGIN: TaskFlowCallActivityLogic.execute");

    var getTaskFlowIdSuccess = function(taskFlowId)
    {
      var invokeBeforeListenerSuccess = function()
      {
        adfc.internal.MetadataService.getTaskFlowDefinition(
          function(taskFlowDef)
          {
            var gatherInputParamsSuccess = function(params)
            {
              var invokeTfSuccess = function()
              {
                routingState.setCurrentOutcome(null);
                routingState.setNextActivityId(taskFlowDef.getDefaultActivityId());

                adfc.internal.LogUtil.perfLog("END: TaskFlowCallActivityLogic.execute");
                successCallback(routingState);
              }

              //
              //  Enter the task flow.
              //
              adfc.internal.LogUtil.fine("TaskFlowCallActivityLogic.prototype.execute() invoking taskFlow: " + taskFlowId + " from activity : " + activity.getActivityId());
              adfc.internal.TaskFlowCallActivityLogic.invokeTaskFlow(taskFlowId, params, activity, routingState, invokeTfSuccess, failCallback);
            }

            if (taskFlowDef == null)
            {
              failCallback(/* What is message? message + ": " + */taskFlowId);
            }
            TaskFlowCallActivityLogic.gatherInputParamerValues(activity, gatherInputParamsSuccess, failCallback)
          },
          taskFlowId);
      }
      TaskFlowCallActivityLogic.invokeBeforeListener(activity, invokeBeforeListenerSuccess, failCallback);
    }
    TaskFlowCallActivityLogic.getTaskFlowId(activity, getTaskFlowIdSuccess, failCallback);
  }

  /**
   * Invoke a bounded task flow and set the flow's default activity as the next
   * activity to be executed.
   */
  TaskFlowCallActivityLogic.invokeTaskFlow = function(taskFlowId, inParams, taskFlowCallActivity, routingState, successCallback, failCallback)
  {
    //
    //  Look up the task flow definition.
    //
    adfc.internal.MetadataService.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        var pushTfSuccess = function()
        {
          var inParamSuccess = function()
          {
            var initializerSuccess = function()
            {
              //
              //  Perform control flow routing beginning with the default activity.
              //
              var defaultActivityId = taskFlowDef.getDefaultActivityId();
              routingState.setNextActivityId(defaultActivityId);
              routingState.setCurrentOutcome(null);
              successCallback(routingState);
            }

            //
            //  Execute the task flow's initializer, if it has one.
            //
            var initializer = taskFlowDef.getInitializer();
            if (initializer && (initializer != null))
            {
              adfc.internal.ElUtil.invokeMethod(initializer, new Array(), new Array(), initializerSuccess, failCallback);
            }
            else
            {
              initializerSuccess();
            }
          }

          //
          //  Store any input parameter values passed to the task flow.
          //
          var request = new Array();
          var inParamDefs = taskFlowDef.getInputParameters();
          if ((inParamDefs != null) && (inParamDefs.length > 0))
          {
            for (var i = 0; i < inParamDefs.length; i++)
            {
              var paramDef = inParamDefs[i];
              var paramName = paramDef.getName();
              if (inParams[paramName] !== undefined)
              {
                var value = inParams[paramName];
                var elExpression = paramDef.getValueExpression();
                if ((elExpression == null) || (elExpression == ""))
                {
                  elExpression = "#{pageFlowScope." + paramName + "}";
                }
                request.push({name: elExpression, value: value});
              }
              else
              {
                //
                //  See if the parameter is required.
                //
                if (paramDef.isRequired())
                {
                  //
                  //  The parameter is required but a value was not supplied.
                  //
                  throw new Error("ADFc: required task flow input parameter [" + paramName + "] not provided.");
                }
              }
            }
            adfc.internal.ElUtil.setValues(request, inParamSuccess, failCallback);
          }
          else
          {
            inParamSuccess();
          }
        }

        var pushTfFailed = function()
        {
          var msg = "ADFc: Push of task flow failed for [" + taskFlowId + "]";
          // What is message? msg += message;
          failCallback(msg);
        }

        if (taskFlowDef == null)
        {
          var msg = "ADFc: Failed to find task flow definition for [" + taskFlowId + "]";
          // What is message? msg += message;
          failCallback(msg);
        }

        //
        //  Determine the calling view activity.  This is defined as the view ativity in
        //  the _current_ flow that was last displayed.  If no view has been displayed in
        //  the current flow then the calling view is null.
        //
        var callingView = null;
        var controllerState = adfc.internal.AdfcContext.getControllerState();
        var currentTfInstance = controllerState.peekTaskFlowStack();
        if (currentTfInstance.getInstanceId() == routingState.getStartingTaskFlowInstanceId())
        {
          //
          //  We're still in the same flow as the last displayed view activity.
          //
          callingView = routingState.getStartingActivityId();
        }

        //
        //  Record this task flow as the 'current' task flow.
        //
        controllerState.pushTaskFlow(taskFlowDef, taskFlowCallActivity, callingView, pushTfSuccess, pushTfFailed);
      },
      taskFlowId);
  }

  /**
   * gets the TaskFlowId of the task flow to be called
   */
  TaskFlowCallActivityLogic.getTaskFlowId = function(activity, successCallback, failCallback)
  {
    var taskFlowId = null;
    if (activity.isDynamic())
    {
      var getTaskFlowIdSuccess = function(request, response)
      {
        var taskFlowIdString = response[0].value;
        taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
      }
      var elExpression = activity.getDynamicTaskFlowIdElExpression();
      adfc.internal.LogUtil.fine("evaluating dynamic task flow call expression: " + elExpression);
      adfc.internal.ElUtil.getValue(elExpression, getTaskFlowIdSuccess, failCallback)
    }
    else
    {
      var taskFlowIdString = activity.getTaskFlowReference();
      taskFlowId = adfc.internal.TaskFlowIdUtil.parseTaskFlowId(taskFlowIdString);
    }
    if (taskFlowId != null)
    {
      successCallback(taskFlowId);
    }
    else
    {
      failCallback();
    }
  }

  /**
   * invokes the before-listener of a the given task flow call activity if it is specified
   */
  TaskFlowCallActivityLogic.invokeBeforeListener = function(activity, successCallback, failCallback)
  {
    //
    // invoke the before listener if specified
    //
    var listener = activity.getBeforeListener();
    if (listener && (listener != null))
    {
      adfc.internal.LogUtil.fine("calling before-listener: " + listener);
      adfc.internal.ElUtil.invokeMethod(listener, new Array(), new Array(), successCallback, failCallback);
    }
    else
    {
      successCallback()
    }
  }

  /**
   * collects input parameters from the task flow call activity
   */
  TaskFlowCallActivityLogic.gatherInputParamerValues = function(activity, successCallback, failCallback)
  {
    var paramExpressions = new Array();
    var paramNames = new Array();

    var getParamsSuccess = function(request, response)
    {
      //
      //  Build a map of the parameter name/value pairs
      //
      var inputParams = {};
      for (var i = 0; i < response.length; i++)
      {
        var paramName = paramNames[i];
        inputParams[paramName] = response[i].value;
      }




      var inputParamMapEL = activity.getInputParameterMapElExpression();
      // Add any parameters specified in a map
      if (inputParamMapEL != null)
      {
        var getMapSuccess = function(request1, response1)
        {
          var inputParamMap = response1[0].value;

          for (var key in inputParamMap)
          {
            adfc.internal.LogUtil.fine("adding input parameter from map: " + key + ":" + inputParamMap[key]);
            inputParams[key] = inputParamMap[key];
          }

          successCallback(inputParams);
        }
        adfc.internal.LogUtil.fine("Evaluating input parameter map expression: " + inputParamMapEL);
        adfc.internal.ElUtil.getValue(inputParamMapEL, getMapSuccess, failCallback);
      }
      else
      {
        successCallback(inputParams);
      }
    }

    //
    //  Collect the task flow call's input parameter values.
    //
    var params = activity.getInputParameters();

    if (params.length > 0)
    {
      for (var i = 0; i < params.length; i++)
      {
        paramExpressions.push(params[i].getValueExpression());
        paramNames.push(params[i].getName());
      }
      adfc.internal.LogUtil.fine("getting method call activity parameter values");
      adfc.internal.ElUtil.getValues(paramExpressions, getParamsSuccess, failCallback);
    }
    else
    {
      //
      //  There aren't any input params.
      //
      adfc.internal.LogUtil.fine("no method call activity parameters specified");
      getParamsSuccess(paramExpressions, paramExpressions);
    }
  }

   /**
   * Determines data control context type. If the EL does not evaluate to "isolated",
   * the data control context is assumed to be shared.
   */
   TaskFlowCallActivityLogic.isDataControlContextIsolated = function(activity, failCallback)
   {
    var isolated = false;
    var elSuccessCallback = function(request, response)
    {
      var result = response[0].value;
      if (adfc.internal.LogUtil.isFine())
      {
        adfc.internal.LogUtil.fine("ADFc: data control context expression '" + elExpression + "' evaluated to '" + result + "'.");
      }
      if (result != null && result.toLowerCase() == "isolated")
      {
        isolated = true;
      }
    }

    var elExpression = activity.getDataControlContextType();
    //
    // Evaluating null el sometimes fails
    //
    if (elExpression != null)
    {
      adfc.internal.LogUtil.fine("evaluating data control context expression: " + elExpression);
      adfc.internal.ElUtil.getValue(elExpression, elSuccessCallback, failCallback);
    }
    return isolated;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowCallActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowId.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Unique identifier of a task flow.
    */
   adfc.internal.TaskFlowId = TaskFlowId;
   function TaskFlowId(documentUri, localId)
   {
      this.mDocumentUri = documentUri;
      this.mLocalTaskFlowId = localId;
   }
   
   TaskFlowId.prototype.getDocumentUri = function()
   {
      return this.mDocumentUri;
   }
   
   TaskFlowId.prototype.getLocalTaskFlowId = function()
   {
      return this.mLocalTaskFlowId;
   }
   
   TaskFlowId.prototype.toString = function()
   {
      return this.mDocumentUri + "#" + this.mLocalTaskFlowId;
   }
   
   TaskFlowId.prototype.equals = function(other)
   {
      var result = false;
      if (other)
      {
         var otherDoc = other.getDocumentUri();
         var otherLocalId = other.getLocalTaskFlowId();
         result = (this.mDocumentUri == otherDoc) && (this.mLocalTaskFlowId == otherLocalId);
      }
      return result;
   }
   
   /**
    * Parses a string representation of a task flow ID and returns a
    * TaskFlowId object.
    */
   TaskFlowId.parse = function(stringId)
   {
      var result = null;
      
      //
      // Document path should not start with a "/"
      //
      if (stringId.indexOf("/") == 0)
      {
        stringId = stringId.substring(1);    
      }
      //
      //  Task flow ID strings are formatted as: <document-uri>#<local-id>
      //
      var index = stringId.indexOf("#");
      if (index > 0)
      {
         var docUri = stringId.substring(0, index);
         var localId = stringId.substring(index+1);
         result = new TaskFlowId(docUri, localId);
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowId.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/TaskFlowStackEntry.js///////////////////////////////////////

/*
* Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc)
  window.adfc = 
  {
  };
if (!adfc.internal)
  adfc.internal = 
  {
  };(function ()
{
  adfc.internal.TaskFlowStackEntry = TaskFlowStackEntry;
  adfc.internal.TaskFlowStackEntry.SequenceCounter = 0;

  function TaskFlowStackEntry(taskFlowId, taskFlowCallActivity, callingViewActivityId, newPageFlowScopeCreated, newDataControlContextCreated)
  {
    this.mInstanceId = adfc.internal.TaskFlowStackEntry.SequenceCounter++;
    
    this.mTaskFlowId = taskFlowId;
    this.mTaskFlowCallActivity = taskFlowCallActivity;
    this.mViewReached = false;
    this.mCallingViewActivityId = callingViewActivityId;
    this.mNewPageFlowScopeCreated = newPageFlowScopeCreated;
    this.mNewDataControlContextCreated = newDataControlContextCreated;
    this.mViewHistoryStack = new Array();
  }

  TaskFlowStackEntry.prototype.getInstanceId = function ()
  {
    return this.mInstanceId;
  }

  TaskFlowStackEntry.prototype.getTaskFlowDefinition = function(callback)
  {
    var getTaskFlowDefinitionFail = function()
    {
      callback(null);
    };

    var getTaskFlowDefinition = function(taskFlowDefinition)
    {
      callback(taskFlowDefinition);
    }

    //
    // null task flow id indicates unbounded flow
    //
    if (this.mTaskFlowId && (this.mTaskFlowId != null))
    {
      adfc.internal.MetadataService.getTaskFlowDefinition(getTaskFlowDefinition, this.mTaskFlowId);
    }
    else
    {
      adfc.internal.MetadataService.loadBootstrapMetadata(getTaskFlowDefinition, getTaskFlowDefinitionFail);
    }
  }

  TaskFlowStackEntry.prototype.getTaskFlowCallActivity = function ()
  {
    return this.mTaskFlowCallActivity;
  }

  TaskFlowStackEntry.prototype.shouldPopPageFlowScope = function ()
  {
    return this.mNewPageFlowScopeCreated;
  }

  TaskFlowStackEntry.prototype.shouldPopDataControlContext = function ()
  {
    return this.mNewDataControlContextCreated;
  }

  TaskFlowStackEntry.prototype.pushViewHistory = function (viewId, amxPage, transType)
  {
    var item = new adfc.internal.ViewHistoryItem(viewId, amxPage, transType);
    this.mViewHistoryStack.push(item);
    adfc.internal.ElUtil.setMfContextInstance(item, true);
  }

  TaskFlowStackEntry.prototype.popViewHistory = function ()
  {
    var result = this.mViewHistoryStack.pop();
    adfc.internal.ElUtil.removeMfContextInstance(result);
    return result;
  }

  TaskFlowStackEntry.prototype.peekViewHistory = function ()
  {
    var result = this.mViewHistoryStack[this.mViewHistoryStack.length - 1];
    return result;
  }

  TaskFlowStackEntry.prototype.clearViewHistory = function ()
  {
    while (this.mViewHistoryStack.length > 0)
    {
      this.popViewHistory();
    }
  }

  TaskFlowStackEntry.prototype.getViewHistoryLength = function ()
  {
    var result = this.mViewHistoryStack.length;
    return result;
  }

  TaskFlowStackEntry.prototype.isViewReached = function ()
  {
    return this.mViewReached;
  }

  TaskFlowStackEntry.prototype.setViewReached = function (value)
  {
    this.mViewReached = value;
  }

  TaskFlowStackEntry.prototype.getCallingViewActivityId = function ()
  {
    return this.mCallingViewActivityId;
  }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/TaskFlowStackEntry.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowRuleXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ControlFlowRuleXmlParser = {};
adfc.internal.ControlFlowRuleXmlParser.parse = function(docPath, taskFlowId, node)
{
   // big ADF handles control flow cases slightly differently:  It has collections for the different combinations
   // of values for from-action and from-outcome.  Since ADFmf currently only supports from-outcome, we store everything
   // in the same Array.  the default (null from-outcome) is just stored along with the normal cases.  
   // ControlFlowRule.getControlFlowCaseIndex(outcome) contains the logic to determine if the default should be used
   
   var fromActivityId = null;
   var cfCases = new Array();
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "from-activity-id")
         {
            var localId = adfc.internal.XmlUtil.getNodeText(child);
            fromActivityId = new adfc.internal.ActivityId(taskFlowId, localId);
         }
         else if (childName == "control-flow-case")
         {
            var cfCase = adfc.internal.ControlFlowCaseXmlParser.parse(docPath, taskFlowId, child);
            if (cfCase)
            {
               cfCases.push(cfCase);
            }
         }
      }
   }
   var result = new adfc.internal.ControlFlowRule(fromActivityId, cfCases);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowRuleXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityType.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ActivityType = ActivityType;
   function ActivityType()
   {}
   
   ActivityType.VIEW = "view";
   ActivityType.ROUTER = "router";
   ActivityType.METHOD_CALL = "method-call";
   ActivityType.TASK_FLOW_RETURN = "task-flow-return";
   ActivityType.TASK_FLOW_CALL = "task-flow-call";

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityType.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedPropertyDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ManagedPropertyDefinition = ManagedPropertyDefinition;
   function ManagedPropertyDefinition(name, type, value)
   {
      this.mName = name;
      this.mType = type;
      this.mValue = value;
   }
   
   ManagedPropertyDefinition.prototype.getName = function() 
   {
      return this.mName;
   }
   
   ManagedPropertyDefinition.prototype.getType = function() 
   {
      return this.mType;
   }
   
   ManagedPropertyDefinition.prototype.getValue = function() 
   {
      return this.mValue;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ManagedPropertyDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallParameter.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */
 
if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-call activity input parameter or return value.
    */
   adfc.internal.TaskFlowCallParameter = TaskFlowCallParameter;
   function TaskFlowCallParameter(name, valueExpression, passByValue)
   {
      this.mName = name;
      this.mValueExpression = valueExpression;
      this.mPassByValue = passByValue;
   }
   
   TaskFlowCallParameter.prototype.getName = function()
   {
      return this.mName;
   }
   
   TaskFlowCallParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }
   
   TaskFlowCallParameter.prototype.getPassByValue = function()
   {
      return this.mPassByValue;
   }

})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ActivityXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ActivityXmlParser = {};
adfc.internal.ActivityXmlParser.parse = function(docPath, taskFlowId, node)
{
   var result = null;
   if (node && (node != null))
   {
      //
      //  Get the activityId.
      //
      var idStr = node.attributes.getNamedItem("id").nodeValue;
      var activityId = new adfc.internal.ActivityId(taskFlowId, idStr);
      
      var nodeName = node.localName;
      if (nodeName == "view")
      {
         result = adfc.internal.ActivityXmlParser.parseViewActivity(activityId, node);
      }
      else if (nodeName == "router")
      {
         result = adfc.internal.ActivityXmlParser.parseRouterActivity(activityId, node);
      }
      else if (nodeName == "method-call")
      {
         result = adfc.internal.ActivityXmlParser.parseMethodCallActivity(activityId, node);
      }
      else if (nodeName == "task-flow-return")
      {
         result = adfc.internal.ActivityXmlParser.parseTaskFlowReturnActivity(activityId, node);
      }
      else if (nodeName == "task-flow-call")
      {
         result = adfc.internal.ActivityXmlParser.parseTaskFlowCallActivity(activityId, node);
      }
   }
   return result;
}

adfc.internal.ActivityXmlParser.parseViewActivity = function(activityId, node)
{
   var vdlDocPath = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "page")
         {
            vdlDocPath = adfc.internal.XmlUtil.getNodeText(child);
            
            //
            //  The VDL document path should begin with a leading slash '/' but it's
            //  possible it might not be that way in the metadata.  Add a leading slash
            //  if needed.
            //
            if ((vdlDocPath != null) && (vdlDocPath.length > 0))
            {
               var firstChar = vdlDocPath.charAt(0);
               if ((firstChar != null) && (firstChar != "/"))
               {
                  vdlDocPath = "/" + vdlDocPath;
               }
            }
         }
      }
   }
   var result = new adfc.internal.ViewActivity(activityId, vdlDocPath);
   return result;
}

adfc.internal.ActivityXmlParser.parseRouterActivity = function(activityId, node)
{
   var cases = new Array();
   var defaultOutcome = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "default-outcome")
         {
            defaultOutcome = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "case")
         {
            var routerCase = adfc.internal.ActivityXmlParser.parseRouterCase(child);
            cases.push(routerCase);
         }
      }
   }
   if (defaultOutcome == null)
   {
      var msg = "task flow router activity " + activityId.toString() + " does not have a default outcome";
      adfc.internal.LogUtil.severe(msg);
   }
   var result = new adfc.internal.RouterActivity(activityId, cases, defaultOutcome);
   return result;
}

adfc.internal.ActivityXmlParser.parseRouterCase = function(node)
{
   var expression = null;
   var outcome = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "expression")
         {
            expression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "outcome")
         {
            outcome = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.RouterCase(expression, outcome);
   return result;
}

adfc.internal.ActivityXmlParser.parseMethodCallActivity = function(activityId, node)
{
   var elExpression = null;
   var defaultOutcome = null;
   var convertToString = false;
   var params = new Array();
   var returnValue = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "method")
         {
            elExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "outcome")
         {
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "fixed-outcome")
                  {
                     defaultOutcome = adfc.internal.XmlUtil.getNodeText(child2);
                     break;
                  }
                  else if (child2Name == "to-string")
                  {
                     convertToString = true;
                     break;
                  }
               }
            }
         }
         else if (childName == "parameter")
         {
            var param = adfc.internal.ActivityXmlParser.parseMethodCallParam(child);
            params.push(param);
         }
         else if (childName == "return-value")
         {
            returnValue = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = 
      new adfc.internal.MethodCallActivity(activityId, elExpression, defaultOutcome, convertToString, params, returnValue);
   return result;
}

adfc.internal.ActivityXmlParser.parseMethodCallParam = function(node)
{
   var type = null;
   var valueExpression = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.MethodCallParameter(type, valueExpression);
   return result;
}

adfc.internal.ActivityXmlParser.parseTaskFlowReturnActivity = function(activityId, node)
{
   var outcomeName = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "outcome")
         {
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "name")
                  {
                     outcomeName = adfc.internal.XmlUtil.getNodeText(child2);
                     break;
                  }
               }
            }
         }
      }
   }
   return new adfc.internal.TaskFlowReturnActivity(activityId, outcomeName);
}


adfc.internal.ActivityXmlParser.parseTaskFlowCallActivity = function(activityId, node)
{
   var taskFlowReference = null;
   var dynamicTaskFlowReferenceEl = null;
   var params = new Array();
   var paramMap = null;
   var returnValues = new Array();
   var beforeListener = null;
   var afterListener = null;
   var dcContext = null;

   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName && (childName != null))
      {
         if (childName == "task-flow-reference")
         {
            var taskFlowDocument = null;
            var taskFlowId = null;
            
            var children2 = child.childNodes;
            for (var j = 0; j < children2.length; j++)
            {
               var child2 = children2.item(j);
               var child2Name = child2.localName;
               if (child2Name && (child2Name != null))
               {
                  if (child2Name == "document")
                  {
                     taskFlowDocument = adfc.internal.XmlUtil.getNodeText(child2);
                  }
                  else if (child2Name == "id")
                  {
                     taskFlowId = adfc.internal.XmlUtil.getNodeText(child2);;
                  }
               }
            }
            
            if (document && taskFlowId)
            {
               taskFlowReference = taskFlowDocument + "#" + taskFlowId;
            }
            else if (document)
            {
               taskFlowReference = taskFlowDocument;
            }
            else if (taskFlowId)
            {
               taskFlowReference = taskFlowId;
            }
            
         }
         else if (childName == "dynamic-task-flow-reference")
         {
            dynamicTaskFlowReferenceEl = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "input-parameter")
         {
            var param = adfc.internal.ActivityXmlParser.parseTaskFlowCallParam(child);
            params.push(param);
         }
         else if (childName == "input-parameter-map")
         {
            paramMap = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "return-value")
         {
            var returnValue = adfc.internal.ActivityXmlParser.parseTaskFlowCallParam(child);
            returnValues.push(returnValue);
         }
         else if (childName == "before-listener")
         {
            beforeListener = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "after-listener")
         {
            afterListener = adfc.internal.XmlUtil.getNodeText(child);
         }
          else if (childName == "data-control-context")
         {
            dcContext = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = 
      new adfc.internal.TaskFlowCallActivity(activityId, taskFlowReference, dynamicTaskFlowReferenceEl, params, paramMap,
                                             returnValues, beforeListener, afterListener, dcContext);
   return result;
}


// Note that this function is used for both input parameters and return values because they have the same elements.  This 
// is similar to the way the big ADF parsing code works
adfc.internal.ActivityXmlParser.parseTaskFlowCallParam = function(node)
{
   var name = null;
   var valueExpression = null;
   var passByValue = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "pass-by-value")
         {
            passByValue = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.TaskFlowCallParameter(name, valueExpression, passByValue);
   return result;
}

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ActivityXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowInputParameterXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.TaskFlowInputParameterXmlParser = {};
adfc.internal.TaskFlowInputParameterXmlParser.parse = function(docPath, taskFlowId, node)
{
   var name = null;
   var valueExpression = null;
   var type = null;
   var isRequired = false;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "name")
         {
            name = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "value")
         {
            valueExpression = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "class")
         {
            type = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "required")
         {
            isRequired = true;
         }
      }
   }
   var result = new adfc.internal.TaskFlowInputParameter(name, valueExpression, type, isRequired);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowInputParameterXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ViewActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a view activity.
    */
   adfc.internal.ViewActivity = ViewActivity;
   function ViewActivity(id, vdlDocumentPath)
   {
      this.mActivityId = id;
      this.mVdlDocumentPath = vdlDocumentPath;
   }
  
   ViewActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.VIEW;
   }
  
   ViewActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
  
   ViewActivity.prototype.getVldDocumentPath = function() 
   {
      return this.mVdlDocumentPath;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ViewActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowCaseXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.ControlFlowCaseXmlParser = {};
adfc.internal.ControlFlowCaseXmlParser.parse = function(docPath, taskFlowId, node)
{
   var outcome = null;
   var guardCondition = null;
   var targetActivityId = null;
   var transition = null;
   
   var children = node.childNodes;
   for (var i = 0; i < children.length; i++)
   {
      var child = children.item(i);
      var childName = child.localName;
      if (childName)
      {
         if (childName == "from-outcome")
         {
            outcome = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "if")
         {
            guardCondition = adfc.internal.XmlUtil.getNodeText(child);
         }
         else if (childName == "to-activity-id")
         {
            var localId = adfc.internal.XmlUtil.getNodeText(child);
            targetActivityId = new adfc.internal.ActivityId(taskFlowId, localId);
         }
         else if (childName == "transition")
         {
            transition = adfc.internal.XmlUtil.getNodeText(child);
         }
      }
   }
   var result = new adfc.internal.ControlFlowCase(outcome, guardCondition, targetActivityId, transition);
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/ControlFlowCaseXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationHandler.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationHandler = NavigationHandler;

  /**
   * NavigationHandler is the public facing interface to the ADFc NavigationHandler.
   * @export
   */
  function NavigationHandler()
  {
  }

  /**
   * Get the initial viewId of a feature.
   * @param {Object} request an initial navigation request.  It must have an
   *                 attribute named:
   *                    entryPoint: the entry point file path.
   *
   * @param {function} success(request, response)  invoked upon successful completion of the navigation.
   * @param {function} failed(request, response)  invoked if navigation failed.
   * @export
   */
  NavigationHandler.getInitialViewId = function(request, successCallback, failCallback)
  {
      adfc.internal.LogUtil.perfLog("BEGIN: NavigationHandler.getInitialViewId");
      if (adfc.internal.LogUtil.isFine())
      {
         adfc.internal.LogUtil.fine("executing NavigationHandler.getInitialViewId() called.");
      }

      var entryPoint = request["entryPoint"];
      var inputParams = request["inputParams"];
      if (typeof inputParams === "undefined")
      {
        inputParams = {};
      }
      
      var success = function(result)
      {
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.getInitialViewId");
         successCallback(request, result);
      }
      
      var failed = function(message)
      {
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.getInitialViewId");
         failCallback(request, message);
      }

      adfc.internal.NavigationHandlerImpl.getInitialViewId(entryPoint, inputParams, success, failed);
  }

  /**
   * Perform navigation handling based on the current viewId and outcome.
   * @param {Object} request an initial navigation request.  It must have
   *                 attributes named:
   *                    currentViewId:  the viewId of the currently displayed view.
   *                    outcome:  the outcome produced by an action.
   * @param {function} success(request, response)  invoked upon successful completion of the navigation.
   * @param {function} failed(request, response)  invoked if navigation failed.
   * @export
   */
  NavigationHandler.handleNavigation = function(request, successCallback, failedCallback)
  {
      adfc.internal.LogUtil.perfLog("BEGIN: NavigationHandler.handleNavigation");

      var currentViewId = request["currentViewId"];
      var outcome = request["outcome"];
      
      if (adfc.internal.LogUtil.isFine())
      {
         adfc.internal.LogUtil.fine("executing NavigationHandler.handleNavigation(), currentViewId=" + 
                                    currentViewId + ", outcome=" + outcome);
      }
      
      var success = function(navResult)
      {
         if (adfc.internal.LogUtil.isFine())
         {
            var isNewView = navResult.isNewViewId();
            var msg = "ADFc: executing NavigationHandler.handleNavigation() completed, isNewView=" + isNewView;
            if (isNewView) 
            {
               var page = navResult.getVdlDocumentPath();
               msg += ", page=" + page;
            }
            adfc.internal.LogUtil.fine(msg);
         }
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.handleNavigation");
         successCallback(request, navResult);
      }
      var failed = function(message) 
      {
         if (adfc.internal.LogUtil.isFine())
         {
            adfc.internal.LogUtil.fine("executing NavigationHandler.handleNavigation() failed");
         }
         adfc.internal.LogUtil.perfLog("END: NavigationHandler.handleNavigation");
         failedCallback(request, message);
      }
      adfc.internal.NavigationHandlerImpl.handleNavigation(currentViewId, outcome, success, failed);
      
  }
  
  /**
   * Registers a navigation listener function. 
   * @param {function} callback(event)  invoked upon start or successful completion of the navigation.
   * @export
   */
  NavigationHandler.addNavigationListener = function(callback)
  {
    for(var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      if(adfc.internal.navigationListeners[i] == callback)
      {
        return;
      }
    }
    adfc.internal.LogUtil.fine("ADFc: addNavigationListener");
    adfc.internal.navigationListeners.push(callback);
  }

  /**
   * Removes a registered navigation listener.
   * @param {function} callback(event)  invoked upon start or successful completion of the navigation.
   * @export
   */
  NavigationHandler.removeNavigationListener = function(callback)
  {
    var temp = [];

    for(var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      if(adfc.internal.navigationListeners[i] != callback)
      {
        adfc.internal.LogUtil.fine("ADFc: removeNavigationListener");
        temp.push(adfc.internal.navigationListeners[i]);
      }
    }
    adfc.internal.navigationListeners = temp;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationHandler.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowReturnActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.TaskFlowReturnActivityLogic = TaskFlowReturnActivityLogic;
   function TaskFlowReturnActivityLogic()
   {
   }

  TaskFlowReturnActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
  {
    var controllerState = adfc.internal.AdfcContext.getControllerState();
    var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(currentTaskFlow)
      {
        var currentTaskFlowCallActivity = currentTaskFlowEntry.getTaskFlowCallActivity()
        if (currentTaskFlowCallActivity && (currentTaskFlowCallActivity != null))
        {
          var finalizerSuccess = function()
          {
            var gatherReturnValuesSuccess = function(returnValueDefs)
            {
              var popTfSuccess = function(poppedTfStackEntry)
              {
                routingState.setLastReturnedFromTfEntry(poppedTfStackEntry);
                var returnValuesSuccess = function()
                {
                  var invokeAfterListenerSuccess = function()
                  {
                    var outcome = activity.getOutcomeName();
                    routingState.setCurrentOutcome(outcome);
                    routingState.setCurrentActivityId(currentTaskFlowCallActivity.getActivityId());
                    routingState.setNextActivityId(null);
                    routingState.setTaskFlowReturnExecuted(true);
                    routingState.setRoutingComplete(false);
                    successCallback(routingState);
                  }
                  // invoke the after-listener
                  TaskFlowReturnActivityLogic.invokeAfterListener(currentTaskFlowCallActivity, invokeAfterListenerSuccess, failCallback);
                }
                // store the return values in the caller
                TaskFlowReturnActivityLogic.storeReturnValues(currentTaskFlowCallActivity, returnValueDefs, returnValuesSuccess, failCallback)
              }
              // pop the task flow from the stack
              adfc.internal.AdfcContext.getControllerState().popTaskFlow(popTfSuccess, failCallback);
            }
            // gather the retun values from the callee
            TaskFlowReturnActivityLogic.gatherReturnValues(currentTaskFlow, gatherReturnValuesSuccess, failCallback);
          }
          // invoke the finalizer
          TaskFlowReturnActivityLogic.invokeFinalizer(currentTaskFlow, finalizerSuccess, failCallback);
        }
        else
        {
          routingState.setTaskFlowReturnExecuted(true);
          routingState.setRoutingComplete(true);
          successCallback(routingState);
        }
      });
  };

   /**
    * invokes the after-listener of a the given task flow call activity if it is specified
    */
   TaskFlowReturnActivityLogic.invokeAfterListener = function(activity, successCallback, failCallback)
   {
      //
      // invoke the after listener if specified
      //
      var listener = activity.getAfterListener();
      if (listener && (listener != null))
      {
         adfc.internal.LogUtil.fine("calling after-listener: " + listener);
         adfc.internal.ElUtil.invokeMethod(listener, new Array(), new Array(), successCallback, failCallback);
      }
      else
      {
         successCallback()
      }
   }
   

   /**
    * invokes the finalizer of a the given task flow activity if it is specified
    */
   TaskFlowReturnActivityLogic.invokeFinalizer = function(taskFlowDef, successCallback, failCallback)
   {
      //
      //  Execute the task flow's finalizer, if it has one.
      //
      var finalizer = taskFlowDef.getFinalizer();
      if (finalizer && (finalizer != null))
      {
         adfc.internal.LogUtil.fine("calling finalzer: " + finalizer);
         adfc.internal.ElUtil.invokeMethod(finalizer, new Array(), new Array(), successCallback, failCallback);
      }
      else
      {
         successCallback();
      }
   }
   
   
   
   /**
    * collects return values from the called taskflow prior to returning
    */
   TaskFlowReturnActivityLogic.gatherReturnValues = function(taskFlowDef, successCallback, failCallback)
   {
      var returnValueExpressions = new Array();
      var returnValueNames = new Array();
      
      var getReturnValuesSuccess = function(request, response)
      {
         //
         //  Build a map of the return value name/value pairs
         //
         var returnValues = {};
         for (var i = 0; i < response.length; i++)
         {
            var returnValueName = returnValueNames[i];
            returnValues[returnValueName] = response[i].value;
         }
         
         successCallback(returnValues);
      }
      
      //
      //  Collect the task flow's return values.
      //
      var values = taskFlowDef.getReturnValues();

      if (values.length > 0)
      {
         for (var i = 0; i < values.length; i++)
         {
            returnValueExpressions.push(values[i].getValueExpression());
            returnValueNames.push(values[i].getName());
         }
         adfc.internal.LogUtil.fine("getting task flow return values");
         adfc.internal.ElUtil.getValues(returnValueExpressions, getReturnValuesSuccess, failCallback);
      }
      else 
      {
         //
         //  There aren't any return values.
         //
         adfc.internal.LogUtil.fine("no task flow return values defined");
         getReturnValuesSuccess(returnValueExpressions, returnValueExpressions);
      }
   }
   
   
   /**
    * stores return values from the called taskflow into the expressions defined in the task flow call
    */
   TaskFlowReturnActivityLogic.storeReturnValues = function(currentTaskFlowCallActivity, returnValueDefs, successCallback, failCallback)
   {
      var request = new Array();
      var returnValues = currentTaskFlowCallActivity.getReturnValues();
      if ((returnValues != null) && (returnValues.length > 0))
      {
         for (var i = 0; i < returnValues.length; i++)
         {
            var returnValue = returnValues[i];
            var returnValueName = returnValue.getName();
            if (returnValueDefs[returnValueName])
            {
               var value = returnValueDefs[returnValueName];
               var elExpression = returnValue.getValueExpression();
               if ((elExpression == null) || (elExpression == ""))
               {
                  elExpression = "#{pageFlowScope." + returnValueName + "}";
               }
               request[i] = {name: elExpression, value: value};
            }
         }
         adfc.internal.ElUtil.setValues(request, successCallback, failCallback);
      }
      else
      {
         successCallback();
      }
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/TaskFlowReturnActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/IdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.IdUtil = IdUtil;
   adfc.internal.IdUtil.seqNum = 0;
   
   function IdUtil()
   {}
   
   IdUtil.uuid = function()
   {
      var result = true;
      if (typeof amx !== "undefined")
      {
         if (typeof amx.uuid !== "undefined")
         {
            result = amx.uuid();
         }
         else
         {
            result = adfc.internal.IdUtil.seqNum++;
         }
      }
      else
      {
         result = adfc.internal.IdUtil.seqNum++;
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/IdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/RouterActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.RouterActivityLogic = RouterActivityLogic;
   function RouterActivityLogic()
   {
   }
      
   RouterActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.perfLog("BEGIN: RouterActivityLogic.execute");
      var currentCase = 0;
      var expression = null;
      var elSuccessCallback = function(request, response)
      {
         //
         //  Convert the result into a boolean value.
         //
         var result = response[0].value;
         if (adfc.internal.LogUtil.isFine())
         {
            adfc.internal.LogUtil.fine("ADFc: router expression '" + expression + "' evaluated to '" + result + "'.");
         }
         result = adfc.internal.ElUtil.resultToBoolean(result);
         
         var cases = activity.getCases();
         if (result == true)
         {
            //
            //  The expression evaluated to true so we want this router case's outcome.
            //
            var outcome = cases[currentCase].getOutcome();
            routingState.setCurrentOutcome(outcome);
            adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
            successCallback(routingState);
         }
         else
         {
            //
            //  The expression evaluated to false so see if there's another
            //  expression case to evaluate.
            //
            if (cases.length > currentCase+1)
            {
               ++currentCase;
               var routerCase = cases[currentCase];
               expression = routerCase.getExpression();
               adfc.internal.ElUtil.getValue(expression, elSuccessCallback, failCallback);
            }
            else
            {
               //
               //  There are no more cases so use the default outcome.
               //
               outcome = activity.getDefaultOutcome();
               routingState.setCurrentOutcome(outcome);
               adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
               successCallback(routingState);
            }
         }
      }
      
      var cases = activity.getCases();
      if ((cases != null) && (cases.length > 0))
      {
         //
         //  Evaluate the first case's expression.
         //
         var routerCase = cases[currentCase];
         var expression = routerCase.getExpression();
         adfc.internal.ElUtil.getValue(expression, elSuccessCallback, failCallback);
      }
      else
      {
         //
         //  There are no cases so use the default outcome.
         //
         var outcome = this.mRouter.getDefaultOutcome();
         routingState.setCurrentOutcome(outcome);
         adfc.internal.LogUtil.perfLog("END: RouterActivityLogic.execute");
         successCallback(routingState);
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/RouterActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a router activity.
    */
   adfc.internal.RouterActivity = RouterActivity;
   function RouterActivity(activityId, cases, defaultOutcome)
   {
      this.mActivityId = activityId;
      this.mCases = cases;
      this.mDefaultOutcome = defaultOutcome;
   }

   RouterActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.ROUTER;
   }
  
   RouterActivity.prototype.getActivityId = function()
   {
      return this.mActivityId;
   }
   
   RouterActivity.prototype.getCases = function()
   {
      return this.mCases;
   }
   
   RouterActivity.prototype.getDefaultOutcome = function()
   {
      return this.mDefaultOutcome;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/application/NavigationHandlerImpl.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.NavigationHandlerImpl = NavigationHandlerImpl;

  adfc.internal.navigationListeners   = [];

  function NavigationHandlerImpl()
  {
  }

  NavigationHandlerImpl.getInitialViewId = function(entryPoint, inputParams, successCallback, failCallback)
  {
    //
    //  See if we're starting with a bounded task flow.
    //
    var isTaskFlow = adfc.internal.XmlUtil.isTaskFlowDocument(
      function(isTaskFlow)
      {
        if (adfc.internal.LogUtil.isFine())
        {
          adfc.internal.LogUtil.fine("isTaskFlow=" + isTaskFlow);
        }
        if (isTaskFlow)
        {
          //
          //  We're starting with a task flow document. Parse the task flow ID.
          //
          var taskFlowId = adfc.internal.TaskFlowId.parse(entryPoint);

          //
          //  Create a RoutingState.
          //
          var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
          var currentTfInstanceId = currentTaskFlowEntry.getInstanceId();
          var routingState = new adfc.internal.RoutingState(currentTfInstanceId, null, null, null);
          routingState.setRoutingSuccessCallback(successCallback);
          routingState.setRoutingFailedCallback(failCallback);

          var invokeSuccessCallback =
            function(routingState2)
            {
              var routingSuccess = function(navResult)
              {
                if (adfc.internal.LogUtil.isFine())
                {
                  adfc.internal.LogUtil.fine("ADFc: routing completed in getInitialViewId.");
                }

                //
                //  Mark back navigation invalid from the initial view.
                //
                var currentTfEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
                if (currentTfEntry.getViewHistoryLength() > 0)
                {
                  var viewItem = currentTfEntry.peekViewHistory();
                  viewItem.setBackNavigationValid(false);
                }

                if (adfc.internal.LogUtil.isFine())
                {
                  adfc.internal.LogUtil.fine("ADFc: getInitialViewId calling successCallback.");
                  if (typeof successCallback === "undefined")
                  {
                    adfc.internal.LogUtil.fine("ADFc: successCallback is undefined!!!");
                  }
                }
                successCallback(navResult);
              }

              //
              //  Perform routing once we're inside the starting flow.
              //
              routingState.setRoutingSuccessCallback(routingSuccess);
              adfc.internal.ControlFlowEngine.doRouting(routingState2);
            };

          //
          //  Invoke the starting task flow.
          //
          adfc.internal.TaskFlowCallActivityLogic.invokeTaskFlow(taskFlowId, inputParams, null, routingState, invokeSuccessCallback, failCallback);
        }
        else
        {
          //
          //  We're not starting with a bounded task flow so see if the entry point is
          //  a view activity in the unbounded flow.
          //
          var tfEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
          NavigationHandlerImpl.getUnboundedFlowViewActivity(
            function(viewActivity)
            {
              if (viewActivity != null)
              {
                //
                //  We're starting with a view activity in the unbounded flow.
                //
                var pagePath = viewActivity.getVldDocumentPath();
                var viewId = viewActivity.getActivityId().getLogicalViewId();
                adfc.internal.LogUtil.info("displaying initial unbounded view activity, page=" + pagePath);
                var navResult = new adfc.NavigationResult(true, false, viewId, pagePath, "", false, true);

                //
                //  Push the initial view history item.
                //
                tfEntry.pushViewHistory(viewId, pagePath, adfc.internal.ControlFlowCase.DEFAULT_TRANSITION);

                successCallback(navResult);
              }
              else
              {
                //
                //  Assume the entry point is an AMX page.
                //
                adfc.internal.LogUtil.info("displaying initial AMX page, page=" + entryPoint);
                var navResult2 = new adfc.NavigationResult(true, false, entryPoint, entryPoint, "", false, true);

                //
                //  Push the initial view history item.
                //
                tfEntry.pushViewHistory(entryPoint, entryPoint, adfc.internal.ControlFlowCase.DEFAULT_TRANSITION);

                successCallback(navResult2);
              }
            },
            entryPoint);
        }
      },
      adfc.Util.addFeatureRootPrefix(entryPoint));
  };

  NavigationHandlerImpl.getUnboundedFlowViewActivity = function(callback, entryPoint)
  {
    var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(unboundedTf)
      {
        if ((unboundedTf == null) || (unboundedTf.getTaskFlowId() != null))
        {
          var msg = "unbounded task flow is not current";
          adfc.internal.LogUtil.showAlert(msg);
          throw new Error(msg);
        }

        //
        //  Look for a view activity that uses the entry point as its VDL document.
        //
        var viewActivity = null;
        var testEntryPoint = entryPoint;
        if ((testEntryPoint != null) && (testEntryPoint.length > 0) &&
          (testEntryPoint.charAt(0) != "/"))
        {
          testEntryPoint = "/" + testEntryPoint;
        }
        var activities = unboundedTf.getActivities();
        for (var name in activities)
        {
          var activity = activities[name];
          if (activity.getActivityType() == adfc.internal.ActivityType.VIEW)
          {
            var vdlDoc = activity.getVldDocumentPath();
            if (vdlDoc == testEntryPoint)
            {
              viewActivity = activity;
              break;
            }
          }
        }
        callback(viewActivity);
      });
  };

  NavigationHandlerImpl.handleNavigation = function(currentViewId, outcome, successCallback,
    failCallback)
  {
    //
    // Deliver navigation start event
    //
    var startNavEvent = new adfc.NavigationEvent(currentViewId, null,
      adfc.NavigationEventType.START);
    NavigationHandlerImpl.notifyNavigationListeners(startNavEvent);

    var controllerState = adfc.internal.AdfcContext.getControllerState();
    var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
    var tfInstanceId = currentTaskFlowEntry.getInstanceId();
    currentTaskFlowEntry.getTaskFlowDefinition(
      function(taskFlowDef)
      {
        var currentTaskFlowId = taskFlowDef.getTaskFlowId();
        var currentActivityId = adfc.internal.ViewIdUtil.logicalViewIdToActivityId(
          currentTaskFlowId, currentViewId);
        var routingState = new adfc.internal.RoutingState(tfInstanceId, currentViewId,
          currentActivityId, outcome);

        routingState.setRoutingSuccessCallback(successCallback);
        routingState.setRoutingFailedCallback(failCallback);
        adfc.internal.ControlFlowEngine.doRouting(routingState);
      });
  };

  NavigationHandlerImpl.notifyNavigationListeners = function(event)
  {
    for (var i = 0; i < adfc.internal.navigationListeners.length; ++i)
    {
      try
      {
        adfc.internal.LogUtil.fine("ADFc: notifyNavigationListeners");
        adfc.internal.navigationListeners[i](event);
      }
      catch(e)
      {
        adf.mf.log.logInfoResource("ADFErrorBundle", adf.mf.log.level.SEVERE,
          "NavigationHandlerImpl.notifyNavigationListeners",
          "ERROR_IN_BULK_NOTIFICATION_CALLBACK");

        // Only log the details at a fine level for security reasons
        adf.mf.log.Framework.logp(adf.mf.log.level.FINE,
          "NavigationHandlerImpl", "notifyNavigationListeners", e);
      }
    }
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/application/NavigationHandlerImpl.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityId.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Unique identifier of an activity.
    */
   adfc.internal.ActivityId = ActivityId;
   function ActivityId(taskFlowId, localId)
   {
      this.mTaskFlowId = taskFlowId;
      this.mLocalActivityId = localId;
   }
   
   /**
    * Parses a string representation of a task flow ID and returns an
    * ActivityId object.
    */
   ActivityId.parse = function(stringId)
   {
      var result = null;
      
      //
      //  The expected format is <task-flow-id>@<local-id>.
      //
      var index = stringId.indexOf("@");
      if (index > 0)
      {
         var tfIdString = stringId.substring(0, index);
         var tfId = adfc.internal.TaskFlowId.parse(tfIdString);
         var localId = stringId.substring(index+1);
         result = new ActivityId(tfId, localId);
      }
      return result;
   }
   
   ActivityId.prototype.getTaskFlowId = function()
   {
      return this.mTaskFlowId;
   }
   
   ActivityId.prototype.getLocalActivityId = function()
   {
      return this.mLocalActivityId;
   }
   
   /**
    * Constructs the logical viewId which is a cancatination of the
    * task flow's localId and the activity's localId.
    */
   ActivityId.prototype.getLogicalViewId = function()
   {
      var tfLocalId = "";
      if (this.mTaskFlowId != null)
      {
         tfLocalId = "/" + this.mTaskFlowId.getLocalTaskFlowId();
      }
      var result = tfLocalId + "/" + this.mLocalActivityId;
      return result;
   }
   
   ActivityId.prototype.toString = function()
   {
      var tfn = (this.mTaskFlowId != null)? this.mTaskFlowId.toString() : "";
      var result = tfn + "@" + this.mLocalActivityId;
      return result;
   }
   
   ActivityId.prototype.equals = function(other)
   {
      var result = false;
      if (other != null)
      {
         if ((typeof other.mTaskFlowId !== "undefined") && (typeof other.mLocalActivityId !== "undefined"))
         {
            if (this.mTaskFlowId != null)
            {
               //
               //  See if the taskFlowIds match.
               //
               if (this.mTaskFlowId.equals(other.mTaskFlowId))
               {
                  //
                  //  See if the local activityIds match.
                  //
                  result = (this.mLocalActivityId == other.mLocalActivityId);
               }
            }
            else if (other.mTaskFlowId == null)
            {
               //
               //  Both taskFlowIds are null.
               //
               result = (this.mLocalActivityId == other.mLocalActivityId);
            }
         }
      }
      return result;
   }
  
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ActivityId.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ElUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ElUtil = ElUtil;
   
   function ElUtil()
   {}
   
   ElUtil.TASK_FLOW_UTILITIES = "oracle.adfmf.framework.TaskFlowUtilities";
   
   /**
    * Get a single value.
    */
   ElUtil.getValue = function(expression, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.getValue(expression, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.getValue(expression, successCallback, failCallback);
      }
   }
   
   /**
    * Get an array of values.
    */
   ElUtil.getValues = function(expressions, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.getValues(expressions, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.getValue(expressions, successCallback, failCallback);
      }
   }
   
   /**
    * Set a single value.
    */
   ElUtil.setValue = function(request, successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.setValue(request, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.setValue(request, successCallback, failCallback);
      }
   }
   
   /**
    * Set an array of values.
    */
    ElUtil.setValues = function(request, successCallback, failCallback)
    {
       ElUtil.setValue(request, successCallback, failCallback);
    }
   
   /**
    * Invoke a method binding.
    */
   ElUtil.invokeMethod = function(expression, argTypes, argValues, successCallback, failCallback)
   {
      if (argTypes == null)
      {
         adfc.internal.LogUtil.warning("ElUtil.invokeMethod() passed null argTypes.  This is likely to fail.");
      }
      
      if (argValues == null)
      {
         adfc.internal.LogUtil.warning("ElUtil.invokeMethod() passed null argValues.  This is likely to fail.");
      }
         
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtilMock.invokeMethod(expression, argTypes, argValues, successCallback, failCallback);
      }
      else
      {
         adf.mf.el.invoke(expression, argValues, null, argTypes, successCallback, failCallback);
      }
   }
   
   /**
    * Set the current binding container.
    */
   ElUtil.setBindingContainerPath = function(path, resetViewScope, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("Setting binding container for: " + path);
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock setBindingContainerPath");
         successCallback();
      }
      else
      {
        // We really should be resetting the context if it exists. We really need a function that resets the 
        // Context if it exits, or else creates if for the first time.
        adf.mf.api.setCurrentContext(path, true, true, resetViewScope, successCallback, failCallback);
      }
   }
   
   /**
    * Reset/release a binding container.
    */
   ElUtil.resetBindingContainerPath = function(path, successCallback, failCallback)
   {
      adfc.internal.LogUtil.fine("Removing binding container for: " + path);
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock resetBindingContainerPath");
         successCallback();
      }
      else
      {  
        // This should be resetting the context instance but for now we are removing it. The issue is I have
        // no way to know it existed to reuse. So I remove it, and recreate it in the setBindingContainerPath
        adf.mf.api.removeContextInstance(path, path, successCallback, failCallback);
      }
   }
      
   ElUtil.getCurrentBindingContainerPath = function(successCallback, failCallback)
   {
      if (adfc.internal.ElUtil.useMockContext())
      {
         adfc.internal.LogUtil.fine("using mock getBindingContainerPath");
         successCallback(null);
      }
      else
      {
         adf.mf.api.getContextId(successCallback, failCallback);
      }
   }
   
   ElUtil.resultToBoolean = function(value)
   {
      var result = false;
      if (value != null)
      {
         if (value == true)
         {
            result = true;
         }
         else
         {
            if (value instanceof Boolean)
            {
               result = value.valueOf();
            }
            else
            {
               value = new String(value);
               if (value.toLowerCase() == "true")
               {
                  result = true;
               }
            }
         }
      }
      return result;
   }
   
   ElUtil.useMockEl = function()
   {
      var result = true;
      if (typeof adf !== "undefined")
      {
         if (typeof adf.mf !== "undefined")
         {
             if (typeof adf.mf.internal !== "undefined")
             {
                 if (typeof adf.mf.internal.isJavaAvailable !== "undefined")
                 {
                    result = !adf.mf.internal.isJavaAvailable();
                 }
             }
         }
      }
      return result;
   }
   
   ElUtil.useMockContext = function()
   {
      var result = ElUtil.useMockEl();
      return result;
   }
   
   /**
    *  Set a collection of managed bean definitions.  The collection of bean
    *  definitions supplied here _REPLACES_ any existing definitions, it does
    *  not add to the existing set.
    */
   ElUtil.setBeanDefinitions = function(beanDefs, successCallback, failCallback)
   {
      if (beanDefs != null)
      {
         adfc.internal.LogUtil.fine("defining " + beanDefs.length + " managed beans");
      }
      if (adfc.internal.ElUtil.useMockEl())
      {
         adfc.internal.ElUtil.currentBeanDefs = beanDefs;
         successCallback();
      }
      else
      {
         var elBeanDefs = ElUtil.createBeanDefinitions(beanDefs);
         adf.mf.internal.mb.setBeanDefinitions(elBeanDefs, successCallback, failCallback);
      }
   }
   
   /**
    *  Create an array of bean definitions in the format used by the EL from the format
    *  used internally by the controller.
    */
   ElUtil.createBeanDefinitions = function(internalBeanDefs)
   {
      var elBeanDefs = new Array();
      if (internalBeanDefs != null)
      {
         for (var i = 0; i < internalBeanDefs.length; i++)
         {
            var bean = internalBeanDefs[i];
            var props = ElUtil.createPropDefinitions(bean.getManagedProperties());
            var elBean = new adf.mf.internal.mb.ManagedBeanDefinition(bean.getBeanName(), bean.getBeanClass(), 
                                                                      bean.getBeanScope(), props);
            elBeanDefs.push(elBean);
         }
      }
      return elBeanDefs;
   }
   
   /**
    *  Create an array of bean definitions in the format used by the EL from the format
    *  used internally by the controller.
    */
   ElUtil.createPropDefinitions = function(internalPropDefs)
   {
      var elPropDefs = new Array();
      if (internalPropDefs != null)
      {
         if (internalPropDefs != null) 
         {
            for (var i = 0; i < internalPropDefs.length; i++)
            {
               var propDef = internalPropDefs[i];
               var elPropDef = new adf.mf.internal.mb.ManagedPropertyDefinition(propDef.getName(), 
                                                                                propDef.getType(), 
                                                                                propDef.getValue());
               elPropDefs.push(elPropDef);
            }
         }
      }
      return elPropDefs;
   }
   
   /**
    *  Push a new pageFlowScope instance and a new data control context, if needed.
    *  This methods marks the beginning of the scope's lifespan.
    */
   ElUtil.pushScopesIfNeeded = function(/* boolean */ pushPageFlowScope, /* boolean */ pushDataControlContext, 
                                        /* function */ successCallback, /* function */ failCallback) 
   {
      var pushSucceeded = true;
      var pushSuccess = function(req, status)
      {
         pushSucceeded = status;
         
         if (pushSucceeded)
         {
           if (pushPageFlowScope)
           {
             // Clear out the cache of the page flow scope to ensure that we have a clean scope
             adf.mf.internal.context.getVariableMapper().setVariable("pageFlowScope", {});
           }
           successCallback();
         }
         else
         {
           var msg = "Maximum data control context stack depth exceeded.";
           adfc.internal.LogUtil.severe(msg);
           if (adfc.internal.ElUtil.useMockContext())
           {
             adfc.internal.LogUtil.showAlert(msg);
           }
           else
           {
             adf.mf.api.amx.addMessage("severe", msg, null, null);    
           }
           failCallback(message);
         }
      }
      if (!(pushPageFlowScope || pushDataControlContext))
      {
        successCallback();
      }
      else
      {
        if (adfc.internal.ElUtil.useMockContext())
        {
           if (pushPageFlowScope)
           {
              adfc.internal.LogUtil.fine("pushing page flow scope");
           }
           if (pushDataControlContext)
           {
             adfc.internal.LogUtil.fine("pushing data control context");
           }
           successCallback();
        }
        else
        {
           adf.mf.api.invokeMethod(ElUtil.TASK_FLOW_UTILITIES, "handleTaskFlowCall",
                                   pushPageFlowScope, pushDataControlContext, pushSuccess, failCallback);                      
        }
      }
   }

   
    /**
    *  Pop the current pageFlowScope instance and data control context, if needed.
    *  This methods marks the end of the scope's lifespan.
    */
   ElUtil.popScopesIfNeeded = function(/* boolean */ popPageFlowScope, /* boolean */ popDataControlContext,
                                       /* function */ successCallback, /* function */ failCallback) 
   {
      var popSucceeded = true;
      var popSuccess = function(req, status)
      {
         popSucceeded = status;
         
         if (popSucceeded)
         {
           if (popPageFlowScope)
           {
              // Clear out the cache of the page flow scope to ensure that we have a clean scope
              adf.mf.internal.context.getVariableMapper().setVariable("pageFlowScope", {});
           }
           successCallback();
         }
         else
         {
           var msg = "Data control context stack is empty.";
           adfc.internal.LogUtil.severe(msg);
           if (adfc.internal.ElUtil.useMockContext())
           {
             adfc.internal.LogUtil.showAlert(msg);
           }
           else
           {
             adf.mf.api.amx.addMessage("severe", msg, null, null);    
           } 
           failCallback(message);
         }
      }
      if (!(popPageFlowScope || popDataControlContext))
      {
        successCallback();
      }
      else
      {
         if (adfc.internal.ElUtil.useMockContext())
         {
           if (popPageFlowScope)
           {
              adfc.internal.LogUtil.fine("popping page flow scope");
           }
           if (popDataControlContext)
           {
             adfc.internal.LogUtil.fine("popping data control context");
           }
           successCallback();
        }
        else
        {  
           adf.mf.api.invokeMethod(ElUtil.TASK_FLOW_UTILITIES, "handleTaskFlowReturn",
                                   popPageFlowScope, popDataControlContext, popSuccess, failCallback);
         }
      }
   }
   
   ElUtil.setMfContextInstance = function(viewHistoryItem, newInstance)
   {
      if ((typeof adf.mf.internal.useNavHandlerViewHistory !== "undefined") && adf.mf.internal.useNavHandlerViewHistory)
      {
         if (typeof adf.mf.internal.amx !== "undefined")
         {
            if (typeof adf.mf.internal.amx.setMfContextInstance !== "undefined")
            {
               if (adfc.internal.LogUtil.isFine())
               {
                  adfc.internal.LogUtil.fine("ADFc: setting MfContextInstance, newInstance=" + newInstance + ".");
               }
               adf.mf.internal.amx.setMfContextInstance(viewHistoryItem, newInstance);
            }
         }
      }
   }
   
   ElUtil.removeMfContextInstance = function(viewHistoryItem)
   {
      if ((typeof adf.mf.internal.useNavHandlerViewHistory !== "undefined") && adf.mf.internal.useNavHandlerViewHistory)
      {
         if (typeof adf.mf.internal.amx !== "undefined")
         {
            if (typeof adf.mf.internal.amx.removeMfContextInstance !== "undefined")
            {
               if (adfc.internal.LogUtil.isFine())
               {
                  adfc.internal.LogUtil.fine("ADFc: removing MfContextInstance.");
               }
               adf.mf.internal.amx.removeMfContextInstance(viewHistoryItem);
            }
         }
      }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/ElUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowDefinitionXmlParser.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

adfc.internal.TaskFlowDefinitionXmlParser = {};
adfc.internal.TaskFlowDefinitionXmlParser.parse = function(docPath, document, tfNode)
{
   var result = null;
   if (tfNode)
   {
      var taskFlowId = null;
      var defaultActivityId = null;
      var initializer = null;
      var finalizer = null;
      var inParams = new Array();
      var returnValues = new Array();
      var activities = new Array();
      var cfRules = new Array();
      var managedBeans = new Array();
      var pageFlowScopeBehavior = "preserve";

      //
      //  If the document path is non-null then get the ID attribute from the
      //  task flow node and construct a taskFlowId.  If the document path is
      //  null then this is the unbounded flow and the taskFlowId should be null.
      //
      if (docPath != null)
      {
         var tfIdStr = tfNode.attributes.getNamedItem("id").nodeValue;
         taskFlowId = new adfc.internal.TaskFlowId(docPath, tfIdStr);
      }

      //
      //  Iterate over the children parsing as we go.
      //
      var children = tfNode.childNodes;
      for (var i = 0; i < children.length; i++)
      {
         var node = children.item(i);
         var nodeName = node.localName;
         var obj = null;
         if (nodeName)
         {
            if (nodeName == "default-activity")
            {
               var defActivityLocalId = adfc.internal.XmlUtil.getNodeText(node);
               defaultActivityId = new adfc.internal.ActivityId(taskFlowId, defActivityLocalId);
            }
            else if (nodeName == "initializer")
            {
               initializer = adfc.internal.XmlUtil.getNodeText(node);
            }
            else if (nodeName == "finalizer")
            {
               finalizer = adfc.internal.XmlUtil.getNodeText(node);
            }
            else if (nodeName == "input-parameter-definition")
            {
               obj = adfc.internal.TaskFlowInputParameterXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  inParams.push(obj);
               }
            }
            else if (nodeName == "return-value-definition")
            {
               obj = adfc.internal.TaskFlowInputParameterXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  returnValues.push(obj);
               }
            }
            else if ((nodeName == "view") || (nodeName == "router") ||
                     (nodeName == "method-call") || (nodeName == "task-flow-return") ||
                     (nodeName == "task-flow-call"))
            {
               obj = adfc.internal.ActivityXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  activities.push(obj);
               }
            }
            else if (nodeName == "control-flow-rule")
            {
               obj = adfc.internal.ControlFlowRuleXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  cfRules.push(obj);
               }
            }
            else if (nodeName == "managed-bean")
            {
               obj = adfc.internal.ManagedBeanDefinitionXmlParser.parse(docPath, taskFlowId, node);
               if (obj)
               {
                  managedBeans.push(obj);
               }
            }
            else if (nodeName == "page-flow-scope-behavior")
            {
               var pfsbChildren = node.childNodes;
               for (var j = 0, size = pfsbChildren.length; j < size; ++j)
               {
                  var childNode = pfsbChildren[j];
                  if (childNode.nodeType == 1 /*Node.ELEMENT_NODE*/)
                  {
                    if (childNode.localName == "push-new")
                    {
                       pageFlowScopeBehavior = "pushNew";
                       break;
                    }
                    else if (childNode.localName == "preserve")
                    {
                       pageFlowScopeBehavior = "preserve";
                       break;
                    }
                  }
               }
            }
         }
      }

      //
      //  Convert the activities array to a map keyed by local activityId.
      //
      var temp = activities;
      activities = new Object();
      for (var index in temp)
      {
         var activity = temp[index];
         activities[activity.getActivityId().getLocalActivityId()] = activity;
      }

      //
      //  Convert the control flow rules to a map keyed by the from activity's local ID.
      //
      temp = cfRules;
      cfRules = new Object();
      for (var index in temp)
      {
         var rule = temp[index];
         var fromId = rule.getFromActivityId().getLocalActivityId();
         var existingRule = cfRules[fromId];
         if (existingRule == null)
         {
            cfRules[rule.getFromActivityId().getLocalActivityId()] = rule;
         }
         else
         {
            existingRule.addControlFlowCases(rule.getControlFlowCases());
         }
      }

      result = new adfc.internal.TaskFlowDefinition(taskFlowId, defaultActivityId, initializer,
         finalizer, inParams, returnValues, activities, cfRules, managedBeans,
         pageFlowScopeBehavior);
   }
   return result;
}


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/xml/TaskFlowDefinitionXmlParser.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowRule.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow control flow rule.
    */
   adfc.internal.ControlFlowRule = ControlFlowRule;
   function ControlFlowRule(fromActivityId, controlFlowCases)
   {
      this.mFromActivityId = fromActivityId;
      this.mControlFlowCases = controlFlowCases;
   }

   ControlFlowRule.prototype.getFromActivityId = function()
   {
      return this.mFromActivityId;
   }

   ControlFlowRule.prototype.getControlFlowCases = function()
   {
      return this.mControlFlowCases;
   }
   
   ControlFlowRule.prototype.addControlFlowCases = function(cases)
   {
      if (cases != null)
      {
         for (var newIndex in cases)
         {
            var newCase = cases[newIndex];
            var outcome = newCase.getOutcome();
            var index = this.getControlFlowCaseIndex(outcome);
            if (index >= 0)
            {
               this.mControlFlowCases[index] = newCase;
            }
            else
            {
               this.mControlFlowCases.push(newCase)
            }
         }
      }
   }
   
   /**
    *  Get the control flow case for a specific outcome value.  If there is no matching case for the given outcome and a
    *  default case exists (null from-outcome) then we'll return the default
    */
   ControlFlowRule.prototype.getControlFlowCase = function(outcome)
   {
      var result = null;
      var index = this.getControlFlowCaseIndex(outcome);
      if (index >= 0)
      {
         result = this.mControlFlowCases[index];
      }
      return result;
   }

   ControlFlowRule.prototype.getControlFlowCaseIndex = function(outcome)
   {
      // ADFmf handles default control flow case logic slightly differently than bigADF.  All cases are stored in the 
      // same Array.  The default (if it exists) has a null Outcome, so while we're iterating over the cases we'll also 
      // attempt to find the default.  If we don't find an exact match, then return the default.
      
      var result = -1;
      for (var index in this.mControlFlowCases)
      {
         var cfCase = this.mControlFlowCases[index];
         var testOutcome = cfCase.getOutcome();
         if (testOutcome == outcome)
         {
            result = index;
            break;
         }
         if (testOutcome == null)
         {
            result = index;
            // we've found the default to use if we don't find an exact match.  Don't break here because we need to 
            // continue searching for an exact match
         }
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowRule.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ViewActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewActivityLogic = ViewActivityLogic;
   function ViewActivityLogic()
   {
   }
      
   ViewActivityLogic.prototype.execute = function(routingState, activity, successCallback, failCallback)
   {
      adfc.internal.LogUtil.perfLog("BEGIN: ViewActivityLogic.execute");
      routingState.setViewReached(true);
      routingState.setRoutingComplete(true);
      var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
      currentTaskFlowEntry.setViewReached(true);
      adfc.internal.LogUtil.perfLog("END: ViewActivityLogic.execute");
      successCallback(routingState);
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ViewActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowDefinition.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow definition.
    */
   adfc.internal.TaskFlowDefinition = TaskFlowDefinition;
   
   /*
    * Represents one of the possible page flow scope behavior settings for the task flow.
    */
   TaskFlowDefinition.PUSH_NEW = "pushNew";
   
   function TaskFlowDefinition(taskFlowId, defActId, initializer, finalizer, inParams, returnValues,
      activities, cfRules, beanDefs, pageFlowScopeBehavior)
   {
      //
      //  Initialize the fields.
      //
      this.mTaskFlowId = taskFlowId;
      this.mDefaultActivityId = defActId;
      this.mInitializer = initializer;
      this.mFinalizer = finalizer;
      this.mActivities = activities;
      this.mControlFlowRules = cfRules;
      this.mBeanDefinitions = beanDefs;
      this.mInputParams = inParams;
      this.mReturnValues = returnValues;
      this.mPageFlowScopeBehavior = pageFlowScopeBehavior;
   }

   TaskFlowDefinition.prototype.getTaskFlowId = function()
   {
      return this.mTaskFlowId;
   };

   TaskFlowDefinition.prototype.getControlFlowRules = function()
   {
      return this.mControlFlowRules;
   };

   TaskFlowDefinition.prototype.getActivities = function()
   {
      return this.mActivities;
   };

   TaskFlowDefinition.prototype.getDefaultActivityId = function()
   {
      return this.mDefaultActivityId;
   };

   TaskFlowDefinition.prototype.getInitializer = function()
   {
      return this.mInitializer;
   };

   TaskFlowDefinition.prototype.getFinalizer = function()
   {
      return this.mFinalizer;
   };

   TaskFlowDefinition.prototype.getInputParameters = function()
   {
      return this.mInputParams;
   };

   TaskFlowDefinition.prototype.getReturnValues = function()
   {
      return this.mReturnValues;
   };

   /**
    *  Returns an array of ManagedBeanDefinition objects.
    */
   TaskFlowDefinition.prototype.getBeanDefinitions = function()
   {
      return this.mBeanDefinitions;
   };

   /**
    * Get the page flow scope behavior. One of "pushNew" or "preserve".
    * @return {string} the page flow scope behavior
    */
   TaskFlowDefinition.prototype.getPageFlowScopeBehavior = function()
   {
      return this.mPageFlowScopeBehavior;
   };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowDefinition.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationResult.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};

(function(){

  adfc.NavigationResult = NavigationResult;

  /**
   * NavigationResult represents the results of navigation handling.
   */
  function NavigationResult(isNewViewId, isBackNav, viewId, vdlDocPath, transitionType, featureExited, isDifferentViewId)
  {
      this.mNewViewId = isNewViewId;
      this.mBackNavigation = isBackNav;
      this.mViewId = viewId;
      this.mVdlDocumentPath = vdlDocPath;
      this.mTransitionType = transitionType;
      this.mFeatureExited = featureExited;
      if (isDifferentViewId !== "undefined")
      {
        this.mDifferentViewId = isDifferentViewId;
      }
      else
      {
        this.mDifferentViewId = isNewViewId;
      }
  }
  
  /**
   * Did navigation result in a transition to a different viewId?  The difference between this
   * and the new viewId flag in that back navigation results in a transition to a different view,
   * but it's not a new view in the view history stack.
   * @return {Boolean} true if navigation resulted in a transition to
   * a different viewId, false if it didn't.
   * @export
   */
  NavigationResult.prototype.isDifferentViewId = function() 
  {
      return this.mDifferentViewId;
  }
  
  /**
   * Did navigation result in a transition to a new viewId?
   * @return {Boolean} true if navigation resulted in a transition to
   * a new viewId, false if it didn't.
   * @export
   */
  NavigationResult.prototype.isNewViewId = function() 
  {
      return this.mNewViewId;
  }
  
  /**
   * Was the navigation due to a "back-button" navigation?
   * @return {Boolean}
   * @export
   */
  NavigationResult.prototype.isBackNavigation = function()
  {
      return this.mBackNavigation;
  }

  /**
   * The new viewId or null if navigation did not transition to a new view.
   * @export
   */
  NavigationResult.prototype.getViewId = function()
  {
      return this.mViewId;
  }

  /**
   * The path to the new view's VDL document or null if navigation did not
   * transition to a new view.
   * @export
   */
  NavigationResult.prototype.getVdlDocumentPath = function()
  {
      return this.mVdlDocumentPath;
  }
  
  /**
   * The type of screen transition to use when displaying the new view or 
   * null if navigation did not transition to a new view.
   * @export
   */
  NavigationResult.prototype.getTransitionType = function()
  {
      return this.mTransitionType;
  }
  
  /**
   * @export
   */
  NavigationResult.prototype.isTaskFlowExited = function()
  {
      adfc.internal.LogUtil.warning("function adfc.NavigationResult.isTaskFlowExited() is deprecated, use adfc.NavigationResult.isFeatureExited() instead.");
      return this.isFeatureExited();
  }
  
  /**
   * Was the initial entry point task flow exited?
   * @export
   */
  NavigationResult.prototype.isFeatureExited = function()
  {
      return this.mTaskFlowExited;
  }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/NavigationResult.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallParameter.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a method-call activity parameter.
    */
   adfc.internal.MethodCallParameter = MethodCallParameter;
   function MethodCallParameter(type, valueExpression)
   {
      this.mType = type;
      this.mValueExpression = valueExpression;
   }
   
   MethodCallParameter.prototype.getType = function()
   {
      return this.mType;
   }
   
   MethodCallParameter.prototype.getValueExpression = function()
   {
      return this.mValueExpression;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallParameter.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowCase.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task flow control flow case.
    */
   adfc.internal.ControlFlowCase = ControlFlowCase;
   ControlFlowCase.DEFAULT_TRANSITION = "slide";
   function ControlFlowCase(outcome, guardCondition, toActivityId, transition)
   {
      this.mOutcome = outcome;
      this.mGuardCondition = guardCondition;
      this.mTargetActivityId = toActivityId;
      if (transition != null)
      {
         this.mTransition = transition;
      }
      else
      {
         this.mTransition = ControlFlowCase.DEFAULT_TRANSITION;
      }
   }

   ControlFlowCase.prototype.getOutcome = function()
   {
      return this.mOutcome;
   }

   ControlFlowCase.prototype.getGuardCondition = function()
   {
      return this.mGuardCondition;
   }

   ControlFlowCase.prototype.getTargetActivityId = function()
   {
      return this.mTargetActivityId;
   }

   ControlFlowCase.prototype.getTransition = function()
   {
      return this.mTransition;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/ControlFlowCase.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/XmlUtil.js///////////////////////////////////////

/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function()
{
  adfc.internal.XmlUtil = XmlUtil;
  function XmlUtil()
  {}

  /**
   * Loads an XML resource and returns it as a DOM.
   */
  XmlUtil.loadXmlFile = function(resourceName, callback)
  {
    var handler = function(xmlString)
      {
        var result = null;
        if ((xmlString != null) && (xmlString.length > 0))
        {
          var parser = new DOMParser();
          result = parser.parseFromString(xmlString, "text/xml");
        }
        else
        {
          adfc.internal.LogUtil.warning("failed to load XML for document: " + resourceName);
        }
        callback(result);
      };

    adf.mf.api.resourceFile._loadFileWithAjax(
      resourceName,
      true,
      function(responseText)
      {
        handler(responseText);
       },
      function()
      {
        handler(null);
      });
  };

  XmlUtil.getNodeText = function(node)
  {
    var result = null;
    if (node)
    {
      var children = node.childNodes;
      for (var i = 0; i < children.length; i++)
      {
        var child = children.item(i);
        if (child.nodeType == Node.TEXT_NODE)
        {
          result = child.nodeValue;
          break;
        }
      }
    }
    if (result && (result.length == 0))
    {
      result = null;
    }
    return result;
  };

  XmlUtil.isTaskFlowDocument = function(callback, path)
  {
    //
    //  Remove the '#' character from the path.
    //
    var index = path.indexOf('#');
    if (index > 0)
    {
       path = path.substring(0, index);
    }

    //
    //  Load the file content.
    //
    adf.mf.api.resourceFile._loadFileWithAjax(
      path,
      true,
      function(responseText)
      {
        //
        //  Look for the 'adfc-mobile-config' element/string.
        //
        var result = false;
        var content = responseText;
        if (content != null)
        {
          if (content.indexOf("adfc-mobile-config") > 0)
          {
            result = true;
          }
        }
        callback(result);
       },
      function()
      {
        throw new Error("failed to read entry point document " + path);
      });
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/XmlUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/AdfcContext.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.AdfcContext = AdfcContext;
   function AdfcContext()
   {
      this.mInitialized = false;
      this.mFinlized = false;
      this.mControllerState = null;
   }
   
   AdfcContext.initialize = function(successCallback, failCallback)
   {
      if (!this.mInitialized)
      {
         this.mInitialized = true;
         this.mControllerState = new adfc.internal.ControllerState();
         adfc.internal.MetadataService.loadBootstrapMetadata(successCallback, failCallback);
      }
   }
   
   AdfcContext.finalize = function()
   {
      this.mController = null;
      this.mFinlized = true;
   }
  
   AdfcContext.getControllerState = function()
   {
      if (!this.mInitialized)
      {
         throw new Error("ADFc: AdfcContext is not initialized.");
      }
      if (this.mFinalized)
      {
         throw new Error("ADFc: AdfcContext has already been finalized.");
      }
      return this.mControllerState;
   }
   
   /**
    * Allow re-setting to initial conditions for unit testing.
    */
   AdfcContext.reinitialize = function()
   {
      this.mInitialized = false;
      this.mFinlized = false;
      this.mControllerState = null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/AdfcContext.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/Util.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
adfc.Util = {};

(function(){

   /**
    * Adds the feature root prefix to a resource path located under the
    * feature's public_html directory.
    */
   adfc.Util.addFeatureRootPrefix = function(path)
   {
      var result = path;
      if (adf.FEATURE_ROOT != null)
      {
         result = adf.FEATURE_ROOT + "/public_html";
         if ((path != null) && (path.length > 0) && (path.charAt(0) != "/"))
         {
            result = result + "/";
         }
         result = result + path;
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adf/controller/Util.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ActivityLogic.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ActivityLogic = ActivityLogic;
   ActivityLogic.sImplementations = {};
   function ActivityLogic()
   {
   }
   
   ActivityLogic.getImplementation = function(type)
   {
      var result = this.sImplementations[type];
      if (!result)
      {
         if (type == adfc.internal.ActivityType.VIEW)
         {
            result = new adfc.internal.ViewActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.VIEW] = result;
         }
         else if (type == adfc.internal.ActivityType.ROUTER)
         {
            result = new adfc.internal.RouterActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.ROUTER] = result;
         }
         else if (type == adfc.internal.ActivityType.METHOD_CALL)
         {
            result = new adfc.internal.MethodCallActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.METHOD_CALL] = result;
         }
         else if (type == adfc.internal.ActivityType.TASK_FLOW_CALL)
         {
            result = new adfc.internal.TaskFlowCallActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.TASK_FLOW_CALL] = result;
         }
         else if (type == adfc.internal.ActivityType.TASK_FLOW_RETURN)
         {
            result = new adfc.internal.TaskFlowReturnActivityLogic();
            ActivityLogic.sImplementations[adfc.internal.ActivityType.TASK_FLOW_RETURN] = result;
         }
      }
      return result;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/activity/ActivityLogic.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/LogUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.LogUtil = LogUtil;
   
   adfc.internal.LogUtil.UseMockLog = (typeof adf === "undefined") || 
                                      (typeof adf.mf === "undefined") || 
                                      (typeof adf.mf.log === "undefined") || 
                                      (typeof adf.mf.log.Framework === "undefined");
   
   function LogUtil()
   {}
   
   LogUtil.LOG_LEVEL_FINE     =  0;
   LogUtil.LOG_LEVEL_INFO     =  1;
   LogUtil.LOG_LEVEL_WARNING  =  2;
   LogUtil.LOG_LEVEL_SEVERE   =  3;

   if (!adfc.internal.LogUtil.UseMockLog)
   {
      LogUtil.LOG_LEVEL_FINE     = adf.mf.log.level.FINE;
      LogUtil.LOG_LEVEL_INFO     = adf.mf.log.level.INFO;
      LogUtil.LOG_LEVEL_WARNING  = adf.mf.log.level.WARNING;
      LogUtil.LOG_LEVEL_SEVERE   = adf.mf.log.level.SEVERE;
   }
   
   LogUtil.currentMockLogLevel = LogUtil.LOG_LEVEL_FINE;
   
   LogUtil.severe = function(message) 
   {
      LogUtil.output("SEVERE", LogUtil.LOG_LEVEL_SEVERE, message);
   }
   
   LogUtil.warning = function(message) 
   {
      LogUtil.output("WARNING", LogUtil.LOG_LEVEL_WARNING, message);
   }
   
   LogUtil.info = function(message) 
   {
      LogUtil.output("INFO", LogUtil.LOG_LEVEL_INFO, message);
   }
   
   LogUtil.fine = function(message) 
   {
      LogUtil.output("FINE", LogUtil.LOG_LEVEL_FINE, message);
   }
   
   LogUtil.showAlert = function(message)
   {
      if (message != null)
      {
         alert(message);
      }
   }
   
   LogUtil.output = function(prefix, level, message)
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          if ((message != null) && (level >= LogUtil.currentMockLogLevel))
          {
             var text = "[ADFc:" + prefix + "] " + LogUtil.formatMessage(message);
             console.log(text);
          }
       }
       else
       {
          var label = "ADFc";
          if (level == LogUtil.LOG_LEVEL_FINE)
          {
             label = "==== ADFc DEBUG ====";
          }
          adf.mf.log.Framework.logp(level, label, "--", message);
       }
   }

   LogUtil.formatMessage = function(message) 
   {
      var text = message;
      if (!(text instanceof String))
      {
        text = new String(message);
      }
      if (text.indexOf("ADFc:") != 0)
      {
        text = "ADFc: " + text;
      }
      return text;
   }
   
   LogUtil.perfLog = function(message)
   {
      if (!adfc.internal.LogUtil.UseMockLog)
      {
         adf.mf.internal.perf.perfTimings(false, false, true, message);
      }
   }
   
   LogUtil.isSevere = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_SEVERE);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_SEVERE);
       }
   }
   
   LogUtil.isWarning = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_WARNING);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_WARNING);
       }
   }
   
   LogUtil.isInfo = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_INFO);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_INFO);
       }
   }
   
   LogUtil.isFine = function() 
   {
       if (adfc.internal.LogUtil.UseMockLog)
       {
          return (LogUtil.currentMockLogLevel >= LogUtil.LOG_LEVEL_FINE);
       }
       else
       {
          return adf.mf.log.Framework.isLoggable(LogUtil.LOG_LEVEL_FINE);
       }
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/LogUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/MsgUtil.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    *  Central location for getting localized text strings.
    */
   adfc.internal.MsgUtil = MsgUtil;
   function MsgUtil()
   {}
   MsgUtil.messages = {};
   
   MsgUtil.getLocalizedText = function(msgId)
   {
      var msg = "<bad message ID>";
      if (typeof MsgUtil.messages[msgId] !== "undefined")
      {
         msg = MsgUtil.messages[msgId];
      }
      return msg;
   }
   
   MsgUtil.NO_FEATURE_ENTRY_POINT = 0;
   MsgUtil.messages[MsgUtil.NO_FEATURE_ENTRY_POINT] = "no feature entry point path found on URL";
   

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/MsgUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/TaskFlowIdUtil.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.TaskFlowIdUtil = TaskFlowIdUtil;

   function TaskFlowIdUtil()
   {}
   
   TaskFlowIdUtil.parseTaskFlowId = function(taskFlowIdString)
   {
      if (taskFlowIdString && (taskFlowIdString != null))
      {
         var taskFlowId = adfc.internal.TaskFlowId.parse(taskFlowIdString);
         if (taskFlowId && (taskFlowId != null))
         {
            return taskFlowId;
         }
      }
      return null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/TaskFlowIdUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/RoutingState.js///////////////////////////////////////

/**
*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.RoutingState = RoutingState;
   function RoutingState(startingTfInstanceId, startingViewId, currentActivityId, currentOutcome)
   {
      this.mStartingTfInstanceId = startingTfInstanceId;
      this.mStartingViewId = startingViewId;
      this.mStartingActivityId = currentActivityId;
      this.mCurrentActivityId = currentActivityId;
      this.mCurrentOutcome = currentOutcome;
      this.mNextActivityId = null;
      this.mRoutingComplete = false;
      this.mViewReached = false;
      this.mBackNavigation = false;
      this.mTaskFlowReturnExecuted = false;
      this.mTransition = null;
      this.mControlFlowCase = null;
      this.mTriedCfRules = {};
      
      this.mNavigationResult = null;
      
      this.mRoutingSuccessCallback = null;
      this.mRoutingFailedCallback = null;
      this.mFindCfCaseCallback = null;
      
      this.mBackNavTfPopped = false;  //  If back nav out of a TF has the TF been popped yet?
      this.mBackNavTfLeftViewItem = null;  //  If back nav out of a TF the view item being left.
      
      this.mLastReturnedFromTfEntry = null;  // Stack entry popped during the last TF return activity.
   }

   RoutingState.prototype.getStartingTaskFlowInstanceId = function()
   {
      return this.mStartingTfInstanceId;
   }
   
   RoutingState.prototype.getStartingViewId = function()
   {
      return this.mStartingViewId;
   }
   
   RoutingState.prototype.getStartingActivityId = function()
   {
      return this.mStartingActivityId;
   }
   
   RoutingState.prototype.getCurrentActivityId = function()
   {
      return this.mCurrentActivityId;
   }
   
   RoutingState.prototype.setCurrentActivityId = function(activityId)
   {
      this.mCurrentActivityId = activityId;
   }
   
   RoutingState.prototype.getCurrentOutcome = function()
   {
      return this.mCurrentOutcome;
   }
   
   RoutingState.prototype.setCurrentOutcome = function(outcome)
   {
      this.mCurrentOutcome = outcome;
   }
   
   RoutingState.prototype.getNextActivityId = function()
   {
      return this.mNextActivityId;
   }
   
   RoutingState.prototype.setNextActivityId = function(activityId)
   {
      this.mNextActivityId = activityId;
   }
   
   RoutingState.prototype.isRoutingComplete = function()
   {
      return this.mRoutingComplete;
   }
   
   RoutingState.prototype.setRoutingComplete = function(value)
   {
      this.mRoutingComplete = value;
   }
   
   RoutingState.prototype.isViewReached = function()
   {
      return this.mViewReached;
   }
   
   RoutingState.prototype.setViewReached = function(value)
   {
      this.mViewReached = value;
   }
   
   RoutingState.prototype.setNavigationResult = function(result)
   {
      this.mNavigationResult = result;
   }
   
   RoutingState.prototype.getNavigationResult = function()
   {
      return this.mNavigationResult;
   }
   
   RoutingState.prototype.setRoutingSuccessCallback = function(callback)
   {
      this.mRoutingSuccessCallback = callback;
   }
   
   RoutingState.prototype.getRoutingSuccessCallback = function()
   {
      return this.mRoutingSuccessCallback;
   }
   
   RoutingState.prototype.setRoutingFailedCallback = function(callback)
   {
      this.mRoutingFailedCallback = callback;
   }
   
   RoutingState.prototype.getRoutingFailedCallback = function()
   {
      return this.mRoutingFailedCallback;
   }
   
   RoutingState.prototype.setBackNavigation = function(value)
   {
      this.mBackNavigation = value;
   }
   
   RoutingState.prototype.getBackNavigation = function()
   {
      return this.mBackNavigation;
   }
   
   RoutingState.prototype.setTaskFlowReturnExecuted = function(value) 
   {
      this.mTaskFlowReturnExecuted = value;
   }
   
   RoutingState.prototype.isTaskFlowReturnExecuted = function() 
   {
      return this.mTaskFlowReturnExecuted;
   }
   
   RoutingState.prototype.setTransition = function(value) 
   {
      this.mTransition = value;
   }
   
   RoutingState.prototype.getTransition = function() 
   {
      return this.mTransition;
   }
   
   RoutingState.prototype.setFindCfCaseCallback = function(callback) 
   {
      this.mFindCfCaseCallback = callback;
   }
   
   RoutingState.prototype.getFindCfCaseCallback = function() 
   {
      return this.mFindCfCaseCallback;
   }
   
   RoutingState.prototype.setControlFlowCase = function(cfCase) 
   {
      this.mControlFlowCase = cfCase;
   }
   
   RoutingState.prototype.getControlFlowCase = function() 
   {
      return this.mControlFlowCase;
   }
   
   RoutingState.prototype.getTriedCfRules = function() 
   {
      return this.mTriedCfRules;
   }

   RoutingState.prototype.isBackNavTfPopped = function() 
   {
      return this.mBackNavTfPopped;
   }

   RoutingState.prototype.setBackNavTfPopped = function(value) 
   {
      this.mBackNavTfPopped = value;
   }

   RoutingState.prototype.setBackNavTfLeftViewItem = function(item) 
   {
      this.mBackNavTfLeftViewItem = item;
   }
   
   RoutingState.prototype.getBackNavTfLeftViewItem = function() 
   {
      return this.mBackNavTfLeftViewItem;
   }

   RoutingState.prototype.setLastReturnedFromTfEntry = function(entry) 
   {
      this.mLastReturnedFromTfEntry = entry;
   }
   
   RoutingState.prototype.getLastReturnedFromTfEntry = function() 
   {
      return this.mLastReturnedFromTfEntry;
   }

   /**
    * Reset the routing state before control flow rule evaluation.
    */
   RoutingState.prototype.resetCfRuleEvaluation = function() 
   {
      this.mTriedCfRules = {};
      this.mControlFlowCase = null;
   }
   
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/engine/RoutingState.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallActivity.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a method-call activity.
    */
   adfc.internal.MethodCallActivity = MethodCallActivity;
   function MethodCallActivity(id, methodEl, defaultOutcome, convertToString, params, returnValue)
   {
      this.mActivityId = id;
      this.mMethodElExpression = methodEl;
      this.mDefaultOutcome = defaultOutcome;
      this.mConvertToString = convertToString;
      this.mParameters = params;
      this.mReturnValue = returnValue;
   }
  
   MethodCallActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.METHOD_CALL;
   }
  
   MethodCallActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   MethodCallActivity.prototype.getMethodElExpression = function()
   {
      return this.mMethodElExpression;
   }
   
   MethodCallActivity.prototype.getDefaultOutcome = function()
   {
      return this.mDefaultOutcome;
   }
   
   MethodCallActivity.prototype.isConvertToString = function()
   {
      return this.mConvertToString;
   }
   
   MethodCallActivity.prototype.getParameters = function()
   {
      return this.mParameters;
   }
   
   MethodCallActivity.prototype.getReturnValue = function()
   {
      return this.mReturnValue;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/MethodCallActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ControllerState.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ControllerState = ControllerState;
   function ControllerState()
   {
      this.mTaskFlowStack = new Array();
   }

   ControllerState.prototype.getTaskFlowStackSize = function()
   {
      var result = this.mTaskFlowStack.length;
      return result;
   }

   ControllerState.prototype.peekTaskFlowStack = function()
   {
      var result = this.mTaskFlowStack[this.mTaskFlowStack.length-1];
      return result;
   }

   ControllerState.prototype.pushTaskFlow = function(taskFlow, taskFlowCallActivity, callingViewActivityId, successCallback, failCallback)
   {
      var pushScopeSuccess = function()
      {
        var updateBeanDefsSuccess = function()
        {
          if (adfc.internal.LogUtil.isFine())
          {
             var currentTaskFlowEntry = adfc.internal.AdfcContext.getControllerState().peekTaskFlowStack();
             currentTaskFlowEntry.getTaskFlowDefinition(
               function(taskFlowDef)
               {
                 var tfId = taskFlowDef.getTaskFlowId();
                 var instanceId = currentTaskFlowEntry.getInstanceId();
                 var msg = "ADFc: pushed task flow, taskFlowId=" + tfId + ", instanceId=" + instanceId;
                 adfc.internal.LogUtil.fine(msg);
               });
          }
          successCallback();
        }

        var updateBeanDefsFailed = function(message)
        {
          var msg = "Failed to set managed bean definitions.";
          adfc.internal.LogUtil.severe(msg);
          adfc.internal.LogUtil.showAlert(msg);
          failCallback(message);
        }

        var controllerState = adfc.internal.AdfcContext.getControllerState();
        controllerState.mTaskFlowStack.push(new adfc.internal.TaskFlowStackEntry(taskFlow.getTaskFlowId(), taskFlowCallActivity, callingViewActivityId, 
                                            pushPageFlowScope, pushDataControlContext));
        controllerState.updateBeanDefinitions(updateBeanDefsSuccess, updateBeanDefsFailed);
      }

      var pushPageFlowScope = (taskFlow.getPageFlowScopeBehavior() == adfc.internal.TaskFlowDefinition.PUSH_NEW);
      var pushDataControlContext = ((taskFlowCallActivity != null) && 
                                    adfc.internal.TaskFlowCallActivityLogic.isDataControlContextIsolated(taskFlowCallActivity, failCallback));
                                    
      adfc.internal.ElUtil.pushScopesIfNeeded(pushPageFlowScope, pushDataControlContext, pushScopeSuccess, failCallback);
   };

   ControllerState.prototype.popTaskFlow = function(successCallback, failCallback)
   {
      var controllerState = adfc.internal.AdfcContext.getControllerState();
      var tfStackEntry = null;

      var popScopeSuccess = function()
      {
         var updateBeanDefsSuccess = function()
         {
            if (adfc.internal.LogUtil.isFine())
            {
              tfStackEntry.getTaskFlowDefinition(
               function(taskFlowDef)
               {
                 var tfId = taskFlowDef.getTaskFlowId();
                 var instanceId = tfStackEntry.getInstanceId();
                 var msg = "ADFc: popped task flow, taskFlowId=" + tfId + ", instanceId=" + instanceId;
                 adfc.internal.LogUtil.fine(msg);
               });
            }
            tfStackEntry.clearViewHistory();
            successCallback(tfStackEntry);
         }
         var updateBeanDefsFailed = function(message)
         {
            var msg = "Failed to set managed bean definitions.";
            adfc.internal.LogUtil.severe(msg);
            adfc.internal.LogUtil.showAlert(msg);
            failCallback(message);
         }

         tfStackEntry = controllerState.mTaskFlowStack.pop();
         controllerState.updateBeanDefinitions(updateBeanDefsSuccess, updateBeanDefsFailed);
      }

      var currentTaskFlowEntry = controllerState.peekTaskFlowStack();
      var popPageFlowScope = currentTaskFlowEntry.shouldPopPageFlowScope();
      var popDataControlContext = currentTaskFlowEntry.shouldPopDataControlContext();
                                    
      adfc.internal.ElUtil.popScopesIfNeeded(popPageFlowScope, popDataControlContext, popScopeSuccess, failCallback);
   };

  ControllerState.prototype.updateBeanDefinitions = function(successCallback, failCallback)
  {
    if (this.mTaskFlowStack.length > 1)
    {
      //
      //  If there's more than one task flow on the stack then we want to get
      //  the application scoped bean definitions from the unbounded flow
      //  and then add in the definitions from the current top of the stack.
      //
      var beanDefs = new Array();
      var controllerState = this;
      this.mTaskFlowStack[0].getTaskFlowDefinition(
        function(unboundedTaskFlowDef)
        {
          var unboundedBeans = unboundedTaskFlowDef.getBeanDefinitions();
          for (var i = 0; i < unboundedBeans.length; i++)
          {
            if (unboundedBeans[i].getBeanScope() == adfc.internal.ManagedBeanDefinition.APPLICATION)
            {
              beanDefs.push(unboundedBeans[i]);
            }
          }

          //
          //  Add in the bean definitions from the current top of stack.
          //
          controllerState.mTaskFlowStack[controllerState.mTaskFlowStack.length-1].getTaskFlowDefinition(
            function(topTaskFlowDef)
            {
              var tfBeans = topTaskFlowDef.getBeanDefinitions();
              beanDefs = beanDefs.concat(tfBeans);
              ControllerState._updateBeanDefinitionsPhase2(
                beanDefs,
                successCallback,
                failCallback);
            });
        });
    }
    else if (this.mTaskFlowStack.length == 1)
    {
      this.mTaskFlowStack[0].getTaskFlowDefinition(
        function(taskFlowDef)
        {
          ControllerState._updateBeanDefinitionsPhase2(
            taskFlowDef.getBeanDefinitions(),
            successCallback,
            failCallback);
        });
    }
    else
    {
      ControllerState._updateBeanDefinitionsPhase2(
        new Array(),
        successCallback,
        failCallback);
    }
  };

  ControllerState._updateBeanDefinitionsPhase2 = function(beanDefs, successCallback, failCallback)
  {
    var setBeanDefsSuccess = function()
    {
      successCallback();
    }

    var setBeanDefsFailed = function(message)
    {
      failCallback(message);
    }

    adfc.internal.ElUtil.setBeanDefinitions(beanDefs, setBeanDefsSuccess, setBeanDefsFailed);
  };

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ControllerState.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ViewHistoryItem.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.ViewHistoryItem = ViewHistoryItem;
   function ViewHistoryItem(viewId, amxPage, transType)
   {
      this.itemId = adfc.internal.IdUtil.uuid(); // Unique item ID.
      this.viewId = viewId;
      this.amxPage = amxPage;
      this.transitionType = transType;
      this.mBackNavIsValid = true;    // To signal cases where back navigation is not valid.
   }
   
   ViewHistoryItem.prototype.isBackNavigationValid = function()
   {
      return this.mBackNavIsValid;
   }
   
   ViewHistoryItem.prototype.setBackNavigationValid = function(value)
   {
      this.mBackNavIsValid = value;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/state/ViewHistoryItem.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/SystemUtil.js///////////////////////////////////////

/*
* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   adfc.internal.SystemUtil = SystemUtil;
   function SystemUtil()
   {}
   
   /**
    * Hides the loading indicator
    */
   SystemUtil.hideLoadingIndicator = function()
   {
      adf.mf.api.amx.hideLoadingIndicator();
   };
   
   /**
    * Optionally performs platform-specific system back action handling
    *
    * @returns true if the action was handled, false otherwise
    */
   SystemUtil.onBackUnhandled = function()
   {
      if (adf.mf.internal.amx.agent["type"] == "Android")
      {
        if (window && window["AdfmfCallback"])
        {
          window.AdfmfCallback.onBackUnhandled();
          return true;
        }
      }
      
      return false;
   };
})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/util/SystemUtil.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallActivity.js///////////////////////////////////////

/*
* Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
 */
 
if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a task-flow-call activity.
    */
   adfc.internal.TaskFlowCallActivity = TaskFlowCallActivity;
   function TaskFlowCallActivity(id, taskFlowReference, dynamicTaskFlowIdElExpression, inputParams, inputParamMapElExpression, returnValues, beforeListener, afterListener, dcContext)
   {
      this.mActivityId = id;
      this.mTaskFlowReference = taskFlowReference;
      this.mDynamicTaskFlowIdElExpression = dynamicTaskFlowIdElExpression;
      this.mIsDynamic = dynamicTaskFlowIdElExpression != null;
      this.mInputParameters = inputParams;
      this.mInputParameterMapElExpression = inputParamMapElExpression;
      this.mReturnValues = returnValues;
      this.mBeforeListener = beforeListener;
      this.mAfterListener = afterListener;
      this.mDCContext = dcContext;
   }
    
   TaskFlowCallActivity.prototype.getActivityType = function()
   {
      return adfc.internal.ActivityType.TASK_FLOW_CALL;
   }
    
   TaskFlowCallActivity.prototype.getActivityId = function() 
   {
      return this.mActivityId;
   }
   
   TaskFlowCallActivity.prototype.getTaskFlowReference = function() 
   {
      return this.mTaskFlowReference;
   }
   
   TaskFlowCallActivity.prototype.isDynamic = function() 
   {
      return this.mIsDynamic;
   }
   
   TaskFlowCallActivity.prototype.getDynamicTaskFlowIdElExpression = function() 
   {
      return this.mDynamicTaskFlowIdElExpression;
   }
   
   TaskFlowCallActivity.prototype.getInputParameters = function() 
   {
      return this.mInputParameters;
   }
   
   TaskFlowCallActivity.prototype.getInputParameterMapElExpression = function() 
   {
      return this.mInputParameterMapElExpression;
   }
   
   TaskFlowCallActivity.prototype.getReturnValues = function()
   {
      return this.mReturnValues;
   }
   
   TaskFlowCallActivity.prototype.getBeforeListener = function()
   {
      return this.mBeforeListener;
   }
   
   TaskFlowCallActivity.prototype.getAfterListener = function()
   {
      return this.mAfterListener;
   }
   
   TaskFlowCallActivity.prototype.getDataControlContextType = function()
   {
      return this.mDCContext;
   }
   
})();

/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/TaskFlowCallActivity.js///////////////////////////////////////



/////////////////////////////////////// start of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterCase.js///////////////////////////////////////

/*
* Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved. 
 */

if (!window.adfc) window.adfc = {};
if (!adfc.internal) adfc.internal = {};

(function(){

   /**
    * Represents a router activity case.
    */
   adfc.internal.RouterCase = RouterCase;
   function RouterCase(expression, outcome)
   {
      this.mExpression = expression;
      this.mOutcome = outcome;
   }

   RouterCase.prototype.getExpression = function()
   {
      return this.mExpression;
   }
  
   RouterCase.prototype.getOutcome = function()
   {
      return this.mOutcome;
   }

})();


/////////////////////////////////////// end of /Volumes/MAF/JenkinsArchive/workspace/MAF-v2.3.2.0.0-And-iOS/Container/JavaScript/Controller/js/oracle/adfinternal/controller/metadata/model/RouterCase.js///////////////////////////////////////

/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------------- */
/* ------------------- base-controller.js ---------------------- */
/* ------------------------------------------------------------- */

// ===========================================================================
// ======= Any touching of this file must have architectural approval. =======
// ===========================================================================

// Let the controller know about the feature root (since adfc-mobile.js re-initializes it to false):
//adf.FEATURE_ROOT =

// Let the controller know about the DT mode (since adfc-mobile.js re-initializes it to false):
adf.AMX_DTMODE = adf.mf.environment.profile.dtMode;

// Initialize the Trinidad library.
if (!adf.mf.environment.profile.dtMode)
{
  // TODO should this be skipped for mock mode too?
  adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
    "base-controller.js", "init", "Loading trinidad lib");

  if (adf.mf.environment.profile.messageBundleBaseUrl != null)
    adf.mf.api.amx.loadTrinidadResources(adf.mf.environment.profile.messageBundleBaseUrl); // defined in amx-resource.js
  else
    adf.mf.api.amx.loadTrinidadResources("js"); // defined in amx-resource.js
}

// PRIVATE FUNCTION USED ONLY BY THIS FILE
function getFeatureRoot()
{
  var queryString = adf.mf.api.getQueryString();
  var featureRoot = adfc.internal.UrlUtil.getFeatureRoot(queryString);
  adf.FEATURE_ROOT = featureRoot; // this variable is used by adfc-mobile.js
  if (featureRoot == null)
  {
    adfc.internal.LogUtil.fine("no feature root specified");
  }
  else
  {
    adfc.internal.LogUtil.fine("using feature root of: " + featureRoot);
  }
}

// PRIVATE FUNCTION USED ONLY BY THIS FILE
function getEntryPointDocumentPath()
{
  var queryString = adf.mf.api.getQueryString();
  var path = adfc.internal.UrlUtil.getEntryPointDocumentPath(queryString);
  if (path == null)
  {
    var msg = adfc.internal.MsgUtil.getLocalizedText(adfc.internal.MsgUtil.NO_FEATURE_ENTRY_POINT);
    adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(msg));
    throw new Error(msg);
  }
  return path;
}

// PRIVATE FUNCTION USED ONLY BY base-core.js
adf.mf.internal.api.showFirstAmxPage = function()
{
  adfc.internal.LogUtil.fine("BEGIN: showFirstAmxPage()");

  adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
    "adf.mf.internal.api", "showFirstAmxPage", "document ready event received");
  adfc.internal.LogUtil.fine("document.ready event received");

  // Get the feature root from the URL if there's one there.
  getFeatureRoot();

  var AdfcContextInitSuccess = function()
  {
    adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
      "adf.mf.internal.api", "showFirstAmxPage", "END: initialize AdfcContext");

     // Get the entry point document.
     var entryDocPath = getEntryPointDocumentPath();
     adfc.internal.LogUtil.fine("entryDocPath=" + entryDocPath);

     // Get the initial view to display.
     var request = {};
     request.entryPoint = entryDocPath;
     var navigationSuccess = function(req, response)
     {
       adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "END: determine first viewId");
       if (response.isNewViewId())
       {
         var amxPage = response.getVdlDocumentPath();
         var displayAmxDone = function()
         {
           adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
             "adf.mf.internal.api", "showFirstAmxPage", "END: display first AMX page");
         };
         adfc.internal.LogUtil.fine("displaying initial view, page=" + amxPage);

         adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
           "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: display firxt AMX page");
         adf.mf.api.amx.displayAmxPage(amxPage).then(displayAmxDone);
       }
       else
       {
         var msg = "failed to determine initial view to display";
         adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(msg));
         throw new Error(msg);
       }
     };

     var navigationFailed = function (req, message)
     {
       adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(message));
       throw new Error(message);
     };

     if (!adf.mf.environment.profile.dtMode)
     {
       adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: determine first viewId");
       adfc.NavigationHandler.getInitialViewId(request, navigationSuccess, navigationFailed);
     }
     else
     {
       // AMX DT mode.
       var navResponse = new adfc.NavigationResult(true, false, entryDocPath, entryDocPath, "", false, true);
       navigationSuccess(request, navResponse);
     }
  }; // End AdfcContextInitSuccess() callback function

  var AdfcContextInitFailed = function(message)
  {
    adfc.internal.LogUtil.showAlert("Failed to initialize the AdfcContext: " + adf.mf.internal.log.getStringifedIfNeeded(message));
  }

  // Load the bootstrap metadata.
  try
  {
    if (!adf.mf.environment.profile.dtMode)
    {
      // Not design-time mode.
      adfc.internal.LogUtil.fine("initializing the AdfcContext ...");
      adf.mf.log.Framework.logp(adf.mf.log.level.FINEST,
        "adf.mf.internal.api", "showFirstAmxPage", "BEGIN: initialize AdfcContext");
      adfc.internal.AdfcContext.initialize(AdfcContextInitSuccess, AdfcContextInitFailed);
    }
    else
    {
      // We're running in design-time mode.
      AdfcContextInitSuccess();
    }
  }
  catch (exp)
  {
    adfc.internal.LogUtil.showAlert(adf.mf.internal.log.getStringifedIfNeeded(exp.message));
    throw exp;
  }
} // End of showFirstAmxPage() function.
/* Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved. */
/*
 *
 * ADF Mobile v1.1 (iOS and Android)
 *
 * http://www.oracle.com/technetwork/developer-tools/adf/overview/adf-mobile-096323.html
 *
 * Copyright (c) 2011 Oracle.
 * All rights reserved.
 *
 */

try
{
    /* Helper code to resolve anonymous callback functions,

    If the function callback can be resolved by name it is returned unaltered.
    If the function is defined in an unknown scope and can't be resolved, an internal reference to the function is added to the internal map.

    Callbacks added to the map are one time use only, they will be deleted once called.

    example 1:
    function myCallback(){};
    fString = GetFunctionName(myCallback);
    - result, the function is defined in the global scope, and will be returned as is because it can be resolved by name.

    example 2:
    fString = GetFunctionName(function(){};);
    - result, the function is defined in place, so it will be returned unchanged.

    example 3:
    function myMethod()
    {
        var funk = function(){};
        fString = GetFunctionName(funk);
    }
    - result, the function CANNOT be resolved by name, so an internal reference wrapper is created and returned.
    */
   window._anomFunkMap = window._anomFunkMap || {};
   window._anomFunkMapNextId = window._anomFunkMapNextId || 0;

   window.anomToNameFunk = window.anomToNameFunk || function(fun)
   {
      var funkId = "f" + _anomFunkMapNextId++;
      var funk = function()
      {
         fun.apply(this,arguments);
         _anomFunkMap[funkId] = null;
         delete _anomFunkMap[funkId];
      }
      _anomFunkMap[funkId] = funk;

      return "_anomFunkMap." + funkId;
   };

   window.GetFunctionName = window.GetFunctionName || function(fn)
   {
      if (typeof fn === "function") {
         var name= fn.name;
         if (!name) {
            var m = fn.toString().match(/^\s*function\s+([^\s\(]+)/);
            name= m && m[1];
         }
         if (name && (window[name] === fn)) {
            return name;
         } else {
            return anomToNameFunk(fn);
         }
      }else {
         return null;
      }
   };

   // Page level API 'namespace' objects - 'window' is the same as
   // using 'var adf;'...
   window.adf = window.adf || {};
   window.adf.mf = window.adf.mf || {};
   window.adf.mf.internal = window.adf.mf.internal || {};
   window.adf.mf.internal.di = window.adf.mf.internal.di || {};
   window.adf.mf.internal.di.api = window.adf.mf.internal.di.api || {};
   window.getAdfmfApiRoot = function()
   {
      return adf.mf.internal.di.api;
   }
   // Location for all the adf.pg functions is container.internal.device.integration
   window.container = window.container || {};
   window.container.internal = window.container.internal || {};
   window.container.internal.device = window.container.internal.device || {};
   window.container.internal.device.integration = window.container.internal.device.integration || {};
   window.containerInternalRoot = window.containerInternalRoot || function()
   {
      return container.internal.device.integration;
   }
   window.containerInternalRootDescription = window.containerInternalRootDescription || function()
   {
      return "container.internal.device.integration";
   }
   containerInternalRoot().getAdfmfPhoneGap = containerInternalRoot().getAdfmfPhoneGap || function ()
   {
      if(typeof(cordova) == 'undefined')
      {
         alert("cordova is undefined.");
         return null;
      }
      return cordova;
   }

   /**
    * The 'adf.pg' varable is used to denote that we are running on a phonegap device and
    *        the user interface layer should act appropriately.
    */
   window.adf.pg = "RUNNING ON A PHONEGAP DEVICE";

   /**
    * Gets the AMX Includes specified for this feature.
    */
   containerInternalRoot().getAmxIncludeList = function(successCB, failureCB)
   {
      var cordovaRequest = new CordovaRequest({params:[]},
                                              function(request, result){ successCB(result) },
                                              failureCB);
      cordovaRequest.setPlugin("ADFMobileShell");
      cordovaRequest.setMethod("getAmxIncludeList");
      cordovaRequest.execute();
   };

   /**
    * Represents the API for interacting with features in the ADF Mobile Container.
    */
   window.ADFMobileFeatures = function()
   {
      this.inProgress = false;
      this.records = new Array();
      this.hideNavigationBar_errorCallback = null;
      this.showNavigationBar_errorCallback = null;
      this.registerActivationHandler_errorCallback = null;
   };

   /**
    * The method to register a function as a handler for activation notices.
    */
   ADFMobileFeatures.prototype.registerActivationHandler = function(scb, ecb)
   {
      // this is necessary until we fully move ADFMobileFeatures.m to use the passed-in ecb value
      this.registerActivationHandler_errorCallback = null;
      var bErrCallback = (ecb == undefined || ecb == null) ? false : true;
      if (bErrCallback)
      {
         this.registerActivationHandler_errorCallback = ecb;
      }

      // console.log("creating registerActivationHandler request");
      var cordovaRequest = new CordovaRequest({params:[window.GetFunctionName(scb)]}, function(){/* Don't Care about success. */}, ecb);
      cordovaRequest.setPlugin("ADFMobileFeatures");
      cordovaRequest.setMethod("registerActivationHandler");
      cordovaRequest.execute();
   };

   /**
    * Represents the API for interacting with the CVM in the ADF Mobile Native Framework.
    */
   window.ADFMobileJava = function()
   {
      this.inProgress = false;
      this.invokeJava_resultsCallback = null;
      this.invokeJava_errorCallback = null;
   };

   /**
    * The method to send a message into the VMChannel
    */
   ADFMobileJava.prototype.invoke = function(passedInMT, request, successCB, errorCB)
   {
      try
      {
         // console.log("creating ADFMobileJava.prototype.invoke request");
         var cordovaRequest = new CordovaRequest(request, successCB, errorCB);
         cordovaRequest.execute();
      }
      catch(e)
      {
         var msg = ("Error in ADFMobileJava.prototype.invoke - error=" + adf.mf.util.stringify(e) + " for request = " + adf.mf.util.stringify(request));

         alert(msg);

         adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "invoke",
               ("Error creating nd executing CordovaRequest error = " + msg));
      }
   };

   /**
    * Represents the API for interacting with regions in the ADF Mobile Container.
    */
   window.AdfmfSlidingWindowPlugIn =  window.AdfmfSlidingWindowPlugIn || function()
   {
   };

   /**
    * The method to create a sliding window
    * The success and failure callback methods have the signature function(request,result)
    * in the case of success the result object is the window identifier
    * in the case of failure the result object is a json map.  the error message can be obtained with result.description
    */
   AdfmfSlidingWindowPlugIn.prototype.create =    AdfmfSlidingWindowPlugIn.prototype.create ||  function(/* String */ featureId, success, failure)
   {
      var cordovaRequest = new CordovaRequest({params:[featureId]},success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("create");
      cordovaRequest.execute();
   };

 /**
    * The method to destroy a sliding window
    */
   AdfmfSlidingWindowPlugIn.prototype.destroy =    AdfmfSlidingWindowPlugIn.prototype.destroy || function(/* String */ windowId, success, failure)
   {
      var cordovaRequest = new CordovaRequest({params : [windowId]}, success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("destroy");
      cordovaRequest.execute();
   };

/**
    * The method to get the current window id for the webview this is called within.  Returns an empty string if the current
    web view was not created with the sliding window plugin
    */
   AdfmfSlidingWindowPlugIn.prototype.getCurrentWindowId =    AdfmfSlidingWindowPlugIn.prototype.getCurrentWindowId || function(success,failure)
   {
      var cordovaRequest = new CordovaRequest({params:[]}, success, failure);

      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("getCurrentWindowId");
      cordovaRequest.execute();
   };

  /**
    * The method to get the top sliding window's identifier as returned by create
    */
   AdfmfSlidingWindowPlugIn.prototype.getTopWindowId =    AdfmfSlidingWindowPlugIn.prototype.getTopWindowId || function(success, failure)
   {
      var cordovaRequest = new CordovaRequest({params:[]}, success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("getTopWindowId");
      cordovaRequest.execute();
   };

   /**
    * The method to get the identifiers of all the sliding windows that are created and valid
    */
   AdfmfSlidingWindowPlugIn.prototype.getWindowIds =    AdfmfSlidingWindowPlugIn.prototype.getWindowIds || function(success, failure)
   {
      var cordovaRequest = new CordovaRequest({params:[]}, success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("getWindowIds");
      cordovaRequest.execute();
   };

   /**
    * The method to show a sliding window
    */
   AdfmfSlidingWindowPlugIn.prototype.show =    AdfmfSlidingWindowPlugIn.prototype.show || function(/* String */ windowId, options, success, failure)
   {
      var cordovaRequest = new CordovaRequest({params:[windowId, options]}, success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("show");
      cordovaRequest.execute();
   };

   /**
    * The method to hide a sliding window
    */
   AdfmfSlidingWindowPlugIn.prototype.hide = AdfmfSlidingWindowPlugIn.prototype.hide || function(/* String */ windowId, success, failure)
   {
      var cordovaRequest = new CordovaRequest({params : [windowId]}, success, failure);
      cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
      cordovaRequest.setMethod("hide");
      cordovaRequest.execute();
   };

   /**
    * The method to get information about a sliding window
    */
    AdfmfSlidingWindowPlugIn.prototype.getWindowInfo =    AdfmfSlidingWindowPlugIn.prototype.getWindowInfo || function(/* String */ windowId, success, failure)
    {
    var cordovaRequest = new CordovaRequest({params:[windowId]}, success, failure);
    cordovaRequest.setPlugin("AdfmfSlidingWindowPlugIn");
    cordovaRequest.setMethod("getWindowInfo");
    cordovaRequest.execute();
    };

   /**
    * Represents the API for interacting with Push Notifications in the ADF Mobile Container.
    */
   window.ADFMobilePushNotifications = window.ADFMobilePushNotifications || function()
   {
   };

   /**
    * Register for notifications
    */
   ADFMobilePushNotifications.prototype.register = function(params, successCB, failureCB)
   {
      var cordovaRequest = new CordovaRequest(params, successCB, failureCB);
      cordovaRequest.setPlugin("PushPlugin");
      cordovaRequest.setMethod("register");
      cordovaRequest.execute();
   };

   /**
    * Represents the API for interacting with Local Notifications 
    */
   window.MafLocalNotification = window.MafLocalNotification || function()
   {
   };

   /**
    * local notifications - add
    */
   MafLocalNotification.prototype.add = function(params, successCB, failureCB)
   {
      var cordovaRequest = new CordovaRequest(params, successCB, failureCB);
      cordovaRequest.setPlugin("MafLocalNotification");
      cordovaRequest.setMethod("add");
      cordovaRequest.execute();
   };
   
   /**
    * local notifications - cancel
    */
   MafLocalNotification.prototype.cancel = function(params, successCB, failureCB)
   {
      var cordovaRequest = new CordovaRequest(params, successCB, failureCB);
      cordovaRequest.setPlugin("MafLocalNotification");
      cordovaRequest.setMethod("cancel");
      cordovaRequest.execute();
   };   

   /**
    * OutstandingRequestList is the implementation for the collection of request currently being processed.
    **/
   OutstandingRequestList = function()
   {
      this.queue      = {};
      this.nextId     = 500;
      this.size       = 0;

      /* return a unique request id */
      this.getUniqueRequestId = function()
      {
         return "CR-" + (++this.nextId);;
      };

      /* echo the outstanding request queue */
      this.showQueue = function()
      {
         try {
            var buf = " ";
            var cnt = 0;

            for(property in this.queue) {
               if((property !== undefined) && (property !== null)) {
                  if((typeof this.queue[property]) != 'function')
                  {
                     buf += ("\"" + property + ":" + this.queue[property].requestId + ":" + this.queue[property].timestamp + "\" ");
                     cnt++;
                  }
               }
            }
            return (" queue:"+cnt+"= [" + buf + "]");
         }
         catch(e)
         {
            return ("--error--");
         }
      };

      /* get (but do not remove) the request associated with the given id */
      this.getRequest = function(/* String */ id)
      {
         return this.queue[id];
      };

      /* insert a new request into the queue */
      this.insert = function(/* CordovaRequest */ cr)
      {
         this.size++;
         this.queue[cr.requestId] = cr;
         // console.log("OutstandingRequestList: insert: request=" + cr.requestId + "/" + cr.timestamp + " -- " + this.showQueue() + " scb="+cr.scb.length);
      };

      /* remove the associated request from the queue */
      this.remove = function(/* String */ id)
      {
         var cr = this.queue[id];

         if(cr === undefined) {
            adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "remove",
                  ("Error remvoving CordovaRequest: ERROR in Outstanding Request List ["+id+"] is not found."));
         }
         else {
            if(cr.requestId != id) {
               adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "remove",
                     ("Error remvoving CordovaRequest: ERROR in Outstanding Request List queue[" + id + "]/" + cr.timestamp + " is not " + cr.requestId));
            }
            delete this.queue[id];
            // console.log("OutstandingRequestList: remove: id=" + id + " request="+cr.requestId + this.showQueue() + " scb="+cr.scb.length);
         }

         return cr;
      };

      return this;
   };
   adf.mf.internal.processingRequestQueue = new OutstandingRequestList();


   /* Generate the associated success callback to be invoked by Corodova */
   containerInternalRoot().cordovaSuccessCallback = function(/* String */ id)
   {
      var body = "";

      body += "try{ ";
      body += "  var req = adf.mf.internal.processingRequestQueue.remove('" + id + "'); ";
      body += "  if((req != undefined) && (req != null))";
      body += "  {";
      body += "    adf.mf.log.Framework.logp(adf.mf.log.level.FINER, 'adf.mf.device.integration', 'cordovaSuccessCallback', 'Cordova Response Success Callback' + req.requestId);";
      // body += "    console.log('SUCCESS (id / req): " + id + " / ' + req.requestId );";
      body += "    req.success(r);";
      body += "  }else{";
      body += "    adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, 'adf.mf.device.integration', 'cordovaSuccessCallback', 'Cordova Success Response Handler Error: Request Id (" + id + ") was not found.');";
      body += "  }";
      body += "}catch(e){";
      body += "  adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, 'adf.mf.device.integration', 'cordovaSuccessCallback', 'Cordova Success Response Handler Error: Request Id (" + id + ") error=' + e);";
      body += "  alert('Cordova Response Success Handler Error:' + e);";
      body += "}";

      return new Function('r', body);
   };

   /* Generate the associated failure callback to be invoked by Corodova */
   containerInternalRoot().cordovaFailureCallback = function(/* String */ id)
   {
      var body = "";

      body += "try{ ";
      body += "  var req = adf.mf.internal.processingRequestQueue.remove('" + id + "'); ";
      body += "  if((req != undefined) && (req != null))";
      body += "  {";
      body += "    adf.mf.log.Framework.logp(adf.mf.log.level.FINER, 'adf.mf.device.integration', 'cordovaFailureCallback', 'Cordova Response Failure Callback' + req.requestId);";
      // body += "    console.log('FAILURE (id / req): " + id + " / ' + req.requestId + ' r=' + adf.mf.util.stringify(r));";
      body += "    req.failure(r);";
      body += "  }else{";
      body += "    adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, 'adf.mf.device.integration', 'cordovaSuccessCallback', 'Cordova Failure Response Handler Error: Request Id (" + id + ") was not found.');";
      body += "  }";
      body += "}catch(e){";
      body += "  adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, 'adf.mf.device.integration', 'cordovaFailureCallback', 'Cordova Failure Response Handler Error: Request Id (" + id + ") error=' + e);";
      body += "  alert('Cordova Response Failure Handler Error:' + e);";
      body += "}";

      return new Function('r', body);
   };

   /* Request object used to hold the pending Cordova request that is out being processed */
   CordovaRequest = function(request, success, failed)
   {
      try
      {
         this.timestamp      = "T" + ((new Date()).getTime() % 600000);
         this.requestId      = adf.mf.internal.processingRequestQueue.getUniqueRequestId();
         this.scb            = adf.mf.internal.util.is_array(success)? success : [success];
         this.fcb            = adf.mf.internal.util.is_array(failed)?  failed  : [failed ];
         this.plugin         = "ADFMobileShell";
         this.methodName     = "invokeJavaMethod";
         this.request        = request;

         /**
          * set the plugin name
          * @param  name
          **/
         /* void */
         this.setPlugin      = function(name)
         {
            this.plugin      = name;
         };

         /**
          * set the method name
          * @param  name
          **/
         /* void */
         this.setMethod      = function(name)
         {
            this.methodName  = name;
         };

         /* internal success callback for this request */
         this.success = function(result)
         {
            try
            {
               if(adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
               {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINE, "device.integration", "success",
                        "Inside the success callback for request " + this.requestId);
               }

               for(var i = 0; i < this.scb.length; ++i)
               {
                  try
                  {
                     // console.log("START: device.integration.success - request = " + this.requestId + " success callback " + i + " with result = " + result);
                     // adf.mf.internal.perf.start("device.integration.success", "request = " + this.requestId + " success callback " + i);
                	 if (this.scb[i])
                     {
                	   this.scb[i](this.request, result);
                	 }

                     // adf.mf.internal.perf.stop("device.integration.success", "request = " + this.requestId + " success callback " + i);
                     // console.log("END: device.integration.success - request = " + this.requestId + " success callback " + i);
                  }
                  catch(sce)
                  {
                     adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "device.integration", "success",
                           ("Error executing Cordova request " + this.requestId +
                                 " success callback " + i + " or " + this.scb[i] +
                                 " request: " + adf.mf.util.stringify(this.request) +
                                 " result: " + adf.mf.util.stringify(result)) +
                                 " error: " + adf.mf.util.stringify(sce));
                     try
                     {
                        // adf.mf.internal.perf.start("device.integration.success", "request = " + this.requestId + " failure callback " + i);
                    	if(this.fcb[i])
                    	{
                    	  this.fcb[i](this.request, sce);
                    	}

                        // adf.mf.internal.perf.stop("device.integration.success", "request = " + this.requestId + " failure callback " + i);
                     }
                     catch(fatalError)
                     {
                        adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "success",
                              ("Error executing Cordova request " + this.requestId + " failed callback " + i + "   error = " + fatalError));
                     }
                  }
               }
            }
            catch(se)
            {
               adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "success",
                     ("Error executing cordovaSuccess callback - " + se));
            }
         }

         /* internal failure callback for this request */
         this.failure = function(result)
         {
            try
            {
               if(adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINE))
               {
                  adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "device.integration", "failure",
                        ("Inside the failure callback for request " + this.requestId));
               }

               for(var i = 0; i < this.fcb.length; ++i)
               {
                  try
                  {
                     // console.log("START: device.integration.failure - request = " + this.requestId + " failure callback " + i + " with result = " + result);
                     // adf.mf.internal.perf.start("device.integration.failure", "request = " + this.requestId + " failure callback " + i);
                     if(this.fcb[i])
                     {
                       this.fcb[i](this.request, result);
                     }

                     // adf.mf.internal.perf.stop("device.integration.failure", "request = " + this.requestId + " failure callback " + i);
                  }
                  catch(fce)
                  {
                     /* nothing we can do */
                     adf.mf.log.Framework.logp(adf.mf.log.level.WARNING, "device.integration", "failure",
                           ("Error executing Cordova request " + this.requestId +
                                 " failure callback " + i + " or " + this.scb[i] +
                                 " request: " + adf.mf.util.stringify(this.request) +
                                 " result: " + adf.mf.util.stringify(result)) +
                                 " error: " + adf.mf.util.stringify(fce));
                }
               }
            }
            catch(fe)
            {
               adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "failure",
                     ("Error executing cordovaFailure callback - " + fe));
            }
         }
         this.fail = this.failure;


         this.execute = function()
         {
            try
            {
               if(typeof(cordova) == "undefined")
               {
                  adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "execute",
                     ("ERROR: Cordova has not been properly included. Aborting Cordova call to " + this.plugin + "." + this.methodName));
                  return;
               }

               adf.mf.internal.processingRequestQueue.insert(this);
               adf.mf.internal.processingRequestQueue.insert(this);

              cordova.exec(containerInternalRoot().cordovaSuccessCallback(this.requestId),
                     containerInternalRoot().cordovaFailureCallback(this.requestId),
                     this.plugin, this.methodName, [this.request]);
            }
            catch(e)
            {
               // console.log("Cordova Request post-exec with exception for " + this.requestId);
               adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "execute",
                     ("Error executing Cordova request " + this.requestId + " with error = " + adf.mf.util.stringify(e)));

               for(var i = 0; i < this.fcb.length; ++i)
               {
                  try
                  {
                	 if(this.fcb[i])
                	 {
                	   this.fcb[i](this.request, e);
                	 }
                  }
                  catch(fe)
                  {
                     /* nothing we can do */
                     adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "execute",
                           ("Error executing Cordova request " + this.requestId + " failed callback " + i));
                  }
               }
            }
         }

         if(adf.mf.log.Framework.isLoggable(adf.mf.log.level.FINER))
         {
            adf.mf.log.Framework.logp(adf.mf.log.level.FINER, "device.integration", "constructor",
                  ("Cordova Request " + this.requestId + " has been created. " + adf.mf.util.stringify(this.request)));
         }
         return this;
      }
      catch(ex)
      {
         adf.mf.log.Framework.logp(adf.mf.log.level.SEVERE, "device.integration", "execute",
               ("Error creating Cordova Request error = " + adf.mf.util.stringify(ex)));
      }
   };

   /**
    * Add the Features service to ADFMobile
    */
   containerInternalRoot().Features = new ADFMobileFeatures();
   adf.mf.Features                  = containerInternalRoot().Features;

   /**
    * Add the vmchannel (formerly Java) service to ADFMobile
    */
   containerInternalRoot().vmchannel = new ADFMobileJava();

   /**
    * Add the SlidingWindow service to ADFMobile
    */
   containerInternalRoot().SlidingWindow = new AdfmfSlidingWindowPlugIn();

   /**
    * Add the PushPlugin service to ADFMobile
    */
   containerInternalRoot().PushNotifications = new ADFMobilePushNotifications();

   /**
    * Add the Local Notification service to Maf
    */
   containerInternalRoot().LocalNotification = new MafLocalNotification();
   
}
catch(e)
{
   console.log("**************************************************");
   console.log("***** ERROR: adf.mf.device.integration.js buildout error: " + e);
}

adf.mf.internal.BUILD_INFO = {
PRODUCT_VERSION: "2.3.2.0.0",
JOB_NAME: "MAF-v2.3.2.0.0-And-iOS",
BUILD_NUMBER: "39"
};
